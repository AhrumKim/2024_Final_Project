
SUB.elf:     file format elf32-tricore

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bmhd_0       00000020  80000000  80000000  000002b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .bmhd_1       00000020  80020000  80020000  000049f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .startup      00000010  80000020  80000020  000002d4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .interface_const 00000000  80000040  80000040  000051c4  2**0
                  CONTENTS
  4 .traptab_tc0  00000100  80000100  80000100  00000300  2**5
                  CONTENTS, ALLOC, LOAD, CODE
  5 .rodata       00000228  80000200  80000200  00000400  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .CPU2.zbss    00000000  50000000  50000000  000051c4  2**0
                  CONTENTS
  7 .CPU2.bss     00000000  50000000  50000000  000051c4  2**0
                  CONTENTS
  8 .CPU1.zbss    00000000  60000000  60000000  000051c4  2**0
                  CONTENTS
  9 .CPU1.bss     00000000  600019a8  600019a8  000051c4  2**0
                  CONTENTS
 10 .CPU0.zbss    00000000  70000000  70000000  000051c4  2**0
                  CONTENTS
 11 .CPU0.bss     00000000  70000000  70000000  000051c4  2**0
                  CONTENTS
 12 .zbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC
 13 .sbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC, SMALL_DATA
 14 .bss          00000440  60000568  801f6864  000051c8  2**3
                  ALLOC
 15 .CPU2.zdata   00000000  50000000  50000000  000051c4  2**0
                  CONTENTS
 16 .CPU2.data    00000000  50000000  50000000  000051c4  2**0
                  CONTENTS
 17 .CPU1.zdata   00000000  60000000  60000000  000051c4  2**0
                  CONTENTS
 18 .CPU1.data    00000000  600019a8  600019a8  000051c4  2**0
                  CONTENTS
 19 .CPU0.zdata   00000000  70000000  70000000  000051c4  2**0
                  CONTENTS
 20 .CPU0.data    00000000  70000000  70000000  000051c4  2**0
                  CONTENTS
 21 .zdata        00000000  60000000  801f6864  000051c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 22 .sdata        00000000  60000000  801f6864  000051c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
 23 .data         00000564  60000000  801f6300  00004c60  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 24 .lmu_zdata    00000000  90000000  90000000  000051c4  2**0
                  CONTENTS
 25 .lmu_sdata    00000000  90000000  90000000  000051c4  2**0
                  CONTENTS
 26 .lmu_data     00000000  90000000  90000000  000051c4  2**0
                  CONTENTS
 27 .CPU0.psram_text 00000000  70100000  70100000  000051c4  2**0
                  CONTENTS
 28 .CPU1.psram_text 00000000  60100000  60100000  000051c4  2**0
                  CONTENTS
 29 .CPU2.psram_text 00000000  50100000  50100000  000051c4  2**0
                  CONTENTS
 30 .text         00004390  80000428  80000428  00000628  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .init         00000010  800047b8  800047b8  000049b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .fini         00000008  800047c8  800047c8  000049c8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .eh_frame     00000000  800047d0  800047d0  000051c4  2**0
                  CONTENTS
 34 .gcc_except_table 00000000  800047d0  800047d0  000051c4  2**0
                  CONTENTS
 35 .ctors        00000010  800047d0  800047d0  000049d0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 36 .dtors        00000010  800047e0  800047e0  000049e0  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 37 .traptab_tc2  00000100  801f6100  801f6100  00004a60  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 38 .traptab_tc1  00000100  801f6200  801f6200  00004b60  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 39 .heap         00001000  600009a8  801f6864  000051c4  2**0
                  ALLOC
 40 .CPU2.ustack  00000800  5001ae00  5001ae00  000002b4  2**0
                  ALLOC
 41 .CPU2.istack  00000400  5001b700  5001b700  000002b4  2**0
                  ALLOC
 42 .CPU2.csa     00002000  5001bc00  5001bc00  000002b4  2**0
                  ALLOC
 43 .CPU1.ustack  00000800  6001ae00  6001ae00  000002b4  2**0
                  ALLOC
 44 .CPU1.istack  00000400  6001b700  6001b700  000002b4  2**0
                  ALLOC
 45 .CPU1.csa     00002000  6001bc00  6001bc00  000002b4  2**0
                  ALLOC
 46 .CPU0.ustack  00000800  70018e00  70018e00  000002b4  2**0
                  ALLOC
 47 .CPU0.istack  00000400  70019700  70019700  000002b4  2**0
                  ALLOC
 48 .CPU0.csa     00002000  70019c00  70019c00  000002b4  2**0
                  ALLOC
 49 .inttab_tc0_000 00000000  801f4000  801f4000  000051c4  2**0
                  CONTENTS
 50 .inttab_tc0_001 00000000  801f4020  801f4020  000051c4  2**0
                  CONTENTS
 51 .inttab_tc0_002 00000000  801f4040  801f4040  000051c4  2**0
                  CONTENTS
 52 .inttab_tc0_003 0000000e  801f4060  801f4060  00004a10  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 53 .inttab_tc0_004 0000000e  801f4080  801f4080  00004a1e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .inttab_tc0_005 00000000  801f40a0  801f40a0  000051c4  2**0
                  CONTENTS
 55 .inttab_tc0_006 00000000  801f40c0  801f40c0  000051c4  2**0
                  CONTENTS
 56 .inttab_tc0_007 00000000  801f40e0  801f40e0  000051c4  2**0
                  CONTENTS
 57 .inttab_tc0_008 00000000  801f4100  801f4100  000051c4  2**0
                  CONTENTS
 58 .inttab_tc0_009 0000000e  801f4120  801f4120  00004a2c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .inttab_tc0_00A 00000000  801f4140  801f4140  000051c4  2**0
                  CONTENTS
 60 .inttab_tc0_00B 00000000  801f4160  801f4160  000051c4  2**0
                  CONTENTS
 61 .inttab_tc0_00C 00000000  801f4180  801f4180  000051c4  2**0
                  CONTENTS
 62 .inttab_tc0_00D 0000000e  801f41a0  801f41a0  00004a3a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .inttab_tc0_00E 00000000  801f41c0  801f41c0  000051c4  2**0
                  CONTENTS
 64 .inttab_tc0_00F 00000000  801f41e0  801f41e0  000051c4  2**0
                  CONTENTS
 65 .inttab_tc0_010 00000000  801f4200  801f4200  000051c4  2**0
                  CONTENTS
 66 .inttab_tc0_011 00000000  801f4220  801f4220  000051c4  2**0
                  CONTENTS
 67 .inttab_tc0_012 00000000  801f4240  801f4240  000051c4  2**0
                  CONTENTS
 68 .inttab_tc0_013 00000000  801f4260  801f4260  000051c4  2**0
                  CONTENTS
 69 .inttab_tc0_014 00000000  801f4280  801f4280  000051c4  2**0
                  CONTENTS
 70 .inttab_tc0_015 00000000  801f42a0  801f42a0  000051c4  2**0
                  CONTENTS
 71 .inttab_tc0_016 00000000  801f42c0  801f42c0  000051c4  2**0
                  CONTENTS
 72 .inttab_tc0_017 00000000  801f42e0  801f42e0  000051c4  2**0
                  CONTENTS
 73 .inttab_tc0_018 00000000  801f4300  801f4300  000051c4  2**0
                  CONTENTS
 74 .inttab_tc0_019 00000000  801f4320  801f4320  000051c4  2**0
                  CONTENTS
 75 .inttab_tc0_01A 00000000  801f4340  801f4340  000051c4  2**0
                  CONTENTS
 76 .inttab_tc0_01B 00000000  801f4360  801f4360  000051c4  2**0
                  CONTENTS
 77 .inttab_tc0_01C 00000000  801f4380  801f4380  000051c4  2**0
                  CONTENTS
 78 .inttab_tc0_01D 00000000  801f43a0  801f43a0  000051c4  2**0
                  CONTENTS
 79 .inttab_tc0_01E 00000000  801f43c0  801f43c0  000051c4  2**0
                  CONTENTS
 80 .inttab_tc0_01F 00000000  801f43e0  801f43e0  000051c4  2**0
                  CONTENTS
 81 .inttab_tc0_020 00000000  801f4400  801f4400  000051c4  2**0
                  CONTENTS
 82 .inttab_tc0_021 00000000  801f4420  801f4420  000051c4  2**0
                  CONTENTS
 83 .inttab_tc0_022 00000000  801f4440  801f4440  000051c4  2**0
                  CONTENTS
 84 .inttab_tc0_023 00000000  801f4460  801f4460  000051c4  2**0
                  CONTENTS
 85 .inttab_tc0_024 00000000  801f4480  801f4480  000051c4  2**0
                  CONTENTS
 86 .inttab_tc0_025 00000000  801f44a0  801f44a0  000051c4  2**0
                  CONTENTS
 87 .inttab_tc0_026 00000000  801f44c0  801f44c0  000051c4  2**0
                  CONTENTS
 88 .inttab_tc0_027 00000000  801f44e0  801f44e0  000051c4  2**0
                  CONTENTS
 89 .inttab_tc0_028 00000000  801f4500  801f4500  000051c4  2**0
                  CONTENTS
 90 .inttab_tc0_029 00000000  801f4520  801f4520  000051c4  2**0
                  CONTENTS
 91 .inttab_tc0_02A 00000000  801f4540  801f4540  000051c4  2**0
                  CONTENTS
 92 .inttab_tc0_02B 00000000  801f4560  801f4560  000051c4  2**0
                  CONTENTS
 93 .inttab_tc0_02C 00000000  801f4580  801f4580  000051c4  2**0
                  CONTENTS
 94 .inttab_tc0_02D 00000000  801f45a0  801f45a0  000051c4  2**0
                  CONTENTS
 95 .inttab_tc0_02E 00000000  801f45c0  801f45c0  000051c4  2**0
                  CONTENTS
 96 .inttab_tc0_02F 00000000  801f45e0  801f45e0  000051c4  2**0
                  CONTENTS
 97 .inttab_tc0_030 00000000  801f4600  801f4600  000051c4  2**0
                  CONTENTS
 98 .inttab_tc0_031 00000000  801f4620  801f4620  000051c4  2**0
                  CONTENTS
 99 .inttab_tc0_032 00000000  801f4640  801f4640  000051c4  2**0
                  CONTENTS
100 .inttab_tc0_033 00000000  801f4660  801f4660  000051c4  2**0
                  CONTENTS
101 .inttab_tc0_034 00000000  801f4680  801f4680  000051c4  2**0
                  CONTENTS
102 .inttab_tc0_035 00000000  801f46a0  801f46a0  000051c4  2**0
                  CONTENTS
103 .inttab_tc0_036 00000000  801f46c0  801f46c0  000051c4  2**0
                  CONTENTS
104 .inttab_tc0_037 00000000  801f46e0  801f46e0  000051c4  2**0
                  CONTENTS
105 .inttab_tc0_038 00000000  801f4700  801f4700  000051c4  2**0
                  CONTENTS
106 .inttab_tc0_039 00000000  801f4720  801f4720  000051c4  2**0
                  CONTENTS
107 .inttab_tc0_03A 00000000  801f4740  801f4740  000051c4  2**0
                  CONTENTS
108 .inttab_tc0_03B 00000000  801f4760  801f4760  000051c4  2**0
                  CONTENTS
109 .inttab_tc0_03C 00000000  801f4780  801f4780  000051c4  2**0
                  CONTENTS
110 .inttab_tc0_03D 00000000  801f47a0  801f47a0  000051c4  2**0
                  CONTENTS
111 .inttab_tc0_03E 00000000  801f47c0  801f47c0  000051c4  2**0
                  CONTENTS
112 .inttab_tc0_03F 00000000  801f47e0  801f47e0  000051c4  2**0
                  CONTENTS
113 .inttab_tc0_040 00000000  801f4800  801f4800  000051c4  2**0
                  CONTENTS
114 .inttab_tc0_041 00000000  801f4820  801f4820  000051c4  2**0
                  CONTENTS
115 .inttab_tc0_042 00000000  801f4840  801f4840  000051c4  2**0
                  CONTENTS
116 .inttab_tc0_043 00000000  801f4860  801f4860  000051c4  2**0
                  CONTENTS
117 .inttab_tc0_044 00000000  801f4880  801f4880  000051c4  2**0
                  CONTENTS
118 .inttab_tc0_045 00000000  801f48a0  801f48a0  000051c4  2**0
                  CONTENTS
119 .inttab_tc0_046 00000000  801f48c0  801f48c0  000051c4  2**0
                  CONTENTS
120 .inttab_tc0_047 00000000  801f48e0  801f48e0  000051c4  2**0
                  CONTENTS
121 .inttab_tc0_048 00000000  801f4900  801f4900  000051c4  2**0
                  CONTENTS
122 .inttab_tc0_049 00000000  801f4920  801f4920  000051c4  2**0
                  CONTENTS
123 .inttab_tc0_04A 00000000  801f4940  801f4940  000051c4  2**0
                  CONTENTS
124 .inttab_tc0_04B 00000000  801f4960  801f4960  000051c4  2**0
                  CONTENTS
125 .inttab_tc0_04C 00000000  801f4980  801f4980  000051c4  2**0
                  CONTENTS
126 .inttab_tc0_04D 00000000  801f49a0  801f49a0  000051c4  2**0
                  CONTENTS
127 .inttab_tc0_04E 00000000  801f49c0  801f49c0  000051c4  2**0
                  CONTENTS
128 .inttab_tc0_04F 00000000  801f49e0  801f49e0  000051c4  2**0
                  CONTENTS
129 .inttab_tc0_050 00000000  801f4a00  801f4a00  000051c4  2**0
                  CONTENTS
130 .inttab_tc0_051 00000000  801f4a20  801f4a20  000051c4  2**0
                  CONTENTS
131 .inttab_tc0_052 00000000  801f4a40  801f4a40  000051c4  2**0
                  CONTENTS
132 .inttab_tc0_053 00000000  801f4a60  801f4a60  000051c4  2**0
                  CONTENTS
133 .inttab_tc0_054 00000000  801f4a80  801f4a80  000051c4  2**0
                  CONTENTS
134 .inttab_tc0_055 00000000  801f4aa0  801f4aa0  000051c4  2**0
                  CONTENTS
135 .inttab_tc0_056 00000000  801f4ac0  801f4ac0  000051c4  2**0
                  CONTENTS
136 .inttab_tc0_057 00000000  801f4ae0  801f4ae0  000051c4  2**0
                  CONTENTS
137 .inttab_tc0_058 00000000  801f4b00  801f4b00  000051c4  2**0
                  CONTENTS
138 .inttab_tc0_059 00000000  801f4b20  801f4b20  000051c4  2**0
                  CONTENTS
139 .inttab_tc0_05A 00000000  801f4b40  801f4b40  000051c4  2**0
                  CONTENTS
140 .inttab_tc0_05B 00000000  801f4b60  801f4b60  000051c4  2**0
                  CONTENTS
141 .inttab_tc0_05C 00000000  801f4b80  801f4b80  000051c4  2**0
                  CONTENTS
142 .inttab_tc0_05D 00000000  801f4ba0  801f4ba0  000051c4  2**0
                  CONTENTS
143 .inttab_tc0_05E 00000000  801f4bc0  801f4bc0  000051c4  2**0
                  CONTENTS
144 .inttab_tc0_05F 00000000  801f4be0  801f4be0  000051c4  2**0
                  CONTENTS
145 .inttab_tc0_060 00000000  801f4c00  801f4c00  000051c4  2**0
                  CONTENTS
146 .inttab_tc0_061 00000000  801f4c20  801f4c20  000051c4  2**0
                  CONTENTS
147 .inttab_tc0_062 00000000  801f4c40  801f4c40  000051c4  2**0
                  CONTENTS
148 .inttab_tc0_063 00000000  801f4c60  801f4c60  000051c4  2**0
                  CONTENTS
149 .inttab_tc0_064 00000000  801f4c80  801f4c80  000051c4  2**0
                  CONTENTS
150 .inttab_tc0_065 00000000  801f4ca0  801f4ca0  000051c4  2**0
                  CONTENTS
151 .inttab_tc0_066 00000000  801f4cc0  801f4cc0  000051c4  2**0
                  CONTENTS
152 .inttab_tc0_067 00000000  801f4ce0  801f4ce0  000051c4  2**0
                  CONTENTS
153 .inttab_tc0_068 00000000  801f4d00  801f4d00  000051c4  2**0
                  CONTENTS
154 .inttab_tc0_069 00000000  801f4d20  801f4d20  000051c4  2**0
                  CONTENTS
155 .inttab_tc0_06A 00000000  801f4d40  801f4d40  000051c4  2**0
                  CONTENTS
156 .inttab_tc0_06B 00000000  801f4d60  801f4d60  000051c4  2**0
                  CONTENTS
157 .inttab_tc0_06C 00000000  801f4d80  801f4d80  000051c4  2**0
                  CONTENTS
158 .inttab_tc0_06D 00000000  801f4da0  801f4da0  000051c4  2**0
                  CONTENTS
159 .inttab_tc0_06E 00000000  801f4dc0  801f4dc0  000051c4  2**0
                  CONTENTS
160 .inttab_tc0_06F 00000000  801f4de0  801f4de0  000051c4  2**0
                  CONTENTS
161 .inttab_tc0_070 00000000  801f4e00  801f4e00  000051c4  2**0
                  CONTENTS
162 .inttab_tc0_071 00000000  801f4e20  801f4e20  000051c4  2**0
                  CONTENTS
163 .inttab_tc0_072 00000000  801f4e40  801f4e40  000051c4  2**0
                  CONTENTS
164 .inttab_tc0_073 00000000  801f4e60  801f4e60  000051c4  2**0
                  CONTENTS
165 .inttab_tc0_074 00000000  801f4e80  801f4e80  000051c4  2**0
                  CONTENTS
166 .inttab_tc0_075 00000000  801f4ea0  801f4ea0  000051c4  2**0
                  CONTENTS
167 .inttab_tc0_076 00000000  801f4ec0  801f4ec0  000051c4  2**0
                  CONTENTS
168 .inttab_tc0_077 00000000  801f4ee0  801f4ee0  000051c4  2**0
                  CONTENTS
169 .inttab_tc0_078 00000000  801f4f00  801f4f00  000051c4  2**0
                  CONTENTS
170 .inttab_tc0_079 00000000  801f4f20  801f4f20  000051c4  2**0
                  CONTENTS
171 .inttab_tc0_07A 00000000  801f4f40  801f4f40  000051c4  2**0
                  CONTENTS
172 .inttab_tc0_07B 00000000  801f4f60  801f4f60  000051c4  2**0
                  CONTENTS
173 .inttab_tc0_07C 00000000  801f4f80  801f4f80  000051c4  2**0
                  CONTENTS
174 .inttab_tc0_07D 00000000  801f4fa0  801f4fa0  000051c4  2**0
                  CONTENTS
175 .inttab_tc0_07E 00000000  801f4fc0  801f4fc0  000051c4  2**0
                  CONTENTS
176 .inttab_tc0_07F 00000000  801f4fe0  801f4fe0  000051c4  2**0
                  CONTENTS
177 .inttab_tc0_080 00000000  801f5000  801f5000  000051c4  2**0
                  CONTENTS
178 .inttab_tc0_081 00000000  801f5020  801f5020  000051c4  2**0
                  CONTENTS
179 .inttab_tc0_082 00000000  801f5040  801f5040  000051c4  2**0
                  CONTENTS
180 .inttab_tc0_083 00000000  801f5060  801f5060  000051c4  2**0
                  CONTENTS
181 .inttab_tc0_084 00000000  801f5080  801f5080  000051c4  2**0
                  CONTENTS
182 .inttab_tc0_085 00000000  801f50a0  801f50a0  000051c4  2**0
                  CONTENTS
183 .inttab_tc0_086 00000000  801f50c0  801f50c0  000051c4  2**0
                  CONTENTS
184 .inttab_tc0_087 00000000  801f50e0  801f50e0  000051c4  2**0
                  CONTENTS
185 .inttab_tc0_088 00000000  801f5100  801f5100  000051c4  2**0
                  CONTENTS
186 .inttab_tc0_089 00000000  801f5120  801f5120  000051c4  2**0
                  CONTENTS
187 .inttab_tc0_08A 00000000  801f5140  801f5140  000051c4  2**0
                  CONTENTS
188 .inttab_tc0_08B 00000000  801f5160  801f5160  000051c4  2**0
                  CONTENTS
189 .inttab_tc0_08C 00000000  801f5180  801f5180  000051c4  2**0
                  CONTENTS
190 .inttab_tc0_08D 00000000  801f51a0  801f51a0  000051c4  2**0
                  CONTENTS
191 .inttab_tc0_08E 00000000  801f51c0  801f51c0  000051c4  2**0
                  CONTENTS
192 .inttab_tc0_08F 00000000  801f51e0  801f51e0  000051c4  2**0
                  CONTENTS
193 .inttab_tc0_090 00000000  801f5200  801f5200  000051c4  2**0
                  CONTENTS
194 .inttab_tc0_091 00000000  801f5220  801f5220  000051c4  2**0
                  CONTENTS
195 .inttab_tc0_092 00000000  801f5240  801f5240  000051c4  2**0
                  CONTENTS
196 .inttab_tc0_093 00000000  801f5260  801f5260  000051c4  2**0
                  CONTENTS
197 .inttab_tc0_094 00000000  801f5280  801f5280  000051c4  2**0
                  CONTENTS
198 .inttab_tc0_095 00000000  801f52a0  801f52a0  000051c4  2**0
                  CONTENTS
199 .inttab_tc0_096 00000000  801f52c0  801f52c0  000051c4  2**0
                  CONTENTS
200 .inttab_tc0_097 00000000  801f52e0  801f52e0  000051c4  2**0
                  CONTENTS
201 .inttab_tc0_098 00000000  801f5300  801f5300  000051c4  2**0
                  CONTENTS
202 .inttab_tc0_099 00000000  801f5320  801f5320  000051c4  2**0
                  CONTENTS
203 .inttab_tc0_09A 00000000  801f5340  801f5340  000051c4  2**0
                  CONTENTS
204 .inttab_tc0_09B 00000000  801f5360  801f5360  000051c4  2**0
                  CONTENTS
205 .inttab_tc0_09C 00000000  801f5380  801f5380  000051c4  2**0
                  CONTENTS
206 .inttab_tc0_09D 00000000  801f53a0  801f53a0  000051c4  2**0
                  CONTENTS
207 .inttab_tc0_09E 00000000  801f53c0  801f53c0  000051c4  2**0
                  CONTENTS
208 .inttab_tc0_09F 00000000  801f53e0  801f53e0  000051c4  2**0
                  CONTENTS
209 .inttab_tc0_0A0 00000000  801f5400  801f5400  000051c4  2**0
                  CONTENTS
210 .inttab_tc0_0A1 00000000  801f5420  801f5420  000051c4  2**0
                  CONTENTS
211 .inttab_tc0_0A2 00000000  801f5440  801f5440  000051c4  2**0
                  CONTENTS
212 .inttab_tc0_0A3 00000000  801f5460  801f5460  000051c4  2**0
                  CONTENTS
213 .inttab_tc0_0A4 00000000  801f5480  801f5480  000051c4  2**0
                  CONTENTS
214 .inttab_tc0_0A5 00000000  801f54a0  801f54a0  000051c4  2**0
                  CONTENTS
215 .inttab_tc0_0A6 00000000  801f54c0  801f54c0  000051c4  2**0
                  CONTENTS
216 .inttab_tc0_0A7 00000000  801f54e0  801f54e0  000051c4  2**0
                  CONTENTS
217 .inttab_tc0_0A8 00000000  801f5500  801f5500  000051c4  2**0
                  CONTENTS
218 .inttab_tc0_0A9 00000000  801f5520  801f5520  000051c4  2**0
                  CONTENTS
219 .inttab_tc0_0AA 00000000  801f5540  801f5540  000051c4  2**0
                  CONTENTS
220 .inttab_tc0_0AB 00000000  801f5560  801f5560  000051c4  2**0
                  CONTENTS
221 .inttab_tc0_0AC 00000000  801f5580  801f5580  000051c4  2**0
                  CONTENTS
222 .inttab_tc0_0AD 00000000  801f55a0  801f55a0  000051c4  2**0
                  CONTENTS
223 .inttab_tc0_0AE 00000000  801f55c0  801f55c0  000051c4  2**0
                  CONTENTS
224 .inttab_tc0_0AF 00000000  801f55e0  801f55e0  000051c4  2**0
                  CONTENTS
225 .inttab_tc0_0B0 00000000  801f5600  801f5600  000051c4  2**0
                  CONTENTS
226 .inttab_tc0_0B1 00000000  801f5620  801f5620  000051c4  2**0
                  CONTENTS
227 .inttab_tc0_0B2 00000000  801f5640  801f5640  000051c4  2**0
                  CONTENTS
228 .inttab_tc0_0B3 00000000  801f5660  801f5660  000051c4  2**0
                  CONTENTS
229 .inttab_tc0_0B4 00000000  801f5680  801f5680  000051c4  2**0
                  CONTENTS
230 .inttab_tc0_0B5 00000000  801f56a0  801f56a0  000051c4  2**0
                  CONTENTS
231 .inttab_tc0_0B6 00000000  801f56c0  801f56c0  000051c4  2**0
                  CONTENTS
232 .inttab_tc0_0B7 00000000  801f56e0  801f56e0  000051c4  2**0
                  CONTENTS
233 .inttab_tc0_0B8 00000000  801f5700  801f5700  000051c4  2**0
                  CONTENTS
234 .inttab_tc0_0B9 00000000  801f5720  801f5720  000051c4  2**0
                  CONTENTS
235 .inttab_tc0_0BA 00000000  801f5740  801f5740  000051c4  2**0
                  CONTENTS
236 .inttab_tc0_0BB 00000000  801f5760  801f5760  000051c4  2**0
                  CONTENTS
237 .inttab_tc0_0BC 00000000  801f5780  801f5780  000051c4  2**0
                  CONTENTS
238 .inttab_tc0_0BD 00000000  801f57a0  801f57a0  000051c4  2**0
                  CONTENTS
239 .inttab_tc0_0BE 00000000  801f57c0  801f57c0  000051c4  2**0
                  CONTENTS
240 .inttab_tc0_0BF 00000000  801f57e0  801f57e0  000051c4  2**0
                  CONTENTS
241 .inttab_tc0_0C0 00000000  801f5800  801f5800  000051c4  2**0
                  CONTENTS
242 .inttab_tc0_0C1 00000000  801f5820  801f5820  000051c4  2**0
                  CONTENTS
243 .inttab_tc0_0C2 00000000  801f5840  801f5840  000051c4  2**0
                  CONTENTS
244 .inttab_tc0_0C3 00000000  801f5860  801f5860  000051c4  2**0
                  CONTENTS
245 .inttab_tc0_0C4 00000000  801f5880  801f5880  000051c4  2**0
                  CONTENTS
246 .inttab_tc0_0C5 00000000  801f58a0  801f58a0  000051c4  2**0
                  CONTENTS
247 .inttab_tc0_0C6 00000000  801f58c0  801f58c0  000051c4  2**0
                  CONTENTS
248 .inttab_tc0_0C7 00000000  801f58e0  801f58e0  000051c4  2**0
                  CONTENTS
249 .inttab_tc0_0C8 00000000  801f5900  801f5900  000051c4  2**0
                  CONTENTS
250 .inttab_tc0_0C9 00000000  801f5920  801f5920  000051c4  2**0
                  CONTENTS
251 .inttab_tc0_0CA 00000000  801f5940  801f5940  000051c4  2**0
                  CONTENTS
252 .inttab_tc0_0CB 00000000  801f5960  801f5960  000051c4  2**0
                  CONTENTS
253 .inttab_tc0_0CC 00000000  801f5980  801f5980  000051c4  2**0
                  CONTENTS
254 .inttab_tc0_0CD 00000000  801f59a0  801f59a0  000051c4  2**0
                  CONTENTS
255 .inttab_tc0_0CE 00000000  801f59c0  801f59c0  000051c4  2**0
                  CONTENTS
256 .inttab_tc0_0CF 00000000  801f59e0  801f59e0  000051c4  2**0
                  CONTENTS
257 .inttab_tc0_0D0 00000000  801f5a00  801f5a00  000051c4  2**0
                  CONTENTS
258 .inttab_tc0_0D1 00000000  801f5a20  801f5a20  000051c4  2**0
                  CONTENTS
259 .inttab_tc0_0D2 00000000  801f5a40  801f5a40  000051c4  2**0
                  CONTENTS
260 .inttab_tc0_0D3 00000000  801f5a60  801f5a60  000051c4  2**0
                  CONTENTS
261 .inttab_tc0_0D4 00000000  801f5a80  801f5a80  000051c4  2**0
                  CONTENTS
262 .inttab_tc0_0D5 00000000  801f5aa0  801f5aa0  000051c4  2**0
                  CONTENTS
263 .inttab_tc0_0D6 00000000  801f5ac0  801f5ac0  000051c4  2**0
                  CONTENTS
264 .inttab_tc0_0D7 00000000  801f5ae0  801f5ae0  000051c4  2**0
                  CONTENTS
265 .inttab_tc0_0D8 00000000  801f5b00  801f5b00  000051c4  2**0
                  CONTENTS
266 .inttab_tc0_0D9 00000000  801f5b20  801f5b20  000051c4  2**0
                  CONTENTS
267 .inttab_tc0_0DA 00000000  801f5b40  801f5b40  000051c4  2**0
                  CONTENTS
268 .inttab_tc0_0DB 00000000  801f5b60  801f5b60  000051c4  2**0
                  CONTENTS
269 .inttab_tc0_0DC 00000000  801f5b80  801f5b80  000051c4  2**0
                  CONTENTS
270 .inttab_tc0_0DD 00000000  801f5ba0  801f5ba0  000051c4  2**0
                  CONTENTS
271 .inttab_tc0_0DE 00000000  801f5bc0  801f5bc0  000051c4  2**0
                  CONTENTS
272 .inttab_tc0_0DF 00000000  801f5be0  801f5be0  000051c4  2**0
                  CONTENTS
273 .inttab_tc0_0E0 00000000  801f5c00  801f5c00  000051c4  2**0
                  CONTENTS
274 .inttab_tc0_0E1 00000000  801f5c20  801f5c20  000051c4  2**0
                  CONTENTS
275 .inttab_tc0_0E2 00000000  801f5c40  801f5c40  000051c4  2**0
                  CONTENTS
276 .inttab_tc0_0E3 00000000  801f5c60  801f5c60  000051c4  2**0
                  CONTENTS
277 .inttab_tc0_0E4 00000000  801f5c80  801f5c80  000051c4  2**0
                  CONTENTS
278 .inttab_tc0_0E5 00000000  801f5ca0  801f5ca0  000051c4  2**0
                  CONTENTS
279 .inttab_tc0_0E6 00000000  801f5cc0  801f5cc0  000051c4  2**0
                  CONTENTS
280 .inttab_tc0_0E7 00000000  801f5ce0  801f5ce0  000051c4  2**0
                  CONTENTS
281 .inttab_tc0_0E8 00000000  801f5d00  801f5d00  000051c4  2**0
                  CONTENTS
282 .inttab_tc0_0E9 00000000  801f5d20  801f5d20  000051c4  2**0
                  CONTENTS
283 .inttab_tc0_0EA 00000000  801f5d40  801f5d40  000051c4  2**0
                  CONTENTS
284 .inttab_tc0_0EB 00000000  801f5d60  801f5d60  000051c4  2**0
                  CONTENTS
285 .inttab_tc0_0EC 00000000  801f5d80  801f5d80  000051c4  2**0
                  CONTENTS
286 .inttab_tc0_0ED 00000000  801f5da0  801f5da0  000051c4  2**0
                  CONTENTS
287 .inttab_tc0_0EE 00000000  801f5dc0  801f5dc0  000051c4  2**0
                  CONTENTS
288 .inttab_tc0_0EF 00000000  801f5de0  801f5de0  000051c4  2**0
                  CONTENTS
289 .inttab_tc0_0F0 00000000  801f5e00  801f5e00  000051c4  2**0
                  CONTENTS
290 .inttab_tc0_0F1 00000000  801f5e20  801f5e20  000051c4  2**0
                  CONTENTS
291 .inttab_tc0_0F2 00000000  801f5e40  801f5e40  000051c4  2**0
                  CONTENTS
292 .inttab_tc0_0F3 00000000  801f5e60  801f5e60  000051c4  2**0
                  CONTENTS
293 .inttab_tc0_0F4 00000000  801f5e80  801f5e80  000051c4  2**0
                  CONTENTS
294 .inttab_tc0_0F5 00000000  801f5ea0  801f5ea0  000051c4  2**0
                  CONTENTS
295 .inttab_tc0_0F6 00000000  801f5ec0  801f5ec0  000051c4  2**0
                  CONTENTS
296 .inttab_tc0_0F7 00000000  801f5ee0  801f5ee0  000051c4  2**0
                  CONTENTS
297 .inttab_tc0_0F8 00000000  801f5f00  801f5f00  000051c4  2**0
                  CONTENTS
298 .inttab_tc0_0F9 00000000  801f5f20  801f5f20  000051c4  2**0
                  CONTENTS
299 .inttab_tc0_0FA 00000000  801f5f40  801f5f40  000051c4  2**0
                  CONTENTS
300 .inttab_tc0_0FB 00000000  801f5f60  801f5f60  000051c4  2**0
                  CONTENTS
301 .inttab_tc0_0FC 00000000  801f5f80  801f5f80  000051c4  2**0
                  CONTENTS
302 .inttab_tc0_0FD 00000000  801f5fa0  801f5fa0  000051c4  2**0
                  CONTENTS
303 .inttab_tc0_0FE 00000000  801f5fc0  801f5fc0  000051c4  2**0
                  CONTENTS
304 .inttab_tc0_0FF 00000000  801f5fe0  801f5fe0  000051c4  2**0
                  CONTENTS
305 .comment      0000001b  00000000  00000000  000051c4  2**0
                  CONTENTS, READONLY
306 .debug_aranges 00000bc8  00000000  00000000  000051e0  2**3
                  CONTENTS, READONLY, DEBUGGING
307 .debug_info   00087ee0  00000000  00000000  00005da8  2**0
                  CONTENTS, READONLY, DEBUGGING
308 .debug_abbrev 00006d6d  00000000  00000000  0008dc88  2**0
                  CONTENTS, READONLY, DEBUGGING
309 .debug_line   00016327  00000000  00000000  000949f5  2**0
                  CONTENTS, READONLY, DEBUGGING
310 .debug_frame  00001768  00000000  00000000  000aad1c  2**2
                  CONTENTS, READONLY, DEBUGGING
311 .debug_str    00001746  00000000  00000000  000ac484  2**0
                  CONTENTS, READONLY, DEBUGGING
312 .debug_loc    0000838f  00000000  00000000  000adbca  2**0
                  CONTENTS, READONLY, DEBUGGING
313 .debug_ranges 00001080  00000000  00000000  000b5f60  2**3
                  CONTENTS, READONLY, DEBUGGING
314 .debug_macro  000f0096  00000000  00000000  000b6fe0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .startup:

80000020 <_START>:
#elif defined(__DCC__)
#pragma section CODE ".start" X
#endif

void _START(void)
{
80000020:	40 ae       	mov.aa %a14,%sp
    __non_return_call(_Core0_start);
80000022:	91 00 00 28 	movh.a %a2,32768
80000026:	d9 22 c2 e1 	lea %a2,[%a2]8066 <80001f82 <_Core0_start>>
8000002a:	dc 02       	ji %a2
}
8000002c:	00 90       	ret 

8000002e <_START_end>:
8000002e:	08 00       	ld.bu %d0,[%a15]0

Disassembly of section .traptab_tc0:

80000100 <IfxCpu_Trap_vectorTable0>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu0"
#endif
void IfxCpu_Trap_vectorTable0(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80000100:	0d 00 00 02 	svlcx 
80000104:	02 f4       	mov %d4,%d15
80000106:	91 00 00 28 	movh.a %a2,32768
8000010a:	d9 22 84 d1 	lea %a2,[%a2]6980 <80001b44 <IfxCpu_Trap_memoryManagementError>>
8000010e:	dc 02       	ji %a2
80000110:	00 80       	rfe 
	...
8000011e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80000120:	0d 00 00 02 	svlcx 
80000124:	02 f4       	mov %d4,%d15
80000126:	91 00 00 28 	movh.a %a2,32768
8000012a:	d9 22 b2 d1 	lea %a2,[%a2]7026 <80001b72 <IfxCpu_Trap_internalProtectionError>>
8000012e:	dc 02       	ji %a2
80000130:	00 80       	rfe 
	...
8000013e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80000140:	0d 00 00 02 	svlcx 
80000144:	02 f4       	mov %d4,%d15
80000146:	91 00 00 28 	movh.a %a2,32768
8000014a:	d9 22 a0 e1 	lea %a2,[%a2]7072 <80001ba0 <IfxCpu_Trap_instructionError>>
8000014e:	dc 02       	ji %a2
80000150:	00 80       	rfe 
	...
8000015e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80000160:	02 f4       	mov %d4,%d15
80000162:	91 00 00 28 	movh.a %a2,32768
80000166:	d9 22 8e f1 	lea %a2,[%a2]7118 <80001bce <IfxCpu_Trap_contextManagementError>>
8000016a:	dc 02       	ji %a2
8000016c:	00 80       	rfe 
	...
8000017e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80000180:	0d 00 00 02 	svlcx 
80000184:	02 f4       	mov %d4,%d15
80000186:	91 00 00 28 	movh.a %a2,32768
8000018a:	d9 22 bc f1 	lea %a2,[%a2]7164 <80001bfc <IfxCpu_Trap_busError>>
8000018e:	dc 02       	ji %a2
80000190:	00 80       	rfe 
	...
8000019e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
800001a0:	0d 00 00 02 	svlcx 
800001a4:	02 f4       	mov %d4,%d15
800001a6:	91 00 00 28 	movh.a %a2,32768
800001aa:	d9 22 ea 01 	lea %a2,[%a2]7210 <80001c2a <IfxCpu_Trap_assertion>>
800001ae:	dc 02       	ji %a2
800001b0:	00 80       	rfe 
	...
800001be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0);
800001c0:	0d 00 00 02 	svlcx 
800001c4:	02 f4       	mov %d4,%d15
800001c6:	91 00 00 28 	movh.a %a2,32768
800001ca:	d9 22 de 11 	lea %a2,[%a2]7262 <80001c5e <IfxCpu_Trap_systemCall_Cpu0>>
800001ce:	dc 02       	ji %a2
800001d0:	00 80       	rfe 
	...
800001de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
800001e0:	0d 00 00 02 	svlcx 
800001e4:	02 f4       	mov %d4,%d15
800001e6:	91 00 00 28 	movh.a %a2,32768
800001ea:	d9 22 e2 31 	lea %a2,[%a2]7394 <80001ce2 <IfxCpu_Trap_nonMaskableInterrupt>>
800001ee:	dc 02       	ji %a2
800001f0:	00 80       	rfe 
}
800001f2:	00 90       	ret 

800001f4 <IfxCpu_Trap_vectorTable0_end>:
	...

Disassembly of section .text:

80000428 <deregister_tm_clones>:
80000428:	7b 00 00 26 	movh %d2,24576
8000042c:	1b 42 56 20 	addi %d2,%d2,1380
80000430:	91 00 00 46 	movh.a %a4,24576
80000434:	60 22       	mov.a %a2,%d2
80000436:	d9 44 64 50 	lea %a4,[%a4]1380 <60000564 <__TMC_END__>>
8000043a:	7d 42 0a 00 	jeq.a %a2,%a4,8000044e <deregister_tm_clones+0x26>
8000043e:	91 00 00 20 	movh.a %a2,0
80000442:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
80000446:	bd 02 04 00 	jz.a %a2,8000044e <deregister_tm_clones+0x26>
8000044a:	2d 02 00 00 	calli %a2
8000044e:	00 90       	ret 

80000450 <register_tm_clones>:
80000450:	7b 00 00 26 	movh %d2,24576
80000454:	1b 42 56 20 	addi %d2,%d2,1380
80000458:	91 00 00 46 	movh.a %a4,24576
8000045c:	60 22       	mov.a %a2,%d2
8000045e:	d9 44 64 50 	lea %a4,[%a4]1380 <60000564 <__TMC_END__>>
80000462:	01 42 20 20 	sub.a %a2,%a2,%a4
80000466:	80 22       	mov.d %d2,%a2
80000468:	8f e2 3f 30 	sha %d3,%d2,-2
8000046c:	8f 12 1e 20 	sh %d2,%d2,-31
80000470:	42 32       	add %d2,%d3
80000472:	8f f2 3f 40 	sha %d4,%d2,-1
80000476:	df 04 0a 00 	jeq %d4,0,8000048a <register_tm_clones+0x3a>
8000047a:	91 00 00 20 	movh.a %a2,0
8000047e:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
80000482:	bd 02 04 00 	jz.a %a2,8000048a <register_tm_clones+0x3a>
80000486:	2d 02 00 00 	calli %a2
8000048a:	00 90       	ret 

8000048c <__do_global_dtors_aux>:
8000048c:	91 00 00 e6 	movh.a %a14,24576
80000490:	39 e2 68 50 	ld.bu %d2,[%a14]1384 <60000568 <completed.1>>
80000494:	df 02 2d 80 	jne %d2,0,800004ee <__do_global_dtors_aux+0x62>
80000498:	91 00 00 38 	movh.a %a3,32768
8000049c:	91 00 00 28 	movh.a %a2,32768
800004a0:	d9 33 70 f4 	lea %a3,[%a3]18416 <800047f0 <__DTOR_END__>>
800004a4:	d9 22 64 f4 	lea %a2,[%a2]18404 <800047e4 <__DTOR_LIST__>>
800004a8:	01 23 20 20 	sub.a %a2,%a3,%a2
800004ac:	80 22       	mov.d %d2,%a2
800004ae:	86 e2       	sha %d2,-2
800004b0:	1b f2 ff 8f 	addi %d8,%d2,-1
800004b4:	91 00 00 c6 	movh.a %a12,24576
800004b8:	7b 00 00 28 	movh %d2,32768
800004bc:	1b 42 7e 24 	addi %d2,%d2,18404
800004c0:	60 2d       	mov.a %a13,%d2
800004c2:	19 c2 6c 50 	ld.w %d2,[%a12]1388 <6000056c <dtor_idx.0>>
800004c6:	7f 82 0f 80 	jge.u %d2,%d8,800004e4 <__do_global_dtors_aux+0x58>
800004ca:	d9 cc 6c 50 	lea %a12,[%a12]1388 <6000056c <dtor_idx.0>>
800004ce:	c2 12       	add %d2,1
800004d0:	74 c2       	st.w [%a12],%d2
800004d2:	06 22       	sh %d2,2
800004d4:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800004d8:	d4 22       	ld.a %a2,[%a2]
800004da:	2d 02 00 00 	calli %a2
800004de:	54 c2       	ld.w %d2,[%a12]
800004e0:	3f 82 f7 ff 	jlt.u %d2,%d8,800004ce <__do_global_dtors_aux+0x42>
800004e4:	6d ff a2 ff 	call 80000428 <deregister_tm_clones>
800004e8:	82 12       	mov %d2,1
800004ea:	e9 e2 68 50 	st.b [%a14]1384 <60000568 <completed.1>>,%d2
800004ee:	00 90       	ret 

800004f0 <frame_dummy>:
800004f0:	6d ff b0 ff 	call 80000450 <register_tm_clones>
800004f4:	00 90       	ret 

800004f6 <init_UART_SUB>:
uint8 SUB_uartTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 SUB_uartRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];


//----------------- Main <-> Sub -----------------//
void init_UART_SUB(void){
800004f6:	40 ae       	mov.aa %a14,%sp
800004f8:	20 98       	sub.a %sp,152
    IfxAsclin_Asc_Config    ascConf;

    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN2);
800004fa:	c5 f5 80 00 	lea %a5,f0000800 <_SMALL_DATA4_+0x5fff8800>
800004fe:	d9 e4 cc ef 	lea %a4,[%a14]-116
80000502:	6d 00 0b 16 	call 80003118 <IfxAsclin_Asc_initModuleConfig>

    ascConf.baudrate.baudrate   = ASC_BAUDRATE;
80000506:	7b 10 7e 24 	movh %d2,18401
8000050a:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    ascConf.baudrate.oversampling   = IfxAsclin_OversamplingFactor_16;
8000050e:	3b f0 00 20 	mov %d2,15
80000512:	59 e2 d8 ef 	st.w [%a14]-104,%d2

    ascConf.bitTiming.medianFilter  = IfxAsclin_SamplesPerBit_three;
80000516:	82 12       	mov %d2,1
80000518:	59 e2 dc ef 	st.w [%a14]-100,%d2
    ascConf.bitTiming.samplePointPosition   = IfxAsclin_SamplePointPosition_8;
8000051c:	3b 80 00 20 	mov %d2,8
80000520:	59 e2 e0 ef 	st.w [%a14]-96,%d2

    ascConf.interrupt.txPriority    = ISR_PRIORITY_ASCLIN_TX_SUB;
80000524:	3b 90 00 20 	mov %d2,9
80000528:	f9 e2 d4 ff 	st.h [%a14]-44,%d2
    ascConf.interrupt.rxPriority    = ISR_PRIORITY_ASCLIN_RX_SUB;
8000052c:	82 42       	mov %d2,4
8000052e:	f9 e2 d6 ff 	st.h [%a14]-42,%d2
    ascConf.interrupt.erPriority    = ISR_PRIORITY_ASCLIN_ER_SUB;
80000532:	3b d0 00 20 	mov %d2,13
80000536:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;
8000053a:	82 02       	mov %d2,0
8000053c:	59 e2 dc ff 	st.w [%a14]-36,%d2

    const IfxAsclin_Asc_Pins pins = {
80000540:	d9 e3 e8 df 	lea %a3,[%a14]-152
80000544:	91 00 00 26 	movh.a %a2,24576
80000548:	d9 22 00 00 	lea %a2,[%a2]0 <60000000 <LCF_DSPR1_START>>
8000054c:	40 34       	mov.aa %a4,%a3
8000054e:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000552:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000556:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
8000055a:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
8000055e:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000562:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000566:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
8000056a:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
8000056e:	44 24       	ld.w %d4,[%a2+]
80000570:	64 44       	st.w [%a4+],%d4
            .ctsMode    = IfxPort_InputMode_pullUp,
            .rts        = NULL_PTR,
            .rtsMode    = IfxPort_OutputMode_pushPull,
            .pinDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;
80000572:	b5 e3 e0 ff 	st.a [%a14]-32 <60000008 <LCF_DSPR1_START+0x8>>,%a3

    ascConf.txBuffer        = SUB_uartTxBuffer;
80000576:	91 00 00 26 	movh.a %a2,24576
8000057a:	d9 22 9c 00 	lea %a2,[%a2]2076 <6000081c <SUB_uartTxBuffer>>
8000057e:	b5 e2 ec ff 	st.a [%a14]-20 <6000081c <SUB_uartTxBuffer>>,%a2
    ascConf.txBufferSize    = ASC_TX_BUFFER_SIZE;
80000582:	3b 00 10 20 	mov %d2,256
80000586:	f9 e2 ea ff 	st.h [%a14]-22,%d2
    ascConf.rxBuffer        = SUB_uartRxBuffer;
8000058a:	91 00 00 26 	movh.a %a2,24576
8000058e:	d9 22 74 b0 	lea %a2,[%a2]1780 <600006f4 <SUB_uartRxBuffer>>
80000592:	b5 e2 f4 ff 	st.a [%a14]-12 <600006f4 <SUB_uartRxBuffer>>,%a2
    ascConf.rxBufferSize    = ASC_RX_BUFFER_SIZE;
80000596:	f9 e2 f0 ff 	st.h [%a14]-16 <600006f4 <SUB_uartRxBuffer>>,%d2

    IfxAsclin_Asc_initModule(&SUB_ascHandle0, &ascConf);
8000059a:	d9 e5 cc ef 	lea %a5,[%a14]-116 <600006f4 <SUB_uartRxBuffer>>
8000059e:	91 00 00 46 	movh.a %a4,24576
800005a2:	d9 44 84 50 	lea %a4,[%a4]2372 <60000944 <SUB_ascHandle0>>
800005a6:	6d 00 7f 13 	call 80002ca4 <IfxAsclin_Asc_initModule>

}
800005aa:	00 90       	ret 

800005ac <out_UART_SUB>:

//char dataSet[5];

uint8 dataSet[3];
void out_UART_SUB(uint8 data){
800005ac:	40 ae       	mov.aa %a14,%sp
800005ae:	20 08       	sub.a %sp,8
    //int n100 = ((int)Num)/100;
//    int n10 = (((int)Num)/10)%10;
//    int n1 = ((int)Num)%10;
    //int n0 = ((int)(Num*10))%10;

    Ifx_SizeT count = 3;
800005b0:	82 32       	mov %d2,3
800005b2:	f9 e2 fe ff 	st.h [%a14]-2,%d2

    //uint8 dataSet[count];

    dataSet[0] = 'E';
800005b6:	91 00 00 26 	movh.a %a2,24576
800005ba:	d9 25 70 b0 	lea %a5,[%a2]1776 <600006f0 <dataSet>>
800005be:	3b 50 04 20 	mov %d2,69
800005c2:	e9 22 70 b0 	st.b [%a2]1776 <600006f0 <dataSet>>,%d2
    dataSet[1] = 'H';
800005c6:	3b 80 04 20 	mov %d2,72
800005ca:	e9 52 01 00 	st.b [%a5]1,%d2
    dataSet[2] = '\n';
800005ce:	3b a0 00 20 	mov %d2,10
800005d2:	e9 52 02 00 	st.b [%a5]2,%d2

    IfxAsclin_Asc_write(&SUB_ascHandle0, dataSet, &count, TIME_INFINITE);
800005d6:	82 f4       	mov %d4,-1
800005d8:	82 f5       	mov %d5,-1
800005da:	06 f5       	sh %d5,-1
800005dc:	d9 e6 fe ff 	lea %a6,[%a14]-2
800005e0:	91 00 00 46 	movh.a %a4,24576
800005e4:	d9 44 84 50 	lea %a4,[%a4]2372 <60000944 <SUB_ascHandle0>>
800005e8:	6d 00 11 16 	call 8000320a <IfxAsclin_Asc_write>

}
800005ec:	00 90       	ret 

800005ee <asc2TxISR>:

//----------------- Main <-> Sub -----------------//
IFX_INTERRUPT(asc2TxISR, 0, ISR_PRIORITY_ASCLIN_TX_SUB);
void asc2TxISR(void){
800005ee:	40 ae       	mov.aa %a14,%sp
    IfxAsclin_Asc_isrTransmit(&SUB_ascHandle0);
800005f0:	91 00 00 46 	movh.a %a4,24576
800005f4:	d9 44 84 50 	lea %a4,[%a4]2372 <60000944 <SUB_ascHandle0>>
800005f8:	6d 00 7c 12 	call 80002af0 <IfxAsclin_Asc_isrTransmit>
}
800005fc:	0d 00 40 02 	rslcx 
80000600:	00 80       	rfe 

80000602 <asc2RxISR>:

IFX_INTERRUPT(asc2RxISR, 0, ISR_PRIORITY_ASCLIN_RX_SUB);
void asc2RxISR(void){
80000602:	40 ae       	mov.aa %a14,%sp
    IfxAsclin_Asc_isrReceive(&SUB_ascHandle0);
80000604:	91 00 00 46 	movh.a %a4,24576
80000608:	d9 44 84 50 	lea %a4,[%a4]2372 <60000944 <SUB_ascHandle0>>
8000060c:	6d 00 d8 12 	call 80002bbc <IfxAsclin_Asc_isrReceive>

    if(RXcnt_SUB == byte0){
80000610:	91 00 00 26 	movh.a %a2,24576
80000614:	d9 22 a4 60 	lea %a2,[%a2]2468 <600009a4 <RXcnt_SUB>>
80000618:	54 23       	ld.w %d3,[%a2]
8000061a:	82 02       	mov %d2,0
8000061c:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000620:	8f d2 00 21 	and %d2,%d2,13
80000624:	df 02 19 00 	jeq %d2,0,80000656 <asc2RxISR+0x54>
        RXcnt_SUB = byte1;
        RXDATA_SUB[byte0] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
    }

    else if(RXcnt_SUB == byte1){
80000628:	7b 00 f8 23 	movh %d2,16256
8000062c:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000630:	8f d2 00 21 	and %d2,%d2,13
80000634:	df 02 24 00 	jeq %d2,0,8000067c <asc2RxISR+0x7a>
            RXcnt_SUB = byte0;
            RXDATA_SUB[byte1] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
    }

    if(RXDATA_SUB[byte0] == 'O'){
80000638:	91 00 00 26 	movh.a %a2,24576
8000063c:	39 22 a0 60 	ld.bu %d2,[%a2]2464 <600009a0 <RXDATA_SUB>>
80000640:	3b f0 04 30 	mov %d3,79
80000644:	5f 32 30 00 	jeq %d2,%d3,800006a4 <asc2RxISR+0xa2>
        IfxPort_setPinHigh(PORT_102);
    }
    else if(RXDATA_SUB[byte0] == 'X'){
80000648:	3b 80 05 30 	mov %d3,88
8000064c:	5f 32 37 00 	jeq %d2,%d3,800006ba <asc2RxISR+0xb8>
        IfxPort_setPinLow(PORT_102);
    }
    //RXDATA_SUB[byte0] = '1';
}
80000650:	0d 00 40 02 	rslcx 
80000654:	00 80       	rfe 
        RXcnt_SUB = byte1;
80000656:	91 00 00 26 	movh.a %a2,24576
8000065a:	7b 00 f8 23 	movh %d2,16256
8000065e:	d9 22 a4 60 	lea %a2,[%a2]2468 <600009a4 <RXcnt_SUB>>
80000662:	74 22       	st.w [%a2],%d2
        RXDATA_SUB[byte0] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
80000664:	91 00 00 46 	movh.a %a4,24576
80000668:	d9 44 84 50 	lea %a4,[%a4]2372 <60000944 <SUB_ascHandle0>>
8000066c:	6d 00 07 13 	call 80002c7a <IfxAsclin_Asc_blockingRead>
80000670:	91 00 00 26 	movh.a %a2,24576
80000674:	e9 22 a0 60 	st.b [%a2]2464 <600009a0 <RXDATA_SUB>>,%d2
80000678:	1d ff e0 ff 	j 80000638 <asc2RxISR+0x36>
            RXcnt_SUB = byte0;
8000067c:	91 00 00 26 	movh.a %a2,24576
80000680:	82 02       	mov %d2,0
80000682:	d9 22 a4 60 	lea %a2,[%a2]2468 <600009a4 <RXcnt_SUB>>
80000686:	74 22       	st.w [%a2],%d2
            RXDATA_SUB[byte1] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
80000688:	91 00 00 46 	movh.a %a4,24576
8000068c:	d9 44 84 50 	lea %a4,[%a4]2372 <60000944 <SUB_ascHandle0>>
80000690:	6d 00 f5 12 	call 80002c7a <IfxAsclin_Asc_blockingRead>
80000694:	91 00 00 26 	movh.a %a2,24576
80000698:	d9 22 a0 60 	lea %a2,[%a2]2464 <600009a0 <RXDATA_SUB>>
8000069c:	e9 22 01 00 	st.b [%a2]1 <60000001 <LCF_DSPR1_START+0x1>>,%d2
800006a0:	1d ff cc ff 	j 80000638 <asc2RxISR+0x36>
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800006a4:	91 40 00 2f 	movh.a %a2,61444
800006a8:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800006ac:	82 42       	mov %d2,4
800006ae:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800006b2:	74 22       	st.w [%a2],%d2
}
800006b4:	0d 00 40 02 	rslcx 
800006b8:	00 80       	rfe 
    port->OMR.U = action << pinIndex;
800006ba:	91 40 00 2f 	movh.a %a2,61444
800006be:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800006c2:	7b 40 00 20 	movh %d2,4
800006c6:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
}
800006ca:	1d ff c3 ff 	j 80000650 <asc2RxISR+0x4e>

800006ce <asc2ErrISR>:

IFX_INTERRUPT(asc2ErrISR, 0, ISR_PRIORITY_ASCLIN_ER_SUB);
void asc2ErrISR(void){
800006ce:	40 ae       	mov.aa %a14,%sp
    // while(1);
}
800006d0:	0d 00 40 02 	rslcx 
800006d4:	00 80       	rfe 

800006d6 <Task1ms>:
        }
    }
}

void Task1ms(void)
{
800006d6:	40 ae       	mov.aa %a14,%sp
    cnt1ms++;
800006d8:	91 00 00 26 	movh.a %a2,24576
800006dc:	d9 23 94 60 	lea %a3,[%a2]2452 <60000994 <cnt1ms>>
800006e0:	54 32       	ld.w %d2,[%a3]
800006e2:	c2 12       	add %d2,1
800006e4:	59 22 94 60 	st.w [%a2]2452 <60000994 <cnt1ms>>,%d2
    //DHT11_read(&temperature, &humidity);


}
800006e8:	00 90       	ret 

800006ea <Task100ms>:
    cnt10ms++;
//    DHT11_read(&temperature, &humidity);
}

void Task100ms(void)
{
800006ea:	40 ae       	mov.aa %a14,%sp
    cnt100ms++;
800006ec:	91 00 00 26 	movh.a %a2,24576
800006f0:	d9 23 90 60 	lea %a3,[%a2]2448 <60000990 <cnt100ms>>
800006f4:	54 32       	ld.w %d2,[%a3]
800006f6:	c2 12       	add %d2,1
800006f8:	59 22 90 60 	st.w [%a2]2448 <60000990 <cnt100ms>>,%d2
    DHT11_read(&temperature, &humidity);
800006fc:	91 00 00 56 	movh.a %a5,24576
80000700:	d9 55 98 60 	lea %a5,[%a5]2456 <60000998 <humidity>>
80000704:	91 00 00 46 	movh.a %a4,24576
80000708:	d9 44 9c 60 	lea %a4,[%a4]2460 <6000099c <temperature>>
8000070c:	6d 00 d3 16 	call 800034b2 <DHT11_read>
    check_temperature_and_send_warning();
80000710:	6d 00 1d 00 	call 8000074a <check_temperature_and_send_warning>

}
80000714:	00 90       	ret 

80000716 <AppScheduling>:
{
80000716:	40 ae       	mov.aa %a14,%sp
    if (Scheduler1msFlag == 1)
80000718:	91 00 00 26 	movh.a %a2,24576
8000071c:	19 22 a8 50 	ld.w %d2,[%a2]2408 <60000968 <Scheduler1msFlag>>
80000720:	df 12 03 00 	jeq %d2,1,80000726 <AppScheduling+0x10>
}
80000724:	00 90       	ret 
        Scheduler1msFlag = 0;
80000726:	82 02       	mov %d2,0
80000728:	59 22 a8 50 	st.w [%a2]2408,%d2
        Task1ms();
8000072c:	6d ff d5 ff 	call 800006d6 <Task1ms>
        if (Scheduler100msFlag == 1)
80000730:	91 00 00 26 	movh.a %a2,24576
80000734:	19 22 a4 50 	ld.w %d2,[%a2]2404 <60000964 <Scheduler100msFlag>>
80000738:	df 12 f6 ff 	jne %d2,1,80000724 <AppScheduling+0xe>
            Scheduler100msFlag = 0;
8000073c:	82 02       	mov %d2,0
8000073e:	59 22 a4 50 	st.w [%a2]2404 <60000964 <Scheduler100msFlag>>,%d2
            Task100ms();
80000742:	6d ff d4 ff 	call 800006ea <Task100ms>
}
80000746:	1d ff ef ff 	j 80000724 <AppScheduling+0xe>

8000074a <check_temperature_and_send_warning>:
 *      Author: 최종윤
 */

#include "Header_USER.h"

void check_temperature_and_send_warning(void) {
8000074a:	40 ae       	mov.aa %a14,%sp

    // DHT11에서 온도 읽기

        if (temperature > 30) {
8000074c:	91 00 00 26 	movh.a %a2,24576
80000750:	19 22 9c 60 	ld.w %d2,[%a2]2460 <6000099c <temperature>>
80000754:	8b f2 41 22 	lt %d2,%d2,31
80000758:	df 02 03 00 	jeq %d2,0,8000075e <check_temperature_and_send_warning+0x14>
            out_UART_SUB(0);  // "EH" 송신
        }
    }
8000075c:	00 90       	ret 
            out_UART_SUB(0);  // "EH" 송신
8000075e:	82 04       	mov %d4,0
80000760:	6d ff 26 ff 	call 800005ac <out_UART_SUB>
    }
80000764:	1d ff fc ff 	j 8000075c <check_temperature_and_send_warning+0x12>

80000768 <init_STM>:
uint32 Scheduler1msFlag = 0;
uint32 Scheduler10msFlag = 0;
uint32 Scheduler100msFlag = 0;

void init_STM(void)
{
80000768:	40 ae       	mov.aa %a14,%sp
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
8000076a:	4d c0 e2 8f 	mfcr %d8,$icr
    return reg.B.IE != 0;
8000076e:	37 08 e1 87 	extr.u %d8,%d8,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
80000772:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80000776:	00 00       	nop 
    boolean ISR_State = IfxCpu_disableInterrupts();

    IfxStm_enableOcdsSuspend(STM0);
80000778:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
8000077c:	6d 00 17 03 	call 80000daa <IfxStm_enableOcdsSuspend>
    IfxStm_initCompareConfig(&stmConfig);
80000780:	91 00 00 c6 	movh.a %a12,24576
80000784:	d9 cc b4 50 	lea %a12,[%a12]2420 <60000974 <stmConfig>>
80000788:	40 c4       	mov.aa %a4,%a12
8000078a:	6d 00 ed 03 	call 80000f64 <IfxStm_initCompareConfig>

    stmConfig.ticks = 100u;     //100u
8000078e:	3b 40 06 20 	mov %d2,100
80000792:	59 c2 10 00 	st.w [%a12]16 <60000010 <LCF_DSPR1_START+0x10>>,%d2
    stmConfig.triggerPriority = 3u;
80000796:	82 32       	mov %d2,3
80000798:	f9 c2 14 00 	st.h [%a12]20 <60000014 <LCF_DSPR1_START+0x14>>,%d2
    stmConfig.typeOfService = IfxSrc_Tos_cpu1;
8000079c:	82 12       	mov %d2,1
8000079e:	59 c2 18 00 	st.w [%a12]24 <60000018 <LCF_DSPR1_START+0x18>>,%d2

    IfxStm_initCompare(STM0, &stmConfig);
800007a2:	40 c5       	mov.aa %a5,%a12
800007a4:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
800007a8:	6d 00 35 03 	call 80000e12 <IfxStm_initCompare>
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
800007ac:	df 08 04 00 	jeq %d8,0,800007b4 <init_STM+0x4c>
    {
        __enable();
800007b0:	0d 00 00 03 	enable 

    IfxCpu_restoreInterrupts(ISR_State);
}
800007b4:	00 90       	ret 

800007b6 <ISR_STM>:

void ISR_STM(void)
{
800007b6:	40 ae       	mov.aa %a14,%sp
    __enable();
800007b8:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    IfxStm_clearCompareFlag(STM0, stmConfig.comparator);
800007bc:	91 00 00 c6 	movh.a %a12,24576
800007c0:	19 c4 b4 50 	ld.w %d4,[%a12]2420 <60000974 <stmConfig>>
800007c4:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
800007c8:	6d 00 c3 02 	call 80000d4e <IfxStm_clearCompareFlag>
    IfxStm_increaseCompare(STM0, stmConfig.comparator, 100u); /***PERIOD***/
800007cc:	19 c2 b4 50 	ld.w %d2,[%a12]2420 <60000974 <stmConfig>>
}


IFX_INLINE void IfxStm_increaseCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks)
{
    stm->CMP[comparator].B.CMPVAL = stm->CMP[comparator].B.CMPVAL + ticks;
800007d0:	1b c2 00 20 	addi %d2,%d2,12
800007d4:	06 22       	sh %d2,2
800007d6:	60 22       	mov.a %a2,%d2
800007d8:	11 02 00 2f 	addih.a %a2,%a2,61440
800007dc:	54 22       	ld.w %d2,[%a2]
800007de:	1b 42 06 20 	addi %d2,%d2,100
800007e2:	74 22       	st.w [%a2],%d2


    //IfxPort_togglePin(DHT11_PIN);

    counter1ms++;
800007e4:	91 00 00 26 	movh.a %a2,24576
800007e8:	d9 23 ac 50 	lea %a3,[%a2]2412 <6000096c <counter1ms>>
800007ec:	54 32       	ld.w %d2,[%a3]
800007ee:	c2 12       	add %d2,1
800007f0:	59 22 ac 50 	st.w [%a2]2412 <6000096c <counter1ms>>,%d2
    //IfxPort_togglePin(PORT_102);

    if((counter1ms % 1) == 0)
    {
        Scheduler1msFlag = 1;
800007f4:	91 00 00 26 	movh.a %a2,24576
800007f8:	82 13       	mov %d3,1
800007fa:	59 23 a8 50 	st.w [%a2]2408 <60000968 <Scheduler1msFlag>>,%d3
    }

    if((counter1ms % 100000) == 0)
800007fe:	7b 20 00 30 	movh %d3,2
80000802:	1b 03 6a 38 	addi %d3,%d3,-31072
80000806:	4b 32 11 22 	div.u %e2,%d2,%d3
8000080a:	df 03 07 80 	jne %d3,0,80000818 <ISR_STM+0x62>
        {
            Scheduler100msFlag = 1;
8000080e:	91 00 00 26 	movh.a %a2,24576
80000812:	82 12       	mov %d2,1
80000814:	59 22 a4 50 	st.w [%a2]2404 <60000964 <Scheduler100msFlag>>,%d2
        }

}
80000818:	0d 00 40 02 	rslcx 
8000081c:	00 80       	rfe 

8000081e <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
8000081e:	40 ae       	mov.aa %a14,%sp
80000820:	40 52       	mov.aa %a2,%a5
    uint8 *Dest = (uint8 *)data;
80000822:	1d 00 07 00 	j 80000830 <Ifx_CircularBuffer_read8+0x12>
        Dest  = &Dest[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80000826:	82 02       	mov %d2,0
80000828:	f9 42 04 00 	st.h [%a4]4,%d2
        }
    } while (count > 0);
8000082c:	bf 14 19 00 	jlt %d4,1,8000085e <Ifx_CircularBuffer_read8+0x40>
        count--;
80000830:	c2 f4       	add %d4,-1
80000832:	37 04 50 40 	extr %d4,%d4,0,16
        *Dest = ((uint8 *)buffer->base)[buffer->index];
80000836:	b9 42 04 00 	ld.hu %d2,[%a4]4
8000083a:	d4 43       	ld.a %a3,[%a4]
8000083c:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80000840:	14 32       	ld.bu %d2,[%a3]
80000842:	24 22       	st.b [%a2+],%d2
        buffer->index++;
80000844:	b9 42 04 00 	ld.hu %d2,[%a4]4
80000848:	c2 12       	add %d2,1
8000084a:	37 02 70 20 	extr.u %d2,%d2,0,16
8000084e:	f9 42 04 00 	st.h [%a4]4,%d2
        if (buffer->index >= buffer->length)
80000852:	b9 43 06 00 	ld.hu %d3,[%a4]6
80000856:	3f 32 eb ff 	jlt.u %d2,%d3,8000082c <Ifx_CircularBuffer_read8+0xe>
8000085a:	1d ff e6 ff 	j 80000826 <Ifx_CircularBuffer_read8+0x8>

    return Dest;
}
8000085e:	00 90       	ret 

80000860 <Ifx_CircularBuffer_write8>:
    return Dest;
}


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
80000860:	40 ae       	mov.aa %a14,%sp
80000862:	40 52       	mov.aa %a2,%a5
    const uint8 *source = (const uint8 *)data;
80000864:	1d 00 07 00 	j 80000872 <Ifx_CircularBuffer_write8+0x12>
        source                                 = &source[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
80000868:	82 02       	mov %d2,0
8000086a:	f9 42 04 00 	st.h [%a4]4,%d2
        }
    } while (count > 0);
8000086e:	bf 14 19 00 	jlt %d4,1,800008a0 <Ifx_CircularBuffer_write8+0x40>
        count--;
80000872:	c2 f4       	add %d4,-1
80000874:	37 04 50 40 	extr %d4,%d4,0,16
        ((uint8 *)buffer->base)[buffer->index] = *source;
80000878:	b9 42 04 00 	ld.hu %d2,[%a4]4
8000087c:	d4 43       	ld.a %a3,[%a4]
8000087e:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80000882:	04 22       	ld.bu %d2,[%a2+]
80000884:	34 32       	st.b [%a3],%d2
        buffer->index++;
80000886:	b9 42 04 00 	ld.hu %d2,[%a4]4
8000088a:	c2 12       	add %d2,1
8000088c:	37 02 70 20 	extr.u %d2,%d2,0,16
80000890:	f9 42 04 00 	st.h [%a4]4,%d2
        if (buffer->index >= buffer->length)
80000894:	b9 43 06 00 	ld.hu %d3,[%a4]6
80000898:	3f 32 eb ff 	jlt.u %d2,%d3,8000086e <Ifx_CircularBuffer_write8+0xe>
8000089c:	1d ff e6 ff 	j 80000868 <Ifx_CircularBuffer_write8+0x8>

    return source;
}
800008a0:	00 90       	ret 

800008a2 <Ifx_Fifo_beginRead>:

/**
 * param: count in bytes
 */
static Ifx_SizeT Ifx_Fifo_beginRead(Ifx_Fifo *fifo, Ifx_SizeT count)
{
800008a2:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_ICR);
800008a4:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
800008a8:	37 03 e1 37 	extr.u %d3,%d3,15,1
    __disable();
800008ac:	0d 00 40 03 	disable 
800008b0:	00 00       	nop 
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
800008b2:	c9 40 04 00 	ld.h %d0,[%a4]4
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800008b6:	0b 04 80 01 	min %d0,%d4,%d0
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
800008ba:	37 00 50 50 	extr %d5,%d0,0,16
    blockSize               -= blockSize % fifo->elementSize;
800008be:	c9 46 1a 00 	ld.h %d6,[%a4]26
800008c2:	4b 65 01 62 	div %e6,%d5,%d6
800008c6:	0b 70 80 20 	sub %d2,%d0,%d7
800008ca:	37 02 50 20 	extr %d2,%d2,0,16
    fifo->eventReader        = FALSE;
800008ce:	82 05       	mov %d5,0
800008d0:	e9 45 1c 00 	st.b [%a4]28,%d5
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
800008d4:	a2 24       	sub %d4,%d2
800008d6:	c9 45 18 00 	ld.h %d5,[%a4]24
800008da:	0b 54 80 41 	min %d4,%d4,%d5
800008de:	59 44 08 00 	st.w [%a4]8,%d4
    if (enabled != FALSE)
800008e2:	df 03 04 00 	jeq %d3,0,800008ea <Ifx_Fifo_beginRead+0x48>
        __enable();
800008e6:	0d 00 00 03 	enable 
    IfxCpu_restoreInterrupts(interruptState);

    return blockSize;
}
800008ea:	00 90       	ret 

800008ec <Ifx_Fifo_readEnd>:

/**
 * param: count in bytes
 */
static Ifx_SizeT Ifx_Fifo_readEnd(Ifx_Fifo *fifo, Ifx_SizeT count, Ifx_SizeT blockSize)
{
800008ec:	40 ae       	mov.aa %a14,%sp
800008ee:	02 47       	mov %d7,%d4
    reg.U = __mfcr(CPU_ICR);
800008f0:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
800008f4:	37 03 e1 37 	extr.u %d3,%d3,15,1
    __disable();
800008f8:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
800008fc:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();

    fifo->shared.count -= blockSize;
800008fe:	37 05 70 20 	extr.u %d2,%d5,0,16
80000902:	c9 46 04 00 	ld.h %d6,[%a4]4
80000906:	a2 26       	sub %d6,%d2
80000908:	f9 46 04 00 	st.h [%a4]4,%d6

    if (fifo->shared.writerWaitx != 0)
8000090c:	d9 42 0c 00 	lea %a2,[%a4]12
80000910:	19 46 0c 00 	ld.w %d6,[%a4]12
80000914:	df 06 07 00 	jeq %d6,0,80000922 <Ifx_Fifo_readEnd+0x36>
    {
        fifo->shared.writerWaitx -= blockSize;
80000918:	0b 56 80 40 	sub %d4,%d6,%d5
8000091c:	74 24       	st.w [%a2],%d4

        if (fifo->shared.writerWaitx <= 0)
8000091e:	bf 14 0b 00 	jlt %d4,1,80000934 <Ifx_Fifo_readEnd+0x48>
    if (enabled != FALSE)
80000922:	df 03 04 00 	jeq %d3,0,8000092a <Ifx_Fifo_readEnd+0x3e>
        __enable();
80000926:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
8000092a:	0b 27 80 20 	sub %d2,%d7,%d2
}
8000092e:	37 02 50 20 	extr %d2,%d2,0,16
80000932:	00 90       	ret 
            fifo->shared.writerWaitx = 0;
80000934:	82 04       	mov %d4,0
80000936:	74 24       	st.w [%a2],%d4
            fifo->eventWriter        = TRUE; /* Signal the writer */
80000938:	82 14       	mov %d4,1
8000093a:	e9 44 1d 00 	st.b [%a4]29,%d4
8000093e:	1d ff f2 ff 	j 80000922 <Ifx_Fifo_readEnd+0x36>

80000942 <Ifx_Fifo_beginWrite>:
    IfxCpu_restoreInterrupts(interruptState);
}


static Ifx_SizeT Ifx_Fifo_beginWrite(Ifx_Fifo *fifo, Ifx_SizeT count)
{
80000942:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_ICR);
80000944:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80000948:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
8000094c:	0d 00 40 03 	disable 
80000950:	00 00       	nop 
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
80000952:	c9 43 18 00 	ld.h %d3,[%a4]24
80000956:	c9 42 04 00 	ld.h %d2,[%a4]4
8000095a:	0b 23 80 20 	sub %d2,%d3,%d2
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000095e:	0b 24 80 01 	min %d0,%d4,%d2
80000962:	37 00 50 60 	extr %d6,%d0,0,16
    blockSize               -= blockSize % fifo->elementSize;
80000966:	c9 42 1a 00 	ld.h %d2,[%a4]26
8000096a:	4b 26 01 62 	div %e6,%d6,%d2
8000096e:	0b 70 80 20 	sub %d2,%d0,%d7
80000972:	37 02 50 20 	extr %d2,%d2,0,16
    fifo->eventWriter        = FALSE;
80000976:	82 06       	mov %d6,0
80000978:	e9 46 1d 00 	st.b [%a4]29,%d6
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
8000097c:	a2 24       	sub %d4,%d2
8000097e:	0b 34 80 41 	min %d4,%d4,%d3
80000982:	59 44 0c 00 	st.w [%a4]12,%d4
    if (enabled != FALSE)
80000986:	df 05 04 00 	jeq %d5,0,8000098e <Ifx_Fifo_beginWrite+0x4c>
        __enable();
8000098a:	0d 00 00 03 	enable 
    IfxCpu_restoreInterrupts(interruptState);

    return blockSize;
}
8000098e:	00 90       	ret 

80000990 <Ifx_Fifo_endWrite>:

    return result;
}

static Ifx_SizeT Ifx_Fifo_endWrite(Ifx_Fifo *fifo, Ifx_SizeT count, Ifx_SizeT blockSize)
{
80000990:	40 ae       	mov.aa %a14,%sp
80000992:	02 40       	mov %d0,%d4
    reg.U = __mfcr(CPU_ICR);
80000994:	4d c0 e2 6f 	mfcr %d6,$icr
    return reg.B.IE != 0;
80000998:	37 06 e1 67 	extr.u %d6,%d6,15,1
    __disable();
8000099c:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
800009a0:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
800009a2:	37 05 70 20 	extr.u %d2,%d5,0,16
800009a6:	c9 43 04 00 	ld.h %d3,[%a4]4
800009aa:	42 23       	add %d3,%d2
800009ac:	37 03 50 30 	extr %d3,%d3,0,16
800009b0:	f9 43 04 00 	st.h [%a4]4,%d3
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
800009b4:	c9 47 10 00 	ld.h %d7,[%a4]16
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800009b8:	0b 37 a0 31 	max %d3,%d7,%d3
800009bc:	f9 43 10 00 	st.h [%a4]16,%d3

    if (fifo->shared.readerWaitx != 0)
800009c0:	d9 42 08 00 	lea %a2,[%a4]8
800009c4:	19 43 08 00 	ld.w %d3,[%a4]8
800009c8:	df 03 06 00 	jeq %d3,0,800009d4 <Ifx_Fifo_endWrite+0x44>
    {
        fifo->shared.readerWaitx -= blockSize;
800009cc:	a2 53       	sub %d3,%d5
800009ce:	74 23       	st.w [%a2],%d3

        if (fifo->shared.readerWaitx <= 0)
800009d0:	bf 13 0b 00 	jlt %d3,1,800009e6 <Ifx_Fifo_endWrite+0x56>
    if (enabled != FALSE)
800009d4:	df 06 04 00 	jeq %d6,0,800009dc <Ifx_Fifo_endWrite+0x4c>
        __enable();
800009d8:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
800009dc:	0b 20 80 20 	sub %d2,%d0,%d2
}
800009e0:	37 02 50 20 	extr %d2,%d2,0,16
800009e4:	00 90       	ret 
            fifo->shared.readerWaitx = 0;
800009e6:	82 03       	mov %d3,0
800009e8:	74 23       	st.w [%a2],%d3
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
800009ea:	82 13       	mov %d3,1
800009ec:	e9 43 1c 00 	st.b [%a4]28,%d3
800009f0:	1d ff f2 ff 	j 800009d4 <Ifx_Fifo_endWrite+0x44>

800009f4 <Ifx_Fifo_init>:
{
800009f4:	40 ae       	mov.aa %a14,%sp
800009f6:	40 42       	mov.aa %a2,%a4
    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
800009f8:	c2 34       	add %d4,3
800009fa:	37 04 50 40 	extr %d4,%d4,0,16
800009fe:	8f 34 c0 41 	andn %d4,%d4,3
        fifo->eventReader        = FALSE;
80000a02:	82 02       	mov %d2,0
80000a04:	e9 42 1c 00 	st.b [%a4]28,%d2
        fifo->eventWriter        = TRUE;
80000a08:	82 12       	mov %d2,1
80000a0a:	e9 42 1d 00 	st.b [%a4]29,%d2
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
80000a0e:	80 42       	mov.d %d2,%a4
80000a10:	1b 72 02 20 	addi %d2,%d2,39
80000a14:	8f 72 c0 21 	andn %d2,%d2,7
80000a18:	74 42       	st.w [%a4],%d2
        fifo->shared.count       = 0;
80000a1a:	82 02       	mov %d2,0
80000a1c:	f9 42 04 00 	st.h [%a4]4,%d2
        fifo->shared.maxcount    = 0;
80000a20:	f9 42 10 00 	st.h [%a4]16,%d2
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
80000a24:	82 02       	mov %d2,0
80000a26:	59 42 0c 00 	st.w [%a4]12,%d2
80000a2a:	59 42 08 00 	st.w [%a4]8,%d2
        fifo->startIndex         = fifo->endIndex = 0;
80000a2e:	f9 42 16 00 	st.h [%a4]22,%d2
80000a32:	f9 42 14 00 	st.h [%a4]20,%d2
        fifo->size               = size;
80000a36:	f9 44 18 00 	st.h [%a4]24,%d4
        fifo->elementSize        = elementSize;
80000a3a:	f9 45 1a 00 	st.h [%a4]26,%d5
}
80000a3e:	00 90       	ret 

80000a40 <Ifx_Fifo_create>:
{
80000a40:	40 ae       	mov.aa %a14,%sp
80000a42:	37 05 50 90 	extr %d9,%d5,0,16
    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
80000a46:	1b 34 00 20 	addi %d2,%d4,3
80000a4a:	37 02 50 20 	extr %d2,%d2,0,16
80000a4e:	8f 32 c0 81 	andn %d8,%d2,3
    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
80000a52:	1b 88 02 40 	addi %d4,%d8,40
80000a56:	6d 00 5a 19 	call 80003d0a <malloc>
    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
80000a5a:	bd 02 07 00 	jz.a %a2,80000a68 <Ifx_Fifo_create+0x28>
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
80000a5e:	02 95       	mov %d5,%d9
80000a60:	02 84       	mov %d4,%d8
80000a62:	40 24       	mov.aa %a4,%a2
80000a64:	6d ff c8 ff 	call 800009f4 <Ifx_Fifo_init>
}
80000a68:	00 90       	ret 

80000a6a <Ifx_Fifo_read>:
{
80000a6a:	40 ae       	mov.aa %a14,%sp
80000a6c:	20 08       	sub.a %sp,8
80000a6e:	40 4c       	mov.aa %a12,%a4
80000a70:	80 5d       	mov.d %d13,%a5
80000a72:	02 69       	mov %d9,%d6
80000a74:	02 78       	mov %d8,%d7
80000a76:	37 04 50 a0 	extr %d10,%d4,0,16
    if (count != 0)
80000a7a:	df 0a 7c 00 	jeq %d10,0,80000b72 <Ifx_Fifo_read+0x108>
        buffer.base   = fifo->buffer;
80000a7e:	54 42       	ld.w %d2,[%a4]
80000a80:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
80000a84:	b9 42 18 00 	ld.hu %d2,[%a4]24
80000a88:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
80000a8c:	b9 42 14 00 	ld.hu %d2,[%a4]20
80000a90:	f9 e2 fc ff 	st.h [%a14]-4,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80000a94:	82 f2       	mov %d2,-1
80000a96:	06 f2       	sh %d2,-1
80000a98:	0b 27 00 21 	eq %d2,%d7,%d2
80000a9c:	8b f6 1f 24 	and.eq %d2,%d6,-1
80000aa0:	df 02 1a 80 	jne %d2,0,80000ad4 <Ifx_Fifo_read+0x6a>
    reg.U = __mfcr(CPU_ICR);
80000aa4:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80000aa8:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80000aac:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
80000ab0:	00 00       	nop 
    result  = stm->TIM0.U;
80000ab2:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80000ab6:	19 26 10 00 	ld.w %d6,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80000aba:	19 22 2c 00 	ld.w %d2,[%a2]44
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80000abe:	02 63       	mov %d3,%d6
80000ac0:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80000ac4:	df 04 04 00 	jeq %d4,0,80000acc <Ifx_Fifo_read+0x62>
        __enable();
80000ac8:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80000acc:	0b 39 40 90 	addx %d9,%d9,%d3
80000ad0:	0b 28 50 80 	addc %d8,%d8,%d2
    boolean            Stop = FALSE;
80000ad4:	82 0c       	mov %d12,0
80000ad6:	1d 00 1f 00 	j 80000b14 <Ifx_Fifo_read+0xaa>
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
80000ada:	02 24       	mov %d4,%d2
80000adc:	60 d5       	mov.a %a5,%d13
80000ade:	d9 e4 f8 ff 	lea %a4,[%a14]-8
80000ae2:	6d ff 9e fe 	call 8000081e <Ifx_CircularBuffer_read8>
80000ae6:	80 2d       	mov.d %d13,%a2
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
80000ae8:	02 b5       	mov %d5,%d11
80000aea:	02 a4       	mov %d4,%d10
80000aec:	40 c4       	mov.aa %a4,%a12
80000aee:	6d ff ff fe 	call 800008ec <Ifx_Fifo_readEnd>
80000af2:	02 2a       	mov %d10,%d2
80000af4:	1d 00 17 00 	j 80000b22 <Ifx_Fifo_read+0xb8>
    {
        result = FALSE;
    }
    else
    {
        result = IfxStm_now() >= deadLine;
80000af8:	0b 38 00 21 	eq %d2,%d8,%d3
80000afc:	0b 94 50 22 	and.ge.u %d2,%d4,%d9
80000b00:	0b 38 90 22 	or.lt %d2,%d8,%d3
80000b04:	8f f2 0f 21 	and %d2,%d2,255
            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80000b08:	df 02 2e 80 	jne %d2,0,80000b64 <Ifx_Fifo_read+0xfa>
            if (count != 0)
80000b0c:	df 0a 3f 80 	jne %d10,0,80000b8a <Ifx_Fifo_read+0x120>
        } while (count != 0);
80000b10:	df 0a 2d 00 	jeq %d10,0,80000b6a <Ifx_Fifo_read+0x100>
            blockSize = Ifx_Fifo_beginRead(fifo, count);
80000b14:	02 a4       	mov %d4,%d10
80000b16:	40 c4       	mov.aa %a4,%a12
80000b18:	6d ff c5 fe 	call 800008a2 <Ifx_Fifo_beginRead>
80000b1c:	02 2b       	mov %d11,%d2
            if (blockSize != 0)
80000b1e:	df 02 de ff 	jne %d2,0,80000ada <Ifx_Fifo_read+0x70>
            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80000b22:	df 0c 21 80 	jne %d12,0,80000b64 <Ifx_Fifo_read+0xfa>
    if (deadLine == TIME_INFINITE)
80000b26:	82 f2       	mov %d2,-1
80000b28:	06 f2       	sh %d2,-1
80000b2a:	0b 28 00 21 	eq %d2,%d8,%d2
80000b2e:	8b f9 1f 24 	and.eq %d2,%d9,-1
80000b32:	df 02 ed ff 	jne %d2,0,80000b0c <Ifx_Fifo_read+0xa2>
    reg.U = __mfcr(CPU_ICR);
80000b36:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80000b3a:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80000b3e:	0d 00 40 03 	disable 
80000b42:	00 00       	nop 
    result  = stm->TIM0.U;
80000b44:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80000b48:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80000b4c:	19 32 2c 00 	ld.w %d2,[%a3]44
80000b50:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80000b54:	b7 02 81 3f 	insert %d3,%d2,0,31,1
    if (enabled != FALSE)
80000b58:	df 05 d0 7f 	jeq %d5,0,80000af8 <Ifx_Fifo_read+0x8e>
        __enable();
80000b5c:	0d 00 00 03 	enable 
80000b60:	1d ff cc ff 	j 80000af8 <Ifx_Fifo_read+0x8e>
                fifo->shared.readerWaitx = 0;
80000b64:	82 02       	mov %d2,0
80000b66:	59 c2 08 00 	st.w [%a12]8,%d2
        fifo->startIndex = buffer.index;
80000b6a:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80000b6e:	f9 c2 14 00 	st.h [%a12]20,%d2
}
80000b72:	02 a2       	mov %d2,%d10
80000b74:	00 90       	ret 
        result = IfxStm_now() >= deadLine;
80000b76:	0b 28 00 31 	eq %d3,%d8,%d2
80000b7a:	0b 94 50 32 	and.ge.u %d3,%d4,%d9
80000b7e:	0b 28 90 32 	or.lt %d3,%d8,%d2
80000b82:	8f f3 0f 31 	and %d3,%d3,255
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80000b86:	df 03 25 80 	jne %d3,0,80000bd0 <Ifx_Fifo_read+0x166>
80000b8a:	39 c2 1c 00 	ld.bu %d2,[%a12]28
80000b8e:	df 02 21 80 	jne %d2,0,80000bd0 <Ifx_Fifo_read+0x166>
    if (deadLine == TIME_INFINITE)
80000b92:	82 f2       	mov %d2,-1
80000b94:	06 f2       	sh %d2,-1
80000b96:	0b 28 00 21 	eq %d2,%d8,%d2
80000b9a:	8b f9 1f 24 	and.eq %d2,%d9,-1
80000b9e:	df 02 f6 ff 	jne %d2,0,80000b8a <Ifx_Fifo_read+0x120>
    reg.U = __mfcr(CPU_ICR);
80000ba2:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80000ba6:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80000baa:	0d 00 40 03 	disable 
80000bae:	00 00       	nop 
    result  = stm->TIM0.U;
80000bb0:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80000bb4:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80000bb8:	19 32 2c 00 	ld.w %d2,[%a3]44
80000bbc:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80000bc0:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80000bc4:	df 05 d9 7f 	jeq %d5,0,80000b76 <Ifx_Fifo_read+0x10c>
        __enable();
80000bc8:	0d 00 00 03 	enable 
80000bcc:	1d ff d5 ff 	j 80000b76 <Ifx_Fifo_read+0x10c>
                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
80000bd0:	39 cc 1c 00 	ld.bu %d12,[%a12]28
80000bd4:	8b 0c 00 c2 	eq %d12,%d12,0
80000bd8:	1d ff 9c ff 	j 80000b10 <Ifx_Fifo_read+0xa6>

80000bdc <Ifx_Fifo_write>:



Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80000bdc:	40 ae       	mov.aa %a14,%sp
80000bde:	20 08       	sub.a %sp,8
80000be0:	40 4c       	mov.aa %a12,%a4
80000be2:	80 5d       	mov.d %d13,%a5
80000be4:	02 69       	mov %d9,%d6
80000be6:	02 78       	mov %d8,%d7
80000be8:	37 04 50 a0 	extr %d10,%d4,0,16
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80000bec:	df 0a 7c 00 	jeq %d10,0,80000ce4 <Ifx_Fifo_write+0x108>
    {
        buffer.base   = fifo->buffer;
80000bf0:	54 42       	ld.w %d2,[%a4]
80000bf2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
80000bf6:	b9 42 18 00 	ld.hu %d2,[%a4]24
80000bfa:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
80000bfe:	b9 42 16 00 	ld.hu %d2,[%a4]22
80000c02:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    if (timeout == TIME_INFINITE)
80000c06:	82 f2       	mov %d2,-1
80000c08:	06 f2       	sh %d2,-1
80000c0a:	0b 27 00 21 	eq %d2,%d7,%d2
80000c0e:	8b f6 1f 24 	and.eq %d2,%d6,-1
80000c12:	df 02 1a 80 	jne %d2,0,80000c46 <Ifx_Fifo_write+0x6a>
    reg.U = __mfcr(CPU_ICR);
80000c16:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80000c1a:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80000c1e:	0d 00 40 03 	disable 
80000c22:	00 00       	nop 
    result  = stm->TIM0.U;
80000c24:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80000c28:	19 26 10 00 	ld.w %d6,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80000c2c:	19 22 2c 00 	ld.w %d2,[%a2]44
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80000c30:	02 63       	mov %d3,%d6
80000c32:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80000c36:	df 04 04 00 	jeq %d4,0,80000c3e <Ifx_Fifo_write+0x62>
        __enable();
80000c3a:	0d 00 00 03 	enable 
        deadLine = IfxStm_now() + timeout;
80000c3e:	0b 39 40 90 	addx %d9,%d9,%d3
80000c42:	0b 28 50 80 	addc %d8,%d8,%d2
    boolean            Stop = FALSE;
80000c46:	82 0c       	mov %d12,0
80000c48:	1d 00 1f 00 	j 80000c86 <Ifx_Fifo_write+0xaa>
            blockSize = Ifx_Fifo_beginWrite(fifo, count);

            if (blockSize != 0)
            {
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
80000c4c:	02 24       	mov %d4,%d2
80000c4e:	60 d5       	mov.a %a5,%d13
80000c50:	d9 e4 f8 ff 	lea %a4,[%a14]-8
80000c54:	6d ff 06 fe 	call 80000860 <Ifx_CircularBuffer_write8>
80000c58:	80 2d       	mov.d %d13,%a2
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
80000c5a:	02 b5       	mov %d5,%d11
80000c5c:	02 a4       	mov %d4,%d10
80000c5e:	40 c4       	mov.aa %a4,%a12
80000c60:	6d ff 98 fe 	call 80000990 <Ifx_Fifo_endWrite>
80000c64:	02 2a       	mov %d10,%d2
80000c66:	1d 00 17 00 	j 80000c94 <Ifx_Fifo_write+0xb8>
        result = IfxStm_now() >= deadLine;
80000c6a:	0b 38 00 21 	eq %d2,%d8,%d3
80000c6e:	0b 94 50 22 	and.ge.u %d2,%d4,%d9
80000c72:	0b 38 90 22 	or.lt %d2,%d8,%d3
80000c76:	8f f2 0f 21 	and %d2,%d2,255
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80000c7a:	df 02 2e 80 	jne %d2,0,80000cd6 <Ifx_Fifo_write+0xfa>
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
                break;
            }

            if (count != 0)
80000c7e:	df 0a 3f 80 	jne %d10,0,80000cfc <Ifx_Fifo_write+0x120>
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
            }
        } while (count != 0);
80000c82:	df 0a 2d 00 	jeq %d10,0,80000cdc <Ifx_Fifo_write+0x100>
            blockSize = Ifx_Fifo_beginWrite(fifo, count);
80000c86:	02 a4       	mov %d4,%d10
80000c88:	40 c4       	mov.aa %a4,%a12
80000c8a:	6d ff 5c fe 	call 80000942 <Ifx_Fifo_beginWrite>
80000c8e:	02 2b       	mov %d11,%d2
            if (blockSize != 0)
80000c90:	df 02 de ff 	jne %d2,0,80000c4c <Ifx_Fifo_write+0x70>
            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80000c94:	df 0c 21 80 	jne %d12,0,80000cd6 <Ifx_Fifo_write+0xfa>
    if (deadLine == TIME_INFINITE)
80000c98:	82 f2       	mov %d2,-1
80000c9a:	06 f2       	sh %d2,-1
80000c9c:	0b 28 00 21 	eq %d2,%d8,%d2
80000ca0:	8b f9 1f 24 	and.eq %d2,%d9,-1
80000ca4:	df 02 ed ff 	jne %d2,0,80000c7e <Ifx_Fifo_write+0xa2>
    reg.U = __mfcr(CPU_ICR);
80000ca8:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80000cac:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80000cb0:	0d 00 40 03 	disable 
80000cb4:	00 00       	nop 
    result  = stm->TIM0.U;
80000cb6:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80000cba:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80000cbe:	19 32 2c 00 	ld.w %d2,[%a3]44
80000cc2:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80000cc6:	b7 02 81 3f 	insert %d3,%d2,0,31,1
    if (enabled != FALSE)
80000cca:	df 05 d0 7f 	jeq %d5,0,80000c6a <Ifx_Fifo_write+0x8e>
        __enable();
80000cce:	0d 00 00 03 	enable 
80000cd2:	1d ff cc ff 	j 80000c6a <Ifx_Fifo_write+0x8e>
                fifo->shared.writerWaitx = 0;
80000cd6:	82 02       	mov %d2,0
80000cd8:	59 c2 0c 00 	st.w [%a12]12,%d2

        fifo->endIndex = buffer.index;
80000cdc:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80000ce0:	f9 c2 16 00 	st.h [%a12]22,%d2
    }

    return count;
}
80000ce4:	02 a2       	mov %d2,%d10
80000ce6:	00 90       	ret 
        result = IfxStm_now() >= deadLine;
80000ce8:	0b 28 00 31 	eq %d3,%d8,%d2
80000cec:	0b 94 50 32 	and.ge.u %d3,%d4,%d9
80000cf0:	0b 28 90 32 	or.lt %d3,%d8,%d2
80000cf4:	8f f3 0f 31 	and %d3,%d3,255
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80000cf8:	df 03 25 80 	jne %d3,0,80000d42 <Ifx_Fifo_write+0x166>
80000cfc:	39 c2 1d 00 	ld.bu %d2,[%a12]29
80000d00:	df 02 21 80 	jne %d2,0,80000d42 <Ifx_Fifo_write+0x166>
    if (deadLine == TIME_INFINITE)
80000d04:	82 f2       	mov %d2,-1
80000d06:	06 f2       	sh %d2,-1
80000d08:	0b 28 00 21 	eq %d2,%d8,%d2
80000d0c:	8b f9 1f 24 	and.eq %d2,%d9,-1
80000d10:	df 02 f6 ff 	jne %d2,0,80000cfc <Ifx_Fifo_write+0x120>
    reg.U = __mfcr(CPU_ICR);
80000d14:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80000d18:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80000d1c:	0d 00 40 03 	disable 
80000d20:	00 00       	nop 
    result  = stm->TIM0.U;
80000d22:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80000d26:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80000d2a:	19 32 2c 00 	ld.w %d2,[%a3]44
80000d2e:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80000d32:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80000d36:	df 05 d9 7f 	jeq %d5,0,80000ce8 <Ifx_Fifo_write+0x10c>
        __enable();
80000d3a:	0d 00 00 03 	enable 
80000d3e:	1d ff d5 ff 	j 80000ce8 <Ifx_Fifo_write+0x10c>
                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
80000d42:	39 cc 1d 00 	ld.bu %d12,[%a12]29
80000d46:	8b 0c 00 c2 	eq %d12,%d12,0
80000d4a:	1d ff 9c ff 	j 80000c82 <Ifx_Fifo_write+0xa6>

80000d4e <IfxStm_clearCompareFlag>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxStm_clearCompareFlag(Ifx_STM *stm, IfxStm_Comparator comparator)
{
80000d4e:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
80000d50:	df 04 0a 80 	jne %d4,0,80000d64 <IfxStm_clearCompareFlag+0x16>
    {
        stm->ISCR.B.CMP0IRR = 1U;
80000d54:	d9 42 00 10 	lea %a2,[%a4]64
80000d58:	19 42 00 10 	ld.w %d2,[%a4]64
80000d5c:	b7 12 01 20 	insert %d2,%d2,1,0,1
80000d60:	74 22       	st.w [%a2],%d2
80000d62:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
80000d64:	df 14 03 00 	jeq %d4,1,80000d6a <IfxStm_clearCompareFlag+0x1c>
    {
        stm->ISCR.B.CMP1IRR = 1U;
    }
}
80000d68:	00 90       	ret 
        stm->ISCR.B.CMP1IRR = 1U;
80000d6a:	d9 42 00 10 	lea %a2,[%a4]64
80000d6e:	19 42 00 10 	ld.w %d2,[%a4]64
80000d72:	b7 12 01 21 	insert %d2,%d2,1,2,1
80000d76:	74 22       	st.w [%a2],%d2
}
80000d78:	1d ff f8 ff 	j 80000d68 <IfxStm_clearCompareFlag+0x1a>

80000d7c <IfxStm_enableComparatorInterrupt>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxStm_enableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator)
{
80000d7c:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
80000d7e:	df 04 0a 80 	jne %d4,0,80000d92 <IfxStm_enableComparatorInterrupt+0x16>
    {
        stm->ICR.B.CMP0EN = 1U;
80000d82:	d9 42 3c 00 	lea %a2,[%a4]60
80000d86:	19 42 3c 00 	ld.w %d2,[%a4]60
80000d8a:	b7 12 01 20 	insert %d2,%d2,1,0,1
80000d8e:	74 22       	st.w [%a2],%d2
80000d90:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
80000d92:	df 14 03 00 	jeq %d4,1,80000d98 <IfxStm_enableComparatorInterrupt+0x1c>
    {
        stm->ICR.B.CMP1EN = 1U;
    }
}
80000d96:	00 90       	ret 
        stm->ICR.B.CMP1EN = 1U;
80000d98:	d9 42 3c 00 	lea %a2,[%a4]60
80000d9c:	19 42 3c 00 	ld.w %d2,[%a4]60
80000da0:	b7 12 01 22 	insert %d2,%d2,1,4,1
80000da4:	74 22       	st.w [%a2],%d2
}
80000da6:	1d ff f8 ff 	j 80000d96 <IfxStm_enableComparatorInterrupt+0x1a>

80000daa <IfxStm_enableOcdsSuspend>:


void IfxStm_enableOcdsSuspend(Ifx_STM *stm)
{
80000daa:	40 ae       	mov.aa %a14,%sp
    Ifx_STM_OCS ocs = stm->OCS;
80000dac:	d9 42 28 30 	lea %a2,[%a4]232
80000db0:	19 42 28 30 	ld.w %d2,[%a4]232

    /* Only if OCDS is enabled write into the OCS register */
    if (MODULE_CBS.OSTATE.B.OEN == 1U)
80000db4:	85 f3 40 20 	ld.w %d3,f0000480 <_SMALL_DATA4_+0x5fff8480>
80000db8:	6f 03 03 80 	jnz.t %d3,0,80000dbe <IfxStm_enableOcdsSuspend+0x14>
        ocs.B.SUS_P      = 1;
        ocs.B.SUS        = 2;
        stm->OCS         = ocs;
        stm->OCS.B.SUS_P = 0;
    }
}
80000dbc:	00 90       	ret 
        ocs.B.SUS_P      = 1;
80000dbe:	b7 12 01 2e 	insert %d2,%d2,1,28,1
        ocs.B.SUS        = 2;
80000dc2:	b7 22 04 2c 	insert %d2,%d2,2,24,4
        stm->OCS         = ocs;
80000dc6:	74 22       	st.w [%a2],%d2
        stm->OCS.B.SUS_P = 0;
80000dc8:	54 22       	ld.w %d2,[%a2]
80000dca:	b7 02 01 2e 	insert %d2,%d2,0,28,1
80000dce:	74 22       	st.w [%a2],%d2
}
80000dd0:	1d ff f6 ff 	j 80000dbc <IfxStm_enableOcdsSuspend+0x12>

80000dd4 <IfxStm_getIndex>:
    return module;
}


IfxStm_Index IfxStm_getIndex(Ifx_STM *stm)
{
80000dd4:	40 ae       	mov.aa %a14,%sp
    uint32       index;
    IfxStm_Index result;

    result = IfxStm_Index_none;

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
80000dd6:	82 02       	mov %d2,0
80000dd8:	1d 00 03 00 	j 80000dde <IfxStm_getIndex+0xa>
80000ddc:	c2 12       	add %d2,1
80000dde:	ff 32 18 80 	jge.u %d2,3,80000e0e <IfxStm_getIndex+0x3a>
    {
        if (IfxStm_cfg_indexMap[index].module == stm)
80000de2:	8f 32 00 30 	sh %d3,%d2,3
80000de6:	91 00 00 28 	movh.a %a2,32768
80000dea:	d9 22 2c 90 	lea %a2,[%a2]620 <8000026c <IfxStm_cfg_indexMap>>
80000dee:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80000df2:	54 23       	ld.w %d3,[%a2]
80000df4:	80 44       	mov.d %d4,%a4
80000df6:	5f 43 f3 ff 	jne %d3,%d4,80000ddc <IfxStm_getIndex+0x8>
        {
            result = (IfxStm_Index)IfxStm_cfg_indexMap[index].index;
80000dfa:	06 32       	sh %d2,3
80000dfc:	91 00 00 28 	movh.a %a2,32768
80000e00:	d9 22 2c 90 	lea %a2,[%a2]620 <8000026c <IfxStm_cfg_indexMap>>
80000e04:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80000e08:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80000e0c:	00 90       	ret 
    result = IfxStm_Index_none;
80000e0e:	82 f2       	mov %d2,-1
        }
    }

    return result;
}
80000e10:	00 90       	ret 

80000e12 <IfxStm_initCompare>:
    return comparator == IfxStm_Comparator_0 ? &MODULE_SRC.STM.STM[index].SR0 : &MODULE_SRC.STM.STM[index].SR1;
}


boolean IfxStm_initCompare(Ifx_STM *stm, const IfxStm_CompareConfig *config)
{
80000e12:	40 ae       	mov.aa %a14,%sp
80000e14:	40 4d       	mov.aa %a13,%a4
80000e16:	40 5c       	mov.aa %a12,%a5
    sint32        index;
    boolean       result;
    Ifx_STM_CMCON comcon = stm->CMCON;
80000e18:	19 42 38 00 	ld.w %d2,[%a4]56
    Ifx_STM_ICR   icr    = stm->ICR;
80000e1c:	19 43 3c 00 	ld.w %d3,[%a4]60

    if (config->comparator == 0)
80000e20:	54 54       	ld.w %d4,[%a5]
80000e22:	df 04 82 80 	jne %d4,0,80000f26 <IfxStm_initCompare+0x114>
    {
        comcon.B.MSIZE0  = config->compareSize;
80000e26:	19 54 0c 00 	ld.w %d4,[%a5]12
80000e2a:	37 42 05 20 	insert %d2,%d2,%d4,0,5
        comcon.B.MSTART0 = config->compareOffset;
80000e2e:	19 54 08 00 	ld.w %d4,[%a5]8
80000e32:	37 42 05 24 	insert %d2,%d2,%d4,8,5
        icr.B.CMP0OS     = config->comparatorInterrupt;
80000e36:	19 54 04 00 	ld.w %d4,[%a5]4
80000e3a:	67 43 02 30 	ins.t %d3,%d3,2,%d4,0
        result           = TRUE;
80000e3e:	82 18       	mov %d8,1
    {
        /*Invalid value */
        result = FALSE;
    }

    stm->ICR.U   = icr.U;
80000e40:	59 d3 3c 00 	st.w [%a13]60,%d3
    stm->CMCON.U = comcon.U;
80000e44:	59 d2 38 00 	st.w [%a13]56,%d2

    /* configure interrupt */
    index = IfxStm_getIndex(stm);
80000e48:	40 d4       	mov.aa %a4,%a13
80000e4a:	6d ff c5 ff 	call 80000dd4 <IfxStm_getIndex>

    if (config->triggerPriority > 0)
80000e4e:	b9 c3 14 00 	ld.hu %d3,[%a12]20
80000e52:	df 03 20 00 	jeq %d3,0,80000e92 <IfxStm_initCompare+0x80>
    {
        volatile Ifx_SRC_SRCR *srcr;

        if (config->comparatorInterrupt == IfxStm_ComparatorInterrupt_ir0)
80000e56:	19 c4 04 00 	ld.w %d4,[%a12]4
80000e5a:	df 04 7a 80 	jne %d4,0,80000f4e <IfxStm_initCompare+0x13c>
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR0);
80000e5e:	06 32       	sh %d2,3
80000e60:	7b 40 00 4f 	movh %d4,61444
80000e64:	1b 04 49 48 	addi %d4,%d4,-31600
80000e68:	60 42       	mov.a %a2,%d4
80000e6a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
        else
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
        }

        IfxSrc_init(srcr, config->typeOfService, config->triggerPriority);
80000e6e:	19 c4 18 00 	ld.w %d4,[%a12]24
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80000e72:	54 22       	ld.w %d2,[%a2]
80000e74:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80000e78:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80000e7a:	54 22       	ld.w %d2,[%a2]
80000e7c:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80000e80:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80000e82:	54 22       	ld.w %d2,[%a2]
80000e84:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80000e88:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80000e8a:	54 22       	ld.w %d2,[%a2]
80000e8c:	b7 12 01 25 	insert %d2,%d2,1,10,1
80000e90:	74 22       	st.w [%a2],%d2
        IfxSrc_enable(srcr);
    }

    /*Configure the comparator ticks to current value to avoid any wrong triggering*/
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset);
80000e92:	39 c5 08 00 	ld.bu %d5,[%a12]8

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
80000e96:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
80000e9a:	19 d2 2c 00 	ld.w %d2,[%a13]44
80000e9e:	8f 06 40 41 	or %d4,%d6,0
80000ea2:	02 23       	mov %d3,%d2
{
    uint64 now;

    now = IfxStm_get(stm);

    return (uint32)(now >> offset);
80000ea4:	8b 05 82 22 	ge %d2,%d5,32
80000ea8:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
80000eac:	ab 03 a0 32 	seln %d3,%d2,%d3,0
80000eb0:	8f f5 01 21 	and %d2,%d5,31
80000eb4:	8b 02 02 51 	rsub %d5,%d2,32
80000eb8:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
80000ebc:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
80000ec0:	54 c2       	ld.w %d2,[%a12]
80000ec2:	1b c2 00 20 	addi %d2,%d2,12
80000ec6:	06 22       	sh %d2,2
80000ec8:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000ecc:	74 23       	st.w [%a2],%d3

    /* clear the interrupt flag of the selected comparator before enabling the interrupt */
    /* this is to avaoid the unneccesary interrupt for the compare match of reset values of the registers */
    IfxStm_clearCompareFlag(stm, config->comparator);
80000ece:	54 c4       	ld.w %d4,[%a12]
80000ed0:	40 d4       	mov.aa %a4,%a13
80000ed2:	6d ff 3e ff 	call 80000d4e <IfxStm_clearCompareFlag>
    /* enable the interrupt for the selected comparator */
    IfxStm_enableComparatorInterrupt(stm, config->comparator);
80000ed6:	54 c4       	ld.w %d4,[%a12]
80000ed8:	40 d4       	mov.aa %a4,%a13
80000eda:	6d ff 51 ff 	call 80000d7c <IfxStm_enableComparatorInterrupt>

    /*Configure the comparator ticks */
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset) + config->ticks;
80000ede:	39 c5 08 00 	ld.bu %d5,[%a12]8
    result  = stm->TIM0.U;
80000ee2:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
80000ee6:	19 d2 2c 00 	ld.w %d2,[%a13]44
80000eea:	8f 06 40 41 	or %d4,%d6,0
80000eee:	02 23       	mov %d3,%d2
    return (uint32)(now >> offset);
80000ef0:	8b 05 82 22 	ge %d2,%d5,32
80000ef4:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
80000ef8:	ab 03 a0 32 	seln %d3,%d2,%d3,0
80000efc:	8f f5 01 21 	and %d2,%d5,31
80000f00:	8b 02 02 51 	rsub %d5,%d2,32
80000f04:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
80000f08:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
80000f0c:	02 34       	mov %d4,%d3
80000f0e:	19 c3 10 00 	ld.w %d3,[%a12]16
80000f12:	54 c2       	ld.w %d2,[%a12]
80000f14:	42 43       	add %d3,%d4
80000f16:	1b c2 00 20 	addi %d2,%d2,12
80000f1a:	06 22       	sh %d2,2
80000f1c:	01 d2 00 d6 	addsc.a %a13,%a13,%d2,0
80000f20:	74 d3       	st.w [%a13],%d3

    return result;
}
80000f22:	02 82       	mov %d2,%d8
80000f24:	00 90       	ret 
    else if (config->comparator == 1)
80000f26:	df 14 05 00 	jeq %d4,1,80000f30 <IfxStm_initCompare+0x11e>
        result = FALSE;
80000f2a:	82 08       	mov %d8,0
80000f2c:	1d ff 8a ff 	j 80000e40 <IfxStm_initCompare+0x2e>
        comcon.B.MSIZE1  = config->compareSize;
80000f30:	19 54 0c 00 	ld.w %d4,[%a5]12
80000f34:	37 42 05 28 	insert %d2,%d2,%d4,16,5
        comcon.B.MSTART1 = config->compareOffset;
80000f38:	19 54 08 00 	ld.w %d4,[%a5]8
80000f3c:	37 42 05 2c 	insert %d2,%d2,%d4,24,5
        icr.B.CMP1OS     = config->comparatorInterrupt;
80000f40:	19 54 04 00 	ld.w %d4,[%a5]4
80000f44:	67 43 06 30 	ins.t %d3,%d3,6,%d4,0
        result           = TRUE;
80000f48:	82 18       	mov %d8,1
80000f4a:	1d ff 7b ff 	j 80000e40 <IfxStm_initCompare+0x2e>
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
80000f4e:	06 32       	sh %d2,3
80000f50:	c2 42       	add %d2,4
80000f52:	7b 40 00 4f 	movh %d4,61444
80000f56:	1b 04 49 48 	addi %d4,%d4,-31600
80000f5a:	60 42       	mov.a %a2,%d4
80000f5c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80000f60:	1d ff 87 ff 	j 80000e6e <IfxStm_initCompare+0x5c>

80000f64 <IfxStm_initCompareConfig>:


void IfxStm_initCompareConfig(IfxStm_CompareConfig *config)
{
80000f64:	40 ae       	mov.aa %a14,%sp
    config->comparator          = IfxStm_Comparator_0;
80000f66:	82 02       	mov %d2,0
80000f68:	74 42       	st.w [%a4],%d2
    config->compareOffset       = IfxStm_ComparatorOffset_0;
80000f6a:	59 42 08 00 	st.w [%a4]8,%d2
    config->compareSize         = IfxStm_ComparatorSize_32Bits;
80000f6e:	3b f0 01 30 	mov %d3,31
80000f72:	59 43 0c 00 	st.w [%a4]12,%d3
    config->comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;     /*User must select the interrupt output */
80000f76:	59 42 04 00 	st.w [%a4]4,%d2
    config->ticks               = 0xFFFFFFFF;
80000f7a:	82 f3       	mov %d3,-1
80000f7c:	59 43 10 00 	st.w [%a4]16,%d3
    config->triggerPriority     = 0;
80000f80:	f9 42 14 00 	st.h [%a4]20,%d2
    config->typeOfService       = IfxSrc_Tos_cpu0;
80000f84:	59 42 18 00 	st.w [%a4]24,%d2
}
80000f88:	00 90       	ret 

80000f8a <IfxScuCcu_isOscillatorStable>:
    *cfg = IfxScuCcu_defaultErayPllConfig;
}


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
80000f8a:	40 ae       	mov.aa %a14,%sp
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
80000f8c:	6d 00 16 05 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
80000f90:	02 28       	mov %d8,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80000f92:	91 30 00 2f 	movh.a %a2,61443
80000f96:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
80000f9a:	54 23       	ld.w %d3,[%a2]
80000f9c:	8f 03 c6 31 	andn %d3,%d3,96
80000fa0:	74 23       	st.w [%a2],%d3

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80000fa2:	91 00 00 36 	movh.a %a3,24576
80000fa6:	19 33 60 50 	ld.w %d3,[%a3]1376 <60000560 <IfxScuCcu_xtalFrequency>>
80000faa:	7b 00 b6 26 	movh %d2,27488
80000fae:	1b b2 a6 2c 	addi %d2,%d2,-13717
80000fb2:	73 23 68 20 	mul.u %e2,%d3,%d2
80000fb6:	8f c3 1e 20 	sh %d2,%d3,-20
80000fba:	c2 f2       	add %d2,-1
80000fbc:	54 23       	ld.w %d3,[%a2]
80000fbe:	37 23 05 38 	insert %d3,%d3,%d2,16,5
80000fc2:	74 23       	st.w [%a2],%d3

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
80000fc4:	54 23       	ld.w %d3,[%a2]
80000fc6:	b7 13 01 31 	insert %d3,%d3,1,2,1
80000fca:	74 23       	st.w [%a2],%d3
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
80000fcc:	3b 00 28 30 	mov %d3,640

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80000fd0:	1d 00 05 00 	j 80000fda <IfxScuCcu_isOscillatorStable+0x50>
    {
        TimeoutCtr--;
80000fd4:	c2 f3       	add %d3,-1

        if (TimeoutCtr == 0)
80000fd6:	df 03 25 00 	jeq %d3,0,80001020 <IfxScuCcu_isOscillatorStable+0x96>
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80000fda:	91 30 00 2f 	movh.a %a2,61443
80000fde:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
80000fe2:	54 25       	ld.w %d5,[%a2]
80000fe4:	6f 15 f8 7f 	jz.t %d5,1,80000fd4 <IfxScuCcu_isOscillatorStable+0x4a>
80000fe8:	54 25       	ld.w %d5,[%a2]
80000fea:	6f 85 f5 7f 	jz.t %d5,8,80000fd4 <IfxScuCcu_isOscillatorStable+0x4a>
    boolean status     = 0;
80000fee:	82 09       	mov %d9,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
80000ff0:	02 84       	mov %d4,%d8
80000ff2:	6d 00 7a 03 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80000ff6:	91 30 00 2f 	movh.a %a2,61443
80000ffa:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
80000ffe:	54 23       	ld.w %d3,[%a2]
80001000:	b7 13 81 31 	insert %d3,%d3,1,3,1
80001004:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
80001006:	91 30 00 2f 	movh.a %a2,61443
8000100a:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
8000100e:	54 23       	ld.w %d3,[%a2]
80001010:	b7 13 81 31 	insert %d3,%d3,1,3,1
80001014:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinitPw);
80001016:	02 84       	mov %d4,%d8
80001018:	6d 00 ed 04 	call 800019f2 <IfxScuWdt_setCpuEndinit>
    }

    return status;
}
8000101c:	02 92       	mov %d2,%d9
8000101e:	00 90       	ret 
            status = 1;
80001020:	82 19       	mov %d9,1
80001022:	1d ff e7 ff 	j 80000ff0 <IfxScuCcu_isOscillatorStable+0x66>

80001026 <IfxScuCcu_getOsc0Frequency>:
{
80001026:	40 ae       	mov.aa %a14,%sp
    return (float32)IfxScuCcu_xtalFrequency;
80001028:	91 00 00 26 	movh.a %a2,24576
8000102c:	19 22 60 50 	ld.w %d2,[%a2]1376 <60000560 <IfxScuCcu_xtalFrequency>>
}
80001030:	4b 02 61 21 	utof %d2,%d2
80001034:	00 90       	ret 

80001036 <IfxScuCcu_getOscFrequency>:
{
80001036:	40 ae       	mov.aa %a14,%sp
    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80001038:	91 30 00 2f 	movh.a %a2,61443
8000103c:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80001040:	54 22       	ld.w %d2,[%a2]
80001042:	37 02 62 2e 	extr.u %d2,%d2,28,2
80001046:	df 02 10 00 	jeq %d2,0,80001066 <IfxScuCcu_getOscFrequency+0x30>
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
8000104a:	54 22       	ld.w %d2,[%a2]
8000104c:	37 02 62 2e 	extr.u %d2,%d2,28,2
80001050:	df 12 04 00 	jeq %d2,1,80001058 <IfxScuCcu_getOscFrequency+0x22>
        freq = 0.0f;
80001054:	82 02       	mov %d2,0
}
80001056:	00 90       	ret 
        freq = (float32)IfxScuCcu_xtalFrequency;
80001058:	91 00 00 26 	movh.a %a2,24576
8000105c:	19 22 60 50 	ld.w %d2,[%a2]1376 <60000560 <IfxScuCcu_xtalFrequency>>
80001060:	4b 02 61 21 	utof %d2,%d2
80001064:	00 90       	ret 
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80001066:	7b f0 cb 24 	movh %d2,19647
8000106a:	1b 02 c2 2b 	addi %d2,%d2,-17376
8000106e:	00 90       	ret 

80001070 <IfxScuCcu_getPllErayFrequency>:
{
80001070:	40 ae       	mov.aa %a14,%sp
    oscFreq = IfxScuCcu_getOscFrequency();
80001072:	6d ff e2 ff 	call 80001036 <IfxScuCcu_getOscFrequency>
80001076:	02 24       	mov %d4,%d2
    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80001078:	91 30 00 2f 	movh.a %a2,61443
8000107c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001080:	19 23 24 00 	ld.w %d3,[%a2]36 <f0030024 <_SMALL_DATA4_+0x60028024>>
80001084:	6f 03 21 80 	jnz.t %d3,0,800010c6 <IfxScuCcu_getPllErayFrequency+0x56>
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80001088:	91 30 00 2f 	movh.a %a2,61443
8000108c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001090:	19 22 24 00 	ld.w %d2,[%a2]36 <f0030024 <_SMALL_DATA4_+0x60028024>>
80001094:	6f 32 27 80 	jnz.t %d2,3,800010e2 <IfxScuCcu_getPllErayFrequency+0x72>
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80001098:	91 30 00 2f 	movh.a %a2,61443
8000109c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
800010a0:	19 22 28 00 	ld.w %d2,[%a2]40 <f0030028 <_SMALL_DATA4_+0x60028028>>
800010a4:	37 02 e5 24 	extr.u %d2,%d2,9,5
800010a8:	c2 12       	add %d2,1
800010aa:	4b 02 41 21 	itof %d2,%d2
800010ae:	4b 42 41 40 	mul.f %d4,%d2,%d4
800010b2:	19 22 2c 00 	ld.w %d2,[%a2]44 <f003002c <_SMALL_DATA4_+0x6002802c>>
800010b6:	8f f2 07 21 	and %d2,%d2,127
800010ba:	c2 12       	add %d2,1
800010bc:	4b 02 41 21 	itof %d2,%d2
800010c0:	4b 24 51 20 	div.f %d2,%d4,%d2
}
800010c4:	00 90       	ret 
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
800010c6:	91 30 00 2f 	movh.a %a2,61443
800010ca:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
800010ce:	19 22 2c 00 	ld.w %d2,[%a2]44 <f003002c <_SMALL_DATA4_+0x6002802c>>
800010d2:	37 02 67 28 	extr.u %d2,%d2,16,7
800010d6:	c2 12       	add %d2,1
800010d8:	4b 02 41 21 	itof %d2,%d2
800010dc:	4b 24 51 20 	div.f %d2,%d4,%d2
800010e0:	00 90       	ret 
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
800010e2:	91 30 00 2f 	movh.a %a2,61443
800010e6:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
800010ea:	19 24 2c 00 	ld.w %d4,[%a2]44 <f003002c <_SMALL_DATA4_+0x6002802c>>
800010ee:	8f f4 07 41 	and %d4,%d4,127
800010f2:	c2 14       	add %d4,1
800010f4:	6d 00 f0 13 	call 800038d4 <__floatsidf>
800010f8:	0b 23 10 68 	mov %e6,%d3,%d2
800010fc:	82 04       	mov %d4,0
800010fe:	7b 80 19 54 	movh %d5,16792
80001102:	1b 45 78 5d 	addi %d5,%d5,-10364
80001106:	6d 00 3f 13 	call 80003784 <__divdf3>
8000110a:	0b 23 10 48 	mov %e4,%d3,%d2
8000110e:	6d 00 1e 14 	call 8000394a <__truncdfsf2>
80001112:	00 90       	ret 

80001114 <IfxScuCcu_getPllFrequency>:
{
80001114:	40 ae       	mov.aa %a14,%sp
    oscFreq = IfxScuCcu_getOscFrequency();
80001116:	6d ff 90 ff 	call 80001036 <IfxScuCcu_getOscFrequency>
8000111a:	02 24       	mov %d4,%d2
    if (scu->PLLSTAT.B.VCOBYST == 1)
8000111c:	91 30 00 2f 	movh.a %a2,61443
80001120:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001124:	19 23 14 00 	ld.w %d3,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
80001128:	6f 03 27 80 	jnz.t %d3,0,80001176 <IfxScuCcu_getPllFrequency+0x62>
    else if (scu->PLLSTAT.B.FINDIS == 1)
8000112c:	91 30 00 2f 	movh.a %a2,61443
80001130:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001134:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
80001138:	6f 32 2d 80 	jnz.t %d2,3,80001192 <IfxScuCcu_getPllFrequency+0x7e>
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
8000113c:	91 30 00 2f 	movh.a %a2,61443
80001140:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001144:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
80001148:	37 02 e7 24 	extr.u %d2,%d2,9,7
8000114c:	c2 12       	add %d2,1
8000114e:	4b 02 41 21 	itof %d2,%d2
80001152:	4b 42 41 30 	mul.f %d3,%d2,%d4
80001156:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
8000115a:	8f f4 07 41 	and %d4,%d4,127
8000115e:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
80001162:	37 02 64 2c 	extr.u %d2,%d2,24,4
80001166:	c2 12       	add %d2,1
80001168:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
8000116c:	4b 02 41 21 	itof %d2,%d2
80001170:	4b 23 51 20 	div.f %d2,%d3,%d2
}
80001174:	00 90       	ret 
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80001176:	91 30 00 2f 	movh.a %a2,61443
8000117a:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
8000117e:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80001182:	37 02 67 28 	extr.u %d2,%d2,16,7
80001186:	c2 12       	add %d2,1
80001188:	4b 02 41 21 	itof %d2,%d2
8000118c:	4b 24 51 20 	div.f %d2,%d4,%d2
80001190:	00 90       	ret 
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80001192:	91 30 00 2f 	movh.a %a2,61443
80001196:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
8000119a:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
8000119e:	8f f4 07 41 	and %d4,%d4,127
800011a2:	c2 14       	add %d4,1
800011a4:	6d 00 98 13 	call 800038d4 <__floatsidf>
800011a8:	0b 23 10 68 	mov %e6,%d3,%d2
800011ac:	82 04       	mov %d4,0
800011ae:	7b 80 19 54 	movh %d5,16792
800011b2:	1b 45 78 5d 	addi %d5,%d5,-10364
800011b6:	6d 00 e7 12 	call 80003784 <__divdf3>
800011ba:	0b 23 10 48 	mov %e4,%d3,%d2
800011be:	6d 00 c6 13 	call 8000394a <__truncdfsf2>
800011c2:	00 90       	ret 

800011c4 <IfxScuCcu_getSourceFrequency>:
{
800011c4:	40 ae       	mov.aa %a14,%sp
    switch (SCU_CCUCON0.B.CLKSEL)
800011c6:	91 30 00 2f 	movh.a %a2,61443
800011ca:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
800011ce:	54 22       	ld.w %d2,[%a2]
800011d0:	37 02 62 2e 	extr.u %d2,%d2,28,2
800011d4:	df 02 07 00 	jeq %d2,0,800011e2 <IfxScuCcu_getSourceFrequency+0x1e>
800011d8:	df 12 0a 80 	jne %d2,1,800011ec <IfxScuCcu_getSourceFrequency+0x28>
        sourcefreq = IfxScuCcu_getPllFrequency();
800011dc:	6d ff 9c ff 	call 80001114 <IfxScuCcu_getPllFrequency>
        break;
800011e0:	00 90       	ret 
    switch (SCU_CCUCON0.B.CLKSEL)
800011e2:	7b f0 cb 24 	movh %d2,19647
800011e6:	1b 02 c2 2b 	addi %d2,%d2,-17376
800011ea:	00 90       	ret 
        sourcefreq = 0;
800011ec:	82 02       	mov %d2,0
}
800011ee:	00 90       	ret 

800011f0 <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
800011f0:	40 ae       	mov.aa %a14,%sp
800011f2:	02 48       	mov %d8,%d4
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
800011f4:	6d ff e8 ff 	call 800011c4 <IfxScuCcu_getSourceFrequency>
800011f8:	91 30 00 2f 	movh.a %a2,61443
800011fc:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80001200:	54 23       	ld.w %d3,[%a2]
80001202:	37 03 64 34 	extr.u %d3,%d3,8,4
80001206:	4b 03 41 31 	itof %d3,%d3
8000120a:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
8000120e:	4b 28 41 40 	mul.f %d4,%d8,%d2
80001212:	4b 04 71 41 	ftouz %d4,%d4
    uint32 stmCountBegin = STM0_TIM0.U;
80001216:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
8000121a:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
8000121e:	a2 32       	sub %d2,%d3
80001220:	3f 42 fd ff 	jlt.u %d2,%d4,8000121a <IfxScuCcu_wait+0x2a>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80001224:	00 90       	ret 
	...

80001228 <IfxScuCcu_getMaxFrequency>:
{
80001228:	40 ae       	mov.aa %a14,%sp
    sourceFrequency = IfxScuCcu_getSourceFrequency();
8000122a:	6d ff cd ff 	call 800011c4 <IfxScuCcu_getSourceFrequency>
    switch (SCU_CCUCON0.B.LPDIV)
8000122e:	91 30 00 2f 	movh.a %a2,61443
80001232:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001236:	54 23       	ld.w %d3,[%a2]
80001238:	37 03 64 36 	extr.u %d3,%d3,12,4
8000123c:	ff 53 39 80 	jge.u %d3,5,800012ae <IfxScuCcu_getMaxFrequency+0x86>
80001240:	91 00 00 28 	movh.a %a2,32768
80001244:	d9 22 10 91 	lea %a2,[%a2]4688 <80001250 <IfxScuCcu_getMaxFrequency+0x28>>
80001248:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
8000124c:	dc 02       	ji %a2
8000124e:	00 00       	nop 
80001250:	1d 00 0a 00 	j 80001264 <IfxScuCcu_getMaxFrequency+0x3c>
80001254:	1d 00 19 00 	j 80001286 <IfxScuCcu_getMaxFrequency+0x5e>
80001258:	1d 00 1c 00 	j 80001290 <IfxScuCcu_getMaxFrequency+0x68>
8000125c:	1d 00 1f 00 	j 8000129a <IfxScuCcu_getMaxFrequency+0x72>
80001260:	1d 00 22 00 	j 800012a4 <IfxScuCcu_getMaxFrequency+0x7c>
        if (SCU_CCUCON5.B.MAXDIV == 0)
80001264:	91 30 00 2f 	movh.a %a2,61443
80001268:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x6002e04c>>
8000126c:	54 23       	ld.w %d3,[%a2]
8000126e:	8f f3 00 31 	and %d3,%d3,15
80001272:	df 03 1f 00 	jeq %d3,0,800012b0 <IfxScuCcu_getMaxFrequency+0x88>
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
80001276:	54 23       	ld.w %d3,[%a2]
80001278:	8f f3 00 31 	and %d3,%d3,15
8000127c:	4b 03 41 31 	itof %d3,%d3
80001280:	4b 32 51 20 	div.f %d2,%d2,%d3
80001284:	00 90       	ret 
        maxFrequency = sourceFrequency / 15;
80001286:	7b 00 17 34 	movh %d3,16752
8000128a:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
8000128e:	00 90       	ret 
        maxFrequency = sourceFrequency / 30;
80001290:	7b 00 1f 34 	movh %d3,16880
80001294:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001298:	00 90       	ret 
        maxFrequency = sourceFrequency / 60;
8000129a:	7b 00 27 34 	movh %d3,17008
8000129e:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
800012a2:	00 90       	ret 
        maxFrequency = sourceFrequency / 120;
800012a4:	7b 00 2f 34 	movh %d3,17136
800012a8:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
800012ac:	00 90       	ret 
    switch (SCU_CCUCON0.B.LPDIV)
800012ae:	82 02       	mov %d2,0
}
800012b0:	00 90       	ret 

800012b2 <IfxScuCcu_getMaxFrequency_end>:
	...

800012b4 <IfxScuCcu_getBaud1Frequency>:
{
800012b4:	40 ae       	mov.aa %a14,%sp
800012b6:	20 08       	sub.a %sp,8
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800012b8:	91 30 00 2f 	movh.a %a2,61443
800012bc:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
800012c0:	54 28       	ld.w %d8,[%a2]
    if (ccucon0.B.BAUD1DIV == 0)
800012c2:	59 e8 fc ff 	st.w [%a14]-4 <f0036030 <_SMALL_DATA4_+0x6002e030>>,%d8
800012c6:	8f f8 00 21 	and %d2,%d8,15
800012ca:	df 02 04 80 	jne %d2,0,800012d2 <IfxScuCcu_getBaud1Frequency+0x1e>
        frequency = 0;
800012ce:	82 02       	mov %d2,0
}
800012d0:	00 90       	ret 
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
800012d2:	6d ff ab ff 	call 80001228 <IfxScuCcu_getMaxFrequency>
800012d6:	8f f8 00 31 	and %d3,%d8,15
800012da:	4b 03 41 31 	itof %d3,%d3
800012de:	4b 32 51 20 	div.f %d2,%d2,%d3
800012e2:	00 90       	ret 

800012e4 <IfxScuCcu_getBaud2Frequency>:
{
800012e4:	40 ae       	mov.aa %a14,%sp
800012e6:	20 08       	sub.a %sp,8
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
800012e8:	91 30 00 2f 	movh.a %a2,61443
800012ec:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
800012f0:	54 28       	ld.w %d8,[%a2]
    if (ccucon0.B.BAUD2DIV == 0)
800012f2:	59 e8 fc ff 	st.w [%a14]-4 <f0036030 <_SMALL_DATA4_+0x6002e030>>,%d8
800012f6:	8f 08 0f 21 	and %d2,%d8,240
800012fa:	df 02 04 80 	jne %d2,0,80001302 <IfxScuCcu_getBaud2Frequency+0x1e>
        frequency = 0;
800012fe:	82 02       	mov %d2,0
}
80001300:	00 90       	ret 
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
80001302:	6d ff 93 ff 	call 80001228 <IfxScuCcu_getMaxFrequency>
80001306:	37 08 64 32 	extr.u %d3,%d8,4,4
8000130a:	4b 03 41 31 	itof %d3,%d3
8000130e:	4b 32 51 20 	div.f %d2,%d2,%d3
80001312:	00 90       	ret 

80001314 <IfxScuCcu_getSpbFrequency>:
{
80001314:	40 ae       	mov.aa %a14,%sp
    sourceFrequency = IfxScuCcu_getSourceFrequency();
80001316:	6d ff 57 ff 	call 800011c4 <IfxScuCcu_getSourceFrequency>
    switch (SCU_CCUCON0.B.LPDIV)
8000131a:	91 30 00 2f 	movh.a %a2,61443
8000131e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001322:	54 23       	ld.w %d3,[%a2]
80001324:	37 03 64 36 	extr.u %d3,%d3,12,4
80001328:	ff 53 39 80 	jge.u %d3,5,8000139a <IfxScuCcu_getSpbFrequency+0x86>
8000132c:	91 00 00 28 	movh.a %a2,32768
80001330:	d9 22 3c c1 	lea %a2,[%a2]4924 <8000133c <IfxScuCcu_getSpbFrequency+0x28>>
80001334:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
80001338:	dc 02       	ji %a2
8000133a:	00 00       	nop 
8000133c:	1d 00 0a 00 	j 80001350 <IfxScuCcu_getSpbFrequency+0x3c>
80001340:	1d 00 19 00 	j 80001372 <IfxScuCcu_getSpbFrequency+0x5e>
80001344:	1d 00 1c 00 	j 8000137c <IfxScuCcu_getSpbFrequency+0x68>
80001348:	1d 00 1f 00 	j 80001386 <IfxScuCcu_getSpbFrequency+0x72>
8000134c:	1d 00 22 00 	j 80001390 <IfxScuCcu_getSpbFrequency+0x7c>
        if (SCU_CCUCON0.B.SPBDIV == 0)
80001350:	91 30 00 2f 	movh.a %a2,61443
80001354:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001358:	54 23       	ld.w %d3,[%a2]
8000135a:	37 03 64 38 	extr.u %d3,%d3,16,4
8000135e:	df 03 20 00 	jeq %d3,0,8000139e <IfxScuCcu_getSpbFrequency+0x8a>
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80001362:	54 23       	ld.w %d3,[%a2]
80001364:	37 03 64 38 	extr.u %d3,%d3,16,4
80001368:	4b 03 41 31 	itof %d3,%d3
8000136c:	4b 32 51 20 	div.f %d2,%d2,%d3
80001370:	00 90       	ret 
        spbFrequency = sourceFrequency / 30;
80001372:	7b 00 1f 34 	movh %d3,16880
80001376:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
8000137a:	00 90       	ret 
        spbFrequency = sourceFrequency / 60;
8000137c:	7b 00 27 34 	movh %d3,17008
80001380:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001384:	00 90       	ret 
        spbFrequency = sourceFrequency / 120;
80001386:	7b 00 2f 34 	movh %d3,17136
8000138a:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
8000138e:	00 90       	ret 
        spbFrequency = sourceFrequency / 240;
80001390:	7b 00 37 34 	movh %d3,17264
80001394:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001398:	00 90       	ret 
    switch (SCU_CCUCON0.B.LPDIV)
8000139a:	82 02       	mov %d2,0
8000139c:	00 90       	ret 
            spbFrequency = 0.0f;
8000139e:	82 02       	mov %d2,0
}
800013a0:	00 90       	ret 

800013a2 <IfxScuCcu_getSpbFrequency_end>:
	...

800013a4 <IfxScuCcu_init>:
{
800013a4:	40 ae       	mov.aa %a14,%sp
800013a6:	40 4c       	mov.aa %a12,%a4
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
800013a8:	19 42 10 10 	ld.w %d2,[%a4]80
800013ac:	91 00 00 26 	movh.a %a2,24576
800013b0:	59 22 60 50 	st.w [%a2]1376 <60000560 <IfxScuCcu_xtalFrequency>>,%d2
    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
800013b4:	6d 00 02 03 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
800013b8:	02 2a       	mov %d10,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
800013ba:	6d 00 11 03 	call 800019dc <IfxScuWdt_getSafetyWatchdogPassword>
800013be:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(endinit_pw);
800013c0:	02 a4       	mov %d4,%d10
800013c2:	6d 00 92 01 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
800013c6:	91 30 00 2f 	movh.a %a2,61443
800013ca:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
800013ce:	54 2d       	ld.w %d13,[%a2]
800013d0:	37 0d e1 d1 	extr.u %d13,%d13,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
800013d4:	54 22       	ld.w %d2,[%a2]
800013d6:	b7 12 81 21 	insert %d2,%d2,1,3,1
800013da:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
800013dc:	02 a4       	mov %d4,%d10
800013de:	6d 00 0a 03 	call 800019f2 <IfxScuWdt_setCpuEndinit>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800013e2:	02 84       	mov %d4,%d8
800013e4:	6d 00 a6 01 	call 80001730 <IfxScuWdt_clearSafetyEndinit>
        while (SCU_CCUCON0.B.LCK != 0U)
800013e8:	91 30 00 2f 	movh.a %a2,61443
800013ec:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
800013f0:	54 23       	ld.w %d3,[%a2]
800013f2:	bf 03 fb 7f 	jlt %d3,0,800013e8 <IfxScuCcu_init+0x44>
        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
800013f6:	54 22       	ld.w %d2,[%a2]
800013f8:	b7 02 02 2e 	insert %d2,%d2,0,28,2
800013fc:	74 22       	st.w [%a2],%d2
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
800013fe:	54 22       	ld.w %d2,[%a2]
80001400:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80001404:	74 22       	st.w [%a2],%d2
        SCU_PLLCON0.B.SETFINDIS = 1;
80001406:	91 30 00 2f 	movh.a %a2,61443
8000140a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
8000140e:	54 22       	ld.w %d2,[%a2]
80001410:	b7 12 01 22 	insert %d2,%d2,1,4,1
80001414:	74 22       	st.w [%a2],%d2
        while (SCU_CCUCON1.B.LCK != 0U)
80001416:	91 30 00 2f 	movh.a %a2,61443
8000141a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000141e:	54 23       	ld.w %d3,[%a2]
80001420:	bf 03 fb 7f 	jlt %d3,0,80001416 <IfxScuCcu_init+0x72>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
80001424:	54 22       	ld.w %d2,[%a2]
80001426:	b7 12 02 2e 	insert %d2,%d2,1,28,2
8000142a:	74 22       	st.w [%a2],%d2
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
8000142c:	54 22       	ld.w %d2,[%a2]
8000142e:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80001432:	74 22       	st.w [%a2],%d2
        status             |= IfxScuCcu_isOscillatorStable();
80001434:	6d ff ab fd 	call 80000f8a <IfxScuCcu_isOscillatorStable>
80001438:	02 2c       	mov %d12,%d2
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000143a:	02 84       	mov %d4,%d8
8000143c:	6d 00 00 03 	call 80001a3c <IfxScuWdt_setSafetyEndinit>
    if (status == 0)
80001440:	df 0c 28 00 	jeq %d12,0,80001490 <IfxScuCcu_init+0xec>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001444:	02 84       	mov %d4,%d8
80001446:	6d 00 75 01 	call 80001730 <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
8000144a:	91 30 00 2f 	movh.a %a2,61443
8000144e:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80001452:	54 23       	ld.w %d3,[%a2]
80001454:	8f 03 c4 31 	andn %d3,%d3,64
80001458:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
8000145a:	02 84       	mov %d4,%d8
8000145c:	6d 00 f0 02 	call 80001a3c <IfxScuWdt_setSafetyEndinit>
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80001460:	02 a4       	mov %d4,%d10
80001462:	6d 00 42 01 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80001466:	91 30 00 2f 	movh.a %a2,61443
8000146a:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
8000146e:	54 23       	ld.w %d3,[%a2]
80001470:	b7 13 81 31 	insert %d3,%d3,1,3,1
80001474:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80001476:	91 30 00 2f 	movh.a %a2,61443
8000147a:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
8000147e:	54 23       	ld.w %d3,[%a2]
80001480:	67 d3 03 30 	ins.t %d3,%d3,3,%d13,0
80001484:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinit_pw);
80001486:	02 a4       	mov %d4,%d10
80001488:	6d 00 b5 02 	call 800019f2 <IfxScuWdt_setCpuEndinit>
}
8000148c:	02 c2       	mov %d2,%d12
8000148e:	00 90       	ret 
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001490:	02 84       	mov %d4,%d8
80001492:	6d 00 4f 01 	call 80001730 <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80001496:	91 30 00 2f 	movh.a %a2,61443
8000149a:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
8000149e:	54 23       	ld.w %d3,[%a2]
800014a0:	6f 53 fb 7f 	jz.t %d3,5,80001496 <IfxScuCcu_init+0xf2>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
800014a4:	39 c3 0a 00 	ld.bu %d3,[%a12]10
800014a8:	91 30 00 2f 	movh.a %a2,61443
800014ac:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
800014b0:	54 22       	ld.w %d2,[%a2]
800014b2:	37 32 07 20 	insert %d2,%d2,%d3,0,7
800014b6:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
800014b8:	39 c3 08 00 	ld.bu %d3,[%a12]8
800014bc:	91 30 00 2f 	movh.a %a2,61443
800014c0:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
800014c4:	54 22       	ld.w %d2,[%a2]
800014c6:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
800014ca:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
800014cc:	39 c3 09 00 	ld.bu %d3,[%a12]9
800014d0:	54 22       	ld.w %d2,[%a2]
800014d2:	37 32 87 24 	insert %d2,%d2,%d3,9,7
800014d6:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
800014d8:	54 22       	ld.w %d2,[%a2]
800014da:	b7 12 01 23 	insert %d2,%d2,1,6,1
800014de:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
800014e0:	54 22       	ld.w %d2,[%a2]
800014e2:	b7 02 01 28 	insert %d2,%d2,0,16,1
800014e6:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
800014e8:	54 22       	ld.w %d2,[%a2]
800014ea:	b7 12 81 22 	insert %d2,%d2,1,5,1
800014ee:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
800014f0:	54 22       	ld.w %d2,[%a2]
800014f2:	b7 12 01 28 	insert %d2,%d2,1,16,1
800014f6:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.RESLD = 1;
800014f8:	54 22       	ld.w %d2,[%a2]
800014fa:	b7 12 01 29 	insert %d2,%d2,1,18,1
800014fe:	74 22       	st.w [%a2],%d2
                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
80001500:	7b 20 85 43 	movh %d4,14418
80001504:	1b 74 71 4b 	addi %d4,%d4,-18665
80001508:	6d ff 74 fe 	call 800011f0 <IfxScuCcu_wait>
                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
8000150c:	91 30 00 2f 	movh.a %a2,61443
80001510:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
80001514:	54 23       	ld.w %d3,[%a2]
80001516:	6f 23 fb 7f 	jz.t %d3,2,8000150c <IfxScuCcu_init+0x168>
                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
8000151a:	91 30 00 2f 	movh.a %a2,61443
8000151e:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80001522:	54 22       	ld.w %d2,[%a2]
80001524:	8f 12 c0 21 	andn %d2,%d2,1
80001528:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
8000152a:	91 30 00 2f 	movh.a %a2,61443
8000152e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001532:	54 23       	ld.w %d3,[%a2]
80001534:	bf 03 fb 7f 	jlt %d3,0,8000152a <IfxScuCcu_init+0x186>
                    SCU_CCUCON0.B.CLKSEL = 0x01;
80001538:	54 22       	ld.w %d2,[%a2]
8000153a:	b7 12 02 2e 	insert %d2,%d2,1,28,2
8000153e:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
80001540:	91 30 00 2f 	movh.a %a2,61443
80001544:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001548:	54 23       	ld.w %d3,[%a2]
8000154a:	bf 03 fb 7f 	jlt %d3,0,80001540 <IfxScuCcu_init+0x19c>
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
8000154e:	19 c4 0c 00 	ld.w %d4,[%a12]12
80001552:	6d ff 4f fe 	call 800011f0 <IfxScuCcu_wait>
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80001556:	91 30 00 2f 	movh.a %a2,61443
8000155a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
8000155e:	54 23       	ld.w %d3,[%a2]
80001560:	19 c4 14 00 	ld.w %d4,[%a12]20 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001564:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
80001568:	19 c2 10 00 	ld.w %d2,[%a12]16
8000156c:	26 42       	and %d2,%d4
8000156e:	a6 23       	or %d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
80001570:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon0.B.UP     = 1;
80001574:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
80001578:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON1.B.LCK != 0U)
8000157a:	91 30 00 2f 	movh.a %a2,61443
8000157e:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80001582:	54 23       	ld.w %d3,[%a2]
80001584:	bf 03 fb 7f 	jlt %d3,0,8000157a <IfxScuCcu_init+0x1d6>
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80001588:	54 23       	ld.w %d3,[%a2]
8000158a:	19 c4 1c 00 	ld.w %d4,[%a12]28
8000158e:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
80001592:	19 c2 18 00 	ld.w %d2,[%a12]24
80001596:	26 42       	and %d2,%d4
80001598:	a6 23       	or %d3,%d2
                        ccucon1.B.INSEL = 1;
8000159a:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon1.B.UP    = 1;
8000159e:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON1     = ccucon1;
800015a2:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON2.B.LCK != 0U)
800015a4:	91 30 00 2f 	movh.a %a2,61443
800015a8:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x6002e040>>
800015ac:	54 23       	ld.w %d3,[%a2]
800015ae:	bf 03 fb 7f 	jlt %d3,0,800015a4 <IfxScuCcu_init+0x200>
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
800015b2:	54 23       	ld.w %d3,[%a2]
800015b4:	19 c4 24 00 	ld.w %d4,[%a12]36
800015b8:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
800015bc:	19 c2 20 00 	ld.w %d2,[%a12]32
800015c0:	26 42       	and %d2,%d4
800015c2:	a6 32       	or %d2,%d3
                        ccucon2.B.UP = 1;
800015c4:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON2  = ccucon2;
800015c8:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON5.B.LCK != 0U)
800015ca:	91 30 00 2f 	movh.a %a2,61443
800015ce:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x6002e04c>>
800015d2:	54 23       	ld.w %d3,[%a2]
800015d4:	bf 03 fb 7f 	jlt %d3,0,800015ca <IfxScuCcu_init+0x226>
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
800015d8:	54 23       	ld.w %d3,[%a2]
800015da:	19 c4 2c 00 	ld.w %d4,[%a12]44
800015de:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
800015e2:	19 c2 28 00 	ld.w %d2,[%a12]40
800015e6:	26 42       	and %d2,%d4
800015e8:	a6 32       	or %d2,%d3
                        ccucon5.B.UP = 1;
800015ea:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON5  = ccucon5;
800015ee:	74 22       	st.w [%a2],%d2
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
800015f0:	91 30 00 2f 	movh.a %a2,61443
800015f4:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x6002e080>>
800015f8:	54 23       	ld.w %d3,[%a2]
800015fa:	19 c4 34 00 	ld.w %d4,[%a12]52 <f0036080 <_SMALL_DATA4_+0x6002e080>>
800015fe:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
80001602:	19 c2 30 00 	ld.w %d2,[%a12]48
80001606:	26 42       	and %d2,%d4
80001608:	a6 32       	or %d2,%d3
                        SCU_CCUCON6 = ccucon6;
8000160a:	74 22       	st.w [%a2],%d2
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
8000160c:	91 30 00 2f 	movh.a %a2,61443
80001610:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x6002e084>>
80001614:	54 23       	ld.w %d3,[%a2]
80001616:	19 c4 3c 00 	ld.w %d4,[%a12]60 <f0036084 <_SMALL_DATA4_+0x6002e084>>
8000161a:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
8000161e:	19 c2 38 00 	ld.w %d2,[%a12]56
80001622:	26 42       	and %d2,%d4
80001624:	a6 32       	or %d2,%d3
                        SCU_CCUCON7 = ccucon7;
80001626:	74 22       	st.w [%a2],%d2
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
80001628:	91 30 00 2f 	movh.a %a2,61443
8000162c:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x6002e088>>
80001630:	54 23       	ld.w %d3,[%a2]
80001632:	19 c4 04 10 	ld.w %d4,[%a12]68 <f0036088 <_SMALL_DATA4_+0x6002e088>>
80001636:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
8000163a:	19 c2 00 10 	ld.w %d2,[%a12]64
8000163e:	26 42       	and %d2,%d4
80001640:	a6 32       	or %d2,%d3
                        SCU_CCUCON8 = ccucon8;
80001642:	74 22       	st.w [%a2],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001644:	02 84       	mov %d4,%d8
80001646:	6d 00 fb 01 	call 80001a3c <IfxScuWdt_setSafetyEndinit>
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
8000164a:	91 00 80 df 	movh.a %a13,63488
8000164e:	d9 dd 14 02 	lea %a13,[%a13]8212 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
80001652:	54 d9       	ld.w %d9,[%a13]
80001654:	19 c4 0c 10 	ld.w %d4,[%a12]76 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
80001658:	0f 49 e0 90 	andn %d9,%d9,%d4
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
8000165c:	19 c2 08 10 	ld.w %d2,[%a12]72
80001660:	26 42       	and %d2,%d4
80001662:	a6 29       	or %d9,%d2
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80001664:	02 a4       	mov %d4,%d10
80001666:	6d 00 40 00 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
8000166a:	74 d9       	st.w [%a13],%d9
                IfxScuWdt_setCpuEndinit(endinit_pw);
8000166c:	02 a4       	mov %d4,%d10
8000166e:	6d 00 c2 01 	call 800019f2 <IfxScuWdt_setCpuEndinit>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80001672:	02 c9       	mov %d9,%d12
80001674:	1d 00 0d 00 	j 8000168e <IfxScuCcu_init+0x2ea>
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
80001678:	99 c2 04 00 	ld.a %a2,[%a12]4
8000167c:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80001680:	19 24 04 00 	ld.w %d4,[%a2]4
80001684:	6d ff b6 fd 	call 800011f0 <IfxScuCcu_wait>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80001688:	c2 19       	add %d9,1
8000168a:	8f f9 0f 91 	and %d9,%d9,255
8000168e:	14 c3       	ld.bu %d3,[%a12]
80001690:	7f 39 da fe 	jge.u %d9,%d3,80001444 <IfxScuCcu_init+0xa0>
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001694:	02 84       	mov %d4,%d8
80001696:	6d 00 4d 00 	call 80001730 <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
8000169a:	91 30 00 2f 	movh.a %a2,61443
8000169e:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
800016a2:	54 23       	ld.w %d3,[%a2]
800016a4:	6f 53 fb 7f 	jz.t %d3,5,8000169a <IfxScuCcu_init+0x2f6>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800016a8:	53 c9 20 b0 	mul %d11,%d9,12
800016ac:	99 c2 04 00 	ld.a %a2,[%a12]4
800016b0:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
800016b4:	14 24       	ld.bu %d4,[%a2]
800016b6:	91 30 00 2f 	movh.a %a2,61443
800016ba:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
800016be:	54 23       	ld.w %d3,[%a2]
800016c0:	37 43 07 30 	insert %d3,%d3,%d4,0,7
800016c4:	74 23       	st.w [%a2],%d3
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800016c6:	02 84       	mov %d4,%d8
800016c8:	6d 00 ba 01 	call 80001a3c <IfxScuWdt_setSafetyEndinit>
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
800016cc:	99 c2 04 00 	ld.a %a2,[%a12]4
800016d0:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
800016d4:	d9 22 08 00 	lea %a2,[%a2]8
800016d8:	d4 22       	ld.a %a2,[%a2]
800016da:	bd 02 cf 7f 	jz.a %a2,80001678 <IfxScuCcu_init+0x2d4>
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
800016de:	2d 02 00 00 	calli %a2
800016e2:	1d ff cb ff 	j 80001678 <IfxScuCcu_init+0x2d4>

800016e6 <IfxScuWdt_clearCpuEndinit>:
    {}
}


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
800016e6:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800016e8:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800016ec:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800016f0:	7b 30 00 3f 	movh %d3,61443
800016f4:	1b 03 10 36 	addi %d3,%d3,24832
800016f8:	13 c2 20 23 	madd %d2,%d3,%d2,12
800016fc:	60 22       	mov.a %a2,%d2
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800016fe:	54 22       	ld.w %d2,[%a2]
80001700:	6f 12 0b 00 	jz.t %d2,1,80001716 <IfxScuWdt_clearCpuEndinit+0x30>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001704:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001708:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000170c:	54 22       	ld.w %d2,[%a2]
8000170e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001712:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001714:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001716:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
8000171a:	8f 23 40 31 	or %d3,%d3,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000171e:	54 22       	ld.w %d2,[%a2]
80001720:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001724:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001726:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80001728:	54 22       	ld.w %d2,[%a2]
8000172a:	6f 02 ff ff 	jnz.t %d2,0,80001728 <IfxScuWdt_clearCpuEndinit+0x42>
}
8000172e:	00 90       	ret 

80001730 <IfxScuWdt_clearSafetyEndinit>:


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
80001730:	40 ae       	mov.aa %a14,%sp
80001732:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80001736:	91 30 00 2f 	movh.a %a2,61443
8000173a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000173e:	54 22       	ld.w %d2,[%a2]
80001740:	6f 12 0b 00 	jz.t %d2,1,80001756 <IfxScuWdt_clearSafetyEndinit+0x26>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001744:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001748:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000174c:	54 22       	ld.w %d2,[%a2]
8000174e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001752:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001754:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001756:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000175a:	8f 23 40 31 	or %d3,%d3,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000175e:	91 30 00 2f 	movh.a %a2,61443
80001762:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001766:	54 22       	ld.w %d2,[%a2]
80001768:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000176c:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000176e:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001770:	91 30 00 2f 	movh.a %a2,61443
80001774:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001778:	54 22       	ld.w %d2,[%a2]
8000177a:	6f 02 fb ff 	jnz.t %d2,0,80001770 <IfxScuWdt_clearSafetyEndinit+0x40>
    IfxScuWdt_clearSafetyEndinitInline(password);
}
8000177e:	00 90       	ret 

80001780 <IfxScuWdt_disableCpuWatchdog>:


void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
80001780:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001782:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001786:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
8000178a:	7b 30 00 3f 	movh %d3,61443
8000178e:	1b 03 10 36 	addi %d3,%d3,24832
80001792:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001796:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001798:	54 22       	ld.w %d2,[%a2]
8000179a:	6f 12 0b 00 	jz.t %d2,1,800017b0 <IfxScuWdt_disableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000179e:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800017a2:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800017a6:	54 22       	ld.w %d2,[%a2]
800017a8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800017ac:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800017ae:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800017b0:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800017b2:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800017b6:	54 22       	ld.w %d2,[%a2]
800017b8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800017bc:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800017be:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800017c0:	54 22       	ld.w %d2,[%a2]
800017c2:	6f 02 ff ff 	jnz.t %d2,0,800017c0 <IfxScuWdt_disableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
800017c6:	d9 23 04 00 	lea %a3,[%a2]4
800017ca:	19 22 04 00 	ld.w %d2,[%a2]4
800017ce:	b7 12 81 21 	insert %d2,%d2,1,3,1
800017d2:	74 32       	st.w [%a3],%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
800017d4:	54 22       	ld.w %d2,[%a2]
800017d6:	6f 12 09 00 	jz.t %d2,1,800017e8 <IfxScuWdt_disableCpuWatchdog+0x68>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800017da:	8f 14 40 31 	or %d3,%d4,1
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800017de:	54 22       	ld.w %d2,[%a2]
800017e0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800017e4:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800017e6:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800017e8:	8f 34 40 41 	or %d4,%d4,3
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800017ec:	54 22       	ld.w %d2,[%a2]
800017ee:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800017f2:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800017f4:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
800017f6:	54 22       	ld.w %d2,[%a2]
800017f8:	6f 02 ff 7f 	jz.t %d2,0,800017f6 <IfxScuWdt_disableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
800017fc:	00 90       	ret 

800017fe <IfxScuWdt_disableSafetyWatchdog>:


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
800017fe:	40 ae       	mov.aa %a14,%sp
80001800:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001804:	91 30 00 2f 	movh.a %a2,61443
80001808:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000180c:	54 22       	ld.w %d2,[%a2]
8000180e:	6f 12 0b 00 	jz.t %d2,1,80001824 <IfxScuWdt_disableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001812:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001816:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000181a:	54 22       	ld.w %d2,[%a2]
8000181c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001820:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001822:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001824:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001826:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000182a:	91 30 00 2f 	movh.a %a2,61443
8000182e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001832:	54 22       	ld.w %d2,[%a2]
80001834:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001838:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000183a:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000183c:	91 30 00 2f 	movh.a %a2,61443
80001840:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001844:	54 22       	ld.w %d2,[%a2]
80001846:	6f 02 fb ff 	jnz.t %d2,0,8000183c <IfxScuWdt_disableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
8000184a:	91 30 00 2f 	movh.a %a2,61443
8000184e:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
80001852:	54 22       	ld.w %d2,[%a2]
80001854:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001858:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
8000185a:	91 30 00 2f 	movh.a %a2,61443
8000185e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001862:	54 22       	ld.w %d2,[%a2]
80001864:	6f 12 09 00 	jz.t %d2,1,80001876 <IfxScuWdt_disableSafetyWatchdog+0x78>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001868:	8f 14 40 31 	or %d3,%d4,1
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000186c:	54 22       	ld.w %d2,[%a2]
8000186e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001872:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001874:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001876:	8f 34 40 41 	or %d4,%d4,3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000187a:	91 30 00 2f 	movh.a %a2,61443
8000187e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001882:	54 22       	ld.w %d2,[%a2]
80001884:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001888:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000188a:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
8000188c:	91 30 00 2f 	movh.a %a2,61443
80001890:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001894:	54 22       	ld.w %d2,[%a2]
80001896:	6f 02 fb 7f 	jz.t %d2,0,8000188c <IfxScuWdt_disableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
8000189a:	00 90       	ret 

8000189c <IfxScuWdt_enableCpuWatchdog>:


void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
8000189c:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
8000189e:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800018a2:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800018a6:	7b 30 00 3f 	movh %d3,61443
800018aa:	1b 03 10 36 	addi %d3,%d3,24832
800018ae:	13 c2 20 23 	madd %d2,%d3,%d2,12
800018b2:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
800018b4:	54 22       	ld.w %d2,[%a2]
800018b6:	6f 12 0b 00 	jz.t %d2,1,800018cc <IfxScuWdt_enableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800018ba:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800018be:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800018c2:	54 22       	ld.w %d2,[%a2]
800018c4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800018c8:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800018ca:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800018cc:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800018ce:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800018d2:	54 22       	ld.w %d2,[%a2]
800018d4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800018d8:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800018da:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800018dc:	54 22       	ld.w %d2,[%a2]
800018de:	6f 02 ff ff 	jnz.t %d2,0,800018dc <IfxScuWdt_enableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
800018e2:	d9 23 04 00 	lea %a3,[%a2]4
800018e6:	19 22 04 00 	ld.w %d2,[%a2]4
800018ea:	8f 82 c0 21 	andn %d2,%d2,8
800018ee:	74 32       	st.w [%a3],%d2
    if (watchdog->CON0.B.LCK)
800018f0:	54 22       	ld.w %d2,[%a2]
800018f2:	6f 12 09 00 	jz.t %d2,1,80001904 <IfxScuWdt_enableCpuWatchdog+0x68>
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800018f6:	8f 14 40 31 	or %d3,%d4,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800018fa:	54 22       	ld.w %d2,[%a2]
800018fc:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001900:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001902:	74 22       	st.w [%a2],%d2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001904:	8f 34 40 41 	or %d4,%d4,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001908:	54 22       	ld.w %d2,[%a2]
8000190a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000190e:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001910:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80001912:	54 22       	ld.w %d2,[%a2]
80001914:	6f 02 ff 7f 	jz.t %d2,0,80001912 <IfxScuWdt_enableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80001918:	00 90       	ret 

8000191a <IfxScuWdt_enableSafetyWatchdog>:


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
8000191a:	40 ae       	mov.aa %a14,%sp
8000191c:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001920:	91 30 00 2f 	movh.a %a2,61443
80001924:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001928:	54 22       	ld.w %d2,[%a2]
8000192a:	6f 12 0b 00 	jz.t %d2,1,80001940 <IfxScuWdt_enableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000192e:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001932:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001936:	54 22       	ld.w %d2,[%a2]
80001938:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000193c:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000193e:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001940:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001942:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001946:	91 30 00 2f 	movh.a %a2,61443
8000194a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000194e:	54 22       	ld.w %d2,[%a2]
80001950:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001954:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001956:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001958:	91 30 00 2f 	movh.a %a2,61443
8000195c:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001960:	54 22       	ld.w %d2,[%a2]
80001962:	6f 02 fb ff 	jnz.t %d2,0,80001958 <IfxScuWdt_enableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
80001966:	91 30 00 2f 	movh.a %a2,61443
8000196a:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
8000196e:	54 22       	ld.w %d2,[%a2]
80001970:	8f 82 c0 21 	andn %d2,%d2,8
80001974:	74 22       	st.w [%a2],%d2
    if (SCU_WDTS_CON0.B.LCK)
80001976:	91 30 00 2f 	movh.a %a2,61443
8000197a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000197e:	54 22       	ld.w %d2,[%a2]
80001980:	6f 12 09 00 	jz.t %d2,1,80001992 <IfxScuWdt_enableSafetyWatchdog+0x78>
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001984:	8f 14 40 31 	or %d3,%d4,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001988:	54 22       	ld.w %d2,[%a2]
8000198a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000198e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001990:	74 22       	st.w [%a2],%d2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001992:	8f 34 40 41 	or %d4,%d4,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001996:	91 30 00 2f 	movh.a %a2,61443
8000199a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000199e:	54 22       	ld.w %d2,[%a2]
800019a0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800019a4:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800019a6:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800019a8:	91 30 00 2f 	movh.a %a2,61443
800019ac:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800019b0:	54 22       	ld.w %d2,[%a2]
800019b2:	6f 02 fb 7f 	jz.t %d2,0,800019a8 <IfxScuWdt_enableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800019b6:	00 90       	ret 

800019b8 <IfxScuWdt_getCpuWatchdogPassword>:


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
800019b8:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800019ba:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800019be:	8f 72 00 21 	and %d2,%d2,7
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800019c2:	7b 30 00 3f 	movh %d3,61443
800019c6:	1b 03 10 36 	addi %d3,%d3,24832
800019ca:	13 c2 20 23 	madd %d2,%d3,%d2,12
    password  = watchdog->CON0.B.PW;
800019ce:	60 22       	mov.a %a2,%d2
800019d0:	54 22       	ld.w %d2,[%a2]
800019d2:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
800019d6:	8f f2 83 21 	xor %d2,%d2,63
800019da:	00 90       	ret 

800019dc <IfxScuWdt_getSafetyWatchdogPassword>:
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
}


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
800019dc:	40 ae       	mov.aa %a14,%sp
    password  = watchdog->CON0.B.PW;
800019de:	91 30 00 2f 	movh.a %a2,61443
800019e2:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800019e6:	54 22       	ld.w %d2,[%a2]
800019e8:	37 02 6e 21 	extr.u %d2,%d2,2,14
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
800019ec:	8f f2 83 21 	xor %d2,%d2,63
800019f0:	00 90       	ret 

800019f2 <IfxScuWdt_setCpuEndinit>:
    IfxScuWdt_setSafetyEndinit(password);
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
800019f2:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800019f4:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800019f8:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
800019fc:	7b 30 00 3f 	movh %d3,61443
80001a00:	1b 03 10 36 	addi %d3,%d3,24832
80001a04:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001a08:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001a0a:	54 22       	ld.w %d2,[%a2]
80001a0c:	6f 12 0b 00 	jz.t %d2,1,80001a22 <IfxScuWdt_setCpuEndinit+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a10:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001a14:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001a18:	54 22       	ld.w %d2,[%a2]
80001a1a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a1e:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001a20:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a22:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001a26:	8f 33 40 31 	or %d3,%d3,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001a2a:	54 22       	ld.w %d2,[%a2]
80001a2c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001a30:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001a32:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80001a34:	54 22       	ld.w %d2,[%a2]
80001a36:	6f 02 ff 7f 	jz.t %d2,0,80001a34 <IfxScuWdt_setCpuEndinit+0x42>
}
80001a3a:	00 90       	ret 

80001a3c <IfxScuWdt_setSafetyEndinit>:


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
80001a3c:	40 ae       	mov.aa %a14,%sp
80001a3e:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001a42:	91 30 00 2f 	movh.a %a2,61443
80001a46:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001a4a:	54 22       	ld.w %d2,[%a2]
80001a4c:	6f 12 0b 00 	jz.t %d2,1,80001a62 <IfxScuWdt_setSafetyEndinit+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a50:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001a54:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001a58:	54 22       	ld.w %d2,[%a2]
80001a5a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a5e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001a60:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a62:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001a66:	8f 33 40 31 	or %d3,%d3,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001a6a:	91 30 00 2f 	movh.a %a2,61443
80001a6e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001a72:	54 22       	ld.w %d2,[%a2]
80001a74:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001a78:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001a7a:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001a7c:	91 30 00 2f 	movh.a %a2,61443
80001a80:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001a84:	54 22       	ld.w %d2,[%a2]
80001a86:	6f 02 fb 7f 	jz.t %d2,0,80001a7c <IfxScuWdt_setSafetyEndinit+0x40>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80001a8a:	00 90       	ret 

80001a8c <IfxPort_setPinMode>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80001a8c:	40 ae       	mov.aa %a14,%sp
80001a8e:	40 4c       	mov.aa %a12,%a4
80001a90:	02 5a       	mov %d10,%d5
80001a92:	8f f4 0f c1 	and %d12,%d4,255
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80001a96:	80 42       	mov.d %d2,%a4
80001a98:	1b 02 01 b0 	addi %d11,%d2,16
    uint8                 iocrIndex = (pinIndex / 4);
80001a9c:	37 04 66 91 	extr.u %d9,%d4,2,6
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80001aa0:	8f 34 00 41 	and %d4,%d4,3
80001aa4:	8f 34 00 80 	sh %d8,%d4,3

    if (port == &MODULE_P40)
80001aa8:	7b 40 00 2f 	movh %d2,61444
80001aac:	1b 02 00 2e 	addi %d2,%d2,-8192
80001ab0:	80 43       	mov.d %d3,%a4
80001ab2:	5f 23 12 00 	jeq %d3,%d2,80001ad6 <IfxPort_setPinMode+0x4a>
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
        IfxScuWdt_setCpuEndinit(passwd);
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80001ab6:	8f 29 00 20 	sh %d2,%d9,2
80001aba:	60 b2       	mov.a %a2,%d11
80001abc:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001ac0:	3b f0 0f 40 	mov %d4,255
80001ac4:	0f 84 00 40 	sh %d4,%d4,%d8
80001ac8:	0f 8a 00 20 	sh %d2,%d10,%d8
                     ::"a"(address), "d"(mask), "d"((long long)value));
80001acc:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
80001ace:	02 43       	mov %d3,%d4
80001ad0:	49 22 40 08 	ldmst [%a2]0,%e2
}
80001ad4:	00 90       	ret 
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80001ad6:	6d ff 71 ff 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
80001ada:	02 2d       	mov %d13,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80001adc:	02 24       	mov %d4,%d2
80001ade:	6d ff 04 fe 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80001ae2:	d9 c2 20 10 	lea %a2,[%a12]96
80001ae6:	19 c2 20 10 	ld.w %d2,[%a12]96
80001aea:	d7 02 01 2c 	insert %d2,%d2,0,%d12,1
80001aee:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(passwd);
80001af0:	02 d4       	mov %d4,%d13
80001af2:	6d ff 80 ff 	call 800019f2 <IfxScuWdt_setCpuEndinit>
80001af6:	1d ff e0 ff 	j 80001ab6 <IfxPort_setPinMode+0x2a>

80001afa <IfxPort_setPinPadDriver>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80001afa:	40 ae       	mov.aa %a14,%sp
80001afc:	80 4b       	mov.d %d11,%a4
80001afe:	02 5a       	mov %d10,%d5
80001b00:	8f f4 0f 81 	and %d8,%d4,255
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80001b04:	6d ff 5a ff 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
80001b08:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80001b0a:	02 24       	mov %d4,%d2
80001b0c:	6d ff ed fd 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
80001b10:	1b 0b 04 40 	addi %d4,%d11,64
        uint8            pdrIndex = (pinIndex / 8);
80001b14:	8f d8 1f 20 	sh %d2,%d8,-3
        uint8            shift    = (pinIndex & 0x7U) * 4;
80001b18:	8f 78 00 31 	and %d3,%d8,7
80001b1c:	06 23       	sh %d3,2
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
80001b1e:	06 22       	sh %d2,2
80001b20:	60 42       	mov.a %a2,%d4
80001b22:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
80001b26:	3b f0 00 20 	mov %d2,15
80001b2a:	0f 32 00 20 	sh %d2,%d2,%d3
80001b2e:	0f 3a 00 30 	sh %d3,%d10,%d3
                     ::"a"(address), "d"(mask), "d"((long long)value));
80001b32:	53 13 40 60 	mul.u %e6,%d3,1
    __asm__ volatile("mov %H2,%1 \n\
80001b36:	02 27       	mov %d7,%d2
80001b38:	49 46 40 08 	ldmst [%a4]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80001b3c:	02 94       	mov %d4,%d9
80001b3e:	6d ff 5a ff 	call 800019f2 <IfxScuWdt_setCpuEndinit>
}
80001b42:	00 90       	ret 

80001b44 <IfxCpu_Trap_memoryManagementError>:
{
80001b44:	40 ae       	mov.aa %a14,%sp
80001b46:	20 08       	sub.a %sp,8
}

IFX_INLINE void* Ifx__getA11(void)
{
    uint32 *res;
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001b48:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001b4a:	8f f4 0f 41 	and %d4,%d4,255
    reg.U = __mfcr(CPU_CORE_ID);
80001b4e:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001b52:	8f 72 00 21 	and %d2,%d2,7
80001b56:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001b5a:	80 22       	mov.d %d2,%a2
80001b5c:	0f 54 a0 30 	or %d3,%d4,%d5
80001b60:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_MME_HOOK(trapWatch);
80001b64:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001b68:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001b6a:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001b6e:	00 80       	rfe 
}
80001b70:	00 90       	ret 

80001b72 <IfxCpu_Trap_internalProtectionError>:
{
80001b72:	40 ae       	mov.aa %a14,%sp
80001b74:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001b76:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001b78:	b7 14 18 44 	insert %d4,%d4,1,8,24
80001b7c:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001b80:	8f 72 00 21 	and %d2,%d2,7
80001b84:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001b88:	80 22       	mov.d %d2,%a2
80001b8a:	0f 54 a0 30 	or %d3,%d4,%d5
80001b8e:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IPE_HOOK(trapWatch);
80001b92:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001b96:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001b98:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001b9c:	00 80       	rfe 
}
80001b9e:	00 90       	ret 

80001ba0 <IfxCpu_Trap_instructionError>:
{
80001ba0:	40 ae       	mov.aa %a14,%sp
80001ba2:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001ba4:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001ba6:	b7 24 18 44 	insert %d4,%d4,2,8,24
80001baa:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001bae:	8f 72 00 21 	and %d2,%d2,7
80001bb2:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001bb6:	80 22       	mov.d %d2,%a2
80001bb8:	0f 54 a0 30 	or %d3,%d4,%d5
80001bbc:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IE_HOOK(trapWatch);
80001bc0:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001bc4:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001bc6:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001bca:	00 80       	rfe 
}
80001bcc:	00 90       	ret 

80001bce <IfxCpu_Trap_contextManagementError>:
{
80001bce:	40 ae       	mov.aa %a14,%sp
80001bd0:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001bd2:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001bd4:	b7 34 18 44 	insert %d4,%d4,3,8,24
80001bd8:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001bdc:	8f 72 00 21 	and %d2,%d2,7
80001be0:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001be4:	80 22       	mov.d %d2,%a2
80001be6:	0f 54 a0 30 	or %d3,%d4,%d5
80001bea:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_CME_HOOK(trapWatch);
80001bee:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001bf2:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001bf4:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001bf8:	00 80       	rfe 
}
80001bfa:	00 90       	ret 

80001bfc <IfxCpu_Trap_busError>:
{
80001bfc:	40 ae       	mov.aa %a14,%sp
80001bfe:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001c00:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001c02:	b7 44 18 44 	insert %d4,%d4,4,8,24
80001c06:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001c0a:	8f 72 00 21 	and %d2,%d2,7
80001c0e:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001c12:	80 22       	mov.d %d2,%a2
80001c14:	0f 54 a0 30 	or %d3,%d4,%d5
80001c18:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_BE_HOOK(trapWatch);
80001c1c:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001c20:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001c22:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001c26:	00 80       	rfe 
}
80001c28:	00 90       	ret 

80001c2a <IfxCpu_Trap_assertion>:
{
80001c2a:	40 ae       	mov.aa %a14,%sp
80001c2c:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001c2e:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001c30:	8f f4 0f 41 	and %d4,%d4,255
80001c34:	3b 00 50 20 	mov %d2,1280
80001c38:	a6 24       	or %d4,%d2
80001c3a:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001c3e:	8f 72 00 21 	and %d2,%d2,7
80001c42:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001c46:	80 22       	mov.d %d2,%a2
80001c48:	0f 54 a0 30 	or %d3,%d4,%d5
80001c4c:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_ASSERT_HOOK(trapWatch);
80001c50:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80001c54:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001c56:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001c5a:	00 80       	rfe 
}
80001c5c:	00 90       	ret 

80001c5e <IfxCpu_Trap_systemCall_Cpu0>:
{
80001c5e:	40 ae       	mov.aa %a14,%sp
80001c60:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80001c62:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001c64:	b7 64 18 44 	insert %d4,%d4,6,8,24
80001c68:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001c6c:	8f 72 00 21 	and %d2,%d2,7
80001c70:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001c74:	80 22       	mov.d %d2,%a2
80001c76:	0f 54 a0 30 	or %d3,%d4,%d5
80001c7a:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU0_HOOK(trapWatch);
80001c7e:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001c82:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001c86:	00 80       	rfe 
}
80001c88:	00 90       	ret 

80001c8a <IfxCpu_Trap_systemCall_Cpu1>:
{
80001c8a:	40 ae       	mov.aa %a14,%sp
80001c8c:	20 08       	sub.a %sp,8
80001c8e:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001c90:	b7 64 18 44 	insert %d4,%d4,6,8,24
80001c94:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001c98:	8f 72 00 21 	and %d2,%d2,7
80001c9c:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001ca0:	80 22       	mov.d %d2,%a2
80001ca2:	0f 54 a0 30 	or %d3,%d4,%d5
80001ca6:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU1_HOOK(trapWatch);
80001caa:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001cae:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001cb2:	00 80       	rfe 
}
80001cb4:	00 90       	ret 

80001cb6 <IfxCpu_Trap_systemCall_Cpu2>:
{
80001cb6:	40 ae       	mov.aa %a14,%sp
80001cb8:	20 08       	sub.a %sp,8
80001cba:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001cbc:	b7 64 18 44 	insert %d4,%d4,6,8,24
80001cc0:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001cc4:	8f 72 00 21 	and %d2,%d2,7
80001cc8:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001ccc:	80 22       	mov.d %d2,%a2
80001cce:	0f 54 a0 30 	or %d3,%d4,%d5
80001cd2:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU2_HOOK(trapWatch);
80001cd6:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001cda:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001cde:	00 80       	rfe 
}
80001ce0:	00 90       	ret 

80001ce2 <IfxCpu_Trap_nonMaskableInterrupt>:
{
80001ce2:	40 ae       	mov.aa %a14,%sp
80001ce4:	20 08       	sub.a %sp,8
80001ce6:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80001ce8:	b7 74 18 44 	insert %d4,%d4,7,8,24
80001cec:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80001cf0:	8f 72 00 21 	and %d2,%d2,7
80001cf4:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80001cf8:	80 22       	mov.d %d2,%a2
80001cfa:	0f 54 a0 30 	or %d3,%d4,%d5
80001cfe:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_NMI_HOOK(trapWatch);    
80001d02:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80001d06:	0d 00 40 02 	rslcx 
    __asm("rfe");
80001d0a:	00 80       	rfe 
}
80001d0c:	00 90       	ret 

80001d0e <IfxCpu_getIndex>:
    return cpuMode;
}


IfxCpu_ResourceCpu IfxCpu_getIndex(Ifx_CPU *cpu)
{
80001d0e:	40 ae       	mov.aa %a14,%sp
    IfxCpu_ResourceCpu result;
    uint32             index;
    result = IfxCpu_ResourceCpu_none;

    for (index = 0; index < IFXCPU_NUM_MODULES; index++)
80001d10:	82 02       	mov %d2,0
80001d12:	1d 00 03 00 	j 80001d18 <IfxCpu_getIndex+0xa>
80001d16:	c2 12       	add %d2,1
80001d18:	ff 32 18 80 	jge.u %d2,3,80001d48 <IfxCpu_getIndex+0x3a>
    {
        if (IfxCpu_cfg_indexMap[index].module == cpu)
80001d1c:	8f 32 00 30 	sh %d3,%d2,3
80001d20:	91 00 00 28 	movh.a %a2,32768
80001d24:	d9 22 14 90 	lea %a2,[%a2]596 <80000254 <IfxCpu_cfg_indexMap>>
80001d28:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80001d2c:	54 23       	ld.w %d3,[%a2]
80001d2e:	80 44       	mov.d %d4,%a4
80001d30:	5f 43 f3 ff 	jne %d3,%d4,80001d16 <IfxCpu_getIndex+0x8>
        {
            result = (IfxCpu_ResourceCpu)IfxCpu_cfg_indexMap[index].index;
80001d34:	06 32       	sh %d2,3
80001d36:	91 00 00 28 	movh.a %a2,32768
80001d3a:	d9 22 14 90 	lea %a2,[%a2]596 <80000254 <IfxCpu_cfg_indexMap>>
80001d3e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001d42:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80001d46:	00 90       	ret 
    result = IfxCpu_ResourceCpu_none;
80001d48:	82 32       	mov %d2,3
        }
    }

    return result;
}
80001d4a:	00 90       	ret 

80001d4c <IfxCpu_getCoreMode>:
{
80001d4c:	40 ae       	mov.aa %a14,%sp
80001d4e:	80 48       	mov.d %d8,%a4
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
80001d50:	6d ff df ff 	call 80001d0e <IfxCpu_getIndex>


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80001d54:	4d c0 e1 3f 	mfcr %d3,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001d58:	8f 73 00 31 	and %d3,%d3,7
    if (IfxCpu_getCoreIndex() != index)
80001d5c:	5f 32 22 00 	jeq %d2,%d3,80001da0 <IfxCpu_getCoreMode+0x54>
        dbgsr = cpu->DBGSR;
80001d60:	bb 00 d0 3f 	mov.u %d3,64768
80001d64:	60 82       	mov.a %a2,%d8
80001d66:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80001d6a:	54 23       	ld.w %d3,[%a2]
    if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_halt)
80001d6c:	37 03 e2 40 	extr.u %d4,%d3,1,2
80001d70:	df 14 1c 00 	jeq %d4,1,80001da8 <IfxCpu_getCoreMode+0x5c>
        if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_run)
80001d74:	df 04 1c 80 	jne %d4,0,80001dac <IfxCpu_getCoreMode+0x60>
            pmcsr_val = &MODULE_SCU.PMCSR[index];
80001d78:	06 22       	sh %d2,2
80001d7a:	7b 30 00 3f 	movh %d3,61443
80001d7e:	1b 43 0d 36 	addi %d3,%d3,24788
80001d82:	60 32       	mov.a %a2,%d3
80001d84:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
            if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
80001d88:	54 22       	ld.w %d2,[%a2]
80001d8a:	37 02 63 24 	extr.u %d2,%d2,8,3
80001d8e:	df 12 11 00 	jeq %d2,1,80001db0 <IfxCpu_getCoreMode+0x64>
                if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
80001d92:	54 22       	ld.w %d2,[%a2]
80001d94:	37 02 63 24 	extr.u %d2,%d2,8,3
80001d98:	df 32 0e 00 	jeq %d2,3,80001db4 <IfxCpu_getCoreMode+0x68>
    cpuMode = IfxCpu_CoreMode_unknown;
80001d9c:	82 52       	mov %d2,5
80001d9e:	00 90       	ret 
        dbgsr.U = __mfcr(CPU_DBGSR);
80001da0:	4d 00 d0 3f 	mfcr %d3,$dbgsr
80001da4:	1d ff e4 ff 	j 80001d6c <IfxCpu_getCoreMode+0x20>
        cpuMode = IfxCpu_CoreMode_halt;
80001da8:	82 02       	mov %d2,0
80001daa:	00 90       	ret 
            cpuMode = IfxCpu_CoreMode_unknown;
80001dac:	82 52       	mov %d2,5
80001dae:	00 90       	ret 
                cpuMode = IfxCpu_CoreMode_run;
80001db0:	82 12       	mov %d2,1
80001db2:	00 90       	ret 
                    cpuMode = IfxCpu_CoreMode_idle;
80001db4:	82 22       	mov %d2,2
}
80001db6:	00 90       	ret 

80001db8 <IfxCpu_setCoreMode>:
    *lock = 0;
}


boolean IfxCpu_setCoreMode(Ifx_CPU *cpu, IfxCpu_CoreMode mode)
{
80001db8:	40 ae       	mov.aa %a14,%sp
80001dba:	80 4c       	mov.d %d12,%a4
80001dbc:	02 48       	mov %d8,%d4
    uint8              reqslp;
    boolean            retValue;
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
80001dbe:	6d ff a8 ff 	call 80001d0e <IfxCpu_getIndex>
80001dc2:	02 2a       	mov %d10,%d2

    /*Modes such as HALT, SLEEP and STBY are not handled at CPU level */
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
80001dc4:	8b 08 20 42 	ne %d4,%d8,0
80001dc8:	8b 38 20 32 	ne %d3,%d8,3
80001dcc:	26 43       	and %d3,%d4
                || (mode == IfxCpu_CoreMode_stby)) ? FALSE : TRUE;
80001dce:	df 03 0a 00 	jeq %d3,0,80001de2 <IfxCpu_setCoreMode+0x2a>
80001dd2:	df 48 05 00 	jeq %d8,4,80001ddc <IfxCpu_setCoreMode+0x24>
80001dd6:	82 19       	mov %d9,1
80001dd8:	1d 00 06 00 	j 80001de4 <IfxCpu_setCoreMode+0x2c>
80001ddc:	82 09       	mov %d9,0
80001dde:	1d 00 03 00 	j 80001de4 <IfxCpu_setCoreMode+0x2c>
80001de2:	82 09       	mov %d9,0
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
80001de4:	8f f9 0f 91 	and %d9,%d9,255

    reqslp = (mode == IfxCpu_CoreMode_idle) ? IfxScu_PMCSR_REQSLP_Idle : IfxScu_PMCSR_REQSLP_Run;
80001de8:	8b 28 00 82 	eq %d8,%d8,2

    if (retValue == TRUE)
80001dec:	df 09 04 80 	jne %d9,0,80001df4 <IfxCpu_setCoreMode+0x3c>
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
        }
    }

    return retValue;
}
80001df0:	02 92       	mov %d2,%d9
80001df2:	00 90       	ret 
    reg.U = __mfcr(CPU_CORE_ID);
80001df4:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001df8:	8f 72 00 21 	and %d2,%d2,7
        if (IfxCpu_getCoreIndex() != index)
80001dfc:	5f 2a 24 00 	jeq %d10,%d2,80001e44 <IfxCpu_setCoreMode+0x8c>
            uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
80001e00:	6d ff ee fd 	call 800019dc <IfxScuWdt_getSafetyWatchdogPassword>
80001e04:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
80001e06:	02 24       	mov %d4,%d2
80001e08:	6d ff 94 fc 	call 80001730 <IfxScuWdt_clearSafetyEndinit>
            MODULE_SCU.PMCSR[(uint32)IfxCpu_getIndex(cpu)].B.REQSLP = reqslp;
80001e0c:	1b 5a 03 20 	addi %d2,%d10,53
80001e10:	06 22       	sh %d2,2
80001e12:	7b 30 00 3f 	movh %d3,61443
80001e16:	1b 03 00 36 	addi %d3,%d3,24576
80001e1a:	60 32       	mov.a %a2,%d3
80001e1c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001e20:	54 23       	ld.w %d3,[%a2]
80001e22:	37 83 02 30 	insert %d3,%d3,%d8,0,2
80001e26:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setSafetyEndinit(safetyWdtPw);
80001e28:	02 b4       	mov %d4,%d11
80001e2a:	6d ff 09 fe 	call 80001a3c <IfxScuWdt_setSafetyEndinit>
            cpu->DBGSR.B.HALT = 2; /*reset the HALT bit, if it is already done it is no harm in writing again */
80001e2e:	bb 00 d0 2f 	mov.u %d2,64768
80001e32:	60 c2       	mov.a %a2,%d12
80001e34:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001e38:	54 22       	ld.w %d2,[%a2]
80001e3a:	b7 22 82 20 	insert %d2,%d2,2,1,2
80001e3e:	74 22       	st.w [%a2],%d2
80001e40:	1d ff d8 ff 	j 80001df0 <IfxCpu_setCoreMode+0x38>
            uint16 cpuWdtPw = IfxScuWdt_getCpuWatchdogPassword();
80001e44:	6d ff ba fd 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
80001e48:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearCpuEndinit(cpuWdtPw);
80001e4a:	02 24       	mov %d4,%d2
80001e4c:	6d ff 4d fc 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
            MODULE_SCU.PMCSR[(uint32)index].B.REQSLP = reqslp;
80001e50:	1b 5a 03 20 	addi %d2,%d10,53
80001e54:	06 22       	sh %d2,2
80001e56:	7b 30 00 3f 	movh %d3,61443
80001e5a:	1b 03 00 36 	addi %d3,%d3,24576
80001e5e:	60 32       	mov.a %a2,%d3
80001e60:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001e64:	54 23       	ld.w %d3,[%a2]
80001e66:	37 83 02 30 	insert %d3,%d3,%d8,0,2
80001e6a:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
80001e6c:	02 b4       	mov %d4,%d11
80001e6e:	6d ff c2 fd 	call 800019f2 <IfxScuWdt_setCpuEndinit>
80001e72:	1d ff bf ff 	j 80001df0 <IfxCpu_setCoreMode+0x38>

80001e76 <IfxCpu_setProgramCounter>:


boolean IfxCpu_setProgramCounter(Ifx_CPU *cpu, uint32 programCounter)
{
80001e76:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001e78:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001e7c:	8f 72 00 21 	and %d2,%d2,7
    if (cpu < IfxCpu_ResourceCpu_none)
80001e80:	ff 32 17 80 	jge.u %d2,3,80001eae <IfxCpu_setProgramCounter+0x38>
        module = (Ifx_CPU *)IfxCpu_cfg_indexMap[cpu].module;
80001e84:	06 32       	sh %d2,3
80001e86:	91 00 00 28 	movh.a %a2,32768
80001e8a:	d9 22 14 90 	lea %a2,[%a2]596 <80000254 <IfxCpu_cfg_indexMap>>
80001e8e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001e92:	54 22       	ld.w %d2,[%a2]
    boolean retVal = TRUE;

    if (cpu == IfxCpu_getAddress(IfxCpu_getCoreIndex()))
80001e94:	80 43       	mov.d %d3,%a4
80001e96:	5f 23 0f 00 	jeq %d3,%d2,80001eb4 <IfxCpu_setProgramCounter+0x3e>
    {
        retVal = FALSE;
    }
    else
    {
        cpu->PC.B.PC = programCounter >> 1;
80001e9a:	bb 80 e0 2f 	mov.u %d2,65032
80001e9e:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
80001ea2:	54 42       	ld.w %d2,[%a4]
80001ea4:	37 24 01 20 	insert %d2,%d4,%d2,0,1
80001ea8:	74 42       	st.w [%a4],%d2
    boolean retVal = TRUE;
80001eaa:	82 12       	mov %d2,1
80001eac:	00 90       	ret 
        module = NULL_PTR;
80001eae:	82 02       	mov %d2,0
80001eb0:	1d ff f2 ff 	j 80001e94 <IfxCpu_setProgramCounter+0x1e>
        retVal = FALSE;
80001eb4:	82 02       	mov %d2,0
    }

    return retVal;
}
80001eb6:	00 90       	ret 

80001eb8 <IfxCpu_startCore>:
    return retVal;
}


boolean IfxCpu_startCore(Ifx_CPU *cpu, uint32 programCounter)
{
80001eb8:	40 ae       	mov.aa %a14,%sp
80001eba:	80 49       	mov.d %d9,%a4
    boolean retVal = TRUE;

    /* Set the PC for Core 1 */
    retVal &= IfxCpu_setProgramCounter(cpu, programCounter);
80001ebc:	6d ff dd ff 	call 80001e76 <IfxCpu_setProgramCounter>
80001ec0:	8f 12 00 81 	and %d8,%d2,1
    /* Get the mode for Core 1 and set it to RUNNING */

    /* Core not running already */
    if (IfxCpu_getCoreMode(cpu) == IfxCpu_CoreMode_halt)
80001ec4:	60 94       	mov.a %a4,%d9
80001ec6:	6d ff 43 ff 	call 80001d4c <IfxCpu_getCoreMode>
80001eca:	df 02 04 00 	jeq %d2,0,80001ed2 <IfxCpu_startCore+0x1a>
    {
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
    }

    return retVal;
}
80001ece:	02 82       	mov %d2,%d8
80001ed0:	00 90       	ret 
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
80001ed2:	82 14       	mov %d4,1
80001ed4:	60 94       	mov.a %a4,%d9
80001ed6:	6d ff 71 ff 	call 80001db8 <IfxCpu_setCoreMode>
80001eda:	26 28       	and %d8,%d2
80001edc:	1d ff f9 ff 	j 80001ece <IfxCpu_startCore+0x16>

80001ee0 <IfxCpu_waitEvent>:


boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec)
{
80001ee0:	40 ae       	mov.aa %a14,%sp
80001ee2:	40 4c       	mov.aa %a12,%a4
80001ee4:	02 48       	mov %d8,%d4
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80001ee6:	80 42       	mov.d %d2,%a4
80001ee8:	b7 02 1c 20 	insert %d2,%d2,0,0,28
80001eec:	7b 00 00 3d 	movh %d3,53248
80001ef0:	5f 32 28 00 	jeq %d2,%d3,80001f40 <IfxCpu_waitEvent+0x60>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80001ef4:	6d ff 68 f9 	call 800011c4 <IfxScuCcu_getSourceFrequency>
80001ef8:	91 30 00 2f 	movh.a %a2,61443
80001efc:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80001f00:	54 23       	ld.w %d3,[%a2]
80001f02:	37 03 64 34 	extr.u %d3,%d3,8,4
80001f06:	4b 03 41 31 	itof %d3,%d3
80001f0a:	4b 32 51 20 	div.f %d2,%d2,%d3

    boolean          errorcnt      = 0U;
    /* Divide with 1000, gives the count value equivalent to milliseconds */
    uint32           stmCount      = (uint32)((IfxScuCcu_getStmFrequency() / 1000) * timeoutMilliSec);
80001f0e:	7b a0 47 34 	movh %d3,17530
80001f12:	4b 32 51 20 	div.f %d2,%d2,%d3
80001f16:	4b 08 61 41 	utof %d4,%d8
80001f1a:	4b 24 41 40 	mul.f %d4,%d4,%d2
80001f1e:	4b 04 71 31 	ftouz %d3,%d4
    uint32           stmCountBegin = STM0_TIM0.U;
80001f22:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((*sync & IFXCPU_CFG_ALLCORE_DONE) != IFXCPU_CFG_ALLCORE_DONE)
80001f26:	54 c2       	ld.w %d2,[%a12]
80001f28:	8f 72 00 21 	and %d2,%d2,7
80001f2c:	df 72 18 00 	jeq %d2,7,80001f5c <IfxCpu_waitEvent+0x7c>
    __asm__ volatile ("nop" : : : "memory");
80001f30:	00 00       	nop 
    {
        __nop();

        if ((uint32)(STM0_TIM0.U - stmCountBegin) >= stmCount)
80001f32:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
80001f36:	a2 42       	sub %d2,%d4
80001f38:	3f 32 f7 ff 	jlt.u %d2,%d3,80001f26 <IfxCpu_waitEvent+0x46>
        {
            errorcnt = 1;
80001f3c:	82 12       	mov %d2,1
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

    return errorcnt;
}
80001f3e:	00 90       	ret 
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80001f40:	80 42       	mov.d %d2,%a4
80001f42:	b7 02 0c 3a 	insert %d3,%d2,0,20,12
80001f46:	b7 f3 03 3e 	insert %d3,%d3,15,28,3
80001f4a:	4d c0 e1 2f 	mfcr %d2,$core_id
80001f4e:	8f c2 01 20 	sh %d2,%d2,28
80001f52:	0b 23 80 20 	sub %d2,%d3,%d2
80001f56:	60 2c       	mov.a %a12,%d2
80001f58:	1d ff ce ff 	j 80001ef4 <IfxCpu_waitEvent+0x14>
    boolean          errorcnt      = 0U;
80001f5c:	82 02       	mov %d2,0
80001f5e:	00 90       	ret 

80001f60 <IfxCpu_emitEvent>:


void IfxCpu_emitEvent(IfxCpu_syncEvent *event)
{
80001f60:	40 ae       	mov.aa %a14,%sp
    Ifx__imaskldmst(event, 1, __mfcr(CPU_CORE_ID), 1);
80001f62:	4d c0 e1 2f 	mfcr %d2,$core_id
80001f66:	82 13       	mov %d3,1
80001f68:	57 30 21 22 	imask %e2,%d3,%d2,1
80001f6c:	49 42 40 08 	ldmst [%a4]0,%e2
}
80001f70:	00 90       	ret 

80001f72 <Ifx_Cpp_Init>:
#pragma section
#elif defined(__DCC__)
#pragma section CONST
#endif
static void Ifx_Cpp_Init(void)
{
80001f72:	40 ae       	mov.aa %a14,%sp
    Ifx_C_Init();           /*Initialization of C runtime variables */
80001f74:	6d 00 8d 09 	call 8000328e <Ifx_C_Init>
#elif defined (__HIGHTEC__)
extern void _init(void); /* cpp initialization */
    _init();
#elif defined (__GNUC__) && !defined(__HIGHTEC__)
    extern void _init(void); /* cpp initialization */
    _init();
80001f78:	6d 00 20 14 	call 800047b8 <_init>
#endif
}
80001f7c:	00 90       	ret 

80001f7e <hardware_init_hook>:
{}
80001f7e:	00 90       	ret 

80001f80 <software_init_hook>:
{}
80001f80:	00 90       	ret 

80001f82 <_Core0_start>:
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
80001f82:	91 30 00 2f 	movh.a %a2,61443
80001f86:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
    __setareg(sp, __USTACK(0));
80001f8a:	91 20 00 37 	movh.a %a3,28674
80001f8e:	37 02 6e 21 	extr.u %d2,%d2,2,14
80001f92:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80001f96:	8f f2 83 81 	xor %d8,%d2,63
80001f9a:	80 32       	mov.d %d2,%a3
80001f9c:	1b 02 60 29 	addi %d2,%d2,-27136
80001fa0:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
80001fa2:	0d 00 80 04 	dsync 
    __mtcr(CPU_PSW, IFXCSTART0_PSW_DEFAULT);
80001fa6:	3b 00 98 20 	mov %d2,2432
80001faa:	cd 42 e0 0f 	mtcr $psw,%d2
    pcxi  = __mfcr(CPU_PCXI);
80001fae:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART0_PCX_O_S_DEFAULT; /*0xfff00000; */
80001fb2:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
80001fb6:	cd 02 e0 0f 	mtcr $pcxi,%d2
    if (enable)
    {                           /* Step 3: Initiate invalidation of current cache contents if any */
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = 0;
        pcon1.B.PCINV = 1;
        __mtcr(CPU_PCON1, pcon1.U);
80001fba:	82 12       	mov %d2,1
80001fbc:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
80001fc0:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001fc4:	8f 72 00 21 	and %d2,%d2,7
    }

    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80001fc8:	01 22 03 26 	addsc.a %a2,%a2,%d2,3
80001fcc:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80001fd0:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80001fd2:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80001fd4:	37 02 6e 21 	extr.u %d2,%d2,2,14
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80001fd8:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80001fdc:	6f 13 41 81 	jnz.t %d3,1,8000225e <_Core0_start+0x2dc>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001fe0:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001fe4:	54 22       	ld.w %d2,[%a2]
80001fe6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001fea:	a6 32       	or %d2,%d3
80001fec:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ff0:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80001ff2:	54 22       	ld.w %d2,[%a2]
80001ff4:	6f 02 ff ff 	jnz.t %d2,0,80001ff2 <_Core0_start+0x70>
        Ifx_CPU_PCON0 pcon0;
        pcon0.U       = 0;
        pcon0.B.PCBYP = enable ? 0 : 1; /*depending on the enable bypass bit is reset/set */
        __mtcr(CPU_PCON0, pcon0.U);
80001ff8:	82 02       	mov %d2,0
80001ffa:	cd c2 20 09 	mtcr $pcon0,%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80001ffe:	54 22       	ld.w %d2,[%a2]
80002000:	6f 12 09 00 	jz.t %d2,1,80002012 <_Core0_start+0x90>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002004:	54 22       	ld.w %d2,[%a2]
80002006:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000200a:	a6 32       	or %d2,%d3
8000200c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002010:	74 22       	st.w [%a2],%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002012:	54 22       	ld.w %d2,[%a2]
80002014:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002018:	a6 32       	or %d2,%d3
8000201a:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000201e:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80002020:	54 22       	ld.w %d2,[%a2]
80002022:	6f 02 ff 7f 	jz.t %d2,0,80002020 <_Core0_start+0x9e>
    __asm__ volatile ("isync" : : : "memory");
80002026:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
8000202a:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
8000202e:	7b 30 00 3f 	movh %d3,61443
80002032:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002036:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
8000203a:	13 c2 20 23 	madd %d2,%d3,%d2,12
8000203e:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
80002040:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80002042:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80002044:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80002048:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
8000204c:	6f 13 fd 80 	jnz.t %d3,1,80002246 <_Core0_start+0x2c4>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002050:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002054:	54 22       	ld.w %d2,[%a2]
80002056:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000205a:	a6 32       	or %d2,%d3
8000205c:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002060:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80002062:	54 22       	ld.w %d2,[%a2]
80002064:	6f 02 ff ff 	jnz.t %d2,0,80002062 <_Core0_start+0xe0>
        __mtcr(CPU_DCON0, dcon0.U);
80002068:	82 22       	mov %d2,2
8000206a:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
8000206e:	54 22       	ld.w %d2,[%a2]
80002070:	6f 12 09 00 	jz.t %d2,1,80002082 <_Core0_start+0x100>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002074:	54 22       	ld.w %d2,[%a2]
80002076:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000207a:	a6 32       	or %d2,%d3
8000207c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002080:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002082:	54 22       	ld.w %d2,[%a2]
80002084:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002088:	a6 32       	or %d2,%d3
8000208a:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000208e:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002090:	54 22       	ld.w %d2,[%a2]
80002092:	6f 02 ff 7f 	jz.t %d2,0,80002090 <_Core0_start+0x10e>
80002096:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
8000209a:	91 30 00 2f 	movh.a %a2,61443
8000209e:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800020a2:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800020a6:	8f 28 00 30 	sh %d3,%d8,2
    if (watchdog->CON0.B.LCK)
800020aa:	6f 12 09 00 	jz.t %d2,1,800020bc <_Core0_start+0x13a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800020ae:	54 22       	ld.w %d2,[%a2]
800020b0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800020b4:	a6 32       	or %d2,%d3
800020b6:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800020ba:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800020bc:	91 30 00 2f 	movh.a %a2,61443
800020c0:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800020c4:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800020c8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800020cc:	a6 32       	or %d2,%d3
800020ce:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800020d2:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800020d4:	54 22       	ld.w %d2,[%a2]
800020d6:	6f 02 ff ff 	jnz.t %d2,0,800020d4 <_Core0_start+0x152>
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(0));
800020da:	91 00 00 38 	movh.a %a3,32768
800020de:	80 32       	mov.d %d2,%a3
800020e0:	1b 02 10 20 	addi %d2,%d2,256
800020e4:	cd 42 e2 0f 	mtcr $btv,%d2
    __mtcr(CPU_BIV, (uint32)__INTTAB(0));
800020e8:	91 f0 01 38 	movh.a %a3,32799
800020ec:	80 32       	mov.d %d2,%a3
800020ee:	1b 02 00 24 	addi %d2,%d2,16384
800020f2:	cd 02 e2 0f 	mtcr $biv,%d2
    __mtcr(CPU_ISP, (uint32)__ISTACK(0));
800020f6:	91 20 00 37 	movh.a %a3,28674
800020fa:	80 32       	mov.d %d2,%a3
800020fc:	1b 02 b0 29 	addi %d2,%d2,-25856
80002100:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
80002104:	54 22       	ld.w %d2,[%a2]
80002106:	6f 12 09 00 	jz.t %d2,1,80002118 <_Core0_start+0x196>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000210a:	54 22       	ld.w %d2,[%a2]
8000210c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002110:	a6 32       	or %d2,%d3
80002112:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002116:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002118:	91 30 00 2f 	movh.a %a2,61443
8000211c:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80002120:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80002124:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002128:	a6 32       	or %d2,%d3
8000212a:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000212e:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002130:	54 22       	ld.w %d2,[%a2]
80002132:	6f 02 ff 7f 	jz.t %d2,0,80002130 <_Core0_start+0x1ae>
    __setareg(a0, __SDATA1(0));
80002136:	91 10 00 26 	movh.a %a2,24577
8000213a:	80 22       	mov.d %d2,%a2
8000213c:	1b 02 00 28 	addi %d2,%d2,-32768
80002140:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(0));
80002142:	91 10 00 28 	movh.a %a2,32769
80002146:	80 22       	mov.d %d2,%a2
80002148:	1b 02 00 28 	addi %d2,%d2,-32768
8000214c:	60 21       	mov.a %a1,%d2
    __setareg(a8, __SDATA3(0));
8000214e:	91 10 00 28 	movh.a %a2,32769
80002152:	80 22       	mov.d %d2,%a2
80002154:	1b 02 00 28 	addi %d2,%d2,-32768
80002158:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(0));
8000215a:	91 10 00 29 	movh.a %a2,36865
8000215e:	80 22       	mov.d %d2,%a2
80002160:	1b 02 00 28 	addi %d2,%d2,-32768
80002164:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
80002166:	91 20 00 37 	movh.a %a3,28674
8000216a:	91 20 00 27 	movh.a %a2,28674
8000216e:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70019c00 <__CSA0>>
80002172:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7001bc00 <__CSA0_END>>
80002176:	01 32 20 20 	sub.a %a2,%a2,%a3
8000217a:	80 22       	mov.d %d2,%a2
8000217c:	8f a2 1f 70 	sh %d7,%d2,-6
    uint32 *prvCsa      = csaBegin;
80002180:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
80002182:	1b d7 ff 0f 	addi %d0,%d7,-3
    for (k = 0U; k < numOfCsa; k++)
80002186:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
80002188:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
8000218a:	7b f0 00 40 	movh %d4,15
    for (k = 0U; k < numOfCsa; k++)
8000218e:	df 07 27 00 	jeq %d7,0,800021dc <_Core0_start+0x25a>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002192:	37 02 70 53 	extr.u %d5,%d2,6,16
80002196:	8f 42 1f 60 	sh %d6,%d2,-12
8000219a:	26 46       	and %d6,%d4
8000219c:	a6 65       	or %d5,%d6
        if (k == 0U)
8000219e:	df 03 16 00 	jeq %d3,0,800021ca <_Core0_start+0x248>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
800021a2:	74 25       	st.w [%a2],%d5
        if (k == (numOfCsa - 3U))
800021a4:	5f 03 04 80 	jne %d3,%d0,800021ac <_Core0_start+0x22a>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800021a8:	cd c5 e3 0f 	mtcr $lcx,%d5
    for (k = 0U; k < numOfCsa; k++)
800021ac:	c2 13       	add %d3,1
800021ae:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
800021b0:	1b 02 04 50 	addi %d5,%d2,64
    for (k = 0U; k < numOfCsa; k++)
800021b4:	5f 37 0f 00 	jeq %d7,%d3,800021d2 <_Core0_start+0x250>
        nxtCsa += 16U;           /* next CSA */
800021b8:	02 52       	mov %d2,%d5
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800021ba:	37 02 70 53 	extr.u %d5,%d2,6,16
800021be:	8f 42 1f 60 	sh %d6,%d2,-12
800021c2:	26 46       	and %d6,%d4
800021c4:	a6 65       	or %d5,%d6
        if (k == 0U)
800021c6:	df 03 ee ff 	jne %d3,0,800021a2 <_Core0_start+0x220>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
800021ca:	cd 85 e3 0f 	mtcr $fcx,%d5
800021ce:	1d ff eb ff 	j 800021a4 <_Core0_start+0x222>
800021d2:	1b f7 ff 2f 	addi %d2,%d7,-1
800021d6:	06 62       	sh %d2,6
800021d8:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
800021dc:	82 02       	mov %d2,0
800021de:	74 22       	st.w [%a2],%d2
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
800021e0:	6d ff fe fb 	call 800019dc <IfxScuWdt_getSafetyWatchdogPassword>
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
800021e4:	02 84       	mov %d4,%d8
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
800021e6:	02 29       	mov %d9,%d2
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
800021e8:	6d ff cc fa 	call 80001780 <IfxScuWdt_disableCpuWatchdog>
        IfxScuWdt_disableSafetyWatchdog(safetyWdtPassword);
800021ec:	02 94       	mov %d4,%d9
800021ee:	6d ff 08 fb 	call 800017fe <IfxScuWdt_disableSafetyWatchdog>
       	hardware_init_hook();
800021f2:	6d ff c6 fe 	call 80001f7e <hardware_init_hook>
        Ifx_Cpp_Init();
800021f6:	6d ff be fe 	call 80001f72 <Ifx_Cpp_Init>
       	software_init_hook();
800021fa:	6d ff c3 fe 	call 80001f80 <software_init_hook>
        IfxScuWdt_enableCpuWatchdog(cpuWdtPassword);
800021fe:	02 84       	mov %d4,%d8
80002200:	6d ff 4e fb 	call 8000189c <IfxScuWdt_enableCpuWatchdog>
        IfxScuWdt_enableSafetyWatchdog(safetyWdtPassword);
80002204:	02 94       	mov %d4,%d9
80002206:	6d ff 8a fb 	call 8000191a <IfxScuWdt_enableSafetyWatchdog>
    IFXCPU_CSTART_CCU_INIT_HOOK();
8000220a:	91 00 00 48 	movh.a %a4,32768
8000220e:	d9 44 04 a0 	lea %a4,[%a4]644 <80000284 <IfxScuCcu_defaultClockConfig>>
80002212:	6d ff c9 f8 	call 800013a4 <IfxScuCcu_init>
    (void)IfxCpu_startCore(&MODULE_CPU1, (uint32)&_Core1_start);       /*The status returned by function call is ignored */
80002216:	91 00 00 28 	movh.a %a2,32768
8000221a:	80 22       	mov.d %d2,%a2
8000221c:	1b 62 27 42 	addi %d4,%d2,8822
80002220:	91 30 88 4f 	movh.a %a4,63619
80002224:	6d ff 4a fe 	call 80001eb8 <IfxCpu_startCore>
    (void)IfxCpu_startCore(&MODULE_CPU2, (uint32)&_Core2_start);       /*The status returned by function call is ignored */
80002228:	91 00 00 28 	movh.a %a2,32768
8000222c:	80 22       	mov.d %d2,%a2
8000222e:	1b 42 51 42 	addi %d4,%d2,9492
80002232:	91 50 88 4f 	movh.a %a4,63621
80002236:	6d ff 41 fe 	call 80001eb8 <IfxCpu_startCore>
    __non_return_call(core0_main);
8000223a:	91 00 00 28 	movh.a %a2,32768
8000223e:	d9 22 7c a3 	lea %a2,[%a2]14012 <800036bc <core0_main>>
80002242:	dc 02       	ji %a2
}
80002244:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002246:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002248:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000224c:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002250:	0f 34 a0 20 	or %d2,%d4,%d3
80002254:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002258:	74 22       	st.w [%a2],%d2
8000225a:	1d ff fd fe 	j 80002054 <_Core0_start+0xd2>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000225e:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002260:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002264:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002268:	0f 34 a0 20 	or %d2,%d4,%d3
8000226c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002270:	74 22       	st.w [%a2],%d2
80002272:	1d ff b9 fe 	j 80001fe4 <_Core0_start+0x62>

80002276 <_Core1_start>:
    password  = watchdog->CON0.B.PW;
80002276:	91 30 00 2f 	movh.a %a2,61443
8000227a:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
8000227e:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80002282:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[1]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(1);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(1));
80002286:	91 20 00 26 	movh.a %a2,24578
8000228a:	8f f2 83 41 	xor %d4,%d2,63
8000228e:	80 22       	mov.d %d2,%a2
80002290:	1b 02 60 2b 	addi %d2,%d2,-18944
80002294:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
80002296:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART1_PSW_DEFAULT);    /* 0x00000980 */
8000229a:	3b 00 98 20 	mov %d2,2432
8000229e:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
800022a2:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART1_PCX_O_S_DEFAULT; /*0xfff00000; */
800022a6:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
800022aa:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
800022ae:	82 12       	mov %d2,1
800022b0:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
800022b4:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800022b8:	7b 30 00 3f 	movh %d3,61443
800022bc:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800022c0:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800022c4:	13 c2 20 23 	madd %d2,%d3,%d2,12
800022c8:	60 22       	mov.a %a2,%d2
800022ca:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
800022cc:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
800022ce:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
800022d2:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800022d6:	6f 13 13 81 	jnz.t %d3,1,800024fc <_Core1_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800022da:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800022de:	54 22       	ld.w %d2,[%a2]
800022e0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800022e4:	a6 32       	or %d2,%d3
800022e6:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800022ea:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800022ec:	54 22       	ld.w %d2,[%a2]
800022ee:	6f 02 ff ff 	jnz.t %d2,0,800022ec <_Core1_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
800022f2:	82 02       	mov %d2,0
800022f4:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
800022f8:	54 22       	ld.w %d2,[%a2]
800022fa:	6f 12 09 00 	jz.t %d2,1,8000230c <_Core1_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800022fe:	54 22       	ld.w %d2,[%a2]
80002300:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002304:	a6 32       	or %d2,%d3
80002306:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000230a:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000230c:	54 22       	ld.w %d2,[%a2]
8000230e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002312:	a6 32       	or %d2,%d3
80002314:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002318:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
8000231a:	54 22       	ld.w %d2,[%a2]
8000231c:	6f 02 ff 7f 	jz.t %d2,0,8000231a <_Core1_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
80002320:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80002324:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002328:	7b 30 00 3f 	movh %d3,61443
8000232c:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002330:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002334:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002338:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
8000233a:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000233c:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000233e:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80002342:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80002346:	6f 13 cf 80 	jnz.t %d3,1,800024e4 <_Core1_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000234a:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000234e:	54 22       	ld.w %d2,[%a2]
80002350:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002354:	a6 32       	or %d2,%d3
80002356:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000235a:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000235c:	54 22       	ld.w %d2,[%a2]
8000235e:	6f 02 ff ff 	jnz.t %d2,0,8000235c <_Core1_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
80002362:	82 02       	mov %d2,0
80002364:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80002368:	54 22       	ld.w %d2,[%a2]
8000236a:	6f 12 09 00 	jz.t %d2,1,8000237c <_Core1_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000236e:	54 22       	ld.w %d2,[%a2]
80002370:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002374:	a6 32       	or %d2,%d3
80002376:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000237a:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000237c:	54 22       	ld.w %d2,[%a2]
8000237e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002382:	a6 32       	or %d2,%d3
80002384:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002388:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
8000238a:	54 22       	ld.w %d2,[%a2]
8000238c:	6f 02 ff 7f 	jz.t %d2,0,8000238a <_Core1_start+0x114>
80002390:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
80002394:	91 30 00 2f 	movh.a %a2,61443
80002398:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
8000239c:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800023a0:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
800023a2:	6f 12 09 00 	jz.t %d2,1,800023b4 <_Core1_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800023a6:	54 22       	ld.w %d2,[%a2]
800023a8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800023ac:	a6 42       	or %d2,%d4
800023ae:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800023b2:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800023b4:	91 30 00 2f 	movh.a %a2,61443
800023b8:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800023bc:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800023c0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800023c4:	a6 42       	or %d2,%d4
800023c6:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800023ca:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800023cc:	54 22       	ld.w %d2,[%a2]
800023ce:	6f 02 ff ff 	jnz.t %d2,0,800023cc <_Core1_start+0x156>

    /* Clear the ENDINIT bit in the WDT_CON1 register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(1));
800023d2:	91 f0 01 38 	movh.a %a3,32799
800023d6:	80 32       	mov.d %d2,%a3
800023d8:	1b 02 20 26 	addi %d2,%d2,25088
800023dc:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(1));
800023e0:	91 f0 01 38 	movh.a %a3,32799
800023e4:	80 32       	mov.d %d2,%a3
800023e6:	1b 02 00 24 	addi %d2,%d2,16384
800023ea:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(1));
800023ee:	91 20 00 36 	movh.a %a3,24578
800023f2:	80 32       	mov.d %d2,%a3
800023f4:	1b 02 b0 2b 	addi %d2,%d2,-17664
800023f8:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
800023fc:	54 22       	ld.w %d2,[%a2]
800023fe:	6f 12 09 00 	jz.t %d2,1,80002410 <_Core1_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002402:	54 22       	ld.w %d2,[%a2]
80002404:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002408:	a6 42       	or %d2,%d4
8000240a:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000240e:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002410:	91 30 00 2f 	movh.a %a2,61443
80002414:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80002418:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
8000241c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002420:	a6 42       	or %d2,%d4
80002422:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002426:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002428:	54 22       	ld.w %d2,[%a2]
8000242a:	6f 02 ff 7f 	jz.t %d2,0,80002428 <_Core1_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(1));
8000242e:	91 10 00 26 	movh.a %a2,24577
80002432:	80 22       	mov.d %d2,%a2
80002434:	1b 02 00 28 	addi %d2,%d2,-32768
80002438:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(1));
8000243a:	91 10 00 28 	movh.a %a2,32769
8000243e:	80 22       	mov.d %d2,%a2
80002440:	1b 02 00 28 	addi %d2,%d2,-32768
80002444:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialised */
    __setareg(a8, __SDATA3(1));
80002446:	91 10 00 28 	movh.a %a2,32769
8000244a:	80 22       	mov.d %d2,%a2
8000244c:	1b 02 00 28 	addi %d2,%d2,-32768
80002450:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(1));
80002452:	91 10 00 29 	movh.a %a2,36865
80002456:	80 22       	mov.d %d2,%a2
80002458:	1b 02 00 28 	addi %d2,%d2,-32768
8000245c:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
8000245e:	91 20 00 36 	movh.a %a3,24578
80002462:	91 20 00 26 	movh.a %a2,24578
80002466:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <6001bc00 <__CSA1>>
8000246a:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <6001dc00 <__CSA1_END>>
8000246e:	01 32 20 20 	sub.a %a2,%a2,%a3
80002472:	80 22       	mov.d %d2,%a2
80002474:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
80002478:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
8000247a:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
8000247e:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
80002480:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002482:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80002486:	df 06 27 00 	jeq %d6,0,800024d4 <_Core1_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
8000248a:	37 02 70 43 	extr.u %d4,%d2,6,16
8000248e:	8f 42 1f 50 	sh %d5,%d2,-12
80002492:	26 75       	and %d5,%d7
80002494:	a6 54       	or %d4,%d5
        if (k == 0U)
80002496:	df 03 16 00 	jeq %d3,0,800024c2 <_Core1_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
8000249a:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
8000249c:	5f 03 04 80 	jne %d3,%d0,800024a4 <_Core1_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800024a0:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
800024a4:	c2 13       	add %d3,1
800024a6:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
800024a8:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
800024ac:	5f 36 0f 00 	jeq %d6,%d3,800024ca <_Core1_start+0x254>
        nxtCsa += 16U;           /* next CSA */
800024b0:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800024b2:	37 02 70 43 	extr.u %d4,%d2,6,16
800024b6:	8f 42 1f 50 	sh %d5,%d2,-12
800024ba:	26 75       	and %d5,%d7
800024bc:	a6 54       	or %d4,%d5
        if (k == 0U)
800024be:	df 03 ee ff 	jne %d3,0,8000249a <_Core1_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
800024c2:	cd 84 e3 0f 	mtcr $fcx,%d4
800024c6:	1d ff eb ff 	j 8000249c <_Core1_start+0x226>
800024ca:	1b f6 ff 2f 	addi %d2,%d6,-1
800024ce:	06 62       	sh %d2,6
800024d0:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
800024d4:	82 02       	mov %d2,0
800024d6:	74 22       	st.w [%a2],%d2

    IfxCpu_initCSA((uint32 *)__CSA(1), (uint32 *)__CSA_END(1));

    /*Call main function of Cpu0 */
    __non_return_call(core1_main);
800024d8:	91 00 00 28 	movh.a %a2,32768
800024dc:	d9 22 4e c3 	lea %a2,[%a2]14094 <8000370e <core1_main>>
800024e0:	dc 02       	ji %a2
}
800024e2:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800024e4:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800024e6:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800024ea:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800024ee:	0f 35 a0 20 	or %d2,%d5,%d3
800024f2:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800024f6:	74 22       	st.w [%a2],%d2
800024f8:	1d ff 2b ff 	j 8000234e <_Core1_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800024fc:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800024fe:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002502:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002506:	0f 35 a0 20 	or %d2,%d5,%d3
8000250a:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000250e:	74 22       	st.w [%a2],%d2
80002510:	1d ff e7 fe 	j 800022de <_Core1_start+0x68>

80002514 <_Core2_start>:
    password  = watchdog->CON0.B.PW;
80002514:	91 30 00 2f 	movh.a %a2,61443
80002518:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000251c:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002520:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[2]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(2);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(2));
80002524:	91 20 00 25 	movh.a %a2,20482
80002528:	8f f2 83 41 	xor %d4,%d2,63
8000252c:	80 22       	mov.d %d2,%a2
8000252e:	1b 02 60 2b 	addi %d2,%d2,-18944
80002532:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
80002534:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART2_PSW_DEFAULT);    /* 0x00000980 */
80002538:	3b 00 98 20 	mov %d2,2432
8000253c:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
80002540:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART2_PCX_O_S_DEFAULT; /*0xfff00000; */
80002544:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
80002548:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
8000254c:	82 12       	mov %d2,1
8000254e:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
80002552:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002556:	7b 30 00 3f 	movh %d3,61443
8000255a:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000255e:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002562:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002566:	60 22       	mov.a %a2,%d2
80002568:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000256a:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000256c:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80002570:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80002574:	6f 13 13 81 	jnz.t %d3,1,8000279a <_Core2_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002578:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000257c:	54 22       	ld.w %d2,[%a2]
8000257e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002582:	a6 32       	or %d2,%d3
80002584:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002588:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000258a:	54 22       	ld.w %d2,[%a2]
8000258c:	6f 02 ff ff 	jnz.t %d2,0,8000258a <_Core2_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
80002590:	82 02       	mov %d2,0
80002592:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
80002596:	54 22       	ld.w %d2,[%a2]
80002598:	6f 12 09 00 	jz.t %d2,1,800025aa <_Core2_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000259c:	54 22       	ld.w %d2,[%a2]
8000259e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800025a2:	a6 32       	or %d2,%d3
800025a4:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800025a8:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800025aa:	54 22       	ld.w %d2,[%a2]
800025ac:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800025b0:	a6 32       	or %d2,%d3
800025b2:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800025b6:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
800025b8:	54 22       	ld.w %d2,[%a2]
800025ba:	6f 02 ff 7f 	jz.t %d2,0,800025b8 <_Core2_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
800025be:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
800025c2:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800025c6:	7b 30 00 3f 	movh %d3,61443
800025ca:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800025ce:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800025d2:	13 c2 20 23 	madd %d2,%d3,%d2,12
800025d6:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
800025d8:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
800025da:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
800025dc:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
800025e0:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800025e4:	6f 13 cf 80 	jnz.t %d3,1,80002782 <_Core2_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800025e8:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800025ec:	54 22       	ld.w %d2,[%a2]
800025ee:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800025f2:	a6 32       	or %d2,%d3
800025f4:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800025f8:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800025fa:	54 22       	ld.w %d2,[%a2]
800025fc:	6f 02 ff ff 	jnz.t %d2,0,800025fa <_Core2_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
80002600:	82 02       	mov %d2,0
80002602:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80002606:	54 22       	ld.w %d2,[%a2]
80002608:	6f 12 09 00 	jz.t %d2,1,8000261a <_Core2_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000260c:	54 22       	ld.w %d2,[%a2]
8000260e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002612:	a6 32       	or %d2,%d3
80002614:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002618:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000261a:	54 22       	ld.w %d2,[%a2]
8000261c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002620:	a6 32       	or %d2,%d3
80002622:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002626:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002628:	54 22       	ld.w %d2,[%a2]
8000262a:	6f 02 ff 7f 	jz.t %d2,0,80002628 <_Core2_start+0x114>
8000262e:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
80002632:	91 30 00 2f 	movh.a %a2,61443
80002636:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000263a:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000263e:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
80002640:	6f 12 09 00 	jz.t %d2,1,80002652 <_Core2_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002644:	54 22       	ld.w %d2,[%a2]
80002646:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000264a:	a6 42       	or %d2,%d4
8000264c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002650:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002652:	91 30 00 2f 	movh.a %a2,61443
80002656:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000265a:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000265e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002662:	a6 42       	or %d2,%d4
80002664:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002668:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000266a:	54 22       	ld.w %d2,[%a2]
8000266c:	6f 02 ff ff 	jnz.t %d2,0,8000266a <_Core2_start+0x156>

    /* Clear the ENDINIT bit in the Password register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(2));
80002670:	91 f0 01 38 	movh.a %a3,32799
80002674:	80 32       	mov.d %d2,%a3
80002676:	1b 02 10 26 	addi %d2,%d2,24832
8000267a:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(2));
8000267e:	91 f0 01 38 	movh.a %a3,32799
80002682:	80 32       	mov.d %d2,%a3
80002684:	1b 02 00 24 	addi %d2,%d2,16384
80002688:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(2));
8000268c:	91 20 00 35 	movh.a %a3,20482
80002690:	80 32       	mov.d %d2,%a3
80002692:	1b 02 b0 2b 	addi %d2,%d2,-17664
80002696:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
8000269a:	54 22       	ld.w %d2,[%a2]
8000269c:	6f 12 09 00 	jz.t %d2,1,800026ae <_Core2_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800026a0:	54 22       	ld.w %d2,[%a2]
800026a2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800026a6:	a6 42       	or %d2,%d4
800026a8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800026ac:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800026ae:	91 30 00 2f 	movh.a %a2,61443
800026b2:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
800026b6:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
800026ba:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800026be:	a6 42       	or %d2,%d4
800026c0:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800026c4:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
800026c6:	54 22       	ld.w %d2,[%a2]
800026c8:	6f 02 ff 7f 	jz.t %d2,0,800026c6 <_Core2_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(2));
800026cc:	91 10 00 26 	movh.a %a2,24577
800026d0:	80 22       	mov.d %d2,%a2
800026d2:	1b 02 00 28 	addi %d2,%d2,-32768
800026d6:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(2));
800026d8:	91 10 00 28 	movh.a %a2,32769
800026dc:	80 22       	mov.d %d2,%a2
800026de:	1b 02 00 28 	addi %d2,%d2,-32768
800026e2:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialized */
    __setareg(a8, __SDATA3(2));
800026e4:	91 10 00 28 	movh.a %a2,32769
800026e8:	80 22       	mov.d %d2,%a2
800026ea:	1b 02 00 28 	addi %d2,%d2,-32768
800026ee:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(2));
800026f0:	91 10 00 29 	movh.a %a2,36865
800026f4:	80 22       	mov.d %d2,%a2
800026f6:	1b 02 00 28 	addi %d2,%d2,-32768
800026fa:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
800026fc:	91 20 00 35 	movh.a %a3,20482
80002700:	91 20 00 25 	movh.a %a2,20482
80002704:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <5001bc00 <__CSA2>>
80002708:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <5001dc00 <__CSA2_END>>
8000270c:	01 32 20 20 	sub.a %a2,%a2,%a3
80002710:	80 22       	mov.d %d2,%a2
80002712:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
80002716:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
80002718:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
8000271c:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
8000271e:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002720:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80002724:	df 06 27 00 	jeq %d6,0,80002772 <_Core2_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002728:	37 02 70 43 	extr.u %d4,%d2,6,16
8000272c:	8f 42 1f 50 	sh %d5,%d2,-12
80002730:	26 75       	and %d5,%d7
80002732:	a6 54       	or %d4,%d5
        if (k == 0U)
80002734:	df 03 16 00 	jeq %d3,0,80002760 <_Core2_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
80002738:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
8000273a:	5f 03 04 80 	jne %d3,%d0,80002742 <_Core2_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8000273e:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80002742:	c2 13       	add %d3,1
80002744:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
80002746:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
8000274a:	5f 36 0f 00 	jeq %d6,%d3,80002768 <_Core2_start+0x254>
        nxtCsa += 16U;           /* next CSA */
8000274e:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002750:	37 02 70 43 	extr.u %d4,%d2,6,16
80002754:	8f 42 1f 50 	sh %d5,%d2,-12
80002758:	26 75       	and %d5,%d7
8000275a:	a6 54       	or %d4,%d5
        if (k == 0U)
8000275c:	df 03 ee ff 	jne %d3,0,80002738 <_Core2_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80002760:	cd 84 e3 0f 	mtcr $fcx,%d4
80002764:	1d ff eb ff 	j 8000273a <_Core2_start+0x226>
80002768:	1b f6 ff 2f 	addi %d2,%d6,-1
8000276c:	06 62       	sh %d2,6
8000276e:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
80002772:	82 02       	mov %d2,0
80002774:	74 22       	st.w [%a2],%d2
    /* Setup the context save area linked list. */

    IfxCpu_initCSA((uint32 *)__CSA(2), (uint32 *)__CSA_END(2));

    /*Call main function of Cpu0 */
    __non_return_call(core2_main);
80002776:	91 00 00 28 	movh.a %a2,32768
8000277a:	d9 22 5a d3 	lea %a2,[%a2]14170 <8000375a <core2_main>>
8000277e:	dc 02       	ji %a2
}
80002780:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002782:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002784:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002788:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000278c:	0f 35 a0 20 	or %d2,%d5,%d3
80002790:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002794:	74 22       	st.w [%a2],%d2
80002796:	1d ff 2b ff 	j 800025ec <_Core2_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000279a:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000279c:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800027a0:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800027a4:	0f 35 a0 20 	or %d2,%d5,%d3
800027a8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800027ac:	74 22       	st.w [%a2],%d2
800027ae:	1d ff e7 fe 	j 8000257c <_Core2_start+0x68>

800027b2 <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
800027b2:	40 ae       	mov.aa %a14,%sp
800027b4:	40 4c       	mov.aa %a12,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
800027b6:	6d ff 01 f9 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
800027ba:	02 28       	mov %d8,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
800027bc:	02 24       	mov %d4,%d2
800027be:	6d ff 94 f7 	call 800016e6 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
800027c2:	54 c3       	ld.w %d3,[%a12]
800027c4:	8f 13 c0 31 	andn %d3,%d3,1
800027c8:	74 c3       	st.w [%a12],%d3
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
800027ca:	02 84       	mov %d4,%d8
800027cc:	6d ff 13 f9 	call 800019f2 <IfxScuWdt_setCpuEndinit>
}
800027d0:	00 90       	ret 

800027d2 <IfxAsclin_enableModule_end>:
	...

800027d4 <IfxAsclin_getFaFrequency>:
    return module;
}


float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
800027d4:	40 ae       	mov.aa %a14,%sp
    return asclin->CSR.B.CLKSEL;
800027d6:	19 42 0c 10 	ld.w %d2,[%a4]76
800027da:	8f f2 01 21 	and %d2,%d2,31
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
800027de:	1b f2 ff 3f 	addi %d3,%d2,-1
800027e2:	8b 03 a1 22 	ge.u %d2,%d3,16
800027e6:	df 02 38 80 	jne %d2,0,80002856 <IfxAsclin_getFaFrequency+0x82>
800027ea:	91 00 00 28 	movh.a %a2,32768
800027ee:	d9 22 78 f2 	lea %a2,[%a2]10232 <800027f8 <IfxAsclin_getFaFrequency+0x24>>
800027f2:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
800027f6:	dc 02       	ji %a2
800027f8:	1d 00 20 00 	j 80002838 <IfxAsclin_getFaFrequency+0x64>
800027fc:	1d 00 21 00 	j 8000283e <IfxAsclin_getFaFrequency+0x6a>
80002800:	1d 00 2b 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002804:	1d 00 20 00 	j 80002844 <IfxAsclin_getFaFrequency+0x70>
80002808:	1d 00 27 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
8000280c:	1d 00 25 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002810:	1d 00 23 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002814:	1d 00 1b 00 	j 8000284a <IfxAsclin_getFaFrequency+0x76>
80002818:	1d 00 1f 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
8000281c:	1d 00 1d 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002820:	1d 00 1b 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002824:	1d 00 19 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002828:	1d 00 17 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
8000282c:	1d 00 15 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002830:	1d 00 13 00 	j 80002856 <IfxAsclin_getFaFrequency+0x82>
80002834:	1d 00 0e 00 	j 80002850 <IfxAsclin_getFaFrequency+0x7c>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0f;
        break;
    case IfxAsclin_ClockSource_kernelClock:
        frequency = IfxScuCcu_getSpbFrequency();
80002838:	6d ff 6e f5 	call 80001314 <IfxScuCcu_getSpbFrequency>
        break;
8000283c:	00 90       	ret 
    case IfxAsclin_ClockSource_oscillatorClock:
        frequency = IfxScuCcu_getOsc0Frequency();
8000283e:	6d ff f4 f3 	call 80001026 <IfxScuCcu_getOsc0Frequency>
        break;
80002842:	00 90       	ret 
    case IfxAsclin_ClockSource_flexRayClock:
        frequency = IfxScuCcu_getPllErayFrequency();
80002844:	6d ff 16 f4 	call 80001070 <IfxScuCcu_getPllErayFrequency>
        break;
80002848:	00 90       	ret 
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getBaud2Frequency();
8000284a:	6d ff 4d f5 	call 800012e4 <IfxScuCcu_getBaud2Frequency>
        break;
8000284e:	00 90       	ret 
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getBaud1Frequency();
80002850:	6d ff 32 f5 	call 800012b4 <IfxScuCcu_getBaud1Frequency>
        break;
80002854:	00 90       	ret 
    switch (clockSource)
80002856:	82 02       	mov %d2,0
        frequency = 0.0f;
        break;
    }

    return frequency;
}
80002858:	00 90       	ret 

8000285a <IfxAsclin_getFaFrequency_end>:
	...

8000285c <IfxAsclin_getIndex>:


IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
8000285c:	40 ae       	mov.aa %a14,%sp
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
8000285e:	82 02       	mov %d2,0
80002860:	ff 42 1b 80 	jge.u %d2,4,80002896 <IfxAsclin_getIndex+0x3a>
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80002864:	8f 32 00 30 	sh %d3,%d2,3
80002868:	91 00 00 28 	movh.a %a2,32768
8000286c:	d9 22 34 80 	lea %a2,[%a2]564 <80000234 <IfxAsclin_cfg_indexMap>>
80002870:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80002874:	54 23       	ld.w %d3,[%a2]
80002876:	80 44       	mov.d %d4,%a4
80002878:	5f 43 05 00 	jeq %d3,%d4,80002882 <IfxAsclin_getIndex+0x26>
    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
8000287c:	c2 12       	add %d2,1
8000287e:	1d ff f1 ff 	j 80002860 <IfxAsclin_getIndex+0x4>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
80002882:	06 32       	sh %d2,3
80002884:	91 00 00 28 	movh.a %a2,32768
80002888:	d9 22 34 80 	lea %a2,[%a2]564 <80000234 <IfxAsclin_cfg_indexMap>>
8000288c:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80002890:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80002894:	00 90       	ret 
    result = IfxAsclin_Index_none;
80002896:	82 f2       	mov %d2,-1
        }
    }

    return result;
}
80002898:	00 90       	ret 

8000289a <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
8000289a:	40 ae       	mov.aa %a14,%sp
8000289c:	40 4c       	mov.aa %a12,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
8000289e:	6d ff 9b ff 	call 800027d4 <IfxAsclin_getFaFrequency>
800028a2:	19 c3 14 00 	ld.w %d3,[%a12]20
800028a6:	b7 03 14 36 	insert %d3,%d3,0,12,20
800028aa:	c2 13       	add %d3,1
800028ac:	4b 03 41 31 	itof %d3,%d3
}
800028b0:	4b 32 51 20 	div.f %d2,%d2,%d3
800028b4:	00 90       	ret 

800028b6 <IfxAsclin_getSrcPointerEr>:
    return IfxAsclin_getOvsFrequency(asclin) / (asclin->BITCON.B.OVERSAMPLING + 1);
}


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
800028b6:	40 ae       	mov.aa %a14,%sp
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
800028b8:	6d ff d2 ff 	call 8000285c <IfxAsclin_getIndex>
800028bc:	53 c2 20 20 	mul %d2,%d2,12
800028c0:	1b 82 00 20 	addi %d2,%d2,8
}
800028c4:	91 40 00 2f 	movh.a %a2,61444
800028c8:	d9 22 00 28 	lea %a2,[%a2]-32640 <f0038080 <_SMALL_DATA4_+0x60030080>>
800028cc:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800028d0:	00 90       	ret 

800028d2 <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
800028d2:	40 ae       	mov.aa %a14,%sp
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
800028d4:	6d ff c4 ff 	call 8000285c <IfxAsclin_getIndex>
800028d8:	53 c2 20 20 	mul %d2,%d2,12
800028dc:	c2 42       	add %d2,4
}
800028de:	91 40 00 2f 	movh.a %a2,61444
800028e2:	d9 22 00 28 	lea %a2,[%a2]-32640 <f0038080 <_SMALL_DATA4_+0x60030080>>
800028e6:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800028ea:	00 90       	ret 

800028ec <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
800028ec:	40 ae       	mov.aa %a14,%sp
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
800028ee:	6d ff b7 ff 	call 8000285c <IfxAsclin_getIndex>
}
800028f2:	91 40 00 2f 	movh.a %a2,61444
800028f6:	d9 22 00 28 	lea %a2,[%a2]-32640 <f0038080 <_SMALL_DATA4_+0x60030080>>
800028fa:	01 22 03 26 	addsc.a %a2,%a2,%d2,3
800028fe:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80002902:	00 90       	ret 

80002904 <IfxAsclin_read8>:
    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80002904:	40 ae       	mov.aa %a14,%sp
80002906:	80 55       	mov.d %d5,%a5
80002908:	02 42       	mov %d2,%d4
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
8000290a:	1d 00 08 00 	j 8000291a <IfxAsclin_read8+0x16>
    {
        *data++ = (uint8)rxData->U;
8000290e:	19 43 08 10 	ld.w %d3,[%a4]72
80002912:	60 55       	mov.a %a5,%d5
80002914:	24 53       	st.b [%a5+],%d3
        count--;
80002916:	c2 f2       	add %d2,-1
        *data++ = (uint8)rxData->U;
80002918:	80 55       	mov.d %d5,%a5
    while (count > 0)
8000291a:	df 02 fa ff 	jne %d2,0,8000290e <IfxAsclin_read8+0xa>
    }

    return count;
}
8000291e:	00 90       	ret 

80002920 <IfxAsclin_setClockSource>:
    return TRUE;
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
80002920:	40 ae       	mov.aa %a14,%sp
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80002922:	d9 42 0c 10 	lea %a2,[%a4]76
80002926:	19 42 0c 10 	ld.w %d2,[%a4]76
8000292a:	37 42 05 20 	insert %d2,%d2,%d4,0,5
8000292e:	74 22       	st.w [%a2],%d2

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
80002930:	df 04 07 80 	jne %d4,0,8000293e <IfxAsclin_setClockSource+0x1e>
    return asclin->CSR.B.CON;
80002934:	19 42 0c 10 	ld.w %d2,[%a4]76
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80002938:	bf 02 fe 7f 	jlt %d2,0,80002934 <IfxAsclin_setClockSource+0x14>
8000293c:	00 90       	ret 
8000293e:	19 42 0c 10 	ld.w %d2,[%a4]76
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
80002942:	ff 02 fe 7f 	jge %d2,0,8000293e <IfxAsclin_setClockSource+0x1e>
        {}
    }
}
80002946:	00 90       	ret 

80002948 <IfxAsclin_setBitTiming>:
{
80002948:	40 ae       	mov.aa %a14,%sp
8000294a:	20 10       	sub.a %sp,16
8000294c:	40 4c       	mov.aa %a12,%a4
8000294e:	02 48       	mov %d8,%d4
80002950:	02 5a       	mov %d10,%d5
80002952:	02 69       	mov %d9,%d6
80002954:	59 e7 f4 ff 	st.w [%a14]-12,%d7
    return asclin->CSR.B.CLKSEL;
80002958:	19 42 0c 10 	ld.w %d2,[%a4]76
8000295c:	8f f2 01 21 	and %d2,%d2,31
80002960:	60 2f       	mov.a %a15,%d2
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80002962:	6d ff 9c ff 	call 8000289a <IfxAsclin_getPdFrequency>
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80002966:	c2 1a       	add %d10,1
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80002968:	82 43       	mov %d3,4
8000296a:	0b 3a b0 31 	max.u %d3,%d10,%d3
8000296e:	60 3d       	mov.a %a13,%d3
80002970:	82 13       	mov %d3,1
80002972:	0b 39 b0 31 	max.u %d3,%d9,%d3
80002976:	59 e3 f8 ff 	st.w [%a14]-8,%d3
    fOvs         = baudrate * oversampling;
8000297a:	80 d3       	mov.d %d3,%a13
8000297c:	4b 03 61 41 	utof %d4,%d3
80002980:	4b 84 41 40 	mul.f %d4,%d4,%d8
    float32               limit      = 0.001f * fOvs;                    // save the error limit
80002984:	7b 30 a8 e3 	movh %d14,14979
80002988:	1b fe 26 e1 	addi %d14,%d14,4719
8000298c:	4b e4 41 e0 	mul.f %d14,%d4,%d14
    d = (uint32)(fpd / fOvs);
80002990:	4b 42 51 c0 	div.f %d12,%d2,%d4
80002994:	4b 0c 71 c1 	ftouz %d12,%d12
    f              = (fpd * n) / d;
80002998:	4b 0c 61 31 	utof %d3,%d12
8000299c:	4b 32 51 30 	div.f %d3,%d2,%d3
    relError       = __absf(fOvs - f);
800029a0:	6b 03 31 14 	sub.f %d1,%d4,%d3
800029a4:	82 03       	mov %d3,0
800029a6:	4b 31 01 30 	cmp.f %d3,%d1,%d3
800029aa:	6f 03 10 80 	jnz.t %d3,0,800029ca <IfxAsclin_setBitTiming+0x82>
    if (relError <= limit)
800029ae:	4b e1 01 30 	cmp.f %d3,%d1,%d14
800029b2:	87 33 a0 30 	or.t %d3,%d3,0,%d3,1
800029b6:	df 03 0e 80 	jne %d3,0,800029d2 <IfxAsclin_setBitTiming+0x8a>
    boolean               terminated = FALSE;
800029ba:	82 0f       	mov %d15,0
    dBest          = d;
800029bc:	59 ec fc ff 	st.w [%a14]-4,%d12
    adder_facL_min = 0;
800029c0:	82 06       	mov %d6,0
    nBest          = n;
800029c2:	82 1d       	mov %d13,1
    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
800029c4:	82 20       	mov %d0,2
800029c6:	1d 00 37 00 	j 80002a34 <IfxAsclin_setBitTiming+0xec>
    relError       = __absf(fOvs - f);
800029ca:	9b 01 00 18 	addih %d1,%d1,32768
800029ce:	1d ff f0 ff 	j 800029ae <IfxAsclin_setBitTiming+0x66>
        terminated = TRUE;
800029d2:	82 1f       	mov %d15,1
800029d4:	1d ff f4 ff 	j 800029bc <IfxAsclin_setBitTiming+0x74>
            adder_facH = 1;
800029d8:	82 19       	mov %d9,1
            adder_facL = 1;
800029da:	02 95       	mov %d5,%d9
        for (count = adder_facL; count <= adder_facH; count++)
800029dc:	1d 00 07 00 	j 800029ea <IfxAsclin_setBitTiming+0xa2>
            newRelError = __absf(fOvs - f);
800029e0:	9b 03 00 38 	addih %d3,%d3,32768
800029e4:	1d 00 16 00 	j 80002a10 <IfxAsclin_setBitTiming+0xc8>
        for (count = adder_facL; count <= adder_facH; count++)
800029e8:	c2 15       	add %d5,1
800029ea:	3f 59 1e 80 	jlt.u %d9,%d5,80002a26 <IfxAsclin_setBitTiming+0xde>
            f           = (fpd * n) / (n * d + count);
800029ee:	4b 00 61 81 	utof %d8,%d0
800029f2:	4b 28 41 80 	mul.f %d8,%d8,%d2
800029f6:	0b 5b 00 a0 	add %d10,%d11,%d5
800029fa:	4b 0a 61 31 	utof %d3,%d10
800029fe:	4b 38 51 30 	div.f %d3,%d8,%d3
            newRelError = __absf(fOvs - f);
80002a02:	6b 03 31 34 	sub.f %d3,%d4,%d3
80002a06:	82 08       	mov %d8,0
80002a08:	4b 83 01 80 	cmp.f %d8,%d3,%d8
80002a0c:	6f 08 ea ff 	jnz.t %d8,0,800029e0 <IfxAsclin_setBitTiming+0x98>
            if (relError > (newRelError))
80002a10:	4b 31 01 80 	cmp.f %d8,%d1,%d3
80002a14:	6f 28 ea 7f 	jz.t %d8,2,800029e8 <IfxAsclin_setBitTiming+0xa0>
                adder_facL_min = count;
80002a18:	02 56       	mov %d6,%d5
                relError       = newRelError;
80002a1a:	02 31       	mov %d1,%d3
                nBest          = n;
80002a1c:	02 0d       	mov %d13,%d0
                dBest          = (n * d + count);
80002a1e:	59 ea fc ff 	st.w [%a14]-4,%d10
80002a22:	1d ff e3 ff 	j 800029e8 <IfxAsclin_setBitTiming+0xa0>
        if (relError <= limit)
80002a26:	4b e1 01 30 	cmp.f %d3,%d1,%d14
80002a2a:	87 33 a0 30 	or.t %d3,%d3,0,%d3,1
80002a2e:	df 03 16 80 	jne %d3,0,80002a5a <IfxAsclin_setBitTiming+0x112>
    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80002a32:	c2 10       	add %d0,1
80002a34:	df 0f 13 80 	jne %d15,0,80002a5a <IfxAsclin_setBitTiming+0x112>
80002a38:	73 c0 0a b0 	mul %d11,%d0,%d12
80002a3c:	3b 00 00 31 	mov %d3,4096
80002a40:	7f 3b 0d 80 	jge.u %d11,%d3,80002a5a <IfxAsclin_setBitTiming+0x112>
        if (n == 2)
80002a44:	df 20 ca 7f 	jeq %d0,2,800029d8 <IfxAsclin_setBitTiming+0x90>
            adder_facL = (adder_facL_min * n) / nBest;
80002a48:	73 60 0a 80 	mul %d8,%d0,%d6
80002a4c:	4b d8 11 82 	div.u %e8,%d8,%d13
80002a50:	02 85       	mov %d5,%d8
            adder_facH = adder_facL + 1;
80002a52:	1b 18 00 90 	addi %d9,%d8,1
80002a56:	1d ff ca ff 	j 800029ea <IfxAsclin_setBitTiming+0xa2>
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
80002a5a:	82 04       	mov %d4,0
80002a5c:	40 c4       	mov.aa %a4,%a12
80002a5e:	6d ff 61 ff 	call 80002920 <IfxAsclin_setClockSource>
    asclin->BRG.B.DENOMINATOR = dBest;
80002a62:	d9 c2 20 00 	lea %a2,[%a12]32
80002a66:	19 c2 20 00 	ld.w %d2,[%a12]32
80002a6a:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80002a6e:	37 32 0c 20 	insert %d2,%d2,%d3,0,12
80002a72:	74 22       	st.w [%a2],%d2
    asclin->BRG.B.NUMERATOR   = nBest;
80002a74:	54 22       	ld.w %d2,[%a2]
80002a76:	37 d2 0c 28 	insert %d2,%d2,%d13,16,12
80002a7a:	74 22       	st.w [%a2],%d2
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80002a7c:	80 d3       	mov.d %d3,%a13
80002a7e:	c2 f3       	add %d3,-1
80002a80:	d9 c2 14 00 	lea %a2,[%a12]20
80002a84:	19 c2 14 00 	ld.w %d2,[%a12]20
80002a88:	37 32 04 28 	insert %d2,%d2,%d3,16,4
80002a8c:	74 22       	st.w [%a2],%d2
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80002a8e:	54 22       	ld.w %d2,[%a2]
80002a90:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80002a94:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
80002a98:	74 22       	st.w [%a2],%d2
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80002a9a:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80002a9e:	8b 02 20 72 	ne %d7,%d2,0
80002aa2:	54 22       	ld.w %d2,[%a2]
80002aa4:	67 72 1f 20 	ins.t %d2,%d2,31,%d7,0
80002aa8:	74 22       	st.w [%a2],%d2
    IfxAsclin_setClockSource(asclin, source);
80002aaa:	80 f4       	mov.d %d4,%a15
80002aac:	40 c4       	mov.aa %a4,%a12
80002aae:	6d ff 39 ff 	call 80002920 <IfxAsclin_setClockSource>
}
80002ab2:	82 12       	mov %d2,1
80002ab4:	00 90       	ret 

80002ab6 <IfxAsclin_write8>:
    return count;
}


uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80002ab6:	40 ae       	mov.aa %a14,%sp
80002ab8:	80 53       	mov.d %d3,%a5
80002aba:	02 42       	mov %d2,%d4
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
80002abc:	1d 00 08 00 	j 80002acc <IfxAsclin_write8+0x16>
    {
        txData->U = *data++;
80002ac0:	60 35       	mov.a %a5,%d3
80002ac2:	04 53       	ld.bu %d3,[%a5+]
80002ac4:	59 43 04 10 	st.w [%a4]68,%d3
        count--;
80002ac8:	c2 f2       	add %d2,-1
        txData->U = *data++;
80002aca:	80 53       	mov.d %d3,%a5
    while ((count > 0))
80002acc:	df 02 fa ff 	jne %d2,0,80002ac0 <IfxAsclin_write8+0xa>
    }

    return count;
}
80002ad0:	00 90       	ret 

80002ad2 <IfxAsclin_Asc_read>:
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80002ad2:	40 ae       	mov.aa %a14,%sp
80002ad4:	40 6c       	mov.aa %a12,%a6
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
80002ad6:	0b 45 10 68 	mov %e6,%d5,%d4
80002ada:	94 64       	ld.h %d4,[%a6]
80002adc:	99 44 08 00 	ld.a %a4,[%a4]8
80002ae0:	6d ff c5 ef 	call 80000a6a <Ifx_Fifo_read>

    *count -= left;
80002ae4:	94 c3       	ld.h %d3,[%a12]
80002ae6:	a2 23       	sub %d3,%d2
80002ae8:	b4 c3       	st.h [%a12],%d3

    return left == 0;
}
80002aea:	8b 02 00 22 	eq %d2,%d2,0
80002aee:	00 90       	ret 

80002af0 <IfxAsclin_Asc_isrTransmit>:
{
80002af0:	40 ae       	mov.aa %a14,%sp
80002af2:	20 18       	sub.a %sp,24
80002af4:	40 4c       	mov.aa %a12,%a4
    reg.U = __mfcr(CPU_ICR);
80002af6:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80002afa:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80002afe:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
80002b02:	00 00       	nop 
    result  = stm->TIM0.U;
80002b04:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80002b08:	19 26 10 00 	ld.w %d6,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80002b0c:	19 22 2c 00 	ld.w %d2,[%a2]44
80002b10:	02 25       	mov %d5,%d2
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80002b12:	02 62       	mov %d2,%d6
80002b14:	b7 05 81 3f 	insert %d3,%d5,0,31,1
    if (enabled != FALSE)
80002b18:	df 04 04 00 	jeq %d4,0,80002b20 <IfxAsclin_Asc_isrTransmit+0x30>
        __enable();
80002b1c:	0d 00 00 03 	enable 
    asclin->txTimestamp = IfxStm_now();
80002b20:	89 c2 58 09 	st.d [%a12]24,%e2
    asclin->sendCount++;
80002b24:	d9 c2 14 00 	lea %a2,[%a12]20
80002b28:	19 c2 14 00 	ld.w %d2,[%a12]20
80002b2c:	c2 12       	add %d2,1
80002b2e:	74 22       	st.w [%a2],%d2
    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
80002b30:	99 c4 04 00 	ld.a %a4,[%a12]4
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80002b34:	c9 48 04 00 	ld.h %d8,[%a4]4
80002b38:	df 08 3e 00 	jeq %d8,0,80002bb4 <IfxAsclin_Asc_isrTransmit+0xc4>
        switch (asclin->dataBufferMode)
80002b3c:	19 c2 10 00 	ld.w %d2,[%a12]16
80002b40:	df 02 05 00 	jeq %d2,0,80002b4a <IfxAsclin_Asc_isrTransmit+0x5a>
80002b44:	df 12 26 00 	jeq %d2,1,80002b90 <IfxAsclin_Asc_isrTransmit+0xa0>
80002b48:	00 90       	ret 
            volatile uint8 hw_tx_fill_level = 0;
80002b4a:	82 02       	mov %d2,0
80002b4c:	e9 e2 ef ff 	st.b [%a14]-17,%d2
            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
80002b50:	37 08 70 80 	extr.u %d8,%d8,0,16
            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
80002b54:	d4 c2       	ld.a %a2,[%a12]
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
80002b56:	19 22 0c 00 	ld.w %d2,[%a2]12
80002b5a:	37 02 65 28 	extr.u %d2,%d2,16,5
80002b5e:	e9 e2 ef ff 	st.b [%a14]-17,%d2
            i_count          = (16 - hw_tx_fill_level);
80002b62:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
80002b66:	8b 02 01 21 	rsub %d2,%d2,16
80002b6a:	37 02 70 20 	extr.u %d2,%d2,0,16
            if (i_count > count)
80002b6e:	3f 28 03 80 	jlt.u %d8,%d2,80002b74 <IfxAsclin_Asc_isrTransmit+0x84>
            i_count          = (16 - hw_tx_fill_level);
80002b72:	02 28       	mov %d8,%d2
            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
80002b74:	d2 06       	mov %e6,0
80002b76:	37 08 50 40 	extr %d4,%d8,0,16
80002b7a:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80002b7e:	6d ff 76 ef 	call 80000a6a <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
80002b82:	02 84       	mov %d4,%d8
80002b84:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80002b88:	d4 c4       	ld.a %a4,[%a12]
80002b8a:	6d ff 96 ff 	call 80002ab6 <IfxAsclin_write8>
        break;
80002b8e:	00 90       	ret 
            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
80002b90:	d2 06       	mov %e6,0
80002b92:	3b c0 00 40 	mov %d4,12
80002b96:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80002b9a:	6d ff 68 ef 	call 80000a6a <Ifx_Fifo_read>
            ascData = packedData.data;
80002b9e:	39 e2 f8 ff 	ld.bu %d2,[%a14]-8
80002ba2:	e9 e2 ef ff 	st.b [%a14]-17,%d2
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
80002ba6:	82 14       	mov %d4,1
80002ba8:	d9 e5 ef ff 	lea %a5,[%a14]-17
80002bac:	d4 c4       	ld.a %a4,[%a12]
80002bae:	6d ff 84 ff 	call 80002ab6 <IfxAsclin_write8>
        break;
80002bb2:	00 90       	ret 
        asclin->txInProgress = FALSE;
80002bb4:	82 02       	mov %d2,0
80002bb6:	e9 c2 0c 00 	st.b [%a12]12,%d2
}
80002bba:	00 90       	ret 

80002bbc <IfxAsclin_Asc_isrReceive>:
{
80002bbc:	40 ae       	mov.aa %a14,%sp
80002bbe:	20 20       	sub.a %sp,32
80002bc0:	40 4c       	mov.aa %a12,%a4
    switch (asclin->dataBufferMode)
80002bc2:	19 42 10 00 	ld.w %d2,[%a4]16
80002bc6:	df 02 05 00 	jeq %d2,0,80002bd0 <IfxAsclin_Asc_isrReceive+0x14>
80002bca:	df 12 34 00 	jeq %d2,1,80002c32 <IfxAsclin_Asc_isrReceive+0x76>
80002bce:	00 90       	ret 
        count = IfxAsclin_getRxFifoFillLevel(asclin->asclin);
80002bd0:	d4 44       	ld.a %a4,[%a4]
    return asclin->RXFIFOCON.B.FILL;
80002bd2:	19 48 10 00 	ld.w %d8,[%a4]16
80002bd6:	37 08 65 88 	extr.u %d8,%d8,16,5
        IfxAsclin_read8(asclin->asclin, &ascData[0], count);
80002bda:	02 84       	mov %d4,%d8
80002bdc:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80002be0:	6d ff 92 fe 	call 80002904 <IfxAsclin_read8>
        if (Ifx_Fifo_write(asclin->rx, &ascData[0], count, TIME_NULL) != 0)
80002be4:	d2 06       	mov %e6,0
80002be6:	02 84       	mov %d4,%d8
80002be8:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80002bec:	99 c4 08 00 	ld.a %a4,[%a12]8
80002bf0:	6d ff f6 ef 	call 80000bdc <Ifx_Fifo_write>
80002bf4:	df 02 42 00 	jeq %d2,0,80002c78 <IfxAsclin_Asc_isrReceive+0xbc>
            asclin->rxSwFifoOverflow = TRUE;
80002bf8:	82 12       	mov %d2,1
80002bfa:	e9 c2 0d 00 	st.b [%a12]13,%d2
80002bfe:	00 90       	ret 
            packedData.timestamp = IfxStm_now();
80002c00:	59 e5 e4 ff 	st.w [%a14]-28,%d5
80002c04:	59 e2 e8 ff 	st.w [%a14]-24,%d2
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
80002c08:	82 14       	mov %d4,1
80002c0a:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80002c0e:	d4 c4       	ld.a %a4,[%a12]
80002c10:	6d ff 7a fe 	call 80002904 <IfxAsclin_read8>
            packedData.data      = ascData[0];
80002c14:	39 e2 f0 ff 	ld.bu %d2,[%a14]-16
80002c18:	e9 e2 ec ff 	st.b [%a14]-20,%d2
            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
80002c1c:	d2 06       	mov %e6,0
80002c1e:	3b c0 00 40 	mov %d4,12
80002c22:	d9 e5 e4 ff 	lea %a5,[%a14]-28
80002c26:	99 c4 08 00 	ld.a %a4,[%a12]8
80002c2a:	6d ff d9 ef 	call 80000bdc <Ifx_Fifo_write>
80002c2e:	df 02 20 80 	jne %d2,0,80002c6e <IfxAsclin_Asc_isrReceive+0xb2>
        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
80002c32:	d4 c2       	ld.a %a2,[%a12]
80002c34:	19 22 10 00 	ld.w %d2,[%a2]16
80002c38:	37 02 65 28 	extr.u %d2,%d2,16,5
80002c3c:	df 02 1e 00 	jeq %d2,0,80002c78 <IfxAsclin_Asc_isrReceive+0xbc>
    reg.U = __mfcr(CPU_ICR);
80002c40:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80002c44:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80002c48:	0d 00 40 03 	disable 
80002c4c:	00 00       	nop 
    result  = stm->TIM0.U;
80002c4e:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80002c52:	19 25 10 00 	ld.w %d5,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80002c56:	19 22 2c 00 	ld.w %d2,[%a2]44
80002c5a:	8f 05 40 51 	or %d5,%d5,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80002c5e:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80002c62:	df 04 cf 7f 	jeq %d4,0,80002c00 <IfxAsclin_Asc_isrReceive+0x44>
        __enable();
80002c66:	0d 00 00 03 	enable 
80002c6a:	1d ff cb ff 	j 80002c00 <IfxAsclin_Asc_isrReceive+0x44>
                asclin->rxSwFifoOverflow = TRUE;
80002c6e:	82 12       	mov %d2,1
80002c70:	e9 c2 0d 00 	st.b [%a12]13,%d2
80002c74:	1d ff df ff 	j 80002c32 <IfxAsclin_Asc_isrReceive+0x76>
}
80002c78:	00 90       	ret 

80002c7a <IfxAsclin_Asc_blockingRead>:
{
80002c7a:	40 ae       	mov.aa %a14,%sp
80002c7c:	20 08       	sub.a %sp,8
80002c7e:	80 48       	mov.d %d8,%a4
    Ifx_SizeT count = 1;
80002c80:	82 12       	mov %d2,1
80002c82:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    while (IfxAsclin_Asc_read(asclin, &data, &count, TIME_INFINITE) != TRUE)
80002c86:	82 f4       	mov %d4,-1
80002c88:	82 f5       	mov %d5,-1
80002c8a:	06 f5       	sh %d5,-1
80002c8c:	d9 e6 fe ff 	lea %a6,[%a14]-2
80002c90:	d9 e5 fd ff 	lea %a5,[%a14]-3
80002c94:	60 84       	mov.a %a4,%d8
80002c96:	6d ff 1e ff 	call 80002ad2 <IfxAsclin_Asc_read>
80002c9a:	df 12 f6 ff 	jne %d2,1,80002c86 <IfxAsclin_Asc_blockingRead+0xc>
}
80002c9e:	39 e2 fd ff 	ld.bu %d2,[%a14]-3
80002ca2:	00 90       	ret 

80002ca4 <IfxAsclin_Asc_initModule>:
{
80002ca4:	40 ae       	mov.aa %a14,%sp
80002ca6:	40 4f       	mov.aa %a15,%a4
80002ca8:	40 5d       	mov.aa %a13,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
80002caa:	d4 5c       	ld.a %a12,[%a5]
    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
80002cac:	f4 4c       	st.a [%a4],%a12
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
80002cae:	40 c4       	mov.aa %a4,%a12
80002cb0:	6d ff 81 fd 	call 800027b2 <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
80002cb4:	82 04       	mov %d4,0
80002cb6:	40 c4       	mov.aa %a4,%a12
80002cb8:	6d ff 34 fe 	call 80002920 <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80002cbc:	d9 c2 18 00 	lea %a2,[%a12]24
80002cc0:	19 c2 18 00 	ld.w %d2,[%a12]24
80002cc4:	b7 02 02 28 	insert %d2,%d2,0,16,2
80002cc8:	74 22       	st.w [%a2],%d2
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
80002cca:	b9 d3 08 00 	ld.hu %d3,[%a13]8
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80002cce:	c2 f3       	add %d3,-1
80002cd0:	d9 c2 14 00 	lea %a2,[%a12]20
80002cd4:	19 c2 14 00 	ld.w %d2,[%a12]20
80002cd8:	37 32 0c 20 	insert %d2,%d2,%d3,0,12
80002cdc:	74 22       	st.w [%a2],%d2
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
80002cde:	19 d4 18 10 	ld.w %d4,[%a13]88
80002ce2:	40 c4       	mov.aa %a4,%a12
80002ce4:	6d ff 1e fe 	call 80002920 <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
80002ce8:	19 d7 10 00 	ld.w %d7,[%a13]16
80002cec:	19 d6 14 00 	ld.w %d6,[%a13]20
80002cf0:	19 d5 0c 00 	ld.w %d5,[%a13]12
80002cf4:	19 d4 04 00 	ld.w %d4,[%a13]4
80002cf8:	40 c4       	mov.aa %a4,%a12
80002cfa:	6d ff 27 fe 	call 80002948 <IfxAsclin_setBitTiming>
80002cfe:	02 2a       	mov %d10,%d2
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
80002d00:	82 04       	mov %d4,0
80002d02:	40 c4       	mov.aa %a4,%a12
80002d04:	6d ff 0e fe 	call 80002920 <IfxAsclin_setClockSource>
    IfxAsclin_enableLoopBackMode(asclinSFR, config->loopBack);                       /* selecting the loopback mode */
80002d08:	39 d4 2c 10 	ld.bu %d4,[%a13]108
    asclin->IOCR.B.LB = enable ? 1 : 0;
80002d0c:	8b 04 20 42 	ne %d4,%d4,0
80002d10:	d9 c2 04 00 	lea %a2,[%a12]4
80002d14:	19 c3 04 00 	ld.w %d3,[%a12]4
80002d18:	67 43 1c 30 	ins.t %d3,%d3,28,%d4,0
80002d1c:	74 23       	st.w [%a2],%d3
    IfxAsclin_enableParity(asclinSFR, config->frame.parityBit);                      /* setting parity enable */
80002d1e:	39 d4 30 00 	ld.bu %d4,[%a13]48
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
80002d22:	8b 04 20 42 	ne %d4,%d4,0
80002d26:	d9 c2 18 00 	lea %a2,[%a12]24
80002d2a:	19 c3 18 00 	ld.w %d3,[%a12]24
80002d2e:	67 43 1e 30 	ins.t %d3,%d3,30,%d4,0
80002d32:	74 23       	st.w [%a2],%d3
    IfxAsclin_setParityType(asclinSFR, config->frame.parityType);                    /* setting parity type (odd/even)*/
80002d34:	19 d2 28 00 	ld.w %d2,[%a13]40
    asclin->FRAMECON.B.ODD = type;
80002d38:	d9 c2 18 00 	lea %a2,[%a12]24
80002d3c:	19 c3 18 00 	ld.w %d3,[%a12]24
80002d40:	67 23 1f 30 	ins.t %d3,%d3,31,%d2,0
80002d44:	74 23       	st.w [%a2],%d3
    IfxAsclin_setStopBit(asclinSFR, config->frame.stopBit);                          /* setting the stop bit */
80002d46:	19 d2 1c 00 	ld.w %d2,[%a13]28
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
80002d4a:	d9 c2 18 00 	lea %a2,[%a12]24
80002d4e:	19 c3 18 00 	ld.w %d3,[%a12]24
80002d52:	37 23 83 34 	insert %d3,%d3,%d2,9,3
80002d56:	74 23       	st.w [%a2],%d3
    IfxAsclin_setShiftDirection(asclinSFR, config->frame.shiftDir);                  /* setting the shift direction */
80002d58:	19 d2 24 00 	ld.w %d2,[%a13]36
    asclin->FRAMECON.B.MSB = dir;
80002d5c:	d9 c2 18 00 	lea %a2,[%a12]24
80002d60:	19 c3 18 00 	ld.w %d3,[%a12]24
80002d64:	67 23 1c 30 	ins.t %d3,%d3,28,%d2,0
80002d68:	74 23       	st.w [%a2],%d3
    IfxAsclin_setDataLength(asclinSFR, config->frame.dataLength);                    /* setting the data length */
80002d6a:	19 d2 2c 00 	ld.w %d2,[%a13]44
    asclin->DATCON.B.DATLEN = length;
80002d6e:	d9 c2 1c 00 	lea %a2,[%a12]28
80002d72:	19 c3 1c 00 	ld.w %d3,[%a12]28
80002d76:	37 23 04 30 	insert %d3,%d3,%d2,0,4
80002d7a:	74 23       	st.w [%a2],%d3
    IfxAsclin_setTxFifoInletWidth(asclinSFR, config->fifo.inWidth);                  /* setting Tx FIFO inlet width */
80002d7c:	19 d2 34 00 	ld.w %d2,[%a13]52
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
80002d80:	d9 c2 0c 00 	lea %a2,[%a12]12
80002d84:	19 c3 0c 00 	ld.w %d3,[%a12]12
80002d88:	37 23 02 33 	insert %d3,%d3,%d2,6,2
80002d8c:	74 23       	st.w [%a2],%d3
    IfxAsclin_setRxFifoOutletWidth(asclinSFR, config->fifo.outWidth);                /* setting Rx FIFO outlet width */
80002d8e:	19 d2 38 00 	ld.w %d2,[%a13]56
    asclin->RXFIFOCON.B.OUTW = width;
80002d92:	d9 c2 10 00 	lea %a2,[%a12]16
80002d96:	19 c3 10 00 	ld.w %d3,[%a12]16
80002d9a:	37 23 02 33 	insert %d3,%d3,%d2,6,2
80002d9e:	74 23       	st.w [%a2],%d3
    IfxAsclin_setIdleDelay(asclinSFR, config->frame.idleDelay);                      /* setting idle delay */
80002da0:	19 d2 18 00 	ld.w %d2,[%a13]24
    asclin->FRAMECON.B.IDLE = delay;
80002da4:	d9 c2 18 00 	lea %a2,[%a12]24
80002da8:	19 c3 18 00 	ld.w %d3,[%a12]24
80002dac:	37 23 03 33 	insert %d3,%d3,%d2,6,3
80002db0:	74 23       	st.w [%a2],%d3
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
80002db2:	19 d2 3c 00 	ld.w %d2,[%a13]60
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80002db6:	3b f0 00 40 	mov %d4,15
80002dba:	0b 42 90 21 	min.u %d2,%d2,%d4
}


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
80002dbe:	d9 c2 0c 00 	lea %a2,[%a12]12
80002dc2:	19 c3 0c 00 	ld.w %d3,[%a12]12
80002dc6:	37 23 04 34 	insert %d3,%d3,%d2,8,4
80002dca:	74 23       	st.w [%a2],%d3
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
80002dcc:	19 d2 00 10 	ld.w %d2,[%a13]64
80002dd0:	0b 42 90 41 	min.u %d4,%d2,%d4
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
80002dd4:	d9 c2 10 00 	lea %a2,[%a12]16
80002dd8:	19 c3 10 00 	ld.w %d3,[%a12]16
80002ddc:	37 43 04 34 	insert %d3,%d3,%d4,8,4
80002de0:	74 23       	st.w [%a2],%d3
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/
80002de2:	19 d2 20 00 	ld.w %d2,[%a13]32
    asclin->FRAMECON.B.MODE = mode;
80002de6:	d9 c2 18 00 	lea %a2,[%a12]24
80002dea:	19 c3 18 00 	ld.w %d3,[%a12]24
80002dee:	37 23 02 38 	insert %d3,%d3,%d2,16,2
80002df2:	74 23       	st.w [%a2],%d3
    const IfxAsclin_Asc_Pins *pins = config->pins;
80002df4:	19 d8 14 10 	ld.w %d8,[%a13]84
    if (pins != NULL_PTR)
80002df8:	df 08 8c 00 	jeq %d8,0,80002f10 <IfxAsclin_Asc_initModule+0x26c>
        IfxAsclin_Cts_In *cts = pins->cts;
80002dfc:	60 82       	mov.a %a2,%d8
80002dfe:	54 29       	ld.w %d9,[%a2]
        if (cts != NULL_PTR)
80002e00:	df 09 2c 00 	jeq %d9,0,80002e58 <IfxAsclin_Asc_initModule+0x1b4>
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
80002e04:	19 25 04 00 	ld.w %d5,[%a2]4
80002e08:	19 2b 20 00 	ld.w %d11,[%a2]32
    if (cts->pin.port != NULL_PTR)
80002e0c:	60 92       	mov.a %a2,%d9
80002e0e:	99 24 04 00 	ld.a %a4,[%a2]4
80002e12:	bd 04 23 00 	jz.a %a4,80002e58 <IfxAsclin_Asc_initModule+0x1b4>
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
80002e16:	39 24 08 00 	ld.bu %d4,[%a2]8
80002e1a:	6d ff 39 f6 	call 80001a8c <IfxPort_setPinMode>
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
80002e1e:	02 b5       	mov %d5,%d11
80002e20:	60 92       	mov.a %a2,%d9
80002e22:	39 24 08 00 	ld.bu %d4,[%a2]8
80002e26:	99 24 04 00 	ld.a %a4,[%a2]4
80002e2a:	6d ff 68 f6 	call 80001afa <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
80002e2e:	60 92       	mov.a %a2,%d9
80002e30:	d4 22       	ld.a %a2,[%a2]
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
80002e32:	d9 23 04 00 	lea %a3,[%a2]4
80002e36:	19 23 04 00 	ld.w %d3,[%a2]4
80002e3a:	b7 13 81 3e 	insert %d3,%d3,1,29,1
80002e3e:	74 33       	st.w [%a3],%d3
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
80002e40:	60 92       	mov.a %a2,%d9
80002e42:	d4 22       	ld.a %a2,[%a2]
80002e44:	60 93       	mov.a %a3,%d9
80002e46:	19 32 0c 00 	ld.w %d2,[%a3]12
    asclin->IOCR.B.CTS = ctsi;
80002e4a:	d9 23 04 00 	lea %a3,[%a2]4
80002e4e:	19 23 04 00 	ld.w %d3,[%a2]4
80002e52:	37 23 02 38 	insert %d3,%d3,%d2,16,2
80002e56:	74 33       	st.w [%a3],%d3
        IfxAsclin_Rx_In *rx = pins->rx;
80002e58:	60 82       	mov.a %a2,%d8
80002e5a:	19 29 08 00 	ld.w %d9,[%a2]8
        if (rx != NULL_PTR)
80002e5e:	df 09 23 00 	jeq %d9,0,80002ea4 <IfxAsclin_Asc_initModule+0x200>
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
80002e62:	19 25 0c 00 	ld.w %d5,[%a2]12
80002e66:	19 2b 20 00 	ld.w %d11,[%a2]32
    if (rx->pin.port != NULL_PTR)
80002e6a:	60 92       	mov.a %a2,%d9
80002e6c:	99 24 04 00 	ld.a %a4,[%a2]4
80002e70:	bd 04 1a 00 	jz.a %a4,80002ea4 <IfxAsclin_Asc_initModule+0x200>
80002e74:	39 24 08 00 	ld.bu %d4,[%a2]8
80002e78:	6d ff 0a f6 	call 80001a8c <IfxPort_setPinMode>
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
80002e7c:	02 b5       	mov %d5,%d11
80002e7e:	60 92       	mov.a %a2,%d9
80002e80:	39 24 08 00 	ld.bu %d4,[%a2]8
80002e84:	99 24 04 00 	ld.a %a4,[%a2]4
80002e88:	6d ff 39 f6 	call 80001afa <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
80002e8c:	60 92       	mov.a %a2,%d9
80002e8e:	d4 22       	ld.a %a2,[%a2]
80002e90:	60 93       	mov.a %a3,%d9
80002e92:	19 32 0c 00 	ld.w %d2,[%a3]12
    asclin->IOCR.B.ALTI = alti;
80002e96:	d9 23 04 00 	lea %a3,[%a2]4
80002e9a:	19 23 04 00 	ld.w %d3,[%a2]4
80002e9e:	37 23 03 30 	insert %d3,%d3,%d2,0,3
80002ea2:	74 33       	st.w [%a3],%d3
        IfxAsclin_Rts_Out *rts = pins->rts;
80002ea4:	60 82       	mov.a %a2,%d8
80002ea6:	19 29 10 00 	ld.w %d9,[%a2]16
        if (rts != NULL_PTR)
80002eaa:	df 09 18 00 	jeq %d9,0,80002eda <IfxAsclin_Asc_initModule+0x236>
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
80002eae:	19 25 14 00 	ld.w %d5,[%a2]20
80002eb2:	19 2b 20 00 	ld.w %d11,[%a2]32
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
80002eb6:	60 92       	mov.a %a2,%d9
80002eb8:	19 22 0c 00 	ld.w %d2,[%a2]12
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80002ebc:	a6 25       	or %d5,%d2
80002ebe:	39 24 08 00 	ld.bu %d4,[%a2]8
80002ec2:	99 24 04 00 	ld.a %a4,[%a2]4
80002ec6:	6d ff e3 f5 	call 80001a8c <IfxPort_setPinMode>
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
80002eca:	02 b5       	mov %d5,%d11
80002ecc:	60 92       	mov.a %a2,%d9
80002ece:	39 24 08 00 	ld.bu %d4,[%a2]8
80002ed2:	99 24 04 00 	ld.a %a4,[%a2]4
80002ed6:	6d ff 12 f6 	call 80001afa <IfxPort_setPinPadDriver>
        IfxAsclin_Tx_Out *tx = pins->tx;
80002eda:	60 82       	mov.a %a2,%d8
80002edc:	19 29 18 00 	ld.w %d9,[%a2]24
        if (tx != NULL_PTR)
80002ee0:	df 09 18 00 	jeq %d9,0,80002f10 <IfxAsclin_Asc_initModule+0x26c>
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
80002ee4:	19 22 1c 00 	ld.w %d2,[%a2]28
80002ee8:	19 28 20 00 	ld.w %d8,[%a2]32
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
80002eec:	60 92       	mov.a %a2,%d9
80002eee:	19 25 0c 00 	ld.w %d5,[%a2]12
80002ef2:	a6 25       	or %d5,%d2
80002ef4:	39 24 08 00 	ld.bu %d4,[%a2]8
80002ef8:	99 24 04 00 	ld.a %a4,[%a2]4
80002efc:	6d ff c8 f5 	call 80001a8c <IfxPort_setPinMode>
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
80002f00:	02 85       	mov %d5,%d8
80002f02:	60 92       	mov.a %a2,%d9
80002f04:	39 24 08 00 	ld.bu %d4,[%a2]8
80002f08:	99 24 04 00 	ld.a %a4,[%a2]4
80002f0c:	6d ff f7 f5 	call 80001afa <IfxPort_setPinPadDriver>
    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
80002f10:	19 d4 18 10 	ld.w %d4,[%a13]88
80002f14:	40 c4       	mov.aa %a4,%a12
80002f16:	6d ff 05 fd 	call 80002920 <IfxAsclin_setClockSource>
    asclin->FLAGSENABLE.U = 0x00000000;
80002f1a:	82 03       	mov %d3,0
80002f1c:	59 c3 00 10 	st.w [%a12]64,%d3
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
80002f20:	82 f2       	mov %d2,-1
80002f22:	59 c2 3c 00 	st.w [%a12]60,%d2
    asclin->errorFlags.ALL = 0;
80002f26:	28 e3       	st.b [%a15]14,%d3
    if (config->errorFlags.flags.parityError)
80002f28:	39 d3 1c 10 	ld.bu %d3,[%a13]92
80002f2c:	6f 03 09 00 	jz.t %d3,0,80002f3e <IfxAsclin_Asc_initModule+0x29a>
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
80002f30:	d9 c2 00 10 	lea %a2,[%a12]64
80002f34:	19 c3 00 10 	ld.w %d3,[%a12]64
80002f38:	b7 13 01 38 	insert %d3,%d3,1,16,1
80002f3c:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.frameError)
80002f3e:	39 d3 1c 10 	ld.bu %d3,[%a13]92
80002f42:	6f 13 09 00 	jz.t %d3,1,80002f54 <IfxAsclin_Asc_initModule+0x2b0>
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
80002f46:	d9 c2 00 10 	lea %a2,[%a12]64
80002f4a:	19 c3 00 10 	ld.w %d3,[%a12]64
80002f4e:	b7 13 01 39 	insert %d3,%d3,1,18,1
80002f52:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.rxFifoOverflow)
80002f54:	39 d3 1c 10 	ld.bu %d3,[%a13]92
80002f58:	6f 23 09 00 	jz.t %d3,2,80002f6a <IfxAsclin_Asc_initModule+0x2c6>
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
80002f5c:	d9 c2 00 10 	lea %a2,[%a12]64
80002f60:	19 c3 00 10 	ld.w %d3,[%a12]64
80002f64:	b7 13 01 3d 	insert %d3,%d3,1,26,1
80002f68:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.rxFifoUnderflow)
80002f6a:	39 d3 1c 10 	ld.bu %d3,[%a13]92
80002f6e:	6f 33 09 00 	jz.t %d3,3,80002f80 <IfxAsclin_Asc_initModule+0x2dc>
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
80002f72:	d9 c2 00 10 	lea %a2,[%a12]64
80002f76:	19 c3 00 10 	ld.w %d3,[%a12]64
80002f7a:	b7 13 81 3d 	insert %d3,%d3,1,27,1
80002f7e:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.txFifoOverflow)
80002f80:	39 d3 1c 10 	ld.bu %d3,[%a13]92
80002f84:	6f 43 09 00 	jz.t %d3,4,80002f96 <IfxAsclin_Asc_initModule+0x2f2>
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
80002f88:	d9 c2 00 10 	lea %a2,[%a12]64
80002f8c:	19 c3 00 10 	ld.w %d3,[%a12]64
80002f90:	b7 13 01 3f 	insert %d3,%d3,1,30,1
80002f94:	74 23       	st.w [%a2],%d3
    asclin->rxSwFifoOverflow = FALSE;
80002f96:	82 03       	mov %d3,0
80002f98:	28 d3       	st.b [%a15]13,%d3
    asclin->txInProgress     = FALSE;
80002f9a:	28 c3       	st.b [%a15]12,%d3
    asclin->dataBufferMode = config->dataBufferMode;
80002f9c:	19 d3 30 10 	ld.w %d3,[%a13]112
80002fa0:	68 43       	st.w [%a15]16,%d3
    asclin->txTimestamp    = 0;
80002fa2:	d2 04       	mov %e4,0
80002fa4:	89 f4 58 09 	st.d [%a15]24,%e4
    asclin->sendCount      = 0;
80002fa8:	82 02       	mov %d2,0
80002faa:	68 52       	st.w [%a15]20,%d2
    switch (asclin->dataBufferMode)
80002fac:	df 03 82 00 	jeq %d3,0,800030b0 <IfxAsclin_Asc_initModule+0x40c>
80002fb0:	df 13 83 80 	jne %d3,1,800030b6 <IfxAsclin_Asc_initModule+0x412>
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
80002fb4:	3b c0 00 80 	mov %d8,12
    if (config->txBuffer != NULL_PTR)
80002fb8:	99 d4 20 10 	ld.a %a4,[%a13]96
80002fbc:	bd 04 80 00 	jz.a %a4,800030bc <IfxAsclin_Asc_initModule+0x418>
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
80002fc0:	02 85       	mov %d5,%d8
80002fc2:	c9 d4 1e 10 	ld.h %d4,[%a13]94
80002fc6:	6d ff 17 ed 	call 800009f4 <Ifx_Fifo_init>
80002fca:	e8 12       	st.a [%a15]4,%a2
    if (config->rxBuffer != NULL_PTR)
80002fcc:	99 d4 28 10 	ld.a %a4,[%a13]104
80002fd0:	bd 04 7e 00 	jz.a %a4,800030cc <IfxAsclin_Asc_initModule+0x428>
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
80002fd4:	02 85       	mov %d5,%d8
80002fd6:	c9 d4 24 10 	ld.h %d4,[%a13]100
80002fda:	6d ff 0d ed 	call 800009f4 <Ifx_Fifo_init>
80002fde:	e8 22       	st.a [%a15]8,%a2
    IfxSrc_Tos tos = config->interrupt.typeOfService;
80002fe0:	19 d8 10 10 	ld.w %d8,[%a13]80
    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
80002fe4:	b9 d3 0a 10 	ld.hu %d3,[%a13]74
80002fe8:	df 03 04 80 	jne %d3,0,80002ff0 <IfxAsclin_Asc_initModule+0x34c>
80002fec:	df 38 1e 80 	jne %d8,3,80003028 <IfxAsclin_Asc_initModule+0x384>
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
80002ff0:	40 c4       	mov.aa %a4,%a12
80002ff2:	6d ff 70 fc 	call 800028d2 <IfxAsclin_getSrcPointerRx>
    src->B.SRPN = priority;
80002ff6:	39 d2 0a 10 	ld.bu %d2,[%a13]74
80002ffa:	54 23       	ld.w %d3,[%a2]
80002ffc:	37 23 08 30 	insert %d3,%d3,%d2,0,8
80003000:	74 23       	st.w [%a2],%d3
    src->B.TOS  = typOfService;
80003002:	54 23       	ld.w %d3,[%a2]
80003004:	37 83 82 35 	insert %d3,%d3,%d8,11,2
80003008:	74 23       	st.w [%a2],%d3
    src->B.CLRR = 1;
8000300a:	54 23       	ld.w %d3,[%a2]
8000300c:	b7 13 81 3c 	insert %d3,%d3,1,25,1
80003010:	74 23       	st.w [%a2],%d3
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
80003012:	d9 c3 00 10 	lea %a3,[%a12]64
80003016:	19 c3 00 10 	ld.w %d3,[%a12]64
8000301a:	b7 13 01 3e 	insert %d3,%d3,1,28,1
8000301e:	74 33       	st.w [%a3],%d3
    src->B.SRE = 1;
80003020:	54 23       	ld.w %d3,[%a2]
80003022:	b7 13 01 35 	insert %d3,%d3,1,10,1
80003026:	74 23       	st.w [%a2],%d3
    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
80003028:	b9 d3 08 10 	ld.hu %d3,[%a13]72
8000302c:	df 03 04 80 	jne %d3,0,80003034 <IfxAsclin_Asc_initModule+0x390>
80003030:	df 38 1e 80 	jne %d8,3,8000306c <IfxAsclin_Asc_initModule+0x3c8>
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
80003034:	40 c4       	mov.aa %a4,%a12
80003036:	6d ff 5b fc 	call 800028ec <IfxAsclin_getSrcPointerTx>
    src->B.SRPN = priority;
8000303a:	39 d2 08 10 	ld.bu %d2,[%a13]72
8000303e:	54 23       	ld.w %d3,[%a2]
80003040:	37 23 08 30 	insert %d3,%d3,%d2,0,8
80003044:	74 23       	st.w [%a2],%d3
    src->B.TOS  = typOfService;
80003046:	54 23       	ld.w %d3,[%a2]
80003048:	37 83 82 35 	insert %d3,%d3,%d8,11,2
8000304c:	74 23       	st.w [%a2],%d3
    src->B.CLRR = 1;
8000304e:	54 23       	ld.w %d3,[%a2]
80003050:	b7 13 81 3c 	insert %d3,%d3,1,25,1
80003054:	74 23       	st.w [%a2],%d3
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
80003056:	d9 c3 00 10 	lea %a3,[%a12]64
8000305a:	19 c3 00 10 	ld.w %d3,[%a12]64
8000305e:	b7 13 81 3f 	insert %d3,%d3,1,31,1
80003062:	74 33       	st.w [%a3],%d3
    src->B.SRE = 1;
80003064:	54 23       	ld.w %d3,[%a2]
80003066:	b7 13 01 35 	insert %d3,%d3,1,10,1
8000306a:	74 23       	st.w [%a2],%d3
    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
8000306c:	b9 d3 0c 10 	ld.hu %d3,[%a13]76
80003070:	df 03 36 80 	jne %d3,0,800030dc <IfxAsclin_Asc_initModule+0x438>
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
80003074:	d9 c2 10 00 	lea %a2,[%a12]16
80003078:	19 c3 10 00 	ld.w %d3,[%a12]16
8000307c:	b7 13 81 30 	insert %d3,%d3,1,1,1
80003080:	74 23       	st.w [%a2],%d3
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
80003082:	d9 c2 0c 00 	lea %a2,[%a12]12
80003086:	19 c3 0c 00 	ld.w %d3,[%a12]12
8000308a:	b7 13 81 30 	insert %d3,%d3,1,1,1
8000308e:	74 23       	st.w [%a2],%d3
    asclin->RXFIFOCON.B.FLUSH = 1;
80003090:	d9 c2 10 00 	lea %a2,[%a12]16
80003094:	19 c3 10 00 	ld.w %d3,[%a12]16
80003098:	b7 13 01 30 	insert %d3,%d3,1,0,1
8000309c:	74 23       	st.w [%a2],%d3
    asclin->TXFIFOCON.B.FLUSH = 1;
8000309e:	d9 c2 0c 00 	lea %a2,[%a12]12
800030a2:	19 c3 0c 00 	ld.w %d3,[%a12]12
800030a6:	b7 13 01 30 	insert %d3,%d3,1,0,1
800030aa:	74 23       	st.w [%a2],%d3
}
800030ac:	02 a2       	mov %d2,%d10
800030ae:	00 90       	ret 
    switch (asclin->dataBufferMode)
800030b0:	82 18       	mov %d8,1
800030b2:	1d ff 83 ff 	j 80002fb8 <IfxAsclin_Asc_initModule+0x314>
        elementSize = 0;
800030b6:	82 08       	mov %d8,0
800030b8:	1d ff 80 ff 	j 80002fb8 <IfxAsclin_Asc_initModule+0x314>
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
800030bc:	02 85       	mov %d5,%d8
800030be:	c9 d4 1e 10 	ld.h %d4,[%a13]94
800030c2:	6d ff bf ec 	call 80000a40 <Ifx_Fifo_create>
800030c6:	e8 12       	st.a [%a15]4,%a2
800030c8:	1d ff 82 ff 	j 80002fcc <IfxAsclin_Asc_initModule+0x328>
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
800030cc:	02 85       	mov %d5,%d8
800030ce:	c9 d4 24 10 	ld.h %d4,[%a13]100
800030d2:	6d ff b7 ec 	call 80000a40 <Ifx_Fifo_create>
800030d6:	e8 22       	st.a [%a15]8,%a2
800030d8:	1d ff 84 ff 	j 80002fe0 <IfxAsclin_Asc_initModule+0x33c>
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
800030dc:	40 c4       	mov.aa %a4,%a12
800030de:	6d ff ec fb 	call 800028b6 <IfxAsclin_getSrcPointerEr>
    src->B.SRPN = priority;
800030e2:	39 d2 0c 10 	ld.bu %d2,[%a13]76
800030e6:	54 23       	ld.w %d3,[%a2]
800030e8:	37 23 08 30 	insert %d3,%d3,%d2,0,8
800030ec:	74 23       	st.w [%a2],%d3
    src->B.TOS  = typOfService;
800030ee:	54 23       	ld.w %d3,[%a2]
800030f0:	37 83 82 35 	insert %d3,%d3,%d8,11,2
800030f4:	74 23       	st.w [%a2],%d3
    src->B.CLRR = 1;
800030f6:	54 23       	ld.w %d3,[%a2]
800030f8:	b7 13 81 3c 	insert %d3,%d3,1,25,1
800030fc:	74 23       	st.w [%a2],%d3
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
800030fe:	d9 c3 00 10 	lea %a3,[%a12]64
80003102:	19 c3 00 10 	ld.w %d3,[%a12]64
80003106:	b7 13 01 38 	insert %d3,%d3,1,16,1
8000310a:	74 33       	st.w [%a3],%d3
    src->B.SRE = 1;
8000310c:	54 23       	ld.w %d3,[%a2]
8000310e:	b7 13 01 35 	insert %d3,%d3,1,10,1
80003112:	74 23       	st.w [%a2],%d3
}
80003114:	1d ff b0 ff 	j 80003074 <IfxAsclin_Asc_initModule+0x3d0>

80003118 <IfxAsclin_Asc_initModuleConfig>:
{
80003118:	40 ae       	mov.aa %a14,%sp
    config->asclin = asclin;
8000311a:	f4 45       	st.a [%a4],%a5
    config->loopBack = FALSE;                                                  /* no loop back*/
8000311c:	82 02       	mov %d2,0
8000311e:	e9 42 2c 10 	st.b [%a4]108,%d2
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
80003122:	82 13       	mov %d3,1
80003124:	59 43 18 10 	st.w [%a4]88,%d3
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
80003128:	f9 43 08 00 	st.h [%a4]8,%d3
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
8000312c:	7b 10 7e 24 	movh %d2,18401
80003130:	59 42 04 00 	st.w [%a4]4,%d2
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
80003134:	82 34       	mov %d4,3
80003136:	59 44 0c 00 	st.w [%a4]12,%d4
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
8000313a:	82 02       	mov %d2,0
8000313c:	59 42 10 00 	st.w [%a4]16,%d2
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
80003140:	59 44 14 00 	st.w [%a4]20,%d4
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
80003144:	59 42 18 00 	st.w [%a4]24,%d2
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
80003148:	59 43 1c 00 	st.w [%a4]28,%d3
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
8000314c:	59 43 20 00 	st.w [%a4]32,%d3
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
80003150:	59 42 24 00 	st.w [%a4]36,%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
80003154:	e9 42 30 00 	st.b [%a4]48,%d2
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
80003158:	59 42 28 00 	st.w [%a4]40,%d2
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
8000315c:	82 74       	mov %d4,7
8000315e:	59 44 2c 00 	st.w [%a4]44,%d4
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
80003162:	59 43 34 00 	st.w [%a4]52,%d3
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
80003166:	59 43 38 00 	st.w [%a4]56,%d3
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
8000316a:	59 42 3c 00 	st.w [%a4]60,%d2
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
8000316e:	59 42 00 10 	st.w [%a4]64,%d2
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
80003172:	59 42 04 10 	st.w [%a4]68,%d2
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
80003176:	f9 42 0a 10 	st.h [%a4]74,%d2
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
8000317a:	f9 42 08 10 	st.h [%a4]72,%d2
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
8000317e:	f9 42 0c 10 	st.h [%a4]76,%d2
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/
80003182:	59 42 10 10 	st.w [%a4]80,%d2
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
80003186:	82 f3       	mov %d3,-1
80003188:	e9 43 1c 10 	st.b [%a4]92,%d3
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
8000318c:	59 42 14 10 	st.w [%a4]84,%d2
    config->rxBuffer       = NULL_PTR;                                         /* Rx Fifo buffer*/
80003190:	59 42 28 10 	st.w [%a4]104,%d2
    config->txBuffer       = NULL_PTR;                                         /* Tx Fifo buffer*/
80003194:	59 42 20 10 	st.w [%a4]96,%d2
    config->txBufferSize   = 0;                                                /* Rx Fifo buffer size*/
80003198:	f9 42 1e 10 	st.h [%a4]94,%d2
    config->rxBufferSize   = 0;                                                /* Rx Fifo buffer size*/
8000319c:	f9 42 24 10 	st.h [%a4]100,%d2
    config->dataBufferMode = Ifx_DataBufferMode_normal;
800031a0:	59 42 30 10 	st.w [%a4]112,%d2
}
800031a4:	00 90       	ret 

800031a6 <IfxAsclin_Asc_initiateTransmission>:
{
800031a6:	40 ae       	mov.aa %a14,%sp
800031a8:	20 10       	sub.a %sp,16
800031aa:	40 4c       	mov.aa %a12,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
800031ac:	39 42 0c 00 	ld.bu %d2,[%a4]12
800031b0:	df 02 17 80 	jne %d2,0,800031de <IfxAsclin_Asc_initiateTransmission+0x38>
        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
800031b4:	99 44 04 00 	ld.a %a4,[%a4]4
800031b8:	c9 42 04 00 	ld.h %d2,[%a4]4
800031bc:	df 02 11 00 	jeq %d2,0,800031de <IfxAsclin_Asc_initiateTransmission+0x38>
            asclin->txInProgress = TRUE;
800031c0:	82 12       	mov %d2,1
800031c2:	e9 c2 0c 00 	st.b [%a12]12,%d2
            switch (asclin->dataBufferMode)
800031c6:	19 c2 10 00 	ld.w %d2,[%a12]16
800031ca:	df 02 0b 00 	jeq %d2,0,800031e0 <IfxAsclin_Asc_initiateTransmission+0x3a>
800031ce:	df 12 11 00 	jeq %d2,1,800031f0 <IfxAsclin_Asc_initiateTransmission+0x4a>
            IfxAsclin_write8(asclin->asclin, &data, 1);
800031d2:	82 14       	mov %d4,1
800031d4:	d9 e5 f3 ff 	lea %a5,[%a14]-13
800031d8:	d4 c4       	ld.a %a4,[%a12]
800031da:	6d ff 6e fc 	call 80002ab6 <IfxAsclin_write8>
}
800031de:	00 90       	ret 
                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
800031e0:	d2 06       	mov %e6,0
800031e2:	82 14       	mov %d4,1
800031e4:	d9 e5 f3 ff 	lea %a5,[%a14]-13
800031e8:	6d ff 41 ec 	call 80000a6a <Ifx_Fifo_read>
            break;
800031ec:	1d ff f3 ff 	j 800031d2 <IfxAsclin_Asc_initiateTransmission+0x2c>
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
800031f0:	d2 06       	mov %e6,0
800031f2:	3b c0 00 40 	mov %d4,12
800031f6:	d9 e5 f4 ff 	lea %a5,[%a14]-12
800031fa:	6d ff 38 ec 	call 80000a6a <Ifx_Fifo_read>
                data = packedData.data;
800031fe:	39 e2 fc ff 	ld.bu %d2,[%a14]-4
80003202:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
            break;
80003206:	1d ff e6 ff 	j 800031d2 <IfxAsclin_Asc_initiateTransmission+0x2c>

8000320a <IfxAsclin_Asc_write>:
    return TRUE;
}


boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
8000320a:	40 ae       	mov.aa %a14,%sp
8000320c:	40 4c       	mov.aa %a12,%a4
8000320e:	80 5b       	mov.d %d11,%a5
80003210:	40 6d       	mov.aa %a13,%a6
80003212:	02 4a       	mov %d10,%d4
80003214:	02 59       	mov %d9,%d5
    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
80003216:	39 43 0c 00 	ld.bu %d3,[%a4]12
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
8000321a:	99 44 04 00 	ld.a %a4,[%a4]4
8000321e:	c9 42 18 00 	ld.h %d2,[%a4]24
80003222:	b9 48 18 00 	ld.hu %d8,[%a4]24

    if (*count != 0)
80003226:	94 64       	ld.h %d4,[%a6]
80003228:	df 04 31 00 	jeq %d4,0,8000328a <IfxAsclin_Asc_write+0x80>
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
8000322c:	df 03 04 80 	jne %d3,0,80003234 <IfxAsclin_Asc_write+0x2a>
80003230:	3f 48 11 00 	jlt %d8,%d4,80003252 <IfxAsclin_Asc_write+0x48>
            IfxAsclin_Asc_initiateTransmission(asclin); /*Will initiate transmission only if txInProgress is False, otherwise interrupts will continue to push data to H/W FIFO*/
        }

        else
        {
            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
80003234:	02 a6       	mov %d6,%d10
80003236:	02 97       	mov %d7,%d9
80003238:	60 b5       	mov.a %a5,%d11
8000323a:	6d ff d1 ec 	call 80000bdc <Ifx_Fifo_write>
8000323e:	02 28       	mov %d8,%d2
            IfxAsclin_Asc_initiateTransmission(asclin);
80003240:	40 c4       	mov.aa %a4,%a12
80003242:	6d ff b2 ff 	call 800031a6 <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
80003246:	94 d2       	ld.h %d2,[%a13]
80003248:	a2 82       	sub %d2,%d8
8000324a:	b4 d2       	st.h [%a13],%d2
        result  = left == 0;
8000324c:	8b 08 00 22 	eq %d2,%d8,0
80003250:	00 90       	ret 
            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
80003252:	02 a6       	mov %d6,%d10
80003254:	02 57       	mov %d7,%d5
80003256:	02 24       	mov %d4,%d2
80003258:	6d ff c2 ec 	call 80000bdc <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
8000325c:	40 c4       	mov.aa %a4,%a12
8000325e:	6d ff a4 ff 	call 800031a6 <IfxAsclin_Asc_initiateTransmission>
            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
80003262:	b9 d4 00 00 	ld.hu %d4,[%a13]0
80003266:	a2 84       	sub %d4,%d8
80003268:	02 a6       	mov %d6,%d10
8000326a:	02 97       	mov %d7,%d9
8000326c:	37 04 50 40 	extr %d4,%d4,0,16
80003270:	60 b2       	mov.a %a2,%d11
80003272:	01 28 00 56 	addsc.a %a5,%a2,%d8,0
80003276:	99 c4 04 00 	ld.a %a4,[%a12]4
8000327a:	6d ff b1 ec 	call 80000bdc <Ifx_Fifo_write>
8000327e:	02 28       	mov %d8,%d2
            IfxAsclin_Asc_initiateTransmission(asclin); /*Will initiate transmission only if txInProgress is False, otherwise interrupts will continue to push data to H/W FIFO*/
80003280:	40 c4       	mov.aa %a4,%a12
80003282:	6d ff 92 ff 	call 800031a6 <IfxAsclin_Asc_initiateTransmission>
80003286:	1d ff e0 ff 	j 80003246 <IfxAsclin_Asc_write+0x3c>
    boolean   result       = TRUE;
8000328a:	82 12       	mov %d2,1
    }

    return result;
}
8000328c:	00 90       	ret 

8000328e <Ifx_C_Init>:
 *
 * Parameters: Nil
 * Return: Nil
 */
void Ifx_C_Init(void)
{
8000328e:	40 ae       	mov.aa %a14,%sp
80003290:	20 08       	sub.a %sp,8
    IfxStart_CTablePtr pBlockDest, pBlockSrc;
    uint32             uiLength, uiCnt;
    uint32            *pTable;
    /* clear table */
    pTable = (uint32 *)&__clear_table;
80003292:	91 00 00 28 	movh.a %a2,32768
80003296:	d9 22 3c b0 	lea %a2,[%a2]764 <800002fc <__clear_table>>

    while (pTable)
8000329a:	1d 00 32 00 	j 800032fe <Ifx_C_Init+0x70>
            break;
        }

        uiCnt = uiLength / 8;

        while (uiCnt--)
8000329e:	91 00 00 28 	movh.a %a2,32768
800032a2:	d9 22 24 d0 	lea %a2,[%a2]868 <80000364 <__copy_table>>
800032a6:	1d 00 7c 00 	j 8000339e <Ifx_C_Init+0x110>
            *pBlockDest.ullPtr++ = 0;
800032aa:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800032ae:	80 22       	mov.d %d2,%a2
800032b0:	1b 82 00 20 	addi %d2,%d2,8
800032b4:	59 e2 fc ff 	st.w [%a14]-4,%d2
800032b8:	d2 02       	mov %e2,0
800032ba:	89 22 40 09 	st.d [%a2],%e2
        while (uiCnt--)
800032be:	02 52       	mov %d2,%d5
800032c0:	1b f2 ff 5f 	addi %d5,%d2,-1
800032c4:	df 02 f3 ff 	jne %d2,0,800032aa <Ifx_C_Init+0x1c>
        if (uiLength & 0x4)
800032c8:	6f 24 0a 00 	jz.t %d4,2,800032dc <Ifx_C_Init+0x4e>
            *pBlockDest.uiPtr++ = 0;
800032cc:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800032d0:	80 22       	mov.d %d2,%a2
800032d2:	c2 42       	add %d2,4
800032d4:	59 e2 fc ff 	st.w [%a14]-4,%d2
800032d8:	82 02       	mov %d2,0
800032da:	74 22       	st.w [%a2],%d2
        if (uiLength & 0x2)
800032dc:	6f 14 0a 00 	jz.t %d4,1,800032f0 <Ifx_C_Init+0x62>
            *pBlockDest.usPtr++ = 0;
800032e0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800032e4:	80 22       	mov.d %d2,%a2
800032e6:	c2 22       	add %d2,2
800032e8:	59 e2 fc ff 	st.w [%a14]-4,%d2
800032ec:	82 02       	mov %d2,0
800032ee:	b4 22       	st.h [%a2],%d2
        if (uiLength & 0x1)
800032f0:	6f 04 06 00 	jz.t %d4,0,800032fc <Ifx_C_Init+0x6e>
            *pBlockDest.ucPtr = 0;
800032f4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800032f8:	82 02       	mov %d2,0
800032fa:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
800032fc:	40 32       	mov.aa %a2,%a3
    while (pTable)
800032fe:	bd 02 d0 7f 	jz.a %a2,8000329e <Ifx_C_Init+0x10>
        pBlockDest.uiPtr = (uint32 *)*pTable++;
80003302:	d9 23 08 00 	lea %a3,[%a2]8
80003306:	54 22       	ld.w %d2,[%a2]
80003308:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
8000330c:	19 24 04 00 	ld.w %d4,[%a2]4
        if (uiLength == 0xFFFFFFFF)
80003310:	df f4 c7 7f 	jeq %d4,-1,8000329e <Ifx_C_Init+0x10>
        uiCnt = uiLength / 8;
80003314:	8f d4 1f 20 	sh %d2,%d4,-3
        while (uiCnt--)
80003318:	1d ff d4 ff 	j 800032c0 <Ifx_C_Init+0x32>
        {
            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;
8000331c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80003320:	80 22       	mov.d %d2,%a2
80003322:	1b 82 00 20 	addi %d2,%d2,8
80003326:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000332a:	99 e3 fc ff 	ld.a %a3,[%a14]-4
8000332e:	80 32       	mov.d %d2,%a3
80003330:	1b 82 00 20 	addi %d2,%d2,8
80003334:	59 e2 fc ff 	st.w [%a14]-4,%d2
80003338:	09 26 40 09 	ld.d %e6,[%a2]
8000333c:	89 36 40 09 	st.d [%a3],%e6
        while (uiCnt--)
80003340:	02 42       	mov %d2,%d4
80003342:	1b f2 ff 4f 	addi %d4,%d2,-1
80003346:	df 02 eb ff 	jne %d2,0,8000331c <Ifx_C_Init+0x8e>
        }

        if (uiLength & 0x4)
8000334a:	6f 23 10 00 	jz.t %d3,2,8000336a <Ifx_C_Init+0xdc>
        {
            *pBlockDest.uiPtr++ = *pBlockSrc.uiPtr++;
8000334e:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80003352:	80 22       	mov.d %d2,%a2
80003354:	c2 42       	add %d2,4
80003356:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000335a:	99 e3 fc ff 	ld.a %a3,[%a14]-4
8000335e:	80 32       	mov.d %d2,%a3
80003360:	c2 42       	add %d2,4
80003362:	59 e2 fc ff 	st.w [%a14]-4,%d2
80003366:	54 22       	ld.w %d2,[%a2]
80003368:	74 32       	st.w [%a3],%d2
        }

        if (uiLength & 0x2)
8000336a:	6f 13 11 00 	jz.t %d3,1,8000338c <Ifx_C_Init+0xfe>
        {
            *pBlockDest.usPtr++ = *pBlockSrc.usPtr++;
8000336e:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80003372:	80 32       	mov.d %d2,%a3
80003374:	c2 22       	add %d2,2
80003376:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000337a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000337e:	80 22       	mov.d %d2,%a2
80003380:	c2 22       	add %d2,2
80003382:	59 e2 fc ff 	st.w [%a14]-4,%d2
80003386:	b9 32 00 00 	ld.hu %d2,[%a3]0
8000338a:	b4 22       	st.h [%a2],%d2
        }

        if (uiLength & 0x1)
8000338c:	6f 03 08 00 	jz.t %d3,0,8000339c <Ifx_C_Init+0x10e>
        {
            *pBlockDest.ucPtr = *pBlockSrc.ucPtr;
80003390:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80003394:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80003398:	14 32       	ld.bu %d2,[%a3]
8000339a:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
8000339c:	60 52       	mov.a %a2,%d5
    while (pTable)
8000339e:	bd 02 14 00 	jz.a %a2,800033c6 <Ifx_C_Init+0x138>
        pBlockSrc.uiPtr  = (uint32 *)*pTable++;
800033a2:	54 22       	ld.w %d2,[%a2]
800033a4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        pBlockDest.uiPtr = (uint32 *)*pTable++;
800033a8:	19 22 04 00 	ld.w %d2,[%a2]4
800033ac:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
800033b0:	80 22       	mov.d %d2,%a2
800033b2:	1b c2 00 50 	addi %d5,%d2,12
800033b6:	19 23 08 00 	ld.w %d3,[%a2]8
        if (uiLength == 0xFFFFFFFF)
800033ba:	df f3 06 00 	jeq %d3,-1,800033c6 <Ifx_C_Init+0x138>
        uiCnt = uiLength / 8;
800033be:	8f d3 1f 20 	sh %d2,%d3,-3
        while (uiCnt--)
800033c2:	1d ff c0 ff 	j 80003342 <Ifx_C_Init+0xb4>
        }
    }
}
800033c6:	00 90       	ret 

800033c8 <init_GPIO>:

#include "Header_USER.h"


void init_GPIO(void)
{
800033c8:	40 ae       	mov.aa %a14,%sp
800033ca:	3b 00 08 50 	mov %d5,128
800033ce:	82 14       	mov %d4,1
800033d0:	91 40 00 4f 	movh.a %a4,61444
800033d4:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800033d8:	6d ff 5a f3 	call 80001a8c <IfxPort_setPinMode>
800033dc:	3b 00 08 50 	mov %d5,128
800033e0:	82 24       	mov %d4,2
800033e2:	91 40 00 4f 	movh.a %a4,61444
800033e6:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800033ea:	6d ff 51 f3 	call 80001a8c <IfxPort_setPinMode>
800033ee:	3b 00 08 50 	mov %d5,128
800033f2:	82 74       	mov %d4,7
800033f4:	91 40 00 4f 	movh.a %a4,61444
800033f8:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800033fc:	6d ff 48 f3 	call 80001a8c <IfxPort_setPinMode>
80003400:	3b 00 08 50 	mov %d5,128
80003404:	82 54       	mov %d4,5
80003406:	91 40 00 4f 	movh.a %a4,61444
8000340a:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
8000340e:	6d ff 3f f3 	call 80001a8c <IfxPort_setPinMode>
80003412:	3b 00 08 50 	mov %d5,128
80003416:	82 34       	mov %d4,3
80003418:	91 40 00 4f 	movh.a %a4,61444
8000341c:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80003420:	6d ff 36 f3 	call 80001a8c <IfxPort_setPinMode>
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
80003424:	3b 80 00 50 	mov %d5,8
80003428:	82 04       	mov %d4,0
8000342a:	91 40 00 4f 	movh.a %a4,61444
8000342e:	d9 44 00 0a 	lea %a4,[%a4]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80003432:	6d ff 2d f3 	call 80001a8c <IfxPort_setPinMode>
80003436:	3b 80 00 50 	mov %d5,8
8000343a:	82 14       	mov %d4,1
8000343c:	91 40 00 4f 	movh.a %a4,61444
80003440:	d9 44 00 0a 	lea %a4,[%a4]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80003444:	6d ff 24 f3 	call 80001a8c <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(PORT_103, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);


    IfxPort_setPinModeInput(PORT_000, IfxPort_InputMode_pullDown);
    IfxPort_setPinModeInput(PORT_001, IfxPort_InputMode_pullDown);
}
80003448:	00 90       	ret 

8000344a <set_pin_low>:
static void set_pin_mode_input(void) {
    IfxPort_setPinModeInput(DHT11_PIN, IfxPort_InputMode_pullDown);
}

// 핀 값 설정 및 읽기
static void set_pin_low(void) {
8000344a:	40 ae       	mov.aa %a14,%sp
    port->OMR.U = action << pinIndex;
8000344c:	91 40 00 2f 	movh.a %a2,61444
80003450:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80003454:	7b 00 01 20 	movh %d2,16
80003458:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
    IfxPort_setPinLow(DHT11_PIN);
}
8000345c:	00 90       	ret 

8000345e <set_pin_high>:

static void set_pin_high(void) {
8000345e:	40 ae       	mov.aa %a14,%sp
80003460:	91 40 00 2f 	movh.a %a2,61444
80003464:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80003468:	3b 00 01 20 	mov %d2,16
8000346c:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
    IfxPort_setPinHigh(DHT11_PIN);
}
80003470:	00 90       	ret 

80003472 <read_pin>:

static int read_pin(void) {
80003472:	40 ae       	mov.aa %a14,%sp
    return (__getbit(&port->IN.U, pinIndex) != 0) ? TRUE : FALSE;
80003474:	91 40 00 2f 	movh.a %a2,61444
80003478:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
8000347c:	19 22 24 00 	ld.w %d2,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
    return IfxPort_getPinState(DHT11_PIN);
}
80003480:	37 02 61 22 	extr.u %d2,%d2,4,1
80003484:	00 90       	ret 

80003486 <set_pin_mode_output>:
static void set_pin_mode_output(void) {
80003486:	40 ae       	mov.aa %a14,%sp
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80003488:	3b 00 08 50 	mov %d5,128
8000348c:	82 44       	mov %d4,4
8000348e:	91 40 00 4f 	movh.a %a4,61444
80003492:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80003496:	6d ff fb f2 	call 80001a8c <IfxPort_setPinMode>
}
8000349a:	00 90       	ret 

8000349c <set_pin_mode_input>:
static void set_pin_mode_input(void) {
8000349c:	40 ae       	mov.aa %a14,%sp
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
8000349e:	3b 80 00 50 	mov %d5,8
800034a2:	82 44       	mov %d4,4
800034a4:	91 40 00 4f 	movh.a %a4,61444
800034a8:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800034ac:	6d ff f0 f2 	call 80001a8c <IfxPort_setPinMode>
}
800034b0:	00 90       	ret 

800034b2 <DHT11_read>:
//void DHT11_init(void) {
//    set_pin_mode_output();
//    set_pin_high();  // 대기 상태 (High)
//}

int DHT11_read(int *temperature, int *humidity) {
800034b2:	40 ae       	mov.aa %a14,%sp
800034b4:	20 08       	sub.a %sp,8
800034b6:	40 4c       	mov.aa %a12,%a4
800034b8:	40 5d       	mov.aa %a13,%a5
    uint8_t data[5] = {0};
800034ba:	82 02       	mov %d2,0
800034bc:	59 e2 f8 ff 	st.w [%a14]-8,%d2
800034c0:	e9 e2 fc ff 	st.b [%a14]-4,%d2

    // DHT11 시작 신호 보내기
    set_pin_mode_output();
800034c4:	6d ff e1 ff 	call 80003486 <set_pin_mode_output>
    set_pin_low();
800034c8:	6d ff c1 ff 	call 8000344a <set_pin_low>
800034cc:	6d ff 7c ee 	call 800011c4 <IfxScuCcu_getSourceFrequency>
800034d0:	91 30 00 2f 	movh.a %a2,61443
800034d4:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
800034d8:	54 23       	ld.w %d3,[%a2]
800034da:	37 03 64 34 	extr.u %d3,%d3,8,4
800034de:	4b 03 41 31 	itof %d3,%d3
800034e2:	4b 32 51 20 	div.f %d2,%d2,%d3
    IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 1000 * 18); // 18ms
800034e6:	7b a0 47 34 	movh %d3,17530
800034ea:	4b 32 51 20 	div.f %d2,%d2,%d3
800034ee:	7b 00 19 34 	movh %d3,16784
800034f2:	4b 32 41 30 	mul.f %d3,%d2,%d3
800034f6:	4b 03 71 31 	ftouz %d3,%d3
    return stm->TIM0.U;
800034fa:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>
800034fe:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
80003502:	a2 42       	sub %d2,%d4
80003504:	3f 32 fd ff 	jlt.u %d2,%d3,800034fe <DHT11_read+0x4c>
    set_pin_high();
80003508:	6d ff ab ff 	call 8000345e <set_pin_high>
8000350c:	6d ff 5c ee 	call 800011c4 <IfxScuCcu_getSourceFrequency>
80003510:	91 30 00 2f 	movh.a %a2,61443
80003514:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80003518:	54 23       	ld.w %d3,[%a2]
8000351a:	37 03 64 34 	extr.u %d3,%d3,8,4
8000351e:	4b 03 41 31 	itof %d3,%d3
80003522:	4b 32 51 20 	div.f %d2,%d2,%d3
    IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 1000000 * 20); // 20us
80003526:	7b 40 97 34 	movh %d3,18804
8000352a:	1b 03 40 32 	addi %d3,%d3,9216
8000352e:	4b 32 51 20 	div.f %d2,%d2,%d3
80003532:	7b 00 1a 34 	movh %d3,16800
80003536:	4b 32 41 30 	mul.f %d3,%d2,%d3
8000353a:	4b 03 71 31 	ftouz %d3,%d3
    return stm->TIM0.U;
8000353e:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>
80003542:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
80003546:	a2 42       	sub %d2,%d4
80003548:	3f 32 fd ff 	jlt.u %d2,%d3,80003542 <DHT11_read+0x90>
    set_pin_mode_input();
8000354c:	6d ff a8 ff 	call 8000349c <set_pin_mode_input>

    // 응답 신호 확인
    if (read_pin() == 1) return 0; // DHT11의 응답 신호 확인
80003550:	6d ff 91 ff 	call 80003472 <read_pin>
80003554:	df 12 af 00 	jeq %d2,1,800036b2 <DHT11_read+0x200>
80003558:	6d ff 36 ee 	call 800011c4 <IfxScuCcu_getSourceFrequency>
8000355c:	91 30 00 2f 	movh.a %a2,61443
80003560:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80003564:	54 23       	ld.w %d3,[%a2]
80003566:	37 03 64 34 	extr.u %d3,%d3,8,4
8000356a:	4b 03 41 31 	itof %d3,%d3
8000356e:	4b 32 51 20 	div.f %d2,%d2,%d3
    IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 1000000 * 80); // 80us
80003572:	7b 40 97 34 	movh %d3,18804
80003576:	1b 03 40 32 	addi %d3,%d3,9216
8000357a:	4b 32 51 20 	div.f %d2,%d2,%d3
8000357e:	7b 00 2a 34 	movh %d3,17056
80003582:	4b 32 41 30 	mul.f %d3,%d2,%d3
80003586:	4b 03 71 31 	ftouz %d3,%d3
    return stm->TIM0.U;
8000358a:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>
8000358e:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
80003592:	a2 42       	sub %d2,%d4
80003594:	3f 32 fd ff 	jlt.u %d2,%d3,8000358e <DHT11_read+0xdc>
    if (read_pin() == 0) return 0; // DHT11이 LOW 신호를 보내는지 확인
80003598:	6d ff 6d ff 	call 80003472 <read_pin>
8000359c:	df 02 03 80 	jne %d2,0,800035a2 <DHT11_read+0xf0>
    if ((uint8_t)(data[0] + data[1] + data[2] + data[3]) != data[4]) return 0;

    *humidity = data[0]; // 습도 데이터
    *temperature = data[2]; // 온도 데이터
    return 1; // 성공적으로 읽음
}
800035a0:	00 90       	ret 
800035a2:	6d ff 11 ee 	call 800011c4 <IfxScuCcu_getSourceFrequency>
800035a6:	91 30 00 2f 	movh.a %a2,61443
800035aa:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
800035ae:	54 23       	ld.w %d3,[%a2]
800035b0:	37 03 64 34 	extr.u %d3,%d3,8,4
800035b4:	4b 03 41 31 	itof %d3,%d3
800035b8:	4b 32 51 20 	div.f %d2,%d2,%d3
    IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 1000000 * 80); // 80us
800035bc:	7b 40 97 34 	movh %d3,18804
800035c0:	1b 03 40 32 	addi %d3,%d3,9216
800035c4:	4b 32 51 20 	div.f %d2,%d2,%d3
800035c8:	7b 00 2a 34 	movh %d3,17056
800035cc:	4b 32 41 30 	mul.f %d3,%d2,%d3
800035d0:	4b 03 71 31 	ftouz %d3,%d3
    return stm->TIM0.U;
800035d4:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>
800035d8:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
800035dc:	a2 42       	sub %d2,%d4
800035de:	3f 32 fd ff 	jlt.u %d2,%d3,800035d8 <DHT11_read+0x126>
    for (int i = 0; i < 40; i++) {
800035e2:	82 08       	mov %d8,0
800035e4:	1d 00 07 00 	j 800035f2 <DHT11_read+0x140>
        while (read_pin() == 1);  // 신호 끝날 때까지 대기
800035e8:	6d ff 45 ff 	call 80003472 <read_pin>
800035ec:	df 12 fe 7f 	jeq %d2,1,800035e8 <DHT11_read+0x136>
    for (int i = 0; i < 40; i++) {
800035f0:	c2 18       	add %d8,1
800035f2:	8b 88 42 22 	lt %d2,%d8,40
800035f6:	df 02 45 00 	jeq %d2,0,80003680 <DHT11_read+0x1ce>
        while (read_pin() == 0);  // 신호 시작 대기
800035fa:	6d ff 3c ff 	call 80003472 <read_pin>
800035fe:	df 02 fe 7f 	jeq %d2,0,800035fa <DHT11_read+0x148>
80003602:	6d ff e1 ed 	call 800011c4 <IfxScuCcu_getSourceFrequency>
80003606:	91 30 00 2f 	movh.a %a2,61443
8000360a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000360e:	54 23       	ld.w %d3,[%a2]
80003610:	37 03 64 34 	extr.u %d3,%d3,8,4
80003614:	4b 03 41 31 	itof %d3,%d3
80003618:	4b 32 51 20 	div.f %d2,%d2,%d3
        IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 1000000 * 30); // 30us
8000361c:	7b 40 97 34 	movh %d3,18804
80003620:	1b 03 40 32 	addi %d3,%d3,9216
80003624:	4b 32 51 20 	div.f %d2,%d2,%d3
80003628:	7b 00 1f 34 	movh %d3,16880
8000362c:	4b 32 41 30 	mul.f %d3,%d2,%d3
80003630:	4b 03 71 31 	ftouz %d3,%d3
    return stm->TIM0.U;
80003634:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>
80003638:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
8000363c:	a2 42       	sub %d2,%d4
8000363e:	3f 32 fd ff 	jlt.u %d2,%d3,80003638 <DHT11_read+0x186>
        if (read_pin() == 1) {
80003642:	6d ff 18 ff 	call 80003472 <read_pin>
80003646:	df 12 d1 ff 	jne %d2,1,800035e8 <DHT11_read+0x136>
            data[i / 8] |= (1 << (7 - (i % 8))); // 비트 설정
8000364a:	8b 08 40 22 	lt %d2,%d8,0
8000364e:	ab 78 00 22 	cadd %d2,%d2,%d8,7
80003652:	8f d2 3f 40 	sha %d4,%d2,-3
80003656:	8f 18 3e 20 	sha %d2,%d8,-31
8000365a:	8f 32 1e 20 	sh %d2,%d2,-29
8000365e:	0b 28 00 30 	add %d3,%d8,%d2
80003662:	8f 73 00 31 	and %d3,%d3,7
80003666:	a2 23       	sub %d3,%d2
80003668:	8b 73 00 31 	rsub %d3,%d3,7
8000366c:	d9 e2 f8 ff 	lea %a2,[%a14]-8
80003670:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80003674:	14 22       	ld.bu %d2,[%a2]
80003676:	d7 12 01 23 	insert %d2,%d2,1,%d3,1
8000367a:	34 22       	st.b [%a2],%d2
8000367c:	1d ff b6 ff 	j 800035e8 <DHT11_read+0x136>
    if ((uint8_t)(data[0] + data[1] + data[2] + data[3]) != data[4]) return 0;
80003680:	39 e5 f8 ff 	ld.bu %d5,[%a14]-8
80003684:	39 e2 f9 ff 	ld.bu %d2,[%a14]-7
80003688:	42 52       	add %d2,%d5
8000368a:	8f f2 0f 21 	and %d2,%d2,255
8000368e:	39 e4 fa ff 	ld.bu %d4,[%a14]-6
80003692:	42 42       	add %d2,%d4
80003694:	8f f2 0f 31 	and %d3,%d2,255
80003698:	39 e2 fb ff 	ld.bu %d2,[%a14]-5
8000369c:	42 23       	add %d3,%d2
8000369e:	8f f3 0f 31 	and %d3,%d3,255
800036a2:	39 e2 fc ff 	ld.bu %d2,[%a14]-4
800036a6:	5f 23 08 80 	jne %d3,%d2,800036b6 <DHT11_read+0x204>
    *humidity = data[0]; // 습도 데이터
800036aa:	74 d5       	st.w [%a13],%d5
    *temperature = data[2]; // 온도 데이터
800036ac:	74 c4       	st.w [%a12],%d4
    return 1; // 성공적으로 읽음
800036ae:	82 12       	mov %d2,1
800036b0:	00 90       	ret 
    if (read_pin() == 1) return 0; // DHT11의 응답 신호 확인
800036b2:	82 02       	mov %d2,0
800036b4:	00 90       	ret 
    if ((uint8_t)(data[0] + data[1] + data[2] + data[3]) != data[4]) return 0;
800036b6:	82 02       	mov %d2,0
800036b8:	1d ff 74 ff 	j 800035a0 <DHT11_read+0xee>

800036bc <core0_main>:
#include "Header_USER.h"

IfxCpu_syncEvent g_cpuSyncEvent = 0;

void core0_main(void)
{
800036bc:	40 ae       	mov.aa %a14,%sp
    __enable();
800036be:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
800036c2:	6d ff 7b f1 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
800036c6:	02 24       	mov %d4,%d2
800036c8:	6d ff 5c f0 	call 80001780 <IfxScuWdt_disableCpuWatchdog>
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
800036cc:	6d ff 88 f1 	call 800019dc <IfxScuWdt_getSafetyWatchdogPassword>
800036d0:	02 24       	mov %d4,%d2
800036d2:	6d ff 96 f0 	call 800017fe <IfxScuWdt_disableSafetyWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
800036d6:	91 00 00 c6 	movh.a %a12,24576
800036da:	d9 cc b0 50 	lea %a12,[%a12]2416 <60000970 <g_cpuSyncEvent>>
800036de:	40 c4       	mov.aa %a4,%a12
800036e0:	6d ff 40 f4 	call 80001f60 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
800036e4:	82 14       	mov %d4,1
800036e6:	40 c4       	mov.aa %a4,%a12
800036e8:	6d ff fc f3 	call 80001ee0 <IfxCpu_waitEvent>

    init_GPIO();
800036ec:	6d ff 6e fe 	call 800033c8 <init_GPIO>
    init_STM();
800036f0:	6d ff 3c e8 	call 80000768 <init_STM>
    init_UART_SUB();
800036f4:	6d ff 01 e7 	call 800004f6 <init_UART_SUB>
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
800036f8:	3b 00 08 50 	mov %d5,128
800036fc:	82 44       	mov %d4,4
800036fe:	91 40 00 4f 	movh.a %a4,61444
80003702:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80003706:	6d ff c3 f1 	call 80001a8c <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(DHT11_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
        
    while(1)
8000370a:	1d 00 00 00 	j 8000370a <core0_main+0x4e>

8000370e <core1_main>:
#include "Header_USER.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core1_main(void)
{
8000370e:	40 ae       	mov.aa %a14,%sp
80003710:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG1 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80003714:	6d ff 52 f1 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
80003718:	02 24       	mov %d4,%d2
8000371a:	6d ff 33 f0 	call 80001780 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
8000371e:	91 00 00 c6 	movh.a %a12,24576
80003722:	d9 cc b0 50 	lea %a12,[%a12]2416 <60000970 <g_cpuSyncEvent>>
80003726:	40 c4       	mov.aa %a4,%a12
80003728:	6d ff 1c f4 	call 80001f60 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
8000372c:	82 14       	mov %d4,1
8000372e:	40 c4       	mov.aa %a4,%a12
80003730:	6d ff d8 f3 	call 80001ee0 <IfxCpu_waitEvent>
    
    init_GPIO();
80003734:	6d ff 4a fe 	call 800033c8 <init_GPIO>
    init_STM();
80003738:	6d ff 18 e8 	call 80000768 <init_STM>
    init_UART_SUB();
8000373c:	6d ff dd e6 	call 800004f6 <init_UART_SUB>
80003740:	3b 00 08 50 	mov %d5,128
80003744:	82 44       	mov %d4,4
80003746:	91 40 00 4f 	movh.a %a4,61444
8000374a:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
8000374e:	6d ff 9f f1 	call 80001a8c <IfxPort_setPinMode>
    IfxPort_setPinModeOutput(DHT11_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    while(1)
    {
        AppScheduling();
80003752:	6d ff e2 e7 	call 80000716 <AppScheduling>
    while(1)
80003756:	1d ff fe ff 	j 80003752 <core1_main+0x44>

8000375a <core2_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core2_main(void)
{
8000375a:	40 ae       	mov.aa %a14,%sp
8000375c:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG2 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80003760:	6d ff 2c f1 	call 800019b8 <IfxScuWdt_getCpuWatchdogPassword>
80003764:	02 24       	mov %d4,%d2
80003766:	6d ff 0d f0 	call 80001780 <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
8000376a:	91 00 00 c6 	movh.a %a12,24576
8000376e:	d9 cc b0 50 	lea %a12,[%a12]2416 <60000970 <g_cpuSyncEvent>>
80003772:	40 c4       	mov.aa %a4,%a12
80003774:	6d ff f6 f3 	call 80001f60 <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80003778:	82 14       	mov %d4,1
8000377a:	40 c4       	mov.aa %a4,%a12
8000377c:	6d ff b2 f3 	call 80001ee0 <IfxCpu_waitEvent>
    
    while(1)
80003780:	1d 00 00 00 	j 80003780 <core2_main+0x26>

80003784 <__divdf3>:
80003784:	20 38       	sub.a %sp,56
80003786:	d9 a5 10 00 	lea %a5,[%sp]16
8000378a:	40 a4       	mov.aa %a4,%sp
8000378c:	89 a4 40 09 	st.d [%sp],%e4
80003790:	89 a6 48 09 	st.d [%sp]8,%e6
80003794:	6d 00 d5 01 	call 80003b3e <__unpack_d>
80003798:	d9 a5 24 00 	lea %a5,[%sp]36
8000379c:	d9 a4 08 00 	lea %a4,[%sp]8
800037a0:	6d 00 cf 01 	call 80003b3e <__unpack_d>
800037a4:	19 a2 10 00 	ld.w %d2,[%sp]16
800037a8:	ff 22 07 80 	jge.u %d2,2,800037b6 <__divdf3+0x32>
800037ac:	d9 a4 10 00 	lea %a4,[%sp]16
800037b0:	6d 00 f8 00 	call 800039a0 <__pack_d>
800037b4:	00 90       	ret 
800037b6:	19 a3 24 00 	ld.w %d3,[%sp]36
800037ba:	d9 a4 24 00 	lea %a4,[%sp]36
800037be:	bf 23 f9 ff 	jlt.u %d3,2,800037b0 <__divdf3+0x2c>
800037c2:	19 a5 14 00 	ld.w %d5,[%sp]20
800037c6:	19 a4 28 00 	ld.w %d4,[%sp]40
800037ca:	c6 54       	xor %d4,%d5
800037cc:	59 a4 14 00 	st.w [%sp]20,%d4
800037d0:	1b e2 ff 4f 	addi %d4,%d2,-2
800037d4:	8f 24 c0 41 	andn %d4,%d4,2
800037d8:	df 04 0a 80 	jne %d4,0,800037ec <__divdf3+0x68>
800037dc:	91 00 00 48 	movh.a %a4,32768
800037e0:	d9 44 00 80 	lea %a4,[%a4]512 <80000200 <__thenan_df>>
800037e4:	5f 32 e4 ff 	jne %d2,%d3,800037ac <__divdf3+0x28>
800037e8:	1d ff e4 ff 	j 800037b0 <__divdf3+0x2c>
800037ec:	df 43 51 00 	jeq %d3,4,8000388e <__divdf3+0x10a>
800037f0:	df 23 5a 00 	jeq %d3,2,800038a4 <__divdf3+0x120>
800037f4:	19 a3 18 00 	ld.w %d3,[%sp]24
800037f8:	19 a2 2c 00 	ld.w %d2,[%sp]44
800037fc:	09 a4 70 09 	ld.d %e4,[%sp]48
80003800:	0b 23 80 00 	sub %d0,%d3,%d2
80003804:	09 a2 5c 09 	ld.d %e2,[%sp]28
80003808:	0b 53 00 61 	eq %d6,%d3,%d5
8000380c:	02 67       	mov %d7,%d6
8000380e:	0b 42 50 72 	and.ge.u %d7,%d2,%d4
80003812:	59 a0 18 00 	st.w [%sp]24,%d0
80003816:	0b 35 a0 72 	or.lt.u %d7,%d5,%d3
8000381a:	df 07 0b 80 	jne %d7,0,80003830 <__divdf3+0xac>
8000381e:	1b f0 ff 6f 	addi %d6,%d0,-1
80003822:	77 23 80 30 	dextr %d3,%d3,%d2,1
80003826:	06 12       	sh %d2,1
80003828:	59 a6 18 00 	st.w [%sp]24,%d6
8000382c:	0b 53 00 61 	eq %d6,%d3,%d5
80003830:	3b d0 03 10 	mov %d1,61
80003834:	d2 08       	mov %e8,0
80003836:	82 00       	mov %d0,0
80003838:	7b 00 00 71 	movh %d7,4096
8000383c:	1d 00 04 00 	j 80003844 <__divdf3+0xc0>
80003840:	0b 53 00 61 	eq %d6,%d3,%d5
80003844:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
80003848:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
8000384c:	df 06 0c 80 	jne %d6,0,80003864 <__divdf3+0xe0>
80003850:	0f 08 a0 a0 	or %d10,%d8,%d0
80003854:	0f 79 a0 60 	or %d6,%d9,%d7
80003858:	0b 42 c0 20 	subx %d2,%d2,%d4
8000385c:	0b a6 10 88 	mov %e8,%d6,%d10
80003860:	0b 53 d0 30 	subc %d3,%d3,%d5
80003864:	c2 f1       	add %d1,-1
80003866:	77 07 80 0f 	dextr %d0,%d7,%d0,31
8000386a:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000386e:	06 f7       	sh %d7,-1
80003870:	06 12       	sh %d2,1
80003872:	df 01 e7 ff 	jne %d1,0,80003840 <__divdf3+0xbc>
80003876:	8f f8 0f 41 	and %d4,%d8,255
8000387a:	8b 04 28 42 	ne %d4,%d4,128
8000387e:	df 04 1a 00 	jeq %d4,0,800038b2 <__divdf3+0x12e>
80003882:	59 a8 1c 00 	st.w [%sp]28,%d8
80003886:	59 a9 20 00 	st.w [%sp]32,%d9
8000388a:	1d ff 91 ff 	j 800037ac <__divdf3+0x28>
8000388e:	82 02       	mov %d2,0
80003890:	a0 02       	mov.a %a2,0
80003892:	a0 03       	mov.a %a3,0
80003894:	89 a2 dc 09 	st.da [%sp]28,%a2
80003898:	59 a2 18 00 	st.w [%sp]24,%d2
8000389c:	d9 a4 10 00 	lea %a4,[%sp]16
800038a0:	1d ff 88 ff 	j 800037b0 <__divdf3+0x2c>
800038a4:	82 42       	mov %d2,4
800038a6:	d9 a4 10 00 	lea %a4,[%sp]16
800038aa:	59 a2 10 00 	st.w [%sp]16,%d2
800038ae:	1d ff 81 ff 	j 800037b0 <__divdf3+0x2c>
800038b2:	a6 32       	or %d2,%d3
800038b4:	77 89 00 4c 	dextr %d4,%d9,%d8,24
800038b8:	8b 02 20 32 	ne %d3,%d2,0
800038bc:	0f 43 e0 20 	andn %d2,%d3,%d4
800038c0:	df 02 e1 7f 	jeq %d2,0,80003882 <__divdf3+0xfe>
800038c4:	8b 08 88 80 	addx %d8,%d8,128
800038c8:	8b 09 a0 90 	addc %d9,%d9,0
800038cc:	8f f8 cf 81 	andn %d8,%d8,255
800038d0:	1d ff d9 ff 	j 80003882 <__divdf3+0xfe>

800038d4 <__floatsidf>:
800038d4:	82 32       	mov %d2,3
800038d6:	20 18       	sub.a %sp,24
800038d8:	59 a2 04 00 	st.w [%sp]4,%d2
800038dc:	8f 14 1e 20 	sh %d2,%d4,-31
800038e0:	59 a2 08 00 	st.w [%sp]8,%d2
800038e4:	df 04 0e 80 	jne %d4,0,80003900 <__floatsidf+0x2c>
800038e8:	82 22       	mov %d2,2
800038ea:	59 a2 04 00 	st.w [%sp]4,%d2
800038ee:	d9 a4 04 00 	lea %a4,[%sp]4
800038f2:	6d 00 57 00 	call 800039a0 <__pack_d>
800038f6:	60 25       	mov.a %a5,%d2
800038f8:	60 34       	mov.a %a4,%d3
800038fa:	80 52       	mov.d %d2,%a5
800038fc:	80 43       	mov.d %d3,%a4
800038fe:	00 90       	ret 
80003900:	ff 04 0a 00 	jge %d4,0,80003914 <__floatsidf+0x40>
80003904:	7b 00 00 28 	movh %d2,32768
80003908:	a0 05       	mov.a %a5,0
8000390a:	91 00 1e 4c 	movh.a %a4,49632
8000390e:	5f 24 f6 7f 	jeq %d4,%d2,800038fa <__floatsidf+0x26>
80003912:	32 54       	rsub %d4
80003914:	0f 04 b0 61 	clz %d6,%d4
80003918:	1b d6 01 60 	addi %d6,%d6,29
8000391c:	8f f6 01 21 	and %d2,%d6,31
80003920:	82 05       	mov %d5,0
80003922:	8b 06 82 72 	ge %d7,%d6,32
80003926:	17 45 80 32 	dextr %d3,%d5,%d4,%d2
8000392a:	0f 24 00 20 	sh %d2,%d4,%d2
8000392e:	2b 23 50 37 	seln %d3,%d7,%d3,%d2
80003932:	8b c6 03 61 	rsub %d6,%d6,60
80003936:	ab 02 a0 27 	seln %d2,%d7,%d2,0
8000393a:	59 a3 14 00 	st.w [%sp]20,%d3
8000393e:	59 a6 0c 00 	st.w [%sp]12,%d6
80003942:	59 a2 10 00 	st.w [%sp]16,%d2
80003946:	1d ff d4 ff 	j 800038ee <__floatsidf+0x1a>

8000394a <__truncdfsf2>:
8000394a:	20 20       	sub.a %sp,32
8000394c:	d9 a5 0c 00 	lea %a5,[%sp]12
80003950:	d9 a4 04 00 	lea %a4,[%sp]4
80003954:	89 a4 44 09 	st.d [%sp]4,%e4
80003958:	6d 00 f3 00 	call 80003b3e <__unpack_d>
8000395c:	19 a3 18 00 	ld.w %d3,[%sp]24
80003960:	19 a2 1c 00 	ld.w %d2,[%sp]28
80003964:	77 32 00 21 	dextr %d2,%d2,%d3,2
80003968:	b7 03 02 3f 	insert %d3,%d3,0,30,2
8000396c:	02 27       	mov %d7,%d2
8000396e:	df 03 04 00 	jeq %d3,0,80003976 <__truncdfsf2+0x2c>
80003972:	8f 12 40 71 	or %d7,%d2,1
80003976:	19 a6 14 00 	ld.w %d6,[%sp]20
8000397a:	19 a5 10 00 	ld.w %d5,[%sp]16
8000397e:	19 a4 0c 00 	ld.w %d4,[%sp]12
80003982:	6d 00 03 00 	call 80003988 <__make_fp>
80003986:	00 90       	ret 

80003988 <__make_fp>:
80003988:	20 10       	sub.a %sp,16
8000398a:	40 a4       	mov.aa %a4,%sp
8000398c:	74 a4       	st.w [%sp],%d4
8000398e:	59 a5 04 00 	st.w [%sp]4,%d5
80003992:	59 a6 08 00 	st.w [%sp]8,%d6
80003996:	59 a7 0c 00 	st.w [%sp]12,%d7
8000399a:	6d 00 31 01 	call 80003bfc <__pack_f>
8000399e:	00 90       	ret 

800039a0 <__pack_d>:
800039a0:	54 44       	ld.w %d4,[%a4]
800039a2:	19 43 0c 00 	ld.w %d3,[%a4]12
800039a6:	19 42 10 00 	ld.w %d2,[%a4]16
800039aa:	19 41 04 00 	ld.w %d1,[%a4]4
800039ae:	bf 24 56 80 	jlt.u %d4,2,80003a5a <__pack_d+0xba>
800039b2:	7b 00 ff 57 	movh %d5,32752
800039b6:	d2 06       	mov %e6,0
800039b8:	df 44 0b 00 	jeq %d4,4,800039ce <__pack_d+0x2e>
800039bc:	0f 23 a0 50 	or %d5,%d3,%d2
800039c0:	8b 05 00 02 	eq %d0,%d5,0
800039c4:	8b 24 e0 04 	or.eq %d0,%d4,2
800039c8:	82 05       	mov %d5,0
800039ca:	df 00 0c 00 	jeq %d0,0,800039e2 <__pack_d+0x42>
800039ce:	0b 10 00 28 	mov %e2,%d1
800039d2:	a6 75       	or %d5,%d7
800039d4:	8f f2 01 20 	sh %d2,%d2,31
800039d8:	0f 25 a0 40 	or %d4,%d5,%d2
800039dc:	02 43       	mov %d3,%d4
800039de:	02 62       	mov %d2,%d6
800039e0:	00 90       	ret 
800039e2:	19 44 08 00 	ld.w %d4,[%a4]8
800039e6:	3b 20 c0 0f 	mov %d0,-1022
800039ea:	3f 04 41 00 	jlt %d4,%d0,80003a6c <__pack_d+0xcc>
800039ee:	3b 00 40 00 	mov %d0,1024
800039f2:	7b 00 ff 57 	movh %d5,32752
800039f6:	7f 04 ec 7f 	jge %d4,%d0,800039ce <__pack_d+0x2e>
800039fa:	8f f3 0f 51 	and %d5,%d3,255
800039fe:	8b 05 28 52 	ne %d5,%d5,128
80003a02:	df 05 1b 00 	jeq %d5,0,80003a38 <__pack_d+0x98>
80003a06:	8b f3 87 30 	addx %d3,%d3,127
80003a0a:	8b 02 a0 20 	addc %d2,%d2,0
80003a0e:	7b 00 00 52 	movh %d5,8192
80003a12:	0b 25 30 61 	lt.u %d6,%d5,%d2
80003a16:	0b 25 70 62 	or.eq %d6,%d5,%d2
80003a1a:	df 06 19 80 	jne %d6,0,80003a4c <__pack_d+0xac>
80003a1e:	1b f4 3f 40 	addi %d4,%d4,1023
80003a22:	0b 40 00 48 	mov %e4,%d4
80003a26:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80003a2a:	06 82       	sh %d2,-8
80003a2c:	b7 02 0c 7a 	insert %d7,%d2,0,20,12
80003a30:	8f 44 01 50 	sh %d5,%d4,20
80003a34:	1d ff cd ff 	j 800039ce <__pack_d+0x2e>
80003a38:	8f 03 10 51 	and %d5,%d3,256
80003a3c:	df 05 e9 7f 	jeq %d5,0,80003a0e <__pack_d+0x6e>
80003a40:	8b 03 88 30 	addx %d3,%d3,128
80003a44:	8b 02 a0 20 	addc %d2,%d2,0
80003a48:	1d ff e3 ff 	j 80003a0e <__pack_d+0x6e>
80003a4c:	77 32 80 3f 	dextr %d3,%d2,%d3,31
80003a50:	1b 04 40 40 	addi %d4,%d4,1024
80003a54:	06 f2       	sh %d2,-1
80003a56:	1d ff e6 ff 	j 80003a22 <__pack_d+0x82>
80003a5a:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80003a5e:	06 82       	sh %d2,-8
80003a60:	b7 12 8d 79 	insert %d7,%d2,1,19,13
80003a64:	7b 00 ff 57 	movh %d5,32752
80003a68:	1d ff b3 ff 	j 800039ce <__pack_d+0x2e>
80003a6c:	0b 40 80 40 	sub %d4,%d0,%d4
80003a70:	8b 94 83 02 	ge %d0,%d4,57
80003a74:	df 00 ad ff 	jne %d0,0,800039ce <__pack_d+0x2e>
80003a78:	8b 04 82 52 	ge %d5,%d4,32
80003a7c:	2b 23 50 05 	seln %d0,%d5,%d3,%d2
80003a80:	ab 02 a0 75 	seln %d7,%d5,%d2,0
80003a84:	8f f4 01 51 	and %d5,%d4,31
80003a88:	8b 05 02 61 	rsub %d6,%d5,32
80003a8c:	17 07 80 66 	dextr %d6,%d7,%d0,%d6
80003a90:	2b 06 40 65 	sel %d6,%d5,%d6,%d0
80003a94:	8b 04 82 82 	ge %d8,%d4,32
80003a98:	32 55       	rsub %d5
80003a9a:	02 60       	mov %d0,%d6
80003a9c:	8f f4 01 41 	and %d4,%d4,31
80003aa0:	82 f6       	mov %d6,-1
80003aa2:	0f 57 00 70 	sh %d7,%d7,%d5
80003aa6:	17 66 80 54 	dextr %d5,%d6,%d6,%d4
80003aaa:	0f 46 00 40 	sh %d4,%d6,%d4
80003aae:	2b 45 50 58 	seln %d5,%d8,%d5,%d4
80003ab2:	ab 04 a0 48 	seln %d4,%d8,%d4,0
80003ab6:	0f 43 e0 30 	andn %d3,%d3,%d4
80003aba:	0f 52 e0 20 	andn %d2,%d2,%d5
80003abe:	a6 32       	or %d2,%d3
80003ac0:	02 03       	mov %d3,%d0
80003ac2:	8b 02 00 35 	or.ne %d3,%d2,0
80003ac6:	8f f3 0f 51 	and %d5,%d3,255
80003aca:	82 12       	mov %d2,1
80003acc:	8b 05 08 24 	and.eq %d2,%d5,128
80003ad0:	02 74       	mov %d4,%d7
80003ad2:	df 02 14 80 	jne %d2,0,80003afa <__pack_d+0x15a>
80003ad6:	8b f3 87 30 	addx %d3,%d3,127
80003ada:	8b 07 a0 20 	addc %d2,%d7,0
80003ade:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80003ae2:	7b 00 00 31 	movh %d3,4096
80003ae6:	8f 82 1f 70 	sh %d7,%d2,-8
80003aea:	0b 32 50 21 	ge.u %d2,%d2,%d3
80003aee:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80003af2:	8f 42 01 50 	sh %d5,%d2,20
80003af6:	1d ff 6c ff 	j 800039ce <__pack_d+0x2e>
80003afa:	8b 03 88 60 	addx %d6,%d3,128
80003afe:	8b 07 a0 20 	addc %d2,%d7,0
80003b02:	7b 00 00 a1 	movh %d10,4096
80003b06:	8f 82 1f 70 	sh %d7,%d2,-8
80003b0a:	77 62 00 6c 	dextr %d6,%d2,%d6,24
80003b0e:	0b a2 50 21 	ge.u %d2,%d2,%d10
80003b12:	53 12 40 80 	mul.u %e8,%d2,1
80003b16:	8f 03 10 01 	and %d0,%d3,256
80003b1a:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80003b1e:	8f 48 01 50 	sh %d5,%d8,20
80003b22:	df 00 56 ff 	jne %d0,0,800039ce <__pack_d+0x2e>
80003b26:	8f 84 1f 70 	sh %d7,%d4,-8
80003b2a:	0b a4 50 21 	ge.u %d2,%d4,%d10
80003b2e:	77 34 00 6c 	dextr %d6,%d4,%d3,24
80003b32:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80003b36:	8f 42 01 50 	sh %d5,%d2,20
80003b3a:	1d ff 4a ff 	j 800039ce <__pack_d+0x2e>

80003b3e <__unpack_d>:
80003b3e:	09 48 40 09 	ld.d %e8,[%a4]
80003b42:	3b f0 7f 00 	mov %d0,2047
80003b46:	8f 19 1e 70 	sh %d7,%d9,-31
80003b4a:	37 09 6b 5a 	extr.u %d5,%d9,20,11
80003b4e:	b7 09 0c 6a 	insert %d6,%d9,0,20,12
80003b52:	59 57 04 00 	st.w [%a5]4,%d7
80003b56:	df 05 26 80 	jne %d5,0,80003ba2 <__unpack_d+0x64>
80003b5a:	8b 08 20 22 	ne %d2,%d8,0
80003b5e:	8b 06 00 25 	or.ne %d2,%d6,0
80003b62:	df 02 33 00 	jeq %d2,0,80003bc8 <__unpack_d+0x8a>
80003b66:	82 32       	mov %d2,3
80003b68:	77 86 00 34 	dextr %d3,%d6,%d8,8
80003b6c:	8f 88 00 40 	sh %d4,%d8,8
80003b70:	74 52       	st.w [%a5],%d2
80003b72:	3b 10 c0 5f 	mov %d5,-1023
80003b76:	7b 00 00 61 	movh %d6,4096
80003b7a:	77 43 80 30 	dextr %d3,%d3,%d4,1
80003b7e:	02 57       	mov %d7,%d5
80003b80:	0b 63 00 21 	eq %d2,%d3,%d6
80003b84:	b7 02 01 20 	insert %d2,%d2,0,0,1
80003b88:	06 14       	sh %d4,1
80003b8a:	0b 63 a0 22 	or.lt.u %d2,%d3,%d6
80003b8e:	c2 f5       	add %d5,-1
80003b90:	df 02 f5 ff 	jne %d2,0,80003b7a <__unpack_d+0x3c>
80003b94:	59 57 08 00 	st.w [%a5]8,%d7
80003b98:	59 54 0c 00 	st.w [%a5]12,%d4
80003b9c:	59 53 10 00 	st.w [%a5]16,%d3
80003ba0:	00 90       	ret 
80003ba2:	5f 05 16 00 	jeq %d5,%d0,80003bce <__unpack_d+0x90>
80003ba6:	82 32       	mov %d2,3
80003ba8:	1b 15 c0 5f 	addi %d5,%d5,-1023
80003bac:	8f 88 00 40 	sh %d4,%d8,8
80003bb0:	74 52       	st.w [%a5],%d2
80003bb2:	77 86 00 24 	dextr %d2,%d6,%d8,8
80003bb6:	59 55 08 00 	st.w [%a5]8,%d5
80003bba:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
80003bbe:	59 54 0c 00 	st.w [%a5]12,%d4
80003bc2:	59 52 10 00 	st.w [%a5]16,%d2
80003bc6:	00 90       	ret 
80003bc8:	82 22       	mov %d2,2
80003bca:	74 52       	st.w [%a5],%d2
80003bcc:	00 90       	ret 
80003bce:	8b 08 20 52 	ne %d5,%d8,0
80003bd2:	8b 06 00 55 	or.ne %d5,%d6,0
80003bd6:	df 05 05 80 	jne %d5,0,80003be0 <__unpack_d+0xa2>
80003bda:	82 42       	mov %d2,4
80003bdc:	74 52       	st.w [%a5],%d2
80003bde:	00 90       	ret 
80003be0:	77 89 00 34 	dextr %d3,%d9,%d8,8
80003be4:	37 09 e1 49 	extr.u %d4,%d9,19,1
80003be8:	b7 03 85 3d 	insert %d3,%d3,0,27,5
80003bec:	8f 88 00 20 	sh %d2,%d8,8
80003bf0:	74 54       	st.w [%a5],%d4
80003bf2:	59 52 0c 00 	st.w [%a5]12,%d2
80003bf6:	59 53 10 00 	st.w [%a5]16,%d3
80003bfa:	00 90       	ret 

80003bfc <__pack_f>:
80003bfc:	54 44       	ld.w %d4,[%a4]
80003bfe:	19 43 0c 00 	ld.w %d3,[%a4]12
80003c02:	19 47 04 00 	ld.w %d7,[%a4]4
80003c06:	bf 24 3f 80 	jlt.u %d4,2,80003c84 <__pack_f+0x88>
80003c0a:	7b 00 f8 57 	movh %d5,32640
80003c0e:	82 06       	mov %d6,0
80003c10:	df 44 09 00 	jeq %d4,4,80003c22 <__pack_f+0x26>
80003c14:	8b 03 00 22 	eq %d2,%d3,0
80003c18:	8b 24 e0 24 	or.eq %d2,%d4,2
80003c1c:	82 05       	mov %d5,0
80003c1e:	df 02 08 00 	jeq %d2,0,80003c2e <__pack_f+0x32>
80003c22:	8f f7 01 70 	sh %d7,%d7,31
80003c26:	0f 56 a0 20 	or %d2,%d6,%d5
80003c2a:	a6 72       	or %d2,%d7
80003c2c:	00 90       	ret 
80003c2e:	19 42 08 00 	ld.w %d2,[%a4]8
80003c32:	8b 22 98 42 	ge %d4,%d2,-126
80003c36:	df 04 33 00 	jeq %d4,0,80003c9c <__pack_f+0xa0>
80003c3a:	8b 02 88 42 	ge %d4,%d2,128
80003c3e:	7b 00 f8 57 	movh %d5,32640
80003c42:	df 04 f0 ff 	jne %d4,0,80003c22 <__pack_f+0x26>
80003c46:	8f f3 07 51 	and %d5,%d3,127
80003c4a:	8f 03 08 41 	and %d4,%d3,128
80003c4e:	8b 05 24 52 	ne %d5,%d5,64
80003c52:	ab 03 04 44 	cadd %d4,%d4,%d3,64
80003c56:	1b f3 03 30 	addi %d3,%d3,63
80003c5a:	2b 43 40 35 	sel %d3,%d5,%d3,%d4
80003c5e:	1b f2 07 50 	addi %d5,%d2,127
80003c62:	bf 03 0c 00 	jlt %d3,0,80003c7a <__pack_f+0x7e>
80003c66:	37 03 f7 63 	extr.u %d6,%d3,7,23
80003c6a:	8f 75 01 50 	sh %d5,%d5,23
80003c6e:	8f f7 01 70 	sh %d7,%d7,31
80003c72:	0f 56 a0 20 	or %d2,%d6,%d5
80003c76:	a6 72       	or %d2,%d7
80003c78:	00 90       	ret 
80003c7a:	06 f3       	sh %d3,-1
80003c7c:	1b 02 08 50 	addi %d5,%d2,128
80003c80:	1d ff f3 ff 	j 80003c66 <__pack_f+0x6a>
80003c84:	37 03 f6 33 	extr.u %d3,%d3,7,22
80003c88:	7b 00 f8 57 	movh %d5,32640
80003c8c:	b7 f3 01 6b 	insert %d6,%d3,15,22,1
80003c90:	8f f7 01 70 	sh %d7,%d7,31
80003c94:	0f 56 a0 20 	or %d2,%d6,%d5
80003c98:	a6 72       	or %d2,%d7
80003c9a:	00 90       	ret 
80003c9c:	8b 22 18 21 	rsub %d2,%d2,-126
80003ca0:	8b a2 81 42 	ge %d4,%d2,26
80003ca4:	df 04 bf ff 	jne %d4,0,80003c22 <__pack_f+0x26>
80003ca8:	82 f5       	mov %d5,-1
80003caa:	8b 02 00 41 	rsub %d4,%d2,0
80003cae:	0f 25 00 20 	sh %d2,%d5,%d2
80003cb2:	0f 43 00 40 	sh %d4,%d3,%d4
80003cb6:	0f 23 e0 30 	andn %d3,%d3,%d2
80003cba:	8b 03 00 45 	or.ne %d4,%d3,0
80003cbe:	8f f4 07 31 	and %d3,%d4,127
80003cc2:	8b 03 04 32 	eq %d3,%d3,64
80003cc6:	df 03 0e 80 	jne %d3,0,80003ce2 <__pack_f+0xe6>
80003cca:	1b f4 03 20 	addi %d2,%d4,63
80003cce:	7b 00 00 34 	movh %d3,16384
80003cd2:	37 02 f7 63 	extr.u %d6,%d2,7,23
80003cd6:	0b 32 50 21 	ge.u %d2,%d2,%d3
80003cda:	8f 72 01 50 	sh %d5,%d2,23
80003cde:	1d ff a2 ff 	j 80003c22 <__pack_f+0x26>
80003ce2:	1b 04 04 30 	addi %d3,%d4,64
80003ce6:	7b 00 00 24 	movh %d2,16384
80003cea:	37 03 f7 63 	extr.u %d6,%d3,7,23
80003cee:	0b 23 50 31 	ge.u %d3,%d3,%d2
80003cf2:	8f 73 01 50 	sh %d5,%d3,23
80003cf6:	6f 74 96 ff 	jnz.t %d4,7,80003c22 <__pack_f+0x26>
80003cfa:	0b 24 50 21 	ge.u %d2,%d4,%d2
80003cfe:	37 04 f7 63 	extr.u %d6,%d4,7,23
80003d02:	8f 72 01 50 	sh %d5,%d2,23
80003d06:	1d ff 8e ff 	j 80003c22 <__pack_f+0x26>

80003d0a <malloc>:
80003d0a:	91 00 00 46 	movh.a %a4,24576
80003d0e:	99 44 28 00 	ld.a %a4,[%a4]40 <60000028 <_impure_ptr>>
80003d12:	6d 00 03 00 	call 80003d18 <_malloc_r>
80003d16:	00 90       	ret 

80003d18 <_malloc_r>:
80003d18:	1b b4 00 20 	addi %d2,%d4,11
80003d1c:	8b 72 a1 32 	ge.u %d3,%d2,23
80003d20:	40 4e       	mov.aa %a14,%a4
80003d22:	df 03 32 80 	jne %d3,0,80003d86 <_malloc_r+0x6e>
80003d26:	8b 14 a1 42 	ge.u %d4,%d4,17
80003d2a:	df 04 db 80 	jne %d4,0,80003ee0 <_malloc_r+0x1c8>
80003d2e:	6d 00 e0 04 	call 800046ee <__malloc_lock>
80003d32:	3b 80 01 30 	mov %d3,24
80003d36:	82 26       	mov %d6,2
80003d38:	3b 00 01 80 	mov %d8,16
80003d3c:	91 00 00 d6 	movh.a %a13,24576
80003d40:	d9 dd 10 50 	lea %a13,[%a13]336 <60000150 <__malloc_av_>>
80003d44:	01 d3 00 26 	addsc.a %a2,%a13,%d3,0
80003d48:	99 2c 04 00 	ld.a %a12,[%a2]4
80003d4c:	d9 23 f8 ff 	lea %a3,[%a2]-8
80003d50:	7d 3c ce 00 	jeq.a %a12,%a3,80003eec <_malloc_r+0x1d4>
80003d54:	99 c2 0c 00 	ld.a %a2,[%a12]12
80003d58:	99 c3 08 00 	ld.a %a3,[%a12]8
80003d5c:	19 c2 04 00 	ld.w %d2,[%a12]4
80003d60:	b5 32 0c 00 	st.a [%a3]12,%a2
80003d64:	8f 32 c0 21 	andn %d2,%d2,3
80003d68:	b5 23 08 00 	st.a [%a2]8,%a3
80003d6c:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80003d70:	b7 10 21 20 	imask %e2,1,0,1
80003d74:	40 e4       	mov.aa %a4,%a14
80003d76:	d9 cc 08 00 	lea %a12,[%a12]8
80003d7a:	49 22 44 08 	ldmst [%a2]4,%e2
80003d7e:	6d 00 b9 04 	call 800046f0 <__malloc_unlock>
80003d82:	40 c2       	mov.aa %a2,%a12
80003d84:	00 90       	ret 
80003d86:	8f 72 c0 81 	andn %d8,%d2,7
80003d8a:	0b 48 30 31 	lt.u %d3,%d8,%d4
80003d8e:	8b 02 20 35 	or.lt %d3,%d2,0
80003d92:	df 03 a7 80 	jne %d3,0,80003ee0 <_malloc_r+0x1c8>
80003d96:	6d 00 ac 04 	call 800046ee <__malloc_lock>
80003d9a:	8b 88 bf 22 	ge.u %d2,%d8,504
80003d9e:	df 02 07 02 	jeq %d2,0,800041ac <_malloc_r+0x494>
80003da2:	8f 78 1f 20 	sh %d2,%d8,-9
80003da6:	3b 00 20 30 	mov %d3,512
80003daa:	3b 00 04 60 	mov %d6,64
80003dae:	3b f0 03 50 	mov %d5,63
80003db2:	df 02 61 81 	jne %d2,0,80004074 <_malloc_r+0x35c>
80003db6:	91 00 00 d6 	movh.a %a13,24576
80003dba:	d9 dd 10 50 	lea %a13,[%a13]336 <60000150 <__malloc_av_>>
80003dbe:	01 d3 00 36 	addsc.a %a3,%a13,%d3,0
80003dc2:	99 3c 04 00 	ld.a %a12,[%a3]4
80003dc6:	d9 32 f8 ff 	lea %a2,[%a3]-8
80003dca:	7d c2 0a 80 	jne.a %a2,%a12,80003dde <_malloc_r+0xc6>
80003dce:	1d 00 13 00 	j 80003df4 <_malloc_r+0xdc>
80003dd2:	ff 02 80 01 	jge %d2,0,800040d2 <_malloc_r+0x3ba>
80003dd6:	99 cc 0c 00 	ld.a %a12,[%a12]12
80003dda:	7d c2 0d 00 	jeq.a %a2,%a12,80003df4 <_malloc_r+0xdc>
80003dde:	19 c2 04 00 	ld.w %d2,[%a12]4
80003de2:	8f 32 c0 41 	andn %d4,%d2,3
80003de6:	0b 84 80 20 	sub %d2,%d4,%d8
80003dea:	8b 02 81 32 	ge %d3,%d2,16
80003dee:	df 03 f2 7f 	jeq %d3,0,80003dd2 <_malloc_r+0xba>
80003df2:	02 56       	mov %d6,%d5
80003df4:	99 dc 10 00 	ld.a %a12,[%a13]16 <60000010 <LCF_DSPR1_START+0x10>>
80003df8:	d9 d4 08 00 	lea %a4,[%a13]8 <60000008 <LCF_DSPR1_START+0x8>>
80003dfc:	7d 4c 83 00 	jeq.a %a12,%a4,80003f02 <_malloc_r+0x1ea>
80003e00:	19 c2 04 00 	ld.w %d2,[%a12]4
80003e04:	8f 32 c0 21 	andn %d2,%d2,3
80003e08:	0b 82 80 30 	sub %d3,%d2,%d8
80003e0c:	8b 03 41 42 	lt %d4,%d3,16
80003e10:	df 04 d4 01 	jeq %d4,0,800041b8 <_malloc_r+0x4a0>
80003e14:	b5 d4 14 00 	st.a [%a13]20 <60000014 <LCF_DSPR1_START+0x14>>,%a4
80003e18:	b5 d4 10 00 	st.a [%a13]16 <60000010 <LCF_DSPR1_START+0x10>>,%a4
80003e1c:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80003e20:	ff 03 a8 7f 	jge %d3,0,80003d70 <_malloc_r+0x58>
80003e24:	3b 00 20 30 	mov %d3,512
80003e28:	7f 32 6a 81 	jge.u %d2,%d3,800040fc <_malloc_r+0x3e4>
80003e2c:	19 d4 04 00 	ld.w %d4,[%a13]4 <60000004 <LCF_DSPR1_START+0x4>>
80003e30:	8f b2 1f 30 	sh %d3,%d2,-5
80003e34:	8f 72 c0 21 	andn %d2,%d2,7
80003e38:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
80003e3c:	1b 82 00 20 	addi %d2,%d2,8
80003e40:	01 d2 00 36 	addsc.a %a3,%a13,%d2,0
80003e44:	d9 d2 04 00 	lea %a2,[%a13]4 <60000004 <LCF_DSPR1_START+0x4>>
80003e48:	d4 35       	ld.a %a5,[%a3]
80003e4a:	74 23       	st.w [%a2],%d3
80003e4c:	40 32       	mov.aa %a2,%a3
80003e4e:	b0 82       	add.a %a2,-8
80003e50:	b5 c2 0c 00 	st.a [%a12]12,%a2
80003e54:	b5 c5 08 00 	st.a [%a12]8,%a5
80003e58:	f4 3c       	st.a [%a3],%a12
80003e5a:	b5 5c 0c 00 	st.a [%a5]12,%a12
80003e5e:	8f e6 3f 40 	sha %d4,%d6,-2
80003e62:	82 12       	mov %d2,1
80003e64:	0f 42 00 20 	sh %d2,%d2,%d4
80003e68:	3f 23 56 80 	jlt.u %d3,%d2,80003f14 <_malloc_r+0x1fc>
80003e6c:	0f 32 80 40 	and %d4,%d2,%d3
80003e70:	df 04 0a 80 	jne %d4,0,80003e84 <_malloc_r+0x16c>
80003e74:	8f 36 c0 61 	andn %d6,%d6,3
80003e78:	06 12       	sh %d2,1
80003e7a:	0f 32 80 40 	and %d4,%d2,%d3
80003e7e:	c2 46       	add %d6,4
80003e80:	df 04 fc 7f 	jeq %d4,0,80003e78 <_malloc_r+0x160>
80003e84:	8f 36 00 30 	sh %d3,%d6,3
80003e88:	01 d3 00 56 	addsc.a %a5,%a13,%d3,0
80003e8c:	02 67       	mov %d7,%d6
80003e8e:	40 52       	mov.aa %a2,%a5
80003e90:	99 23 0c 00 	ld.a %a3,[%a2]12
80003e94:	7d 32 62 01 	jeq.a %a2,%a3,80004158 <_malloc_r+0x440>
80003e98:	19 33 04 00 	ld.w %d3,[%a3]4
80003e9c:	d9 36 04 00 	lea %a6,[%a3]4
80003ea0:	8f 33 c0 51 	andn %d5,%d3,3
80003ea4:	0b 85 80 30 	sub %d3,%d5,%d8
80003ea8:	40 3c       	mov.aa %a12,%a3
80003eaa:	8b 03 41 42 	lt %d4,%d3,16
80003eae:	d9 33 0c 00 	lea %a3,[%a3]12
80003eb2:	d4 33       	ld.a %a3,[%a3]
80003eb4:	df 04 5b 01 	jeq %d4,0,8000416a <_malloc_r+0x452>
80003eb8:	bf 03 ee 7f 	jlt %d3,0,80003e94 <_malloc_r+0x17c>
80003ebc:	b7 10 21 20 	imask %e2,1,0,1
80003ec0:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
80003ec4:	d9 cc 08 00 	lea %a12,[%a12]8
80003ec8:	40 e4       	mov.aa %a4,%a14
80003eca:	49 22 44 08 	ldmst [%a2]4,%e2
80003ece:	d4 c2       	ld.a %a2,[%a12]
80003ed0:	b5 23 0c 00 	st.a [%a2]12,%a3
80003ed4:	b5 32 08 00 	st.a [%a3]8,%a2
80003ed8:	6d 00 0c 04 	call 800046f0 <__malloc_unlock>
80003edc:	1d 00 06 00 	j 80003ee8 <_malloc_r+0x1d0>
80003ee0:	3b c0 00 20 	mov %d2,12
80003ee4:	a0 0c       	mov.a %a12,0
80003ee6:	74 e2       	st.w [%a14],%d2
80003ee8:	40 c2       	mov.aa %a2,%a12
80003eea:	00 90       	ret 
80003eec:	99 2c 0c 00 	ld.a %a12,[%a2]12
80003ef0:	c2 26       	add %d6,2
80003ef2:	7d c2 31 ff 	jne.a %a2,%a12,80003d54 <_malloc_r+0x3c>
80003ef6:	99 dc 10 00 	ld.a %a12,[%a13]16
80003efa:	d9 d4 08 00 	lea %a4,[%a13]8
80003efe:	7d 4c 81 ff 	jne.a %a12,%a4,80003e00 <_malloc_r+0xe8>
80003f02:	8f e6 3f 40 	sha %d4,%d6,-2
80003f06:	82 12       	mov %d2,1
80003f08:	19 d3 04 00 	ld.w %d3,[%a13]4
80003f0c:	0f 42 00 20 	sh %d2,%d2,%d4
80003f10:	7f 23 ae ff 	jge.u %d3,%d2,80003e6c <_malloc_r+0x154>
80003f14:	99 dc 08 00 	ld.a %a12,[%a13]8
80003f18:	19 c2 04 00 	ld.w %d2,[%a12]4
80003f1c:	8f 32 c0 b1 	andn %d11,%d2,3
80003f20:	0b 8b 80 20 	sub %d2,%d11,%d8
80003f24:	8b 02 41 32 	lt %d3,%d2,16
80003f28:	0b 8b a0 32 	or.lt.u %d3,%d11,%d8
80003f2c:	df 03 c0 00 	jeq %d3,0,800040ac <_malloc_r+0x394>
80003f30:	80 c2       	mov.d %d2,%a12
80003f32:	91 00 00 26 	movh.a %a2,24576
80003f36:	0b b2 00 c0 	add %d12,%d2,%d11
80003f3a:	19 22 60 b0 	ld.w %d2,[%a2]1760 <600006e0 <__malloc_top_pad>>
80003f3e:	91 00 00 f6 	movh.a %a15,24576
80003f42:	19 f4 08 50 	ld.w %d4,[%a15]328 <60000148 <__malloc_sbrk_base>>
80003f46:	42 82       	add %d2,%d8
80003f48:	1b 02 01 a0 	addi %d10,%d2,16
80003f4c:	1b f2 08 20 	addi %d2,%d2,143
80003f50:	8f f2 c7 21 	andn %d2,%d2,127
80003f54:	8b f4 3f 42 	ne %d4,%d4,-1
80003f58:	2b a2 40 a4 	sel %d10,%d4,%d2,%d10
80003f5c:	02 a4       	mov %d4,%d10
80003f5e:	40 e4       	mov.aa %a4,%a14
80003f60:	6d 00 ce 03 	call 800046fc <_sbrk_r>
80003f64:	80 29       	mov.d %d9,%a2
80003f66:	df f9 8a 01 	jeq %d9,-1,8000427a <_malloc_r+0x562>
80003f6a:	80 c3       	mov.d %d3,%a12
80003f6c:	80 d4       	mov.d %d4,%a13
80003f6e:	0b c9 30 21 	lt.u %d2,%d9,%d12
80003f72:	0b 43 10 22 	and.ne %d2,%d3,%d4
80003f76:	df 02 82 81 	jne %d2,0,8000427a <_malloc_r+0x562>
80003f7a:	7b 00 00 d6 	movh %d13,24576
80003f7e:	60 d2       	mov.a %a2,%d13
80003f80:	d9 22 70 a0 	lea %a2,[%a2]1712
80003f84:	54 22       	ld.w %d2,[%a2]
80003f86:	60 d2       	mov.a %a2,%d13
80003f88:	42 a2       	add %d2,%d10
80003f8a:	59 22 70 a0 	st.w [%a2]1712,%d2
80003f8e:	5f 9c 64 01 	jeq %d12,%d9,80004256 <_malloc_r+0x53e>
80003f92:	19 f3 08 50 	ld.w %d3,[%a15]328 <60000148 <__malloc_sbrk_base>>
80003f96:	df f3 6e 01 	jeq %d3,-1,80004272 <_malloc_r+0x55a>
80003f9a:	0b c9 80 c0 	sub %d12,%d9,%d12
80003f9e:	42 c2       	add %d2,%d12
80003fa0:	60 d2       	mov.a %a2,%d13
80003fa2:	59 22 70 a0 	st.w [%a2]1712,%d2
80003fa6:	8f 79 00 e1 	and %d14,%d9,7
80003faa:	df 0e 78 01 	jeq %d14,0,8000429a <_malloc_r+0x582>
80003fae:	8b 8e 00 21 	rsub %d2,%d14,8
80003fb2:	42 29       	add %d9,%d2
80003fb4:	42 9a       	add %d10,%d9
80003fb6:	8b 8e 08 21 	rsub %d2,%d14,136
80003fba:	a2 a2       	sub %d2,%d10
80003fbc:	8f f2 07 c1 	and %d12,%d2,127
80003fc0:	02 c4       	mov %d4,%d12
80003fc2:	40 e4       	mov.aa %a4,%a14
80003fc4:	6d 00 9c 03 	call 800046fc <_sbrk_r>
80003fc8:	80 22       	mov.d %d2,%a2
80003fca:	df f2 bd 01 	jeq %d2,-1,80004344 <_malloc_r+0x62c>
80003fce:	a2 92       	sub %d2,%d9
80003fd0:	0b c2 00 a0 	add %d10,%d2,%d12
80003fd4:	60 d2       	mov.a %a2,%d13
80003fd6:	8f 1a 40 31 	or %d3,%d10,1
80003fda:	d9 22 70 a0 	lea %a2,[%a2]1712
80003fde:	54 22       	ld.w %d2,[%a2]
80003fe0:	60 d2       	mov.a %a2,%d13
80003fe2:	42 c2       	add %d2,%d12
80003fe4:	59 d9 08 00 	st.w [%a13]8,%d9
80003fe8:	59 22 70 a0 	st.w [%a2]1712,%d2
80003fec:	60 92       	mov.a %a2,%d9
80003fee:	59 23 04 00 	st.w [%a2]4,%d3
80003ff2:	7d dc 7f 01 	jeq.a %a12,%a13,800042f0 <_malloc_r+0x5d8>
80003ff6:	8b 0b a1 32 	ge.u %d3,%d11,16
80003ffa:	df 03 7e 01 	jeq %d3,0,800042f6 <_malloc_r+0x5de>
80003ffe:	19 c4 04 00 	ld.w %d4,[%a12]4
80004002:	1b 4b ff 3f 	addi %d3,%d11,-12
80004006:	8f 73 c0 31 	andn %d3,%d3,7
8000400a:	8f 14 00 41 	and %d4,%d4,1
8000400e:	a6 34       	or %d4,%d3
80004010:	d9 c2 04 00 	lea %a2,[%a12]4
80004014:	74 24       	st.w [%a2],%d4
80004016:	82 54       	mov %d4,5
80004018:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
8000401c:	8b 03 a1 32 	ge.u %d3,%d3,16
80004020:	59 24 04 00 	st.w [%a2]4,%d4
80004024:	59 24 08 00 	st.w [%a2]8,%d4
80004028:	df 03 94 81 	jne %d3,0,80004350 <_malloc_r+0x638>
8000402c:	60 92       	mov.a %a2,%d9
8000402e:	60 9c       	mov.a %a12,%d9
80004030:	19 23 04 00 	ld.w %d3,[%a2]4
80004034:	91 00 00 26 	movh.a %a2,24576
80004038:	19 24 5c b0 	ld.w %d4,[%a2]1756 <600006dc <__malloc_max_sbrked_mem>>
8000403c:	7f 24 04 80 	jge.u %d4,%d2,80004044 <_malloc_r+0x32c>
80004040:	59 22 5c b0 	st.w [%a2]1756 <600006dc <__malloc_max_sbrked_mem>>,%d2
80004044:	91 00 00 26 	movh.a %a2,24576
80004048:	19 24 58 b0 	ld.w %d4,[%a2]1752 <600006d8 <__malloc_max_total_mem>>
8000404c:	7f 24 04 80 	jge.u %d4,%d2,80004054 <_malloc_r+0x33c>
80004050:	59 22 58 b0 	st.w [%a2]1752 <600006d8 <__malloc_max_total_mem>>,%d2
80004054:	8f 33 c0 31 	andn %d3,%d3,3
80004058:	0b 83 80 20 	sub %d2,%d3,%d8
8000405c:	0b 83 30 41 	lt.u %d4,%d3,%d8
80004060:	8b 02 21 45 	or.lt %d4,%d2,16
80004064:	df 04 24 00 	jeq %d4,0,800040ac <_malloc_r+0x394>
80004068:	40 e4       	mov.aa %a4,%a14
8000406a:	6d 00 43 03 	call 800046f0 <__malloc_unlock>
8000406e:	a0 0c       	mov.a %a12,0
80004070:	1d ff 3c ff 	j 80003ee8 <_malloc_r+0x1d0>
80004074:	8f a8 1f 60 	sh %d6,%d8,-6
80004078:	1b 86 03 50 	addi %d5,%d6,56
8000407c:	1b 96 03 60 	addi %d6,%d6,57
80004080:	8f 36 00 30 	sh %d3,%d6,3
80004084:	bf 52 99 fe 	jlt.u %d2,5,80003db6 <_malloc_r+0x9e>
80004088:	8b 52 a1 32 	ge.u %d3,%d2,21
8000408c:	df 03 bc 00 	jeq %d3,0,80004204 <_malloc_r+0x4ec>
80004090:	8b 52 a5 32 	ge.u %d3,%d2,85
80004094:	df 03 20 81 	jne %d3,0,800042d4 <_malloc_r+0x5bc>
80004098:	8f 48 1f 60 	sh %d6,%d8,-12
8000409c:	1b e6 06 50 	addi %d5,%d6,110
800040a0:	1b f6 06 60 	addi %d6,%d6,111
800040a4:	8f 36 00 30 	sh %d3,%d6,3
800040a8:	1d ff 87 fe 	j 80003db6 <_malloc_r+0x9e>
800040ac:	8f 18 40 31 	or %d3,%d8,1
800040b0:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
800040b4:	8f 12 40 21 	or %d2,%d2,1
800040b8:	59 c3 04 00 	st.w [%a12]4,%d3
800040bc:	b5 d2 08 00 	st.a [%a13]8,%a2
800040c0:	59 22 04 00 	st.w [%a2]4,%d2
800040c4:	40 e4       	mov.aa %a4,%a14
800040c6:	6d 00 15 03 	call 800046f0 <__malloc_unlock>
800040ca:	d9 cc 08 00 	lea %a12,[%a12]8
800040ce:	40 c2       	mov.aa %a2,%a12
800040d0:	00 90       	ret 
800040d2:	99 c2 0c 00 	ld.a %a2,[%a12]12
800040d6:	99 c3 08 00 	ld.a %a3,[%a12]8
800040da:	b7 10 21 20 	imask %e2,1,0,1
800040de:	40 e4       	mov.aa %a4,%a14
800040e0:	b5 32 0c 00 	st.a [%a3]12,%a2
800040e4:	b5 23 08 00 	st.a [%a2]8,%a3
800040e8:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
800040ec:	d9 cc 08 00 	lea %a12,[%a12]8
800040f0:	49 22 44 08 	ldmst [%a2]4,%e2
800040f4:	6d 00 fe 02 	call 800046f0 <__malloc_unlock>
800040f8:	1d ff 45 fe 	j 80003d82 <_malloc_r+0x6a>
800040fc:	8f 72 1f 30 	sh %d3,%d2,-9
80004100:	bf 53 78 80 	jlt.u %d3,5,800041f0 <_malloc_r+0x4d8>
80004104:	8b 53 a1 42 	ge.u %d4,%d3,21
80004108:	df 04 d8 80 	jne %d4,0,800042b8 <_malloc_r+0x5a0>
8000410c:	1b b3 05 50 	addi %d5,%d3,91
80004110:	1b c3 05 30 	addi %d3,%d3,92
80004114:	8f 33 00 40 	sh %d4,%d3,3
80004118:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
8000411c:	40 23       	mov.aa %a3,%a2
8000411e:	d4 33       	ld.a %a3,[%a3]
80004120:	b0 82       	add.a %a2,-8
80004122:	7d 32 b2 00 	jeq.a %a2,%a3,80004286 <_malloc_r+0x56e>
80004126:	19 33 04 00 	ld.w %d3,[%a3]4
8000412a:	8f 33 c0 31 	andn %d3,%d3,3
8000412e:	7f 32 07 80 	jge.u %d2,%d3,8000413c <_malloc_r+0x424>
80004132:	d9 33 08 00 	lea %a3,[%a3]8
80004136:	d4 33       	ld.a %a3,[%a3]
80004138:	7d 32 f7 ff 	jne.a %a2,%a3,80004126 <_malloc_r+0x40e>
8000413c:	99 32 0c 00 	ld.a %a2,[%a3]12
80004140:	19 d3 04 00 	ld.w %d3,[%a13]4
80004144:	b5 c2 0c 00 	st.a [%a12]12,%a2
80004148:	b5 c3 08 00 	st.a [%a12]8,%a3
8000414c:	b5 2c 08 00 	st.a [%a2]8,%a12
80004150:	b5 3c 0c 00 	st.a [%a3]12,%a12
80004154:	1d ff 85 fe 	j 80003e5e <_malloc_r+0x146>
80004158:	c2 17       	add %d7,1
8000415a:	8f 37 00 31 	and %d3,%d7,3
8000415e:	d9 22 08 00 	lea %a2,[%a2]8
80004162:	df 03 97 fe 	jne %d3,0,80003e90 <_malloc_r+0x178>
80004166:	1d 00 5d 00 	j 80004220 <_malloc_r+0x508>
8000416a:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
8000416e:	8f 18 40 81 	or %d8,%d8,1
80004172:	99 c5 08 00 	ld.a %a5,[%a12]8
80004176:	8f 13 40 21 	or %d2,%d3,1
8000417a:	74 68       	st.w [%a6],%d8
8000417c:	b5 53 0c 00 	st.a [%a5]12,%a3
80004180:	b5 35 08 00 	st.a [%a3]8,%a5
80004184:	b5 d2 14 00 	st.a [%a13]20,%a2
80004188:	b5 d2 10 00 	st.a [%a13]16,%a2
8000418c:	b5 24 0c 00 	st.a [%a2]12,%a4
80004190:	b5 24 08 00 	st.a [%a2]8,%a4
80004194:	59 22 04 00 	st.w [%a2]4,%d2
80004198:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
8000419c:	40 e4       	mov.aa %a4,%a14
8000419e:	74 23       	st.w [%a2],%d3
800041a0:	6d 00 a8 02 	call 800046f0 <__malloc_unlock>
800041a4:	d9 cc 08 00 	lea %a12,[%a12]8
800041a8:	1d ff a0 fe 	j 80003ee8 <_malloc_r+0x1d0>
800041ac:	8f d8 1f 60 	sh %d6,%d8,-3
800041b0:	1b 88 00 30 	addi %d3,%d8,8
800041b4:	1d ff c4 fd 	j 80003d3c <_malloc_r+0x24>
800041b8:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
800041bc:	8f 18 40 81 	or %d8,%d8,1
800041c0:	8f 13 40 41 	or %d4,%d3,1
800041c4:	59 c8 04 00 	st.w [%a12]4,%d8
800041c8:	b5 d2 14 00 	st.a [%a13]20,%a2
800041cc:	b5 d2 10 00 	st.a [%a13]16,%a2
800041d0:	b5 24 0c 00 	st.a [%a2]12,%a4
800041d4:	b5 24 08 00 	st.a [%a2]8,%a4
800041d8:	59 24 04 00 	st.w [%a2]4,%d4
800041dc:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800041e0:	40 e4       	mov.aa %a4,%a14
800041e2:	74 23       	st.w [%a2],%d3
800041e4:	6d 00 86 02 	call 800046f0 <__malloc_unlock>
800041e8:	d9 cc 08 00 	lea %a12,[%a12]8
800041ec:	1d ff 7e fe 	j 80003ee8 <_malloc_r+0x1d0>
800041f0:	8f a2 1f 30 	sh %d3,%d2,-6
800041f4:	1b 83 03 50 	addi %d5,%d3,56
800041f8:	1b 93 03 30 	addi %d3,%d3,57
800041fc:	8f 33 00 40 	sh %d4,%d3,3
80004200:	1d ff 8c ff 	j 80004118 <_malloc_r+0x400>
80004204:	1b c2 05 60 	addi %d6,%d2,92
80004208:	1b b2 05 50 	addi %d5,%d2,91
8000420c:	8f 36 00 30 	sh %d3,%d6,3
80004210:	1d ff d3 fd 	j 80003db6 <_malloc_r+0x9e>
80004214:	40 52       	mov.aa %a2,%a5
80004216:	d4 22       	ld.a %a2,[%a2]
80004218:	b0 85       	add.a %a5,-8
8000421a:	c2 f6       	add %d6,-1
8000421c:	7d 52 ba 80 	jne.a %a2,%a5,80004390 <_malloc_r+0x678>
80004220:	8f 36 00 31 	and %d3,%d6,3
80004224:	df 03 f8 ff 	jne %d3,0,80004214 <_malloc_r+0x4fc>
80004228:	19 d3 04 00 	ld.w %d3,[%a13]4
8000422c:	d9 d2 04 00 	lea %a2,[%a13]4
80004230:	0f 23 e0 30 	andn %d3,%d3,%d2
80004234:	74 23       	st.w [%a2],%d3
80004236:	06 12       	sh %d2,1
80004238:	1b f2 ff 4f 	addi %d4,%d2,-1
8000423c:	3f 34 06 80 	jlt.u %d4,%d3,80004248 <_malloc_r+0x530>
80004240:	1d ff 6a fe 	j 80003f14 <_malloc_r+0x1fc>
80004244:	c2 47       	add %d7,4
80004246:	06 12       	sh %d2,1
80004248:	0f 32 80 40 	and %d4,%d2,%d3
8000424c:	df 04 fc 7f 	jeq %d4,0,80004244 <_malloc_r+0x52c>
80004250:	02 76       	mov %d6,%d7
80004252:	1d ff 19 fe 	j 80003e84 <_malloc_r+0x16c>
80004256:	8f fc 07 31 	and %d3,%d12,127
8000425a:	df 03 9c fe 	jne %d3,0,80003f92 <_malloc_r+0x27a>
8000425e:	0b ab 00 30 	add %d3,%d11,%d10
80004262:	99 dc 08 00 	ld.a %a12,[%a13]8
80004266:	8f 13 40 31 	or %d3,%d3,1
8000426a:	59 c3 04 00 	st.w [%a12]4,%d3
8000426e:	1d ff e3 fe 	j 80004034 <_malloc_r+0x31c>
80004272:	59 f9 08 50 	st.w [%a15]328,%d9
80004276:	1d ff 98 fe 	j 80003fa6 <_malloc_r+0x28e>
8000427a:	99 dc 08 00 	ld.a %a12,[%a13]8
8000427e:	19 c3 04 00 	ld.w %d3,[%a12]4
80004282:	1d ff e9 fe 	j 80004054 <_malloc_r+0x33c>
80004286:	19 d3 04 00 	ld.w %d3,[%a13]4
8000428a:	86 e5       	sha %d5,-2
8000428c:	d7 13 01 35 	insert %d3,%d3,1,%d5,1
80004290:	d9 d5 04 00 	lea %a5,[%a13]4
80004294:	74 53       	st.w [%a5],%d3
80004296:	1d ff 57 ff 	j 80004144 <_malloc_r+0x42c>
8000429a:	0b a9 00 20 	add %d2,%d9,%d10
8000429e:	32 52       	rsub %d2
800042a0:	8f f2 07 c1 	and %d12,%d2,127
800042a4:	02 c4       	mov %d4,%d12
800042a6:	40 e4       	mov.aa %a4,%a14
800042a8:	6d 00 2a 02 	call 800046fc <_sbrk_r>
800042ac:	80 22       	mov.d %d2,%a2
800042ae:	df f2 90 fe 	jne %d2,-1,80003fce <_malloc_r+0x2b6>
800042b2:	82 0c       	mov %d12,0
800042b4:	1d ff 90 fe 	j 80003fd4 <_malloc_r+0x2bc>
800042b8:	8b 53 a5 42 	ge.u %d4,%d3,85
800042bc:	df 04 22 80 	jne %d4,0,80004300 <_malloc_r+0x5e8>
800042c0:	8f 42 1f 30 	sh %d3,%d2,-12
800042c4:	1b e3 06 50 	addi %d5,%d3,110
800042c8:	1b f3 06 30 	addi %d3,%d3,111
800042cc:	8f 33 00 40 	sh %d4,%d3,3
800042d0:	1d ff 24 ff 	j 80004118 <_malloc_r+0x400>
800042d4:	8b 52 b5 32 	ge.u %d3,%d2,341
800042d8:	df 03 22 80 	jne %d3,0,8000431c <_malloc_r+0x604>
800042dc:	8f 18 1f 60 	sh %d6,%d8,-15
800042e0:	1b 76 07 50 	addi %d5,%d6,119
800042e4:	1b 86 07 60 	addi %d6,%d6,120
800042e8:	8f 36 00 30 	sh %d3,%d6,3
800042ec:	1d ff 65 fd 	j 80003db6 <_malloc_r+0x9e>
800042f0:	60 9c       	mov.a %a12,%d9
800042f2:	1d ff a1 fe 	j 80004034 <_malloc_r+0x31c>
800042f6:	82 12       	mov %d2,1
800042f8:	59 22 04 00 	st.w [%a2]4,%d2
800042fc:	1d ff b6 fe 	j 80004068 <_malloc_r+0x350>
80004300:	8b 53 b5 42 	ge.u %d4,%d3,341
80004304:	df 04 34 80 	jne %d4,0,8000436c <_malloc_r+0x654>
80004308:	8f 12 1f 30 	sh %d3,%d2,-15
8000430c:	1b 73 07 50 	addi %d5,%d3,119
80004310:	1b 83 07 30 	addi %d3,%d3,120
80004314:	8f 33 00 40 	sh %d4,%d3,3
80004318:	1d ff 00 ff 	j 80004118 <_malloc_r+0x400>
8000431c:	3b 50 55 40 	mov %d4,1365
80004320:	3b 80 3f 30 	mov %d3,1016
80004324:	3b f0 07 60 	mov %d6,127
80004328:	3b e0 07 50 	mov %d5,126
8000432c:	7f 42 45 fd 	jge.u %d2,%d4,80003db6 <_malloc_r+0x9e>
80004330:	8f e8 1e 60 	sh %d6,%d8,-18
80004334:	1b c6 07 50 	addi %d5,%d6,124
80004338:	1b d6 07 60 	addi %d6,%d6,125
8000433c:	8f 36 00 30 	sh %d3,%d6,3
80004340:	1d ff 3b fd 	j 80003db6 <_malloc_r+0x9e>
80004344:	c2 8e       	add %d14,-8
80004346:	42 ea       	add %d10,%d14
80004348:	a2 9a       	sub %d10,%d9
8000434a:	82 0c       	mov %d12,0
8000434c:	1d ff 44 fe 	j 80003fd4 <_malloc_r+0x2bc>
80004350:	d9 c5 08 00 	lea %a5,[%a12]8
80004354:	40 e4       	mov.aa %a4,%a14
80004356:	6d 00 85 00 	call 80004460 <_free_r>
8000435a:	99 dc 08 00 	ld.a %a12,[%a13]8
8000435e:	60 d2       	mov.a %a2,%d13
80004360:	19 c3 04 00 	ld.w %d3,[%a12]4
80004364:	19 22 70 a0 	ld.w %d2,[%a2]1712
80004368:	1d ff 66 fe 	j 80004034 <_malloc_r+0x31c>
8000436c:	3b 50 55 70 	mov %d7,1365
80004370:	3b 80 3f 40 	mov %d4,1016
80004374:	3b e0 07 50 	mov %d5,126
80004378:	7f 73 d0 fe 	jge.u %d3,%d7,80004118 <_malloc_r+0x400>
8000437c:	8f e2 1e 30 	sh %d3,%d2,-18
80004380:	1b c3 07 50 	addi %d5,%d3,124
80004384:	1b d3 07 30 	addi %d3,%d3,125
80004388:	8f 33 00 40 	sh %d4,%d3,3
8000438c:	1d ff c6 fe 	j 80004118 <_malloc_r+0x400>
80004390:	19 d3 04 00 	ld.w %d3,[%a13]4
80004394:	1d ff 51 ff 	j 80004236 <_malloc_r+0x51e>

80004398 <_malloc_trim_r>:
80004398:	91 00 00 c6 	movh.a %a12,24576
8000439c:	02 49       	mov %d9,%d4
8000439e:	80 48       	mov.d %d8,%a4
800043a0:	d9 cc 10 50 	lea %a12,[%a12]336 <60000150 <__malloc_av_>>
800043a4:	6d 00 a5 01 	call 800046ee <__malloc_lock>
800043a8:	99 c2 08 00 	ld.a %a2,[%a12]8 <60000008 <LCF_DSPR1_START+0x8>>
800043ac:	8b f9 06 21 	rsub %d2,%d9,111
800043b0:	19 2a 04 00 	ld.w %d10,[%a2]4
800043b4:	8f 3a c0 a1 	andn %d10,%d10,3
800043b8:	42 a2       	add %d2,%d10
800043ba:	8f f2 c7 21 	andn %d2,%d2,127
800043be:	1b 02 f8 9f 	addi %d9,%d2,-128
800043c2:	8b 09 88 22 	ge %d2,%d9,128
800043c6:	df 02 0c 00 	jeq %d2,0,800043de <_malloc_trim_r+0x46>
800043ca:	60 84       	mov.a %a4,%d8
800043cc:	82 04       	mov %d4,0
800043ce:	6d 00 97 01 	call 800046fc <_sbrk_r>
800043d2:	19 c2 08 00 	ld.w %d2,[%a12]8 <60000008 <LCF_DSPR1_START+0x8>>
800043d6:	80 23       	mov.d %d3,%a2
800043d8:	42 a2       	add %d2,%d10
800043da:	5f 23 07 00 	jeq %d3,%d2,800043e8 <_malloc_trim_r+0x50>
800043de:	60 84       	mov.a %a4,%d8
800043e0:	6d 00 88 01 	call 800046f0 <__malloc_unlock>
800043e4:	82 02       	mov %d2,0
800043e6:	00 90       	ret 
800043e8:	60 84       	mov.a %a4,%d8
800043ea:	8b 09 00 41 	rsub %d4,%d9,0
800043ee:	6d 00 87 01 	call 800046fc <_sbrk_r>
800043f2:	80 22       	mov.d %d2,%a2
800043f4:	df f2 18 00 	jeq %d2,-1,80004424 <_malloc_trim_r+0x8c>
800043f8:	0b 9a 80 20 	sub %d2,%d10,%d9
800043fc:	99 c2 08 00 	ld.a %a2,[%a12]8
80004400:	8f 12 40 21 	or %d2,%d2,1
80004404:	60 84       	mov.a %a4,%d8
80004406:	59 22 04 00 	st.w [%a2]4,%d2
8000440a:	91 00 00 26 	movh.a %a2,24576
8000440e:	d9 23 70 a0 	lea %a3,[%a2]1712 <600006b0 <__malloc_current_mallinfo>>
80004412:	54 32       	ld.w %d2,[%a3]
80004414:	0b 92 80 90 	sub %d9,%d2,%d9
80004418:	59 29 70 a0 	st.w [%a2]1712 <600006b0 <__malloc_current_mallinfo>>,%d9
8000441c:	6d 00 6a 01 	call 800046f0 <__malloc_unlock>
80004420:	82 12       	mov %d2,1
80004422:	00 90       	ret 
80004424:	60 84       	mov.a %a4,%d8
80004426:	82 04       	mov %d4,0
80004428:	6d 00 6a 01 	call 800046fc <_sbrk_r>
8000442c:	80 24       	mov.d %d4,%a2
8000442e:	99 c2 08 00 	ld.a %a2,[%a12]8
80004432:	80 22       	mov.d %d2,%a2
80004434:	0b 24 80 30 	sub %d3,%d4,%d2
80004438:	8b 03 41 22 	lt %d2,%d3,16
8000443c:	df 02 d1 ff 	jne %d2,0,800043de <_malloc_trim_r+0x46>
80004440:	91 00 00 36 	movh.a %a3,24576
80004444:	19 32 08 50 	ld.w %d2,[%a3]328 <60000148 <__malloc_sbrk_base>>
80004448:	8f 13 40 31 	or %d3,%d3,1
8000444c:	0b 24 80 20 	sub %d2,%d4,%d2
80004450:	91 00 00 36 	movh.a %a3,24576
80004454:	59 23 04 00 	st.w [%a2]4,%d3
80004458:	59 32 70 a0 	st.w [%a3]1712 <600006b0 <__malloc_current_mallinfo>>,%d2
8000445c:	1d ff c1 ff 	j 800043de <_malloc_trim_r+0x46>

80004460 <_free_r>:
80004460:	80 48       	mov.d %d8,%a4
80004462:	40 5c       	mov.aa %a12,%a5
80004464:	bd 05 5c 00 	jz.a %a5,8000451c <_free_r+0xbc>
80004468:	6d 00 43 01 	call 800046ee <__malloc_lock>
8000446c:	19 c3 fc ff 	ld.w %d3,[%a12]-4
80004470:	d9 c3 f8 ff 	lea %a3,[%a12]-8
80004474:	8f 13 c0 21 	andn %d2,%d3,1
80004478:	91 00 00 66 	movh.a %a6,24576
8000447c:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
80004480:	d9 66 10 50 	lea %a6,[%a6]336 <60000150 <__malloc_av_>>
80004484:	99 64 08 00 	ld.a %a4,[%a6]8 <60000008 <LCF_DSPR1_START+0x8>>
80004488:	19 24 04 00 	ld.w %d4,[%a2]4 <60000008 <LCF_DSPR1_START+0x8>>
8000448c:	8f 34 c0 41 	andn %d4,%d4,3
80004490:	7d 24 ae 00 	jeq.a %a4,%a2,800045ec <_free_r+0x18c>
80004494:	59 24 04 00 	st.w [%a2]4,%d4
80004498:	01 24 00 56 	addsc.a %a5,%a2,%d4,0
8000449c:	6f 03 41 80 	jnz.t %d3,0,8000451e <_free_r+0xbe>
800044a0:	19 c3 f8 ff 	ld.w %d3,[%a12]-8
800044a4:	60 34       	mov.a %a4,%d3
800044a6:	42 32       	add %d2,%d3
800044a8:	01 43 20 30 	sub.a %a3,%a3,%a4
800044ac:	99 34 08 00 	ld.a %a4,[%a3]8
800044b0:	19 53 04 00 	ld.w %d3,[%a5]4
800044b4:	d9 65 08 00 	lea %a5,[%a6]8 <60000008 <LCF_DSPR1_START+0x8>>
800044b8:	8f 13 00 31 	and %d3,%d3,1
800044bc:	7d 54 81 00 	jeq.a %a4,%a5,800045be <_free_r+0x15e>
800044c0:	99 37 0c 00 	ld.a %a7,[%a3]12
800044c4:	b5 47 0c 00 	st.a [%a4]12,%a7
800044c8:	b5 74 08 00 	st.a [%a7]8,%a4
800044cc:	df 03 c7 00 	jeq %d3,0,8000465a <_free_r+0x1fa>
800044d0:	8f 12 40 31 	or %d3,%d2,1
800044d4:	59 33 04 00 	st.w [%a3]4,%d3
800044d8:	74 22       	st.w [%a2],%d2
800044da:	3b 00 20 30 	mov %d3,512
800044de:	7f 32 44 80 	jge.u %d2,%d3,80004566 <_free_r+0x106>
800044e2:	19 64 04 00 	ld.w %d4,[%a6]4 <60000004 <LCF_DSPR1_START+0x4>>
800044e6:	8f b2 1f 30 	sh %d3,%d2,-5
800044ea:	8f 72 c0 21 	andn %d2,%d2,7
800044ee:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
800044f2:	1b 82 00 20 	addi %d2,%d2,8
800044f6:	d9 62 04 00 	lea %a2,[%a6]4 <60000004 <LCF_DSPR1_START+0x4>>
800044fa:	01 62 00 66 	addsc.a %a6,%a6,%d2,0
800044fe:	74 23       	st.w [%a2],%d3
80004500:	d4 65       	ld.a %a5,[%a6]
80004502:	40 62       	mov.aa %a2,%a6
80004504:	b0 82       	add.a %a2,-8
80004506:	b5 32 0c 00 	st.a [%a3]12,%a2
8000450a:	b5 35 08 00 	st.a [%a3]8,%a5
8000450e:	f4 63       	st.a [%a6],%a3
80004510:	b5 53 0c 00 	st.a [%a5]12,%a3
80004514:	60 84       	mov.a %a4,%d8
80004516:	6d 00 ed 00 	call 800046f0 <__malloc_unlock>
8000451a:	00 90       	ret 
8000451c:	00 90       	ret 
8000451e:	19 53 04 00 	ld.w %d3,[%a5]4
80004522:	6f 03 19 80 	jnz.t %d3,0,80004554 <_free_r+0xf4>
80004526:	42 42       	add %d2,%d4
80004528:	d9 65 08 00 	lea %a5,[%a6]8
8000452c:	99 24 08 00 	ld.a %a4,[%a2]8
80004530:	01 32 00 76 	addsc.a %a7,%a3,%d2,0
80004534:	8f 12 40 31 	or %d3,%d2,1
80004538:	7d 54 9c 00 	jeq.a %a4,%a5,80004670 <_free_r+0x210>
8000453c:	d9 22 0c 00 	lea %a2,[%a2]12
80004540:	d4 22       	ld.a %a2,[%a2]
80004542:	b5 42 0c 00 	st.a [%a4]12,%a2
80004546:	b5 24 08 00 	st.a [%a2]8,%a4
8000454a:	59 33 04 00 	st.w [%a3]4,%d3
8000454e:	74 72       	st.w [%a7],%d2
80004550:	1d ff c5 ff 	j 800044da <_free_r+0x7a>
80004554:	8f 12 40 31 	or %d3,%d2,1
80004558:	59 c3 fc ff 	st.w [%a12]-4,%d3
8000455c:	74 22       	st.w [%a2],%d2
8000455e:	3b 00 20 30 	mov %d3,512
80004562:	3f 32 c0 ff 	jlt.u %d2,%d3,800044e2 <_free_r+0x82>
80004566:	8f 72 1f 30 	sh %d3,%d2,-9
8000456a:	ff 53 66 80 	jge.u %d3,5,80004636 <_free_r+0x1d6>
8000456e:	8f a2 1f 30 	sh %d3,%d2,-6
80004572:	1b 83 03 50 	addi %d5,%d3,56
80004576:	1b 93 03 30 	addi %d3,%d3,57
8000457a:	8f 33 00 40 	sh %d4,%d3,3
8000457e:	01 64 00 56 	addsc.a %a5,%a6,%d4,0
80004582:	40 52       	mov.aa %a2,%a5
80004584:	d4 22       	ld.a %a2,[%a2]
80004586:	b0 85       	add.a %a5,-8
80004588:	7d 25 81 00 	jeq.a %a5,%a2,8000468a <_free_r+0x22a>
8000458c:	19 23 04 00 	ld.w %d3,[%a2]4
80004590:	8f 33 c0 31 	andn %d3,%d3,3
80004594:	7f 32 07 80 	jge.u %d2,%d3,800045a2 <_free_r+0x142>
80004598:	d9 22 08 00 	lea %a2,[%a2]8
8000459c:	d4 22       	ld.a %a2,[%a2]
8000459e:	7d 25 f7 ff 	jne.a %a5,%a2,8000458c <_free_r+0x12c>
800045a2:	99 25 0c 00 	ld.a %a5,[%a2]12
800045a6:	b5 35 0c 00 	st.a [%a3]12,%a5
800045aa:	b5 32 08 00 	st.a [%a3]8,%a2
800045ae:	b5 53 08 00 	st.a [%a5]8,%a3
800045b2:	60 84       	mov.a %a4,%d8
800045b4:	b5 23 0c 00 	st.a [%a2]12,%a3
800045b8:	6d 00 9c 00 	call 800046f0 <__malloc_unlock>
800045bc:	00 90       	ret 
800045be:	df 03 91 80 	jne %d3,0,800046e0 <_free_r+0x280>
800045c2:	99 24 0c 00 	ld.a %a4,[%a2]12
800045c6:	d9 22 08 00 	lea %a2,[%a2]8
800045ca:	d4 22       	ld.a %a2,[%a2]
800045cc:	42 42       	add %d2,%d4
800045ce:	8f 12 40 31 	or %d3,%d2,1
800045d2:	b5 24 0c 00 	st.a [%a2]12,%a4
800045d6:	b5 42 08 00 	st.a [%a4]8,%a2
800045da:	59 33 04 00 	st.w [%a3]4,%d3
800045de:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
800045e2:	60 84       	mov.a %a4,%d8
800045e4:	74 32       	st.w [%a3],%d2
800045e6:	6d 00 85 00 	call 800046f0 <__malloc_unlock>
800045ea:	00 90       	ret 
800045ec:	42 42       	add %d2,%d4
800045ee:	6f 03 0f 80 	jnz.t %d3,0,8000460c <_free_r+0x1ac>
800045f2:	54 33       	ld.w %d3,[%a3]
800045f4:	60 32       	mov.a %a2,%d3
800045f6:	42 32       	add %d2,%d3
800045f8:	01 23 20 30 	sub.a %a3,%a3,%a2
800045fc:	99 32 0c 00 	ld.a %a2,[%a3]12
80004600:	99 34 08 00 	ld.a %a4,[%a3]8
80004604:	b5 42 0c 00 	st.a [%a4]12,%a2
80004608:	b5 24 08 00 	st.a [%a2]8,%a4
8000460c:	8f 12 40 31 	or %d3,%d2,1
80004610:	91 00 00 26 	movh.a %a2,24576
80004614:	59 33 04 00 	st.w [%a3]4,%d3
80004618:	19 23 0c 50 	ld.w %d3,[%a2]332 <6000014c <__malloc_trim_threshold>>
8000461c:	b5 63 08 00 	st.a [%a6]8 <6000014c <__malloc_trim_threshold>>,%a3
80004620:	3f 32 7a ff 	jlt.u %d2,%d3,80004514 <_free_r+0xb4>
80004624:	91 00 00 26 	movh.a %a2,24576
80004628:	19 24 60 b0 	ld.w %d4,[%a2]1760 <600006e0 <__malloc_top_pad>>
8000462c:	60 84       	mov.a %a4,%d8
8000462e:	6d ff b5 fe 	call 80004398 <_malloc_trim_r>
80004632:	1d ff 71 ff 	j 80004514 <_free_r+0xb4>
80004636:	8b 53 a1 42 	ge.u %d4,%d3,21
8000463a:	df 04 13 00 	jeq %d4,0,80004660 <_free_r+0x200>
8000463e:	8b 53 a5 42 	ge.u %d4,%d3,85
80004642:	df 04 2f 80 	jne %d4,0,800046a0 <_free_r+0x240>
80004646:	8f 42 1f 30 	sh %d3,%d2,-12
8000464a:	1b e3 06 50 	addi %d5,%d3,110
8000464e:	1b f3 06 30 	addi %d3,%d3,111
80004652:	8f 33 00 40 	sh %d4,%d3,3
80004656:	1d ff 94 ff 	j 8000457e <_free_r+0x11e>
8000465a:	42 42       	add %d2,%d4
8000465c:	1d ff 68 ff 	j 8000452c <_free_r+0xcc>
80004660:	1b b3 05 50 	addi %d5,%d3,91
80004664:	1b c3 05 30 	addi %d3,%d3,92
80004668:	8f 33 00 40 	sh %d4,%d3,3
8000466c:	1d ff 89 ff 	j 8000457e <_free_r+0x11e>
80004670:	b5 63 14 00 	st.a [%a6]20,%a3
80004674:	b5 63 10 00 	st.a [%a6]16,%a3
80004678:	b5 35 0c 00 	st.a [%a3]12,%a5
8000467c:	b5 35 08 00 	st.a [%a3]8,%a5
80004680:	59 33 04 00 	st.w [%a3]4,%d3
80004684:	74 72       	st.w [%a7],%d2
80004686:	1d ff 47 ff 	j 80004514 <_free_r+0xb4>
8000468a:	19 63 04 00 	ld.w %d3,[%a6]4
8000468e:	8f e5 3f 20 	sha %d2,%d5,-2
80004692:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80004696:	d9 64 04 00 	lea %a4,[%a6]4
8000469a:	74 42       	st.w [%a4],%d2
8000469c:	1d ff 85 ff 	j 800045a6 <_free_r+0x146>
800046a0:	8b 53 b5 42 	ge.u %d4,%d3,341
800046a4:	df 04 0c 80 	jne %d4,0,800046bc <_free_r+0x25c>
800046a8:	8f 12 1f 30 	sh %d3,%d2,-15
800046ac:	1b 73 07 50 	addi %d5,%d3,119
800046b0:	1b 83 07 30 	addi %d3,%d3,120
800046b4:	8f 33 00 40 	sh %d4,%d3,3
800046b8:	1d ff 63 ff 	j 8000457e <_free_r+0x11e>
800046bc:	3b 50 55 60 	mov %d6,1365
800046c0:	3b 80 3f 40 	mov %d4,1016
800046c4:	3b e0 07 50 	mov %d5,126
800046c8:	7f 63 5b ff 	jge.u %d3,%d6,8000457e <_free_r+0x11e>
800046cc:	8f e2 1e 30 	sh %d3,%d2,-18
800046d0:	1b c3 07 50 	addi %d5,%d3,124
800046d4:	1b d3 07 30 	addi %d3,%d3,125
800046d8:	8f 33 00 40 	sh %d4,%d3,3
800046dc:	1d ff 51 ff 	j 8000457e <_free_r+0x11e>
800046e0:	8f 12 40 31 	or %d3,%d2,1
800046e4:	59 33 04 00 	st.w [%a3]4,%d3
800046e8:	74 22       	st.w [%a2],%d2
800046ea:	1d ff 15 ff 	j 80004514 <_free_r+0xb4>

800046ee <__malloc_lock>:
800046ee:	00 90       	ret 

800046f0 <__malloc_unlock>:
800046f0:	00 90       	ret 

800046f2 <__errno>:
800046f2:	91 00 00 26 	movh.a %a2,24576
800046f6:	99 22 28 00 	ld.a %a2,[%a2]40 <60000028 <_impure_ptr>>
800046fa:	00 90       	ret 

800046fc <_sbrk_r>:
800046fc:	82 02       	mov %d2,0
800046fe:	91 00 00 c6 	movh.a %a12,24576
80004702:	40 4d       	mov.aa %a13,%a4
80004704:	59 c2 68 b0 	st.w [%a12]1768 <600006e8 <errno>>,%d2
80004708:	6d 00 24 00 	call 80004750 <sbrk>
8000470c:	80 22       	mov.d %d2,%a2
8000470e:	df f2 04 00 	jeq %d2,-1,80004716 <_sbrk_r+0x1a>
80004712:	60 22       	mov.a %a2,%d2
80004714:	00 90       	ret 
80004716:	19 c3 68 b0 	ld.w %d3,[%a12]1768
8000471a:	df 03 fc 7f 	jeq %d3,0,80004712 <_sbrk_r+0x16>
8000471e:	60 22       	mov.a %a2,%d2
80004720:	74 d3       	st.w [%a13],%d3
80004722:	00 90       	ret 

80004724 <abort>:
80004724:	00 a0       	debug 
80004726:	7b e0 ea 2d 	movh %d2,57006
8000472a:	1b f2 ee 2b 	addi %d2,%d2,-16657
8000472e:	60 2e       	mov.a %a14,%d2
80004730:	1d 00 04 00 	j 80004738 <_exit>
80004734:	1d 00 00 00 	j 80004734 <abort+0x10>

80004738 <_exit>:
80004738:	df 04 06 00 	jeq %d4,0,80004744 <_exit+0xc>
8000473c:	60 4e       	mov.a %a14,%d4
8000473e:	00 a0       	debug 
80004740:	1d 00 00 00 	j 80004740 <_exit+0x8>
80004744:	bb d0 00 29 	mov.u %d2,36877
80004748:	60 2e       	mov.a %a14,%d2
8000474a:	00 a0       	debug 
8000474c:	1d ff fa ff 	j 80004740 <_exit+0x8>

80004750 <sbrk>:
80004750:	91 00 00 36 	movh.a %a3,24576
80004754:	99 32 58 50 	ld.a %a2,[%a3]1368 <60000558 <heap_top.0>>
80004758:	91 00 00 46 	movh.a %a4,24576
8000475c:	80 22       	mov.d %d2,%a2
8000475e:	42 24       	add %d4,%d2
80004760:	80 42       	mov.d %d2,%a4
80004762:	1b 82 9a 21 	addi %d2,%d2,6568
80004766:	3f 42 0c 80 	jlt.u %d2,%d4,8000477e <sbrk+0x2e>
8000476a:	91 00 00 46 	movh.a %a4,24576
8000476e:	80 42       	mov.d %d2,%a4
80004770:	1b 82 9a 20 	addi %d2,%d2,2472
80004774:	3f 24 0d 80 	jlt.u %d4,%d2,8000478e <sbrk+0x3e>
80004778:	59 34 58 50 	st.w [%a3]1368 <60000558 <heap_top.0>>,%d4
8000477c:	00 90       	ret 
8000477e:	6d ff ba ff 	call 800046f2 <__errno>
80004782:	3b c0 00 20 	mov %d2,12
80004786:	74 22       	st.w [%a2],%d2
80004788:	a0 02       	mov.a %a2,0
8000478a:	b0 f2       	add.a %a2,-1
8000478c:	00 90       	ret 
8000478e:	6d ff cb ff 	call 80004724 <abort>

80004792 <__do_global_ctors_aux>:
80004792:	91 00 00 28 	movh.a %a2,32768
80004796:	d9 22 58 f4 	lea %a2,[%a2]18392 <800047d8 <__CTOR_END__>>
8000479a:	19 22 fc ff 	ld.w %d2,[%a2]-4 <7ffffffc <__CSA0_END+0xffe43fc>>
8000479e:	d9 23 fc ff 	lea %a3,[%a2]-4 <7ffffffc <__CSA0_END+0xffe43fc>>
800047a2:	df f2 0a 00 	jeq %d2,-1,800047b6 <__do_global_ctors_aux+0x24>
800047a6:	40 3c       	mov.aa %a12,%a3
800047a8:	60 22       	mov.a %a2,%d2
800047aa:	b0 cc       	add.a %a12,-4
800047ac:	2d 02 00 00 	calli %a2
800047b0:	54 c2       	ld.w %d2,[%a12]
800047b2:	df f2 fb ff 	jne %d2,-1,800047a8 <__do_global_ctors_aux+0x16>
800047b6:	00 90       	ret 

Disassembly of section .init:

800047b8 <_init>:
800047b8:	6d ff 9c de 	call 800004f0 <frame_dummy>
800047bc:	6d ff eb ff 	call 80004792 <__do_global_ctors_aux>
800047c0:	00 90       	ret 
800047c2:	00 00       	nop 
800047c4:	00 00       	nop 
	...

Disassembly of section .fini:

800047c8 <_fini>:
800047c8:	6d ff 62 de 	call 8000048c <__do_global_dtors_aux>
800047cc:	00 90       	ret 
	...

Disassembly of section .traptab_tc2:

801f6100 <IfxCpu_Trap_vectorTable2>:
#pragma ghs section text=".traptab_cpu2"
#endif

void IfxCpu_Trap_vectorTable2(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6100:	0d 00 00 02 	svlcx 
801f6104:	02 f4       	mov %d4,%d15
801f6106:	91 00 00 28 	movh.a %a2,32768
801f610a:	d9 22 84 d1 	lea %a2,[%a2]6980 <80001b44 <IfxCpu_Trap_memoryManagementError>>
801f610e:	dc 02       	ji %a2
801f6110:	00 80       	rfe 
	...
801f611e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6120:	0d 00 00 02 	svlcx 
801f6124:	02 f4       	mov %d4,%d15
801f6126:	91 00 00 28 	movh.a %a2,32768
801f612a:	d9 22 b2 d1 	lea %a2,[%a2]7026 <80001b72 <IfxCpu_Trap_internalProtectionError>>
801f612e:	dc 02       	ji %a2
801f6130:	00 80       	rfe 
	...
801f613e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6140:	0d 00 00 02 	svlcx 
801f6144:	02 f4       	mov %d4,%d15
801f6146:	91 00 00 28 	movh.a %a2,32768
801f614a:	d9 22 a0 e1 	lea %a2,[%a2]7072 <80001ba0 <IfxCpu_Trap_instructionError>>
801f614e:	dc 02       	ji %a2
801f6150:	00 80       	rfe 
	...
801f615e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6160:	02 f4       	mov %d4,%d15
801f6162:	91 00 00 28 	movh.a %a2,32768
801f6166:	d9 22 8e f1 	lea %a2,[%a2]7118 <80001bce <IfxCpu_Trap_contextManagementError>>
801f616a:	dc 02       	ji %a2
801f616c:	00 80       	rfe 
	...
801f617e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6180:	0d 00 00 02 	svlcx 
801f6184:	02 f4       	mov %d4,%d15
801f6186:	91 00 00 28 	movh.a %a2,32768
801f618a:	d9 22 bc f1 	lea %a2,[%a2]7164 <80001bfc <IfxCpu_Trap_busError>>
801f618e:	dc 02       	ji %a2
801f6190:	00 80       	rfe 
	...
801f619e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f61a0:	0d 00 00 02 	svlcx 
801f61a4:	02 f4       	mov %d4,%d15
801f61a6:	91 00 00 28 	movh.a %a2,32768
801f61aa:	d9 22 ea 01 	lea %a2,[%a2]7210 <80001c2a <IfxCpu_Trap_assertion>>
801f61ae:	dc 02       	ji %a2
801f61b0:	00 80       	rfe 
	...
801f61be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu2);
801f61c0:	0d 00 00 02 	svlcx 
801f61c4:	02 f4       	mov %d4,%d15
801f61c6:	91 00 00 28 	movh.a %a2,32768
801f61ca:	d9 22 f6 21 	lea %a2,[%a2]7350 <80001cb6 <IfxCpu_Trap_systemCall_Cpu2>>
801f61ce:	dc 02       	ji %a2
801f61d0:	00 80       	rfe 
	...
801f61de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f61e0:	0d 00 00 02 	svlcx 
801f61e4:	02 f4       	mov %d4,%d15
801f61e6:	91 00 00 28 	movh.a %a2,32768
801f61ea:	d9 22 e2 31 	lea %a2,[%a2]7394 <80001ce2 <IfxCpu_Trap_nonMaskableInterrupt>>
801f61ee:	dc 02       	ji %a2
801f61f0:	00 80       	rfe 
}
801f61f2:	00 90       	ret 

801f61f4 <IfxCpu_Trap_vectorTable2_end>:
	...

Disassembly of section .traptab_tc1:

801f6200 <IfxCpu_Trap_vectorTable1>:
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6200:	0d 00 00 02 	svlcx 
801f6204:	02 f4       	mov %d4,%d15
801f6206:	91 00 00 28 	movh.a %a2,32768
801f620a:	d9 22 84 d1 	lea %a2,[%a2]6980 <80001b44 <IfxCpu_Trap_memoryManagementError>>
801f620e:	dc 02       	ji %a2
801f6210:	00 80       	rfe 
	...
801f621e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6220:	0d 00 00 02 	svlcx 
801f6224:	02 f4       	mov %d4,%d15
801f6226:	91 00 00 28 	movh.a %a2,32768
801f622a:	d9 22 b2 d1 	lea %a2,[%a2]7026 <80001b72 <IfxCpu_Trap_internalProtectionError>>
801f622e:	dc 02       	ji %a2
801f6230:	00 80       	rfe 
	...
801f623e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6240:	0d 00 00 02 	svlcx 
801f6244:	02 f4       	mov %d4,%d15
801f6246:	91 00 00 28 	movh.a %a2,32768
801f624a:	d9 22 a0 e1 	lea %a2,[%a2]7072 <80001ba0 <IfxCpu_Trap_instructionError>>
801f624e:	dc 02       	ji %a2
801f6250:	00 80       	rfe 
	...
801f625e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6260:	02 f4       	mov %d4,%d15
801f6262:	91 00 00 28 	movh.a %a2,32768
801f6266:	d9 22 8e f1 	lea %a2,[%a2]7118 <80001bce <IfxCpu_Trap_contextManagementError>>
801f626a:	dc 02       	ji %a2
801f626c:	00 80       	rfe 
	...
801f627e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6280:	0d 00 00 02 	svlcx 
801f6284:	02 f4       	mov %d4,%d15
801f6286:	91 00 00 28 	movh.a %a2,32768
801f628a:	d9 22 bc f1 	lea %a2,[%a2]7164 <80001bfc <IfxCpu_Trap_busError>>
801f628e:	dc 02       	ji %a2
801f6290:	00 80       	rfe 
	...
801f629e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f62a0:	0d 00 00 02 	svlcx 
801f62a4:	02 f4       	mov %d4,%d15
801f62a6:	91 00 00 28 	movh.a %a2,32768
801f62aa:	d9 22 ea 01 	lea %a2,[%a2]7210 <80001c2a <IfxCpu_Trap_assertion>>
801f62ae:	dc 02       	ji %a2
801f62b0:	00 80       	rfe 
	...
801f62be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu1);
801f62c0:	0d 00 00 02 	svlcx 
801f62c4:	02 f4       	mov %d4,%d15
801f62c6:	91 00 00 28 	movh.a %a2,32768
801f62ca:	d9 22 ca 21 	lea %a2,[%a2]7306 <80001c8a <IfxCpu_Trap_systemCall_Cpu1>>
801f62ce:	dc 02       	ji %a2
801f62d0:	00 80       	rfe 
	...
801f62de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f62e0:	0d 00 00 02 	svlcx 
801f62e4:	02 f4       	mov %d4,%d15
801f62e6:	91 00 00 28 	movh.a %a2,32768
801f62ea:	d9 22 e2 31 	lea %a2,[%a2]7394 <80001ce2 <IfxCpu_Trap_nonMaskableInterrupt>>
801f62ee:	dc 02       	ji %a2
801f62f0:	00 80       	rfe 
}
801f62f2:	00 90       	ret 

801f62f4 <IfxCpu_Trap_vectorTable1_end>:
	...

Disassembly of section .inttab_tc0_003:

801f4060 <__intvec_tc0_3>:
801f4060:	0d 00 00 02 	svlcx 
801f4064:	91 00 00 e8 	movh.a %a14,32768
801f4068:	d9 ee 76 e0 	lea %a14,[%a14]1974 <800007b6 <ISR_STM>>
801f406c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_004:

801f4080 <__intvec_tc0_4>:
801f4080:	0d 00 00 02 	svlcx 
801f4084:	91 00 00 e8 	movh.a %a14,32768
801f4088:	d9 ee 42 80 	lea %a14,[%a14]1538 <80000602 <asc2RxISR>>
801f408c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_009:

801f4120 <__intvec_tc0_9>:
801f4120:	0d 00 00 02 	svlcx 
801f4124:	91 00 00 e8 	movh.a %a14,32768
801f4128:	d9 ee 6e 70 	lea %a14,[%a14]1518 <800005ee <asc2TxISR>>
801f412c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_00D:

801f41a0 <__intvec_tc0_13>:
801f41a0:	0d 00 00 02 	svlcx 
801f41a4:	91 00 00 e8 	movh.a %a14,32768
801f41a8:	d9 ee 4e b0 	lea %a14,[%a14]1742 <800006ce <asc2ErrISR>>
801f41ac:	dc 0e       	ji %a14
