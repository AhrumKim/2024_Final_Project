
CAN.elf:     file format elf32-tricore

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bmhd_0       00000020  80000000  80000000  00000274  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .bmhd_1       00000020  80020000  80020000  00003920  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .startup      00000010  80000020  80000020  00000294  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .interface_const 00000000  80000040  80000040  00003b64  2**0
                  CONTENTS
  4 .traptab_tc0  00000100  80000100  80000100  000002c0  2**5
                  CONTENTS, ALLOC, LOAD, CODE
  5 .rodata       000002c8  80000200  80000200  000003c0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .CPU2.zbss    00000000  50000000  50000000  00003b64  2**0
                  CONTENTS
  7 .CPU2.bss     00000000  50000000  50000000  00003b64  2**0
                  CONTENTS
  8 .CPU1.zbss    00000000  60000000  60000000  00003b64  2**0
                  CONTENTS
  9 .CPU1.bss     00000000  600011ac  600011ac  00003b64  2**0
                  CONTENTS
 10 .CPU0.zbss    00000000  70000000  70000000  00003b64  2**0
                  CONTENTS
 11 .CPU0.bss     00000000  70000000  70000000  00003b64  2**0
                  CONTENTS
 12 .zbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC
 13 .sbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC, SMALL_DATA
 14 .bss          000001a4  60000008  801f6304  00003b68  2**3
                  ALLOC
 15 .CPU2.zdata   00000000  50000000  50000000  00003b64  2**0
                  CONTENTS
 16 .CPU2.data    00000000  50000000  50000000  00003b64  2**0
                  CONTENTS
 17 .CPU1.zdata   00000000  60000000  60000000  00003b64  2**0
                  CONTENTS
 18 .CPU1.data    00000000  600011ac  600011ac  00003b64  2**0
                  CONTENTS
 19 .CPU0.zdata   00000000  70000000  70000000  00003b64  2**0
                  CONTENTS
 20 .CPU0.data    00000000  70000000  70000000  00003b64  2**0
                  CONTENTS
 21 .zdata        00000000  60000000  801f6304  00003b64  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 22 .sdata        00000000  60000000  801f6304  00003b64  2**0
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
 23 .data         00000004  60000000  801f6300  00003b60  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 24 .lmu_zdata    00000000  90000000  90000000  00003b64  2**0
                  CONTENTS
 25 .lmu_sdata    00000000  90000000  90000000  00003b64  2**0
                  CONTENTS
 26 .lmu_data     00000000  90000000  90000000  00003b64  2**0
                  CONTENTS
 27 .CPU0.psram_text 00000000  70100000  70100000  00003b64  2**0
                  CONTENTS
 28 .CPU1.psram_text 00000000  60100000  60100000  00003b64  2**0
                  CONTENTS
 29 .CPU2.psram_text 00000000  50100000  50100000  00003b64  2**0
                  CONTENTS
 30 .text         00003260  800004c8  800004c8  00000688  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .init         00000010  80003728  80003728  000038e8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .fini         00000008  80003738  80003738  000038f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .eh_frame     00000000  80003740  80003740  00003b64  2**0
                  CONTENTS
 34 .gcc_except_table 00000000  80003740  80003740  00003b64  2**0
                  CONTENTS
 35 .ctors        00000010  80003740  80003740  00003900  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 36 .dtors        00000010  80003750  80003750  00003910  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 37 .traptab_tc2  00000100  801f6100  801f6100  00003960  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 38 .traptab_tc1  00000100  801f6200  801f6200  00003a60  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 39 .heap         00001000  600001ac  801f6304  00003b64  2**0
                  ALLOC
 40 .CPU2.ustack  00000800  5001ae00  5001ae00  00000274  2**0
                  ALLOC
 41 .CPU2.istack  00000400  5001b700  5001b700  00000274  2**0
                  ALLOC
 42 .CPU2.csa     00002000  5001bc00  5001bc00  00000274  2**0
                  ALLOC
 43 .CPU1.ustack  00000800  6001ae00  6001ae00  00000274  2**0
                  ALLOC
 44 .CPU1.istack  00000400  6001b700  6001b700  00000274  2**0
                  ALLOC
 45 .CPU1.csa     00002000  6001bc00  6001bc00  00000274  2**0
                  ALLOC
 46 .CPU0.ustack  00000800  70018e00  70018e00  00000274  2**0
                  ALLOC
 47 .CPU0.istack  00000400  70019700  70019700  00000274  2**0
                  ALLOC
 48 .CPU0.csa     00002000  70019c00  70019c00  00000274  2**0
                  ALLOC
 49 .inttab_tc0_000 00000000  801f4000  801f4000  00003b64  2**0
                  CONTENTS
 50 .inttab_tc0_001 00000000  801f4020  801f4020  00003b64  2**0
                  CONTENTS
 51 .inttab_tc0_002 00000000  801f4040  801f4040  00003b64  2**0
                  CONTENTS
 52 .inttab_tc0_003 00000000  801f4060  801f4060  00003b64  2**0
                  CONTENTS
 53 .inttab_tc0_004 00000000  801f4080  801f4080  00003b64  2**0
                  CONTENTS
 54 .inttab_tc0_005 00000000  801f40a0  801f40a0  00003b64  2**0
                  CONTENTS
 55 .inttab_tc0_006 00000000  801f40c0  801f40c0  00003b64  2**0
                  CONTENTS
 56 .inttab_tc0_007 00000000  801f40e0  801f40e0  00003b64  2**0
                  CONTENTS
 57 .inttab_tc0_008 00000000  801f4100  801f4100  00003b64  2**0
                  CONTENTS
 58 .inttab_tc0_009 00000000  801f4120  801f4120  00003b64  2**0
                  CONTENTS
 59 .inttab_tc0_00A 00000000  801f4140  801f4140  00003b64  2**0
                  CONTENTS
 60 .inttab_tc0_00B 00000000  801f4160  801f4160  00003b64  2**0
                  CONTENTS
 61 .inttab_tc0_00C 00000000  801f4180  801f4180  00003b64  2**0
                  CONTENTS
 62 .inttab_tc0_00D 00000000  801f41a0  801f41a0  00003b64  2**0
                  CONTENTS
 63 .inttab_tc0_00E 00000000  801f41c0  801f41c0  00003b64  2**0
                  CONTENTS
 64 .inttab_tc0_00F 00000000  801f41e0  801f41e0  00003b64  2**0
                  CONTENTS
 65 .inttab_tc0_010 00000000  801f4200  801f4200  00003b64  2**0
                  CONTENTS
 66 .inttab_tc0_011 00000000  801f4220  801f4220  00003b64  2**0
                  CONTENTS
 67 .inttab_tc0_012 00000000  801f4240  801f4240  00003b64  2**0
                  CONTENTS
 68 .inttab_tc0_013 00000000  801f4260  801f4260  00003b64  2**0
                  CONTENTS
 69 .inttab_tc0_014 00000000  801f4280  801f4280  00003b64  2**0
                  CONTENTS
 70 .inttab_tc0_015 00000000  801f42a0  801f42a0  00003b64  2**0
                  CONTENTS
 71 .inttab_tc0_016 00000000  801f42c0  801f42c0  00003b64  2**0
                  CONTENTS
 72 .inttab_tc0_017 00000000  801f42e0  801f42e0  00003b64  2**0
                  CONTENTS
 73 .inttab_tc0_018 00000000  801f4300  801f4300  00003b64  2**0
                  CONTENTS
 74 .inttab_tc0_019 00000000  801f4320  801f4320  00003b64  2**0
                  CONTENTS
 75 .inttab_tc0_01A 00000000  801f4340  801f4340  00003b64  2**0
                  CONTENTS
 76 .inttab_tc0_01B 00000000  801f4360  801f4360  00003b64  2**0
                  CONTENTS
 77 .inttab_tc0_01C 00000000  801f4380  801f4380  00003b64  2**0
                  CONTENTS
 78 .inttab_tc0_01D 00000000  801f43a0  801f43a0  00003b64  2**0
                  CONTENTS
 79 .inttab_tc0_01E 0000000e  801f43c0  801f43c0  00003940  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 80 .inttab_tc0_01F 00000000  801f43e0  801f43e0  00003b64  2**0
                  CONTENTS
 81 .inttab_tc0_020 00000000  801f4400  801f4400  00003b64  2**0
                  CONTENTS
 82 .inttab_tc0_021 00000000  801f4420  801f4420  00003b64  2**0
                  CONTENTS
 83 .inttab_tc0_022 00000000  801f4440  801f4440  00003b64  2**0
                  CONTENTS
 84 .inttab_tc0_023 00000000  801f4460  801f4460  00003b64  2**0
                  CONTENTS
 85 .inttab_tc0_024 00000000  801f4480  801f4480  00003b64  2**0
                  CONTENTS
 86 .inttab_tc0_025 00000000  801f44a0  801f44a0  00003b64  2**0
                  CONTENTS
 87 .inttab_tc0_026 00000000  801f44c0  801f44c0  00003b64  2**0
                  CONTENTS
 88 .inttab_tc0_027 00000000  801f44e0  801f44e0  00003b64  2**0
                  CONTENTS
 89 .inttab_tc0_028 00000000  801f4500  801f4500  00003b64  2**0
                  CONTENTS
 90 .inttab_tc0_029 00000000  801f4520  801f4520  00003b64  2**0
                  CONTENTS
 91 .inttab_tc0_02A 00000000  801f4540  801f4540  00003b64  2**0
                  CONTENTS
 92 .inttab_tc0_02B 00000000  801f4560  801f4560  00003b64  2**0
                  CONTENTS
 93 .inttab_tc0_02C 00000000  801f4580  801f4580  00003b64  2**0
                  CONTENTS
 94 .inttab_tc0_02D 00000000  801f45a0  801f45a0  00003b64  2**0
                  CONTENTS
 95 .inttab_tc0_02E 00000000  801f45c0  801f45c0  00003b64  2**0
                  CONTENTS
 96 .inttab_tc0_02F 00000000  801f45e0  801f45e0  00003b64  2**0
                  CONTENTS
 97 .inttab_tc0_030 00000000  801f4600  801f4600  00003b64  2**0
                  CONTENTS
 98 .inttab_tc0_031 00000000  801f4620  801f4620  00003b64  2**0
                  CONTENTS
 99 .inttab_tc0_032 00000000  801f4640  801f4640  00003b64  2**0
                  CONTENTS
100 .inttab_tc0_033 00000000  801f4660  801f4660  00003b64  2**0
                  CONTENTS
101 .inttab_tc0_034 00000000  801f4680  801f4680  00003b64  2**0
                  CONTENTS
102 .inttab_tc0_035 00000000  801f46a0  801f46a0  00003b64  2**0
                  CONTENTS
103 .inttab_tc0_036 00000000  801f46c0  801f46c0  00003b64  2**0
                  CONTENTS
104 .inttab_tc0_037 00000000  801f46e0  801f46e0  00003b64  2**0
                  CONTENTS
105 .inttab_tc0_038 00000000  801f4700  801f4700  00003b64  2**0
                  CONTENTS
106 .inttab_tc0_039 00000000  801f4720  801f4720  00003b64  2**0
                  CONTENTS
107 .inttab_tc0_03A 00000000  801f4740  801f4740  00003b64  2**0
                  CONTENTS
108 .inttab_tc0_03B 00000000  801f4760  801f4760  00003b64  2**0
                  CONTENTS
109 .inttab_tc0_03C 00000000  801f4780  801f4780  00003b64  2**0
                  CONTENTS
110 .inttab_tc0_03D 00000000  801f47a0  801f47a0  00003b64  2**0
                  CONTENTS
111 .inttab_tc0_03E 00000000  801f47c0  801f47c0  00003b64  2**0
                  CONTENTS
112 .inttab_tc0_03F 00000000  801f47e0  801f47e0  00003b64  2**0
                  CONTENTS
113 .inttab_tc0_040 00000000  801f4800  801f4800  00003b64  2**0
                  CONTENTS
114 .inttab_tc0_041 00000000  801f4820  801f4820  00003b64  2**0
                  CONTENTS
115 .inttab_tc0_042 00000000  801f4840  801f4840  00003b64  2**0
                  CONTENTS
116 .inttab_tc0_043 00000000  801f4860  801f4860  00003b64  2**0
                  CONTENTS
117 .inttab_tc0_044 00000000  801f4880  801f4880  00003b64  2**0
                  CONTENTS
118 .inttab_tc0_045 00000000  801f48a0  801f48a0  00003b64  2**0
                  CONTENTS
119 .inttab_tc0_046 00000000  801f48c0  801f48c0  00003b64  2**0
                  CONTENTS
120 .inttab_tc0_047 00000000  801f48e0  801f48e0  00003b64  2**0
                  CONTENTS
121 .inttab_tc0_048 00000000  801f4900  801f4900  00003b64  2**0
                  CONTENTS
122 .inttab_tc0_049 00000000  801f4920  801f4920  00003b64  2**0
                  CONTENTS
123 .inttab_tc0_04A 00000000  801f4940  801f4940  00003b64  2**0
                  CONTENTS
124 .inttab_tc0_04B 00000000  801f4960  801f4960  00003b64  2**0
                  CONTENTS
125 .inttab_tc0_04C 00000000  801f4980  801f4980  00003b64  2**0
                  CONTENTS
126 .inttab_tc0_04D 00000000  801f49a0  801f49a0  00003b64  2**0
                  CONTENTS
127 .inttab_tc0_04E 00000000  801f49c0  801f49c0  00003b64  2**0
                  CONTENTS
128 .inttab_tc0_04F 00000000  801f49e0  801f49e0  00003b64  2**0
                  CONTENTS
129 .inttab_tc0_050 00000000  801f4a00  801f4a00  00003b64  2**0
                  CONTENTS
130 .inttab_tc0_051 00000000  801f4a20  801f4a20  00003b64  2**0
                  CONTENTS
131 .inttab_tc0_052 00000000  801f4a40  801f4a40  00003b64  2**0
                  CONTENTS
132 .inttab_tc0_053 00000000  801f4a60  801f4a60  00003b64  2**0
                  CONTENTS
133 .inttab_tc0_054 00000000  801f4a80  801f4a80  00003b64  2**0
                  CONTENTS
134 .inttab_tc0_055 00000000  801f4aa0  801f4aa0  00003b64  2**0
                  CONTENTS
135 .inttab_tc0_056 00000000  801f4ac0  801f4ac0  00003b64  2**0
                  CONTENTS
136 .inttab_tc0_057 00000000  801f4ae0  801f4ae0  00003b64  2**0
                  CONTENTS
137 .inttab_tc0_058 00000000  801f4b00  801f4b00  00003b64  2**0
                  CONTENTS
138 .inttab_tc0_059 00000000  801f4b20  801f4b20  00003b64  2**0
                  CONTENTS
139 .inttab_tc0_05A 00000000  801f4b40  801f4b40  00003b64  2**0
                  CONTENTS
140 .inttab_tc0_05B 00000000  801f4b60  801f4b60  00003b64  2**0
                  CONTENTS
141 .inttab_tc0_05C 00000000  801f4b80  801f4b80  00003b64  2**0
                  CONTENTS
142 .inttab_tc0_05D 00000000  801f4ba0  801f4ba0  00003b64  2**0
                  CONTENTS
143 .inttab_tc0_05E 00000000  801f4bc0  801f4bc0  00003b64  2**0
                  CONTENTS
144 .inttab_tc0_05F 00000000  801f4be0  801f4be0  00003b64  2**0
                  CONTENTS
145 .inttab_tc0_060 00000000  801f4c00  801f4c00  00003b64  2**0
                  CONTENTS
146 .inttab_tc0_061 00000000  801f4c20  801f4c20  00003b64  2**0
                  CONTENTS
147 .inttab_tc0_062 00000000  801f4c40  801f4c40  00003b64  2**0
                  CONTENTS
148 .inttab_tc0_063 00000000  801f4c60  801f4c60  00003b64  2**0
                  CONTENTS
149 .inttab_tc0_064 0000000e  801f4c80  801f4c80  0000394e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
150 .inttab_tc0_065 00000000  801f4ca0  801f4ca0  00003b64  2**0
                  CONTENTS
151 .inttab_tc0_066 00000000  801f4cc0  801f4cc0  00003b64  2**0
                  CONTENTS
152 .inttab_tc0_067 00000000  801f4ce0  801f4ce0  00003b64  2**0
                  CONTENTS
153 .inttab_tc0_068 00000000  801f4d00  801f4d00  00003b64  2**0
                  CONTENTS
154 .inttab_tc0_069 00000000  801f4d20  801f4d20  00003b64  2**0
                  CONTENTS
155 .inttab_tc0_06A 00000000  801f4d40  801f4d40  00003b64  2**0
                  CONTENTS
156 .inttab_tc0_06B 00000000  801f4d60  801f4d60  00003b64  2**0
                  CONTENTS
157 .inttab_tc0_06C 00000000  801f4d80  801f4d80  00003b64  2**0
                  CONTENTS
158 .inttab_tc0_06D 00000000  801f4da0  801f4da0  00003b64  2**0
                  CONTENTS
159 .inttab_tc0_06E 00000000  801f4dc0  801f4dc0  00003b64  2**0
                  CONTENTS
160 .inttab_tc0_06F 00000000  801f4de0  801f4de0  00003b64  2**0
                  CONTENTS
161 .inttab_tc0_070 00000000  801f4e00  801f4e00  00003b64  2**0
                  CONTENTS
162 .inttab_tc0_071 00000000  801f4e20  801f4e20  00003b64  2**0
                  CONTENTS
163 .inttab_tc0_072 00000000  801f4e40  801f4e40  00003b64  2**0
                  CONTENTS
164 .inttab_tc0_073 00000000  801f4e60  801f4e60  00003b64  2**0
                  CONTENTS
165 .inttab_tc0_074 00000000  801f4e80  801f4e80  00003b64  2**0
                  CONTENTS
166 .inttab_tc0_075 00000000  801f4ea0  801f4ea0  00003b64  2**0
                  CONTENTS
167 .inttab_tc0_076 00000000  801f4ec0  801f4ec0  00003b64  2**0
                  CONTENTS
168 .inttab_tc0_077 00000000  801f4ee0  801f4ee0  00003b64  2**0
                  CONTENTS
169 .inttab_tc0_078 00000000  801f4f00  801f4f00  00003b64  2**0
                  CONTENTS
170 .inttab_tc0_079 00000000  801f4f20  801f4f20  00003b64  2**0
                  CONTENTS
171 .inttab_tc0_07A 00000000  801f4f40  801f4f40  00003b64  2**0
                  CONTENTS
172 .inttab_tc0_07B 00000000  801f4f60  801f4f60  00003b64  2**0
                  CONTENTS
173 .inttab_tc0_07C 00000000  801f4f80  801f4f80  00003b64  2**0
                  CONTENTS
174 .inttab_tc0_07D 00000000  801f4fa0  801f4fa0  00003b64  2**0
                  CONTENTS
175 .inttab_tc0_07E 00000000  801f4fc0  801f4fc0  00003b64  2**0
                  CONTENTS
176 .inttab_tc0_07F 00000000  801f4fe0  801f4fe0  00003b64  2**0
                  CONTENTS
177 .inttab_tc0_080 00000000  801f5000  801f5000  00003b64  2**0
                  CONTENTS
178 .inttab_tc0_081 00000000  801f5020  801f5020  00003b64  2**0
                  CONTENTS
179 .inttab_tc0_082 00000000  801f5040  801f5040  00003b64  2**0
                  CONTENTS
180 .inttab_tc0_083 00000000  801f5060  801f5060  00003b64  2**0
                  CONTENTS
181 .inttab_tc0_084 00000000  801f5080  801f5080  00003b64  2**0
                  CONTENTS
182 .inttab_tc0_085 00000000  801f50a0  801f50a0  00003b64  2**0
                  CONTENTS
183 .inttab_tc0_086 00000000  801f50c0  801f50c0  00003b64  2**0
                  CONTENTS
184 .inttab_tc0_087 00000000  801f50e0  801f50e0  00003b64  2**0
                  CONTENTS
185 .inttab_tc0_088 00000000  801f5100  801f5100  00003b64  2**0
                  CONTENTS
186 .inttab_tc0_089 00000000  801f5120  801f5120  00003b64  2**0
                  CONTENTS
187 .inttab_tc0_08A 00000000  801f5140  801f5140  00003b64  2**0
                  CONTENTS
188 .inttab_tc0_08B 00000000  801f5160  801f5160  00003b64  2**0
                  CONTENTS
189 .inttab_tc0_08C 00000000  801f5180  801f5180  00003b64  2**0
                  CONTENTS
190 .inttab_tc0_08D 00000000  801f51a0  801f51a0  00003b64  2**0
                  CONTENTS
191 .inttab_tc0_08E 00000000  801f51c0  801f51c0  00003b64  2**0
                  CONTENTS
192 .inttab_tc0_08F 00000000  801f51e0  801f51e0  00003b64  2**0
                  CONTENTS
193 .inttab_tc0_090 00000000  801f5200  801f5200  00003b64  2**0
                  CONTENTS
194 .inttab_tc0_091 00000000  801f5220  801f5220  00003b64  2**0
                  CONTENTS
195 .inttab_tc0_092 00000000  801f5240  801f5240  00003b64  2**0
                  CONTENTS
196 .inttab_tc0_093 00000000  801f5260  801f5260  00003b64  2**0
                  CONTENTS
197 .inttab_tc0_094 00000000  801f5280  801f5280  00003b64  2**0
                  CONTENTS
198 .inttab_tc0_095 00000000  801f52a0  801f52a0  00003b64  2**0
                  CONTENTS
199 .inttab_tc0_096 00000000  801f52c0  801f52c0  00003b64  2**0
                  CONTENTS
200 .inttab_tc0_097 00000000  801f52e0  801f52e0  00003b64  2**0
                  CONTENTS
201 .inttab_tc0_098 00000000  801f5300  801f5300  00003b64  2**0
                  CONTENTS
202 .inttab_tc0_099 00000000  801f5320  801f5320  00003b64  2**0
                  CONTENTS
203 .inttab_tc0_09A 00000000  801f5340  801f5340  00003b64  2**0
                  CONTENTS
204 .inttab_tc0_09B 00000000  801f5360  801f5360  00003b64  2**0
                  CONTENTS
205 .inttab_tc0_09C 00000000  801f5380  801f5380  00003b64  2**0
                  CONTENTS
206 .inttab_tc0_09D 00000000  801f53a0  801f53a0  00003b64  2**0
                  CONTENTS
207 .inttab_tc0_09E 00000000  801f53c0  801f53c0  00003b64  2**0
                  CONTENTS
208 .inttab_tc0_09F 00000000  801f53e0  801f53e0  00003b64  2**0
                  CONTENTS
209 .inttab_tc0_0A0 00000000  801f5400  801f5400  00003b64  2**0
                  CONTENTS
210 .inttab_tc0_0A1 00000000  801f5420  801f5420  00003b64  2**0
                  CONTENTS
211 .inttab_tc0_0A2 00000000  801f5440  801f5440  00003b64  2**0
                  CONTENTS
212 .inttab_tc0_0A3 00000000  801f5460  801f5460  00003b64  2**0
                  CONTENTS
213 .inttab_tc0_0A4 00000000  801f5480  801f5480  00003b64  2**0
                  CONTENTS
214 .inttab_tc0_0A5 00000000  801f54a0  801f54a0  00003b64  2**0
                  CONTENTS
215 .inttab_tc0_0A6 00000000  801f54c0  801f54c0  00003b64  2**0
                  CONTENTS
216 .inttab_tc0_0A7 00000000  801f54e0  801f54e0  00003b64  2**0
                  CONTENTS
217 .inttab_tc0_0A8 00000000  801f5500  801f5500  00003b64  2**0
                  CONTENTS
218 .inttab_tc0_0A9 00000000  801f5520  801f5520  00003b64  2**0
                  CONTENTS
219 .inttab_tc0_0AA 00000000  801f5540  801f5540  00003b64  2**0
                  CONTENTS
220 .inttab_tc0_0AB 00000000  801f5560  801f5560  00003b64  2**0
                  CONTENTS
221 .inttab_tc0_0AC 00000000  801f5580  801f5580  00003b64  2**0
                  CONTENTS
222 .inttab_tc0_0AD 00000000  801f55a0  801f55a0  00003b64  2**0
                  CONTENTS
223 .inttab_tc0_0AE 00000000  801f55c0  801f55c0  00003b64  2**0
                  CONTENTS
224 .inttab_tc0_0AF 00000000  801f55e0  801f55e0  00003b64  2**0
                  CONTENTS
225 .inttab_tc0_0B0 00000000  801f5600  801f5600  00003b64  2**0
                  CONTENTS
226 .inttab_tc0_0B1 00000000  801f5620  801f5620  00003b64  2**0
                  CONTENTS
227 .inttab_tc0_0B2 00000000  801f5640  801f5640  00003b64  2**0
                  CONTENTS
228 .inttab_tc0_0B3 00000000  801f5660  801f5660  00003b64  2**0
                  CONTENTS
229 .inttab_tc0_0B4 00000000  801f5680  801f5680  00003b64  2**0
                  CONTENTS
230 .inttab_tc0_0B5 00000000  801f56a0  801f56a0  00003b64  2**0
                  CONTENTS
231 .inttab_tc0_0B6 00000000  801f56c0  801f56c0  00003b64  2**0
                  CONTENTS
232 .inttab_tc0_0B7 00000000  801f56e0  801f56e0  00003b64  2**0
                  CONTENTS
233 .inttab_tc0_0B8 00000000  801f5700  801f5700  00003b64  2**0
                  CONTENTS
234 .inttab_tc0_0B9 00000000  801f5720  801f5720  00003b64  2**0
                  CONTENTS
235 .inttab_tc0_0BA 00000000  801f5740  801f5740  00003b64  2**0
                  CONTENTS
236 .inttab_tc0_0BB 00000000  801f5760  801f5760  00003b64  2**0
                  CONTENTS
237 .inttab_tc0_0BC 00000000  801f5780  801f5780  00003b64  2**0
                  CONTENTS
238 .inttab_tc0_0BD 00000000  801f57a0  801f57a0  00003b64  2**0
                  CONTENTS
239 .inttab_tc0_0BE 00000000  801f57c0  801f57c0  00003b64  2**0
                  CONTENTS
240 .inttab_tc0_0BF 00000000  801f57e0  801f57e0  00003b64  2**0
                  CONTENTS
241 .inttab_tc0_0C0 00000000  801f5800  801f5800  00003b64  2**0
                  CONTENTS
242 .inttab_tc0_0C1 00000000  801f5820  801f5820  00003b64  2**0
                  CONTENTS
243 .inttab_tc0_0C2 00000000  801f5840  801f5840  00003b64  2**0
                  CONTENTS
244 .inttab_tc0_0C3 00000000  801f5860  801f5860  00003b64  2**0
                  CONTENTS
245 .inttab_tc0_0C4 00000000  801f5880  801f5880  00003b64  2**0
                  CONTENTS
246 .inttab_tc0_0C5 00000000  801f58a0  801f58a0  00003b64  2**0
                  CONTENTS
247 .inttab_tc0_0C6 00000000  801f58c0  801f58c0  00003b64  2**0
                  CONTENTS
248 .inttab_tc0_0C7 00000000  801f58e0  801f58e0  00003b64  2**0
                  CONTENTS
249 .inttab_tc0_0C8 00000000  801f5900  801f5900  00003b64  2**0
                  CONTENTS
250 .inttab_tc0_0C9 00000000  801f5920  801f5920  00003b64  2**0
                  CONTENTS
251 .inttab_tc0_0CA 00000000  801f5940  801f5940  00003b64  2**0
                  CONTENTS
252 .inttab_tc0_0CB 00000000  801f5960  801f5960  00003b64  2**0
                  CONTENTS
253 .inttab_tc0_0CC 00000000  801f5980  801f5980  00003b64  2**0
                  CONTENTS
254 .inttab_tc0_0CD 00000000  801f59a0  801f59a0  00003b64  2**0
                  CONTENTS
255 .inttab_tc0_0CE 00000000  801f59c0  801f59c0  00003b64  2**0
                  CONTENTS
256 .inttab_tc0_0CF 00000000  801f59e0  801f59e0  00003b64  2**0
                  CONTENTS
257 .inttab_tc0_0D0 00000000  801f5a00  801f5a00  00003b64  2**0
                  CONTENTS
258 .inttab_tc0_0D1 00000000  801f5a20  801f5a20  00003b64  2**0
                  CONTENTS
259 .inttab_tc0_0D2 00000000  801f5a40  801f5a40  00003b64  2**0
                  CONTENTS
260 .inttab_tc0_0D3 00000000  801f5a60  801f5a60  00003b64  2**0
                  CONTENTS
261 .inttab_tc0_0D4 00000000  801f5a80  801f5a80  00003b64  2**0
                  CONTENTS
262 .inttab_tc0_0D5 00000000  801f5aa0  801f5aa0  00003b64  2**0
                  CONTENTS
263 .inttab_tc0_0D6 00000000  801f5ac0  801f5ac0  00003b64  2**0
                  CONTENTS
264 .inttab_tc0_0D7 00000000  801f5ae0  801f5ae0  00003b64  2**0
                  CONTENTS
265 .inttab_tc0_0D8 00000000  801f5b00  801f5b00  00003b64  2**0
                  CONTENTS
266 .inttab_tc0_0D9 00000000  801f5b20  801f5b20  00003b64  2**0
                  CONTENTS
267 .inttab_tc0_0DA 00000000  801f5b40  801f5b40  00003b64  2**0
                  CONTENTS
268 .inttab_tc0_0DB 00000000  801f5b60  801f5b60  00003b64  2**0
                  CONTENTS
269 .inttab_tc0_0DC 00000000  801f5b80  801f5b80  00003b64  2**0
                  CONTENTS
270 .inttab_tc0_0DD 00000000  801f5ba0  801f5ba0  00003b64  2**0
                  CONTENTS
271 .inttab_tc0_0DE 00000000  801f5bc0  801f5bc0  00003b64  2**0
                  CONTENTS
272 .inttab_tc0_0DF 00000000  801f5be0  801f5be0  00003b64  2**0
                  CONTENTS
273 .inttab_tc0_0E0 00000000  801f5c00  801f5c00  00003b64  2**0
                  CONTENTS
274 .inttab_tc0_0E1 00000000  801f5c20  801f5c20  00003b64  2**0
                  CONTENTS
275 .inttab_tc0_0E2 00000000  801f5c40  801f5c40  00003b64  2**0
                  CONTENTS
276 .inttab_tc0_0E3 00000000  801f5c60  801f5c60  00003b64  2**0
                  CONTENTS
277 .inttab_tc0_0E4 00000000  801f5c80  801f5c80  00003b64  2**0
                  CONTENTS
278 .inttab_tc0_0E5 00000000  801f5ca0  801f5ca0  00003b64  2**0
                  CONTENTS
279 .inttab_tc0_0E6 00000000  801f5cc0  801f5cc0  00003b64  2**0
                  CONTENTS
280 .inttab_tc0_0E7 00000000  801f5ce0  801f5ce0  00003b64  2**0
                  CONTENTS
281 .inttab_tc0_0E8 00000000  801f5d00  801f5d00  00003b64  2**0
                  CONTENTS
282 .inttab_tc0_0E9 00000000  801f5d20  801f5d20  00003b64  2**0
                  CONTENTS
283 .inttab_tc0_0EA 00000000  801f5d40  801f5d40  00003b64  2**0
                  CONTENTS
284 .inttab_tc0_0EB 00000000  801f5d60  801f5d60  00003b64  2**0
                  CONTENTS
285 .inttab_tc0_0EC 00000000  801f5d80  801f5d80  00003b64  2**0
                  CONTENTS
286 .inttab_tc0_0ED 00000000  801f5da0  801f5da0  00003b64  2**0
                  CONTENTS
287 .inttab_tc0_0EE 00000000  801f5dc0  801f5dc0  00003b64  2**0
                  CONTENTS
288 .inttab_tc0_0EF 00000000  801f5de0  801f5de0  00003b64  2**0
                  CONTENTS
289 .inttab_tc0_0F0 00000000  801f5e00  801f5e00  00003b64  2**0
                  CONTENTS
290 .inttab_tc0_0F1 00000000  801f5e20  801f5e20  00003b64  2**0
                  CONTENTS
291 .inttab_tc0_0F2 00000000  801f5e40  801f5e40  00003b64  2**0
                  CONTENTS
292 .inttab_tc0_0F3 00000000  801f5e60  801f5e60  00003b64  2**0
                  CONTENTS
293 .inttab_tc0_0F4 00000000  801f5e80  801f5e80  00003b64  2**0
                  CONTENTS
294 .inttab_tc0_0F5 00000000  801f5ea0  801f5ea0  00003b64  2**0
                  CONTENTS
295 .inttab_tc0_0F6 00000000  801f5ec0  801f5ec0  00003b64  2**0
                  CONTENTS
296 .inttab_tc0_0F7 00000000  801f5ee0  801f5ee0  00003b64  2**0
                  CONTENTS
297 .inttab_tc0_0F8 00000000  801f5f00  801f5f00  00003b64  2**0
                  CONTENTS
298 .inttab_tc0_0F9 00000000  801f5f20  801f5f20  00003b64  2**0
                  CONTENTS
299 .inttab_tc0_0FA 00000000  801f5f40  801f5f40  00003b64  2**0
                  CONTENTS
300 .inttab_tc0_0FB 00000000  801f5f60  801f5f60  00003b64  2**0
                  CONTENTS
301 .inttab_tc0_0FC 00000000  801f5f80  801f5f80  00003b64  2**0
                  CONTENTS
302 .inttab_tc0_0FD 00000000  801f5fa0  801f5fa0  00003b64  2**0
                  CONTENTS
303 .inttab_tc0_0FE 00000000  801f5fc0  801f5fc0  00003b64  2**0
                  CONTENTS
304 .inttab_tc0_0FF 00000000  801f5fe0  801f5fe0  00003b64  2**0
                  CONTENTS
305 .comment      00000082  00000000  00000000  00003b64  2**0
                  CONTENTS, READONLY
306 .debug_aranges 00000a58  00000000  00000000  00003be8  2**3
                  CONTENTS, READONLY, DEBUGGING
307 .debug_info   000992a0  00000000  00000000  00004640  2**0
                  CONTENTS, READONLY, DEBUGGING
308 .debug_abbrev 0000593b  00000000  00000000  0009d8e0  2**0
                  CONTENTS, READONLY, DEBUGGING
309 .debug_line   00017021  00000000  00000000  000a321b  2**0
                  CONTENTS, READONLY, DEBUGGING
310 .debug_frame  00001660  00000000  00000000  000ba23c  2**2
                  CONTENTS, READONLY, DEBUGGING
311 .debug_str    00001f78  00000000  00000000  000bb89c  2**0
                  CONTENTS, READONLY, DEBUGGING
312 .debug_loc    0000a5dc  00000000  00000000  000bd814  2**0
                  CONTENTS, READONLY, DEBUGGING
313 .debug_ranges 00001130  00000000  00000000  000c7df0  2**3
                  CONTENTS, READONLY, DEBUGGING
314 .debug_macro  001542ea  00000000  00000000  000c8f20  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .startup:

80000020 <_START>:
#elif defined(__DCC__)
#pragma section CODE ".start" X
#endif

void _START(void)
{
80000020:	40 ae       	mov.aa %a14,%sp
    __non_return_call(_Core0_start);
80000022:	91 00 00 28 	movh.a %a2,32768
80000026:	d9 22 5c 62 	lea %a2,[%a2]9628 <8000259c <_Core0_start>>
8000002a:	dc 02       	ji %a2
}
8000002c:	00 90       	ret 

8000002e <_START_end>:
8000002e:	08 00       	ld.bu %d0,[%a15]0

Disassembly of section .traptab_tc0:

80000100 <IfxCpu_Trap_vectorTable0>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu0"
#endif
void IfxCpu_Trap_vectorTable0(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80000100:	0d 00 00 02 	svlcx 
80000104:	02 f4       	mov %d4,%d15
80000106:	91 00 00 28 	movh.a %a2,32768
8000010a:	d9 22 1e 52 	lea %a2,[%a2]8542 <8000215e <IfxCpu_Trap_memoryManagementError>>
8000010e:	dc 02       	ji %a2
80000110:	00 80       	rfe 
	...
8000011e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80000120:	0d 00 00 02 	svlcx 
80000124:	02 f4       	mov %d4,%d15
80000126:	91 00 00 28 	movh.a %a2,32768
8000012a:	d9 22 0c 62 	lea %a2,[%a2]8588 <8000218c <IfxCpu_Trap_internalProtectionError>>
8000012e:	dc 02       	ji %a2
80000130:	00 80       	rfe 
	...
8000013e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80000140:	0d 00 00 02 	svlcx 
80000144:	02 f4       	mov %d4,%d15
80000146:	91 00 00 28 	movh.a %a2,32768
8000014a:	d9 22 3a 62 	lea %a2,[%a2]8634 <800021ba <IfxCpu_Trap_instructionError>>
8000014e:	dc 02       	ji %a2
80000150:	00 80       	rfe 
	...
8000015e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80000160:	02 f4       	mov %d4,%d15
80000162:	91 00 00 28 	movh.a %a2,32768
80000166:	d9 22 28 72 	lea %a2,[%a2]8680 <800021e8 <IfxCpu_Trap_contextManagementError>>
8000016a:	dc 02       	ji %a2
8000016c:	00 80       	rfe 
	...
8000017e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80000180:	0d 00 00 02 	svlcx 
80000184:	02 f4       	mov %d4,%d15
80000186:	91 00 00 28 	movh.a %a2,32768
8000018a:	d9 22 16 82 	lea %a2,[%a2]8726 <80002216 <IfxCpu_Trap_busError>>
8000018e:	dc 02       	ji %a2
80000190:	00 80       	rfe 
	...
8000019e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
800001a0:	0d 00 00 02 	svlcx 
800001a4:	02 f4       	mov %d4,%d15
800001a6:	91 00 00 28 	movh.a %a2,32768
800001aa:	d9 22 04 92 	lea %a2,[%a2]8772 <80002244 <IfxCpu_Trap_assertion>>
800001ae:	dc 02       	ji %a2
800001b0:	00 80       	rfe 
	...
800001be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0);
800001c0:	0d 00 00 02 	svlcx 
800001c4:	02 f4       	mov %d4,%d15
800001c6:	91 00 00 28 	movh.a %a2,32768
800001ca:	d9 22 38 92 	lea %a2,[%a2]8824 <80002278 <IfxCpu_Trap_systemCall_Cpu0>>
800001ce:	dc 02       	ji %a2
800001d0:	00 80       	rfe 
	...
800001de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
800001e0:	0d 00 00 02 	svlcx 
800001e4:	02 f4       	mov %d4,%d15
800001e6:	91 00 00 28 	movh.a %a2,32768
800001ea:	d9 22 3c b2 	lea %a2,[%a2]8956 <800022fc <IfxCpu_Trap_nonMaskableInterrupt>>
800001ee:	dc 02       	ji %a2
800001f0:	00 80       	rfe 
}
800001f2:	00 90       	ret 

800001f4 <IfxCpu_Trap_vectorTable0_end>:
	...

Disassembly of section .text:

800004c8 <deregister_tm_clones>:
800004c8:	7b 00 00 26 	movh %d2,24576
800004cc:	1b 42 00 20 	addi %d2,%d2,4
800004d0:	91 00 00 46 	movh.a %a4,24576
800004d4:	60 22       	mov.a %a2,%d2
800004d6:	d9 44 04 00 	lea %a4,[%a4]4 <60000004 <__TMC_END__>>
800004da:	7d 42 0a 00 	jeq.a %a2,%a4,800004ee <deregister_tm_clones+0x26>
800004de:	91 00 00 20 	movh.a %a2,0
800004e2:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
800004e6:	bd 02 04 00 	jz.a %a2,800004ee <deregister_tm_clones+0x26>
800004ea:	2d 02 00 00 	calli %a2
800004ee:	00 90       	ret 

800004f0 <register_tm_clones>:
800004f0:	7b 00 00 26 	movh %d2,24576
800004f4:	1b 42 00 20 	addi %d2,%d2,4
800004f8:	91 00 00 46 	movh.a %a4,24576
800004fc:	60 22       	mov.a %a2,%d2
800004fe:	d9 44 04 00 	lea %a4,[%a4]4 <60000004 <__TMC_END__>>
80000502:	01 42 20 20 	sub.a %a2,%a2,%a4
80000506:	80 22       	mov.d %d2,%a2
80000508:	8f e2 3f 30 	sha %d3,%d2,-2
8000050c:	8f 12 1e 20 	sh %d2,%d2,-31
80000510:	42 32       	add %d2,%d3
80000512:	8f f2 3f 40 	sha %d4,%d2,-1
80000516:	df 04 0a 00 	jeq %d4,0,8000052a <register_tm_clones+0x3a>
8000051a:	91 00 00 20 	movh.a %a2,0
8000051e:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
80000522:	bd 02 04 00 	jz.a %a2,8000052a <register_tm_clones+0x3a>
80000526:	2d 02 00 00 	calli %a2
8000052a:	00 90       	ret 

8000052c <__do_global_dtors_aux>:
8000052c:	91 00 00 e6 	movh.a %a14,24576
80000530:	39 e2 08 00 	ld.bu %d2,[%a14]8 <60000008 <completed.1>>
80000534:	df 02 2d 80 	jne %d2,0,8000058e <__do_global_dtors_aux+0x62>
80000538:	91 00 00 38 	movh.a %a3,32768
8000053c:	91 00 00 28 	movh.a %a2,32768
80000540:	d9 33 60 d3 	lea %a3,[%a3]14176 <80003760 <__DTOR_END__>>
80000544:	d9 22 54 d3 	lea %a2,[%a2]14164 <80003754 <__DTOR_LIST__>>
80000548:	01 23 20 20 	sub.a %a2,%a3,%a2
8000054c:	80 22       	mov.d %d2,%a2
8000054e:	86 e2       	sha %d2,-2
80000550:	1b f2 ff 8f 	addi %d8,%d2,-1
80000554:	91 00 00 c6 	movh.a %a12,24576
80000558:	7b 00 00 28 	movh %d2,32768
8000055c:	1b 42 75 23 	addi %d2,%d2,14164
80000560:	60 2d       	mov.a %a13,%d2
80000562:	19 c2 0c 00 	ld.w %d2,[%a12]12 <6000000c <dtor_idx.0>>
80000566:	7f 82 0f 80 	jge.u %d2,%d8,80000584 <__do_global_dtors_aux+0x58>
8000056a:	d9 cc 0c 00 	lea %a12,[%a12]12 <6000000c <dtor_idx.0>>
8000056e:	c2 12       	add %d2,1
80000570:	74 c2       	st.w [%a12],%d2
80000572:	06 22       	sh %d2,2
80000574:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000578:	d4 22       	ld.a %a2,[%a2]
8000057a:	2d 02 00 00 	calli %a2
8000057e:	54 c2       	ld.w %d2,[%a12]
80000580:	3f 82 f7 ff 	jlt.u %d2,%d8,8000056e <__do_global_dtors_aux+0x42>
80000584:	6d ff a2 ff 	call 800004c8 <deregister_tm_clones>
80000588:	82 12       	mov %d2,1
8000058a:	e9 e2 08 00 	st.b [%a14]8 <60000008 <completed.1>>,%d2
8000058e:	00 90       	ret 

80000590 <frame_dummy>:
80000590:	6d ff b0 ff 	call 800004f0 <register_tm_clones>
80000594:	00 90       	ret 

80000596 <Task1ms>:
    }
}


void Task1ms(void)
{
80000596:	40 ae       	mov.aa %a14,%sp
       cnt1ms++;
80000598:	91 00 00 26 	movh.a %a2,24576
8000059c:	d9 23 0c 60 	lea %a3,[%a2]396 <6000018c <cnt1ms>>
800005a0:	54 32       	ld.w %d2,[%a3]
800005a2:	c2 12       	add %d2,1
800005a4:	59 22 0c 60 	st.w [%a2]396 <6000018c <cnt1ms>>,%d2
}
800005a8:	00 90       	ret 

800005aa <Task10ms>:
void Task10ms(void)
{
800005aa:	40 ae       	mov.aa %a14,%sp
    CAN_TX();
800005ac:	6d 00 e4 14 	call 80002f74 <CAN_TX>
    cnt10ms++;
800005b0:	91 00 00 26 	movh.a %a2,24576
800005b4:	d9 23 08 60 	lea %a3,[%a2]392 <60000188 <cnt10ms>>
800005b8:	54 32       	ld.w %d2,[%a3]
800005ba:	c2 12       	add %d2,1
800005bc:	59 22 08 60 	st.w [%a2]392 <60000188 <cnt10ms>>,%d2
}
800005c0:	00 90       	ret 

800005c2 <Task100ms>:
void Task100ms(void)
{
800005c2:	40 ae       	mov.aa %a14,%sp
    cnt100ms++;
800005c4:	91 00 00 26 	movh.a %a2,24576
800005c8:	d9 23 04 60 	lea %a3,[%a2]388 <60000184 <cnt100ms>>
800005cc:	54 32       	ld.w %d2,[%a3]
800005ce:	c2 12       	add %d2,1
800005d0:	59 22 04 60 	st.w [%a2]388 <60000184 <cnt100ms>>,%d2
}
800005d4:	00 90       	ret 

800005d6 <AppScheduling>:
{
800005d6:	40 ae       	mov.aa %a14,%sp
    if (Scheduler1msFlag == 1)
800005d8:	91 00 00 26 	movh.a %a2,24576
800005dc:	19 22 18 00 	ld.w %d2,[%a2]24 <60000018 <Scheduler1msFlag>>
800005e0:	df 12 03 00 	jeq %d2,1,800005e6 <AppScheduling+0x10>
}
800005e4:	00 90       	ret 
        Scheduler1msFlag = 0;
800005e6:	82 02       	mov %d2,0
800005e8:	59 22 18 00 	st.w [%a2]24,%d2
        Task1ms();
800005ec:	6d ff d5 ff 	call 80000596 <Task1ms>
        if (Scheduler10msFlag == 1)
800005f0:	91 00 00 26 	movh.a %a2,24576
800005f4:	19 22 14 00 	ld.w %d2,[%a2]20 <60000014 <Scheduler10msFlag>>
800005f8:	df 12 0f 00 	jeq %d2,1,80000616 <AppScheduling+0x40>
        if (Scheduler100msFlag == 1)
800005fc:	91 00 00 26 	movh.a %a2,24576
80000600:	19 22 10 00 	ld.w %d2,[%a2]16 <60000010 <Scheduler100msFlag>>
80000604:	df 12 f0 ff 	jne %d2,1,800005e4 <AppScheduling+0xe>
            Scheduler100msFlag = 0;
80000608:	82 02       	mov %d2,0
8000060a:	59 22 10 00 	st.w [%a2]16 <60000010 <Scheduler100msFlag>>,%d2
            Task100ms();
8000060e:	6d ff da ff 	call 800005c2 <Task100ms>
}
80000612:	1d ff e9 ff 	j 800005e4 <AppScheduling+0xe>
            Scheduler10msFlag = 0;
80000616:	82 02       	mov %d2,0
80000618:	59 22 14 00 	st.w [%a2]20,%d2
            Task10ms();
8000061c:	6d ff c7 ff 	call 800005aa <Task10ms>
80000620:	1d ff ee ff 	j 800005fc <AppScheduling+0x26>

80000624 <init_STM>:
uint32 Scheduler10msFlag = 0;
uint32 Scheduler100msFlag = 0;

//IfxStm_CompareConfig     stmConfig;
void init_STM(void)
{
80000624:	40 ae       	mov.aa %a14,%sp
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
80000626:	4d c0 e2 8f 	mfcr %d8,$icr
    return reg.B.IE != 0;
8000062a:	37 08 e1 87 	extr.u %d8,%d8,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
8000062e:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
80000632:	00 00       	nop 
    boolean ISR_State = IfxCpu_disableInterrupts();     // 진행 중인 인터럽트를 반환 및 인터럽트 중지

    IfxStm_enableOcdsSuspend(STM0);                     //OCDS: on chip debugging system [디버깅 시,cpu 중단하면 타이머도 같이 중단되도록 설정(시스템 상태분석 용이)]
80000634:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
80000638:	6d 00 68 06 	call 80001308 <IfxStm_enableOcdsSuspend>
    IfxStm_initCompareConfig(&stmConfig);                // 비교기능 구조체 초기화 (초기값 정의)
8000063c:	91 00 00 c6 	movh.a %a12,24576
80000640:	d9 cc 10 60 	lea %a12,[%a12]400 <60000190 <stmConfig>>
80000644:	40 c4       	mov.aa %a4,%a12
80000646:	6d 00 3e 07 	call 800014c2 <IfxStm_initCompareConfig>

    stmConfig.ticks           = 100000u;             // 주기 (비교 값) 설정 1초 뒤 시작
8000064a:	7b 20 00 20 	movh %d2,2
8000064e:	1b 02 6a 28 	addi %d2,%d2,-31072
80000652:	59 c2 10 00 	st.w [%a12]16 <60000010 <Scheduler100msFlag>>,%d2
    stmConfig.triggerPriority = 100u;                   // STM 모듈에서 발생한 인터럽트 우선순위 설정 100번째 함수
80000656:	3b 40 06 20 	mov %d2,100
8000065a:	f9 c2 14 00 	st.h [%a12]20 <60000014 <Scheduler10msFlag>>,%d2
    stmConfig.typeOfService   = IfxSrc_Tos_cpu0;        // STM에서 발생한 인터럽트를 cpu0에서 처리하도록 설정
8000065e:	82 02       	mov %d2,0
80000660:	59 c2 18 00 	st.w [%a12]24 <60000018 <Scheduler1msFlag>>,%d2

    IfxStm_initCompare(STM0, &stmConfig);               // STM0의 비교기 초기화 및 설정 값 적용 (stmConfig로 바꿈)
80000664:	40 c5       	mov.aa %a5,%a12
80000666:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
8000066a:	6d 00 83 06 	call 80001370 <IfxStm_initCompare>
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
8000066e:	df 08 04 00 	jeq %d8,0,80000676 <init_STM+0x52>
    {
        __enable();
80000672:	0d 00 00 03 	enable 

    IfxCpu_restoreInterrupts(ISR_State);                // 진행 중이던 인터럽트 상태 복원
}
80000676:	00 90       	ret 

80000678 <ISR_STM>:


IFX_INTERRUPT(ISR_STM,0,100);
void ISR_STM(void)
{
80000678:	40 ae       	mov.aa %a14,%sp
    __enable();
8000067a:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    IfxStm_clearCompareFlag(STM0, stmConfig.comparator);
8000067e:	91 00 00 c6 	movh.a %a12,24576
80000682:	19 c4 10 60 	ld.w %d4,[%a12]400 <60000190 <stmConfig>>
80000686:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
8000068a:	6d 00 11 06 	call 800012ac <IfxStm_clearCompareFlag>
    IfxStm_increaseCompare(STM0, stmConfig.comparator, 1000000u);     // 비교 값 업데이트 (10000000u를 바꾸면 주기가 바뀜)
8000068e:	19 c2 10 60 	ld.w %d2,[%a12]400 <60000190 <stmConfig>>
}


IFX_INLINE void IfxStm_increaseCompare(Ifx_STM *stm, IfxStm_Comparator comparator, uint32 ticks)
{
    stm->CMP[comparator].B.CMPVAL = stm->CMP[comparator].B.CMPVAL + ticks;
80000692:	1b c2 00 20 	addi %d2,%d2,12
80000696:	06 22       	sh %d2,2
80000698:	60 22       	mov.a %a2,%d2
8000069a:	11 02 00 2f 	addih.a %a2,%a2,61440
8000069e:	54 22       	ld.w %d2,[%a2]
800006a0:	7b f0 00 30 	movh %d3,15
800006a4:	1b 03 24 34 	addi %d3,%d3,16960
800006a8:	42 32       	add %d2,%d3
800006aa:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800006ac:	91 40 00 2f 	movh.a %a2,61444
800006b0:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800006b4:	7b 40 00 20 	movh %d2,4
800006b8:	c2 42       	add %d2,4
800006ba:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2

    IfxPort_togglePin(PORT_102);

    counter1ms++;
800006be:	91 00 00 26 	movh.a %a2,24576
800006c2:	d9 23 1c 00 	lea %a3,[%a2]28 <6000001c <counter1ms>>
800006c6:	54 32       	ld.w %d2,[%a3]
800006c8:	c2 12       	add %d2,1
800006ca:	59 22 1c 00 	st.w [%a2]28 <6000001c <counter1ms>>,%d2

    if((counter1ms % 1) ==0){Scheduler1msFlag = 1;}
800006ce:	91 00 00 26 	movh.a %a2,24576
800006d2:	82 13       	mov %d3,1
800006d4:	59 23 18 00 	st.w [%a2]24 <60000018 <Scheduler1msFlag>>,%d3
    if((counter1ms % 10) ==0){Scheduler10msFlag = 1;}
800006d8:	7b d0 cc 4c 	movh %d4,52429
800006dc:	1b d4 cc 4c 	addi %d4,%d4,-13107
800006e0:	73 42 68 40 	mul.u %e4,%d2,%d4
800006e4:	8f d5 1f 30 	sh %d3,%d5,-3
800006e8:	53 a3 20 30 	mul %d3,%d3,10
800006ec:	5f 32 07 80 	jne %d2,%d3,800006fa <ISR_STM+0x82>
800006f0:	91 00 00 26 	movh.a %a2,24576
800006f4:	82 13       	mov %d3,1
800006f6:	59 23 14 00 	st.w [%a2]20 <60000014 <Scheduler10msFlag>>,%d3
    if((counter1ms % 100) ==0){Scheduler100msFlag = 1;}
800006fa:	7b c0 1e 45 	movh %d4,20972
800006fe:	1b f4 51 48 	addi %d4,%d4,-31457
80000702:	73 42 68 40 	mul.u %e4,%d2,%d4
80000706:	8f b5 1f 30 	sh %d3,%d5,-5
8000070a:	53 43 26 30 	mul %d3,%d3,100
8000070e:	5f 32 07 80 	jne %d2,%d3,8000071c <ISR_STM+0xa4>
80000712:	91 00 00 26 	movh.a %a2,24576
80000716:	82 12       	mov %d2,1
80000718:	59 22 10 00 	st.w [%a2]16 <60000010 <Scheduler100msFlag>>,%d2
}
8000071c:	0d 00 40 02 	rslcx 
80000720:	00 80       	rfe 

80000722 <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80000722:	40 ae       	mov.aa %a14,%sp
80000724:	40 4c       	mov.aa %a12,%a4
80000726:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80000728:	6d 00 38 0b 	call 80001d98 <IfxScuWdt_getSafetyWatchdogPassword>
8000072c:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
8000072e:	02 24       	mov %d4,%d2
80000730:	6d 00 de 09 	call 80001aec <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80000734:	8b 08 a2 32 	ge.u %d3,%d8,32
80000738:	df 03 0d 80 	jne %d3,0,80000752 <IfxVadc_disableAccess+0x30>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
8000073c:	d9 c2 08 20 	lea %a2,[%a12]136
80000740:	19 c2 08 20 	ld.w %d2,[%a12]136
80000744:	d7 12 01 28 	insert %d2,%d2,1,%d8,1
80000748:	74 22       	st.w [%a2],%d2
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
    }

    IfxScuWdt_setSafetyEndinit(passwd);
8000074a:	02 94       	mov %d4,%d9
8000074c:	6d 00 56 0b 	call 80001df8 <IfxScuWdt_setSafetyEndinit>
}
80000750:	00 90       	ret 
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
80000752:	d9 c2 0c 20 	lea %a2,[%a12]140
80000756:	19 c3 0c 20 	ld.w %d3,[%a12]140
8000075a:	8f f8 01 21 	and %d2,%d8,31
8000075e:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80000762:	74 22       	st.w [%a2],%d2
80000764:	1d ff f3 ff 	j 8000074a <IfxVadc_disableAccess+0x28>

80000768 <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80000768:	40 ae       	mov.aa %a14,%sp
8000076a:	40 4c       	mov.aa %a12,%a4
8000076c:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
8000076e:	6d 00 15 0b 	call 80001d98 <IfxScuWdt_getSafetyWatchdogPassword>
80000772:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80000774:	02 24       	mov %d4,%d2
80000776:	6d 00 bb 09 	call 80001aec <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
8000077a:	8b 08 a2 32 	ge.u %d3,%d8,32
8000077e:	df 03 0d 80 	jne %d3,0,80000798 <IfxVadc_enableAccess+0x30>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
80000782:	d9 c2 08 20 	lea %a2,[%a12]136
80000786:	19 c2 08 20 	ld.w %d2,[%a12]136
8000078a:	d7 02 01 28 	insert %d2,%d2,0,%d8,1
8000078e:	74 22       	st.w [%a2],%d2
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80000790:	02 94       	mov %d4,%d9
80000792:	6d 00 33 0b 	call 80001df8 <IfxScuWdt_setSafetyEndinit>
}
80000796:	00 90       	ret 
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
80000798:	d9 c2 0c 20 	lea %a2,[%a12]140
8000079c:	19 c3 0c 20 	ld.w %d3,[%a12]140
800007a0:	8f f8 01 21 	and %d2,%d8,31
800007a4:	d7 03 01 22 	insert %d2,%d3,0,%d2,1
800007a8:	74 22       	st.w [%a2],%d2
800007aa:	1d ff f3 ff 	j 80000790 <IfxVadc_enableAccess+0x28>

800007ae <IfxVadc_disablePostCalibration>:
{
800007ae:	40 ae       	mov.aa %a14,%sp
800007b0:	40 4c       	mov.aa %a12,%a4
800007b2:	02 48       	mov %d8,%d4
800007b4:	8f f5 0f 91 	and %d9,%d5,255
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
800007b8:	bf 84 03 80 	jlt.u %d4,8,800007be <IfxVadc_disablePostCalibration+0x10>
}
800007bc:	00 90       	ret 
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800007be:	3b f0 01 40 	mov %d4,31
800007c2:	6d ff d3 ff 	call 80000768 <IfxVadc_enableAccess>
        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
800007c6:	1b 08 01 80 	addi %d8,%d8,16
800007ca:	82 12       	mov %d2,1
800007cc:	0f 82 00 20 	sh %d2,%d2,%d8
        if (disable == TRUE)
800007d0:	df 19 10 00 	jeq %d9,1,800007f0 <IfxVadc_disablePostCalibration+0x42>
            vadc->GLOBCFG.U &= ~mask;
800007d4:	d9 c2 00 20 	lea %a2,[%a12]128
800007d8:	19 c3 00 20 	ld.w %d3,[%a12]128
800007dc:	0f 23 e0 20 	andn %d2,%d3,%d2
800007e0:	74 22       	st.w [%a2],%d2
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800007e2:	3b f0 01 40 	mov %d4,31
800007e6:	40 c4       	mov.aa %a4,%a12
800007e8:	6d ff 9d ff 	call 80000722 <IfxVadc_disableAccess>
}
800007ec:	1d ff e8 ff 	j 800007bc <IfxVadc_disablePostCalibration+0xe>
            vadc->GLOBCFG.U |= mask;
800007f0:	d9 c2 00 20 	lea %a2,[%a12]128
800007f4:	19 c3 00 20 	ld.w %d3,[%a12]128
800007f8:	a6 32       	or %d2,%d3
800007fa:	74 22       	st.w [%a2],%d2
800007fc:	1d ff f3 ff 	j 800007e2 <IfxVadc_disablePostCalibration+0x34>

80000800 <IfxVadc_getAdcAnalogFrequency>:
    IfxScuWdt_setCpuEndinit(passwd);
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
80000800:	40 ae       	mov.aa %a14,%sp
80000802:	40 4c       	mov.aa %a12,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
80000804:	6d 00 66 07 	call 800016d0 <IfxScuCcu_getSpbFrequency>
80000808:	19 c3 00 20 	ld.w %d3,[%a12]128
8000080c:	8f f3 01 31 	and %d3,%d3,31
80000810:	c2 13       	add %d3,1
80000812:	4b 03 61 31 	utof %d3,%d3
}
80000816:	4b 32 51 20 	div.f %d2,%d2,%d3
8000081a:	00 90       	ret 

8000081c <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
8000081c:	40 ae       	mov.aa %a14,%sp
8000081e:	40 4c       	mov.aa %a12,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
80000820:	6d 00 58 07 	call 800016d0 <IfxScuCcu_getSpbFrequency>
80000824:	19 c3 00 20 	ld.w %d3,[%a12]128
80000828:	37 03 62 34 	extr.u %d3,%d3,8,2
8000082c:	c2 13       	add %d3,1
8000082e:	4b 03 61 31 	utof %d3,%d3
}
80000832:	4b 32 51 20 	div.f %d2,%d2,%d3
80000836:	00 90       	ret 

80000838 <IfxVadc_getSrcAddress>:
    }
}


volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
80000838:	40 ae       	mov.aa %a14,%sp
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
8000083a:	bf 45 07 80 	jlt.u %d5,4,80000848 <IfxVadc_getSrcAddress+0x10>
    {
        index -= 4;
8000083e:	c2 c5       	add %d5,-4

        if ((group & 0x1) != 0)
80000840:	6f 04 10 00 	jz.t %d4,0,80000860 <IfxVadc_getSrcAddress+0x28>
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
80000844:	3b 90 00 40 	mov %d4,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
80000848:	8f 24 00 20 	sh %d2,%d4,2
8000084c:	42 52       	add %d2,%d5
8000084e:	06 22       	sh %d2,2
80000850:	91 00 00 28 	movh.a %a2,32768
80000854:	d9 22 04 90 	lea %a2,[%a2]580 <80000244 <IfxVadc_cfg_srcAddresses>>
80000858:	01 22 00 26 	addsc.a %a2,%a2,%d2,0

    return &(base[0]);
}
8000085c:	d4 22       	ld.a %a2,[%a2]
8000085e:	00 90       	ret 
            group = IfxVadc_GroupId_global0;    /* Shared interrupt common 0 is used */
80000860:	3b 80 00 40 	mov %d4,8
80000864:	1d ff f2 ff 	j 80000848 <IfxVadc_getSrcAddress+0x10>

80000868 <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
80000868:	40 ae       	mov.aa %a14,%sp
8000086a:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
8000086c:	19 42 00 20 	ld.w %d2,[%a4]128
80000870:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
80000872:	37 48 02 84 	insert %d8,%d8,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
80000876:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
8000087a:	3b f0 01 40 	mov %d4,31
8000087e:	6d ff 75 ff 	call 80000768 <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80000882:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80000886:	3b f0 01 40 	mov %d4,31
8000088a:	40 c4       	mov.aa %a4,%a12
8000088c:	6d ff 4b ff 	call 80000722 <IfxVadc_disableAccess>
}
80000890:	00 90       	ret 

80000892 <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
80000892:	40 ae       	mov.aa %a14,%sp
80000894:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80000896:	19 42 00 20 	ld.w %d2,[%a4]128
8000089a:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.DIVA  = converterClockDivider;
8000089c:	37 48 05 80 	insert %d8,%d8,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
800008a0:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
800008a4:	3b f0 01 40 	mov %d4,31
800008a8:	6d ff 60 ff 	call 80000768 <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
800008ac:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
800008b0:	3b f0 01 40 	mov %d4,31
800008b4:	40 c4       	mov.aa %a4,%a12
800008b6:	6d ff 36 ff 	call 80000722 <IfxVadc_disableAccess>
}
800008ba:	00 90       	ret 

800008bc <IfxVadc_initializeFAdcD>:


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
800008bc:	40 ae       	mov.aa %a14,%sp
800008be:	80 4a       	mov.d %d10,%a4
800008c0:	02 48       	mov %d8,%d4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
800008c2:	6d 00 07 07 	call 800016d0 <IfxScuCcu_getSpbFrequency>
800008c6:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
800008ca:	4b 82 11 82 	div.u %e8,%d2,%d8
800008ce:	1b f8 ff 3f 	addi %d3,%d8,-1
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
800008d2:	82 34       	mov %d4,3
800008d4:	0b 43 90 41 	min.u %d4,%d3,%d4

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
800008d8:	1b 14 00 80 	addi %d8,%d4,1
800008dc:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
800008e0:	60 a4       	mov.a %a4,%d10
800008e2:	6d ff c3 ff 	call 80000868 <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
800008e6:	02 82       	mov %d2,%d8
800008e8:	00 90       	ret 

800008ea <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
800008ea:	40 ae       	mov.aa %a14,%sp
800008ec:	80 49       	mov.d %d9,%a4
800008ee:	02 48       	mov %d8,%d4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
800008f0:	6d 00 f0 06 	call 800016d0 <IfxScuCcu_getSpbFrequency>
800008f4:	4b 02 71 31 	ftouz %d3,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
800008f8:	8f 23 00 40 	sh %d4,%d3,2
800008fc:	4b 84 11 42 	div.u %e4,%d4,%d8

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
80000900:	1b 24 00 20 	addi %d2,%d4,2
80000904:	06 e2       	sh %d2,-2
    divA   = __minu(divA - 1, 0x1Fu);
80000906:	c2 f2       	add %d2,-1
80000908:	3b f0 01 40 	mov %d4,31
8000090c:	0b 42 90 41 	min.u %d4,%d2,%d4
    result = fadc / (divA + 1);
80000910:	1b 14 00 20 	addi %d2,%d4,1
80000914:	4b 23 11 62 	div.u %e6,%d3,%d2
80000918:	02 68       	mov %d8,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
8000091a:	7b 10 13 50 	movh %d5,305
8000091e:	1b 05 d0 52 	addi %d5,%d5,11520
80000922:	7f 65 0b 80 	jge.u %d5,%d6,80000938 <IfxVadc_initializeFAdcI+0x4e>
80000926:	3b f0 01 40 	mov %d4,31
8000092a:	0b 42 90 41 	min.u %d4,%d2,%d4
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
8000092e:	1b 14 00 20 	addi %d2,%d4,1
80000932:	4b 23 11 22 	div.u %e2,%d3,%d2
80000936:	02 28       	mov %d8,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
80000938:	7b 80 ff 2f 	movh %d2,65528
8000093c:	1b 02 ee 25 	addi %d2,%d2,24288
80000940:	42 82       	add %d2,%d8
80000942:	7b a0 12 30 	movh %d3,298
80000946:	1b 03 be 38 	addi %d3,%d3,-29728
8000094a:	7f 23 05 80 	jge.u %d3,%d2,80000954 <IfxVadc_initializeFAdcI+0x6a>
    {
        result = 0;             /* Min / Max FAdcI frequency */
8000094e:	82 08       	mov %d8,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
80000950:	02 82       	mov %d2,%d8
80000952:	00 90       	ret 
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
80000954:	60 94       	mov.a %a4,%d9
80000956:	6d ff 9e ff 	call 80000892 <IfxVadc_initialiseAdcConverterClock>
8000095a:	1d ff fb ff 	j 80000950 <IfxVadc_initializeFAdcI+0x66>

8000095e <IfxVadc_selectPowerSupplyVoltage>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
8000095e:	40 ae       	mov.aa %a14,%sp
80000960:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80000962:	19 42 00 20 	ld.w %d2,[%a4]128
80000966:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.LOSUP = supplyVoltage;
80000968:	67 48 0e 80 	ins.t %d8,%d8,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
8000096c:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80000970:	3b f0 01 40 	mov %d4,31
80000974:	6d ff fa fe 	call 80000768 <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80000978:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
8000097c:	3b f0 01 40 	mov %d4,31
80000980:	40 c4       	mov.aa %a4,%a12
80000982:	6d ff d0 fe 	call 80000722 <IfxVadc_disableAccess>
}
80000986:	00 90       	ret 

80000988 <IfxVadc_setArbiterPriority>:


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80000988:	40 ae       	mov.aa %a14,%sp
8000098a:	02 50       	mov %d0,%d5
    if (slotEnable != FALSE)
8000098c:	df 04 2a 00 	jeq %d4,0,800009e0 <IfxVadc_setArbiterPriority+0x58>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80000990:	d9 42 04 00 	lea %a2,[%a4]4
80000994:	19 43 04 00 	ld.w %d3,[%a4]4
80000998:	1b 87 01 20 	addi %d2,%d7,24
8000099c:	0f 24 00 20 	sh %d2,%d4,%d2
800009a0:	a6 32       	or %d2,%d3
800009a2:	74 22       	st.w [%a2],%d2
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
800009a4:	54 23       	ld.w %d3,[%a2]
800009a6:	06 27       	sh %d7,2
800009a8:	82 32       	mov %d2,3
800009aa:	0f 72 00 20 	sh %d2,%d2,%d7
800009ae:	0f 23 e0 20 	andn %d2,%d3,%d2
800009b2:	74 22       	st.w [%a2],%d2
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
800009b4:	54 23       	ld.w %d3,[%a2]
800009b6:	0f 70 00 20 	sh %d2,%d0,%d7
800009ba:	a6 32       	or %d2,%d3
800009bc:	74 22       	st.w [%a2],%d2

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
800009be:	df 06 08 00 	jeq %d6,0,800009ce <IfxVadc_setArbiterPriority+0x46>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
800009c2:	54 22       	ld.w %d2,[%a2]
800009c4:	c2 37       	add %d7,3
800009c6:	d7 12 01 27 	insert %d2,%d2,1,%d7,1
800009ca:	74 22       	st.w [%a2],%d2
800009cc:	00 90       	ret 
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
800009ce:	d9 42 04 00 	lea %a2,[%a4]4
800009d2:	19 42 04 00 	ld.w %d2,[%a4]4
800009d6:	c2 37       	add %d7,3
800009d8:	d7 02 01 27 	insert %d2,%d2,0,%d7,1
800009dc:	74 22       	st.w [%a2],%d2
800009de:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
800009e0:	d9 42 04 00 	lea %a2,[%a4]4
800009e4:	19 43 04 00 	ld.w %d3,[%a4]4
800009e8:	1b 87 01 20 	addi %d2,%d7,24
800009ec:	d7 03 01 22 	insert %d2,%d3,0,%d2,1
800009f0:	74 22       	st.w [%a2],%d2
    }
}
800009f2:	00 90       	ret 

800009f4 <IfxVadc_setScan>:


void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
800009f4:	40 ae       	mov.aa %a14,%sp
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
800009f6:	d9 42 28 20 	lea %a2,[%a4]168
800009fa:	19 42 28 20 	ld.w %d2,[%a4]168
800009fe:	0f 42 c0 30 	xor %d3,%d2,%d4
80000a02:	26 53       	and %d3,%d5
80000a04:	c6 32       	xor %d2,%d3
80000a06:	74 22       	st.w [%a2],%d2
}
80000a08:	00 90       	ret 

80000a0a <IfxVadc_startupCalibration>:


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80000a0a:	40 ae       	mov.aa %a14,%sp
80000a0c:	40 4c       	mov.aa %a12,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80000a0e:	3b f0 01 40 	mov %d4,31
80000a12:	6d ff ab fe 	call 80000768 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80000a16:	d9 c2 00 20 	lea %a2,[%a12]128
80000a1a:	19 c2 00 20 	ld.w %d2,[%a12]128
80000a1e:	b7 12 81 2f 	insert %d2,%d2,1,31,1
80000a22:	74 22       	st.w [%a2],%d2
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80000a24:	3b f0 01 40 	mov %d4,31
80000a28:	40 c4       	mov.aa %a4,%a12
80000a2a:	6d ff 7c fe 	call 80000722 <IfxVadc_disableAccess>
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80000a2e:	82 02       	mov %d2,0
        calibrationRunning = FALSE;
80000a30:	82 04       	mov %d4,0
        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80000a32:	1d 00 05 00 	j 80000a3c <IfxVadc_startupCalibration+0x32>
80000a36:	c2 12       	add %d2,1
80000a38:	8f f2 0f 21 	and %d2,%d2,255
80000a3c:	ff 82 0d 80 	jge.u %d2,8,80000a56 <IfxVadc_startupCalibration+0x4c>
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
80000a40:	8f a2 00 30 	sh %d3,%d2,10
80000a44:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80000a48:	19 23 40 20 	ld.w %d3,[%a2]1152
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
80000a4c:	ef c3 f5 7f 	jz.t %d3,28,80000a36 <IfxVadc_startupCalibration+0x2c>
            {
                calibrationRunning = TRUE;
80000a50:	82 14       	mov %d4,1
80000a52:	1d ff f2 ff 	j 80000a36 <IfxVadc_startupCalibration+0x2c>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80000a56:	df 04 ec ff 	jne %d4,0,80000a2e <IfxVadc_startupCalibration+0x24>
}
80000a5a:	00 90       	ret 

80000a5c <IfxVadc_Adc_initChannel>:
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
80000a5c:	40 ae       	mov.aa %a14,%sp
80000a5e:	40 4f       	mov.aa %a15,%a4
80000a60:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
80000a62:	99 52 38 00 	ld.a %a2,[%a5]56
}


IFX_INLINE Ifx_VADC *IfxVadc_Adc_getVadcFromGroup(const IfxVadc_Adc_Group *group)
{
    return group->module.vadc;
80000a66:	54 28       	ld.w %d8,[%a2]
    return group->group;
80000a68:	99 2d 04 00 	ld.a %a13,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
80000a6c:	b5 42 08 00 	st.a [%a4]8,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
80000a70:	19 29 08 00 	ld.w %d9,[%a2]8
    IfxVadc_ChannelId channelIndex = config->channelId;
80000a74:	19 5a 18 00 	ld.w %d10,[%a5]24

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80000a78:	02 94       	mov %d4,%d9
80000a7a:	60 84       	mov.a %a4,%d8
80000a7c:	6d ff 76 fe 	call 80000768 <IfxVadc_enableAccess>

    /* Configure Channel */
    {
        IfxVadc_setReferenceInput(vadcG, channelIndex, config->reference);
80000a80:	19 c3 20 00 	ld.w %d3,[%a12]32
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
80000a84:	1b 0a 06 20 	addi %d2,%d10,96
80000a88:	06 22       	sh %d2,2
80000a8a:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000a8e:	54 22       	ld.w %d2,[%a2]
80000a90:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
80000a94:	74 22       	st.w [%a2],%d2
        IfxVadc_storeGroupResult(vadcG, channelIndex, config->resultRegister);
80000a96:	19 c3 24 00 	ld.w %d3,[%a12]36
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
80000a9a:	54 22       	ld.w %d2,[%a2]
80000a9c:	37 32 04 28 	insert %d2,%d2,%d3,16,4
80000aa0:	74 22       	st.w [%a2],%d2
        IfxVadc_setLowerBoundary(vadcG, channelIndex, config->lowerBoundary);
80000aa2:	19 c3 28 00 	ld.w %d3,[%a12]40
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
80000aa6:	54 22       	ld.w %d2,[%a2]
80000aa8:	37 32 02 22 	insert %d2,%d2,%d3,4,2
80000aac:	74 22       	st.w [%a2],%d2
        IfxVadc_setUpperBoundary(vadcG, channelIndex, config->upperBoundary);
80000aae:	19 c3 2c 00 	ld.w %d3,[%a12]44
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
80000ab2:	54 22       	ld.w %d2,[%a2]
80000ab4:	37 32 02 23 	insert %d2,%d2,%d3,6,2
80000ab8:	74 22       	st.w [%a2],%d2
        IfxVadc_setSyncRequest(vadcG, channelIndex, config->synchonize);
80000aba:	39 c3 01 00 	ld.bu %d3,[%a12]1
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
80000abe:	54 22       	ld.w %d2,[%a2]
80000ac0:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
80000ac4:	74 22       	st.w [%a2],%d2
        IfxVadc_setChannelInputClass(vadcG, channelIndex, config->inputClass);
80000ac6:	19 c3 1c 00 	ld.w %d3,[%a12]28
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
80000aca:	54 22       	ld.w %d2,[%a2]
80000acc:	37 32 02 20 	insert %d2,%d2,%d3,0,2
80000ad0:	74 22       	st.w [%a2],%d2
        IfxVadc_setChannelLimitCheckMode(vadcG, channelIndex, config->limitCheck);
80000ad2:	19 c3 34 00 	ld.w %d3,[%a12]52
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
80000ad6:	54 22       	ld.w %d2,[%a2]
80000ad8:	37 32 02 24 	insert %d2,%d2,%d3,8,2
80000adc:	74 22       	st.w [%a2],%d2
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
80000ade:	39 c3 03 00 	ld.bu %d3,[%a12]3
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
80000ae2:	54 22       	ld.w %d2,[%a2]
80000ae4:	67 32 15 20 	ins.t %d2,%d2,21,%d3,0
80000ae8:	74 22       	st.w [%a2],%d2
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
80000aea:	14 c3       	ld.bu %d3,[%a12]
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
80000aec:	54 22       	ld.w %d2,[%a2]
80000aee:	67 32 14 20 	ins.t %d2,%d2,20,%d3,0
80000af2:	74 22       	st.w [%a2],%d2
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
80000af4:	19 c3 30 00 	ld.w %d3,[%a12]48
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
80000af8:	54 22       	ld.w %d2,[%a2]
80000afa:	37 32 04 26 	insert %d2,%d2,%d3,12,4
80000afe:	74 22       	st.w [%a2],%d2
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80000b00:	1b 09 01 b0 	addi %d11,%d9,16
80000b04:	02 b4       	mov %d4,%d11
80000b06:	60 84       	mov.a %a4,%d8
80000b08:	6d ff 30 fe 	call 80000768 <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
80000b0c:	39 c2 02 00 	ld.bu %d2,[%a12]2
80000b10:	df 02 4c 80 	jne %d2,0,80000ba8 <IfxVadc_Adc_initChannel+0x14c>
    vadcG->CHASS.U |= (1 << channelIndex);
80000b14:	d9 d2 08 00 	lea %a2,[%a13]8
80000b18:	19 d2 08 00 	ld.w %d2,[%a13]8
80000b1c:	d7 12 01 2a 	insert %d2,%d2,1,%d10,1
80000b20:	74 22       	st.w [%a2],%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80000b22:	02 b4       	mov %d4,%d11
80000b24:	60 84       	mov.a %a4,%d8
80000b26:	6d ff fe fd 	call 80000722 <IfxVadc_disableAccess>

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
80000b2a:	19 c4 14 00 	ld.w %d4,[%a12]20
80000b2e:	48 02       	ld.w %d2,[%a15]0
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
80000b30:	d9 d2 20 40 	lea %a2,[%a13]288
80000b34:	19 d5 20 40 	ld.w %d5,[%a13]288
80000b38:	06 22       	sh %d2,2
80000b3a:	3b f0 00 30 	mov %d3,15
80000b3e:	0f 23 00 30 	sh %d3,%d3,%d2
80000b42:	0f 35 e0 30 	andn %d3,%d5,%d3
80000b46:	74 23       	st.w [%a2],%d3
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
80000b48:	54 23       	ld.w %d3,[%a2]
80000b4a:	0f 24 00 20 	sh %d2,%d4,%d2
80000b4e:	a6 32       	or %d2,%d3
80000b50:	74 22       	st.w [%a2],%d2

    if (config->channelPriority > 0)
80000b52:	b9 c2 06 00 	ld.hu %d2,[%a12]6
80000b56:	df 02 32 80 	jne %d2,0,80000bba <IfxVadc_Adc_initChannel+0x15e>
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80000b5a:	19 c2 24 00 	ld.w %d2,[%a12]36
80000b5e:	ff 82 51 80 	jge.u %d2,8,80000c00 <IfxVadc_Adc_initChannel+0x1a4>
    {
        IfxVadc_setResultNodeEventPointer0(vadcG, config->resultSrcNr, config->resultRegister);
80000b62:	19 c4 10 00 	ld.w %d4,[%a12]16
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
80000b66:	d9 d2 30 40 	lea %a2,[%a13]304
80000b6a:	19 d5 30 40 	ld.w %d5,[%a13]304
80000b6e:	06 22       	sh %d2,2
80000b70:	3b f0 00 30 	mov %d3,15
80000b74:	0f 23 00 30 	sh %d3,%d3,%d2
80000b78:	0f 35 e0 30 	andn %d3,%d5,%d3
80000b7c:	74 23       	st.w [%a2],%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
80000b7e:	54 23       	ld.w %d3,[%a2]
80000b80:	0f 24 00 20 	sh %d2,%d4,%d2
80000b84:	a6 32       	or %d2,%d3
80000b86:	74 22       	st.w [%a2],%d2
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
80000b88:	b9 c2 04 00 	ld.hu %d2,[%a12]4
80000b8c:	df 02 50 80 	jne %d2,0,80000c2c <IfxVadc_Adc_initChannel+0x1d0>
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80000b90:	02 94       	mov %d4,%d9
80000b92:	60 84       	mov.a %a4,%d8
80000b94:	6d ff c7 fd 	call 80000722 <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80000b98:	19 c2 24 00 	ld.w %d2,[%a12]36
80000b9c:	68 12       	st.w [%a15]4,%d2
    channel->channel   = config->channelId;
80000b9e:	19 c2 18 00 	ld.w %d2,[%a12]24
80000ba2:	68 02       	st.w [%a15]0,%d2

    return Status;
}
80000ba4:	82 02       	mov %d2,0
80000ba6:	00 90       	ret 
    vadcG->CHASS.U &= ~(1 << channelIndex);
80000ba8:	d9 d2 08 00 	lea %a2,[%a13]8
80000bac:	19 d2 08 00 	ld.w %d2,[%a13]8
80000bb0:	d7 02 01 2a 	insert %d2,%d2,0,%d10,1
80000bb4:	74 22       	st.w [%a2],%d2
}
80000bb6:	1d ff b6 ff 	j 80000b22 <IfxVadc_Adc_initChannel+0xc6>
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
80000bba:	19 c5 14 00 	ld.w %d5,[%a12]20
80000bbe:	02 94       	mov %d4,%d9
80000bc0:	6d ff 3c fe 	call 80000838 <IfxVadc_getSrcAddress>
        IfxVadc_clearChannelRequest(vadcG, config->channelId);
80000bc4:	19 c4 18 00 	ld.w %d4,[%a12]24
    vadcG->CEFCLR.U = 1 << channelId;
80000bc8:	82 13       	mov %d3,1
80000bca:	82 12       	mov %d2,1
80000bcc:	0f 42 00 20 	sh %d2,%d2,%d4
80000bd0:	59 d2 10 40 	st.w [%a13]272,%d2
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
80000bd4:	19 c5 0c 00 	ld.w %d5,[%a12]12
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
80000bd8:	39 c4 06 00 	ld.bu %d4,[%a12]6
80000bdc:	54 22       	ld.w %d2,[%a2]
80000bde:	37 42 08 20 	insert %d2,%d2,%d4,0,8
80000be2:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80000be4:	54 22       	ld.w %d2,[%a2]
80000be6:	37 52 82 25 	insert %d2,%d2,%d5,11,2
80000bea:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80000bec:	54 22       	ld.w %d2,[%a2]
80000bee:	67 32 19 20 	ins.t %d2,%d2,25,%d3,0
80000bf2:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80000bf4:	54 22       	ld.w %d2,[%a2]
80000bf6:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
80000bfa:	74 22       	st.w [%a2],%d2
}
80000bfc:	1d ff af ff 	j 80000b5a <IfxVadc_Adc_initChannel+0xfe>
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
80000c00:	19 c4 10 00 	ld.w %d4,[%a12]16
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80000c04:	d9 d2 34 40 	lea %a2,[%a13]308
80000c08:	19 d5 34 40 	ld.w %d5,[%a13]308
80000c0c:	c2 82       	add %d2,-8
80000c0e:	06 22       	sh %d2,2
80000c10:	3b f0 00 30 	mov %d3,15
80000c14:	0f 23 00 30 	sh %d3,%d3,%d2
80000c18:	0f 35 e0 30 	andn %d3,%d5,%d3
80000c1c:	74 23       	st.w [%a2],%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
80000c1e:	54 23       	ld.w %d3,[%a2]
80000c20:	0f 24 00 20 	sh %d2,%d4,%d2
80000c24:	a6 32       	or %d2,%d3
80000c26:	74 22       	st.w [%a2],%d2
}
80000c28:	1d ff b0 ff 	j 80000b88 <IfxVadc_Adc_initChannel+0x12c>
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
80000c2c:	19 c5 10 00 	ld.w %d5,[%a12]16
80000c30:	02 94       	mov %d4,%d9
80000c32:	6d ff 03 fe 	call 80000838 <IfxVadc_getSrcAddress>
    vadcG->RCR[resultRegister].B.SRGEN = 1;
80000c36:	19 c2 24 00 	ld.w %d2,[%a12]36
80000c3a:	1b 02 08 20 	addi %d2,%d2,128
80000c3e:	06 22       	sh %d2,2
80000c40:	01 d2 00 36 	addsc.a %a3,%a13,%d2,0
80000c44:	54 32       	ld.w %d2,[%a3]
80000c46:	b7 12 81 2f 	insert %d2,%d2,1,31,1
80000c4a:	74 32       	st.w [%a3],%d2
    vadcG->REFCLR.U = 0x0000FFFFu;
80000c4c:	bb f0 ff 2f 	mov.u %d2,65535
80000c50:	59 d2 14 40 	st.w [%a13]276,%d2
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
80000c54:	19 c4 08 00 	ld.w %d4,[%a12]8
    src->B.SRPN = priority;
80000c58:	39 c3 04 00 	ld.bu %d3,[%a12]4
80000c5c:	54 22       	ld.w %d2,[%a2]
80000c5e:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80000c62:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80000c64:	54 22       	ld.w %d2,[%a2]
80000c66:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80000c6a:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80000c6c:	54 22       	ld.w %d2,[%a2]
80000c6e:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80000c72:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80000c74:	54 22       	ld.w %d2,[%a2]
80000c76:	b7 12 01 25 	insert %d2,%d2,1,10,1
80000c7a:	74 22       	st.w [%a2],%d2
}
80000c7c:	1d ff 8a ff 	j 80000b90 <IfxVadc_Adc_initChannel+0x134>

80000c80 <IfxVadc_Adc_initChannelConfig>:


void IfxVadc_Adc_initChannelConfig(IfxVadc_Adc_ChannelConfig *config, const IfxVadc_Adc_Group *group)
{
80000c80:	40 ae       	mov.aa %a14,%sp
80000c82:	40 4c       	mov.aa %a12,%a4
80000c84:	80 58       	mov.d %d8,%a5
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
80000c86:	3b c0 03 50 	mov %d5,60
80000c8a:	82 04       	mov %d4,0
80000c8c:	6d 00 6e 12 	call 80003168 <memset>
    config->group = group;
80000c90:	59 c8 38 00 	st.w [%a12]56,%d8
}
80000c94:	00 90       	ret 

80000c96 <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
80000c96:	40 ae       	mov.aa %a14,%sp
80000c98:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80000c9a:	d4 52       	ld.a %a2,[%a5]
80000c9c:	d4 2d       	ld.a %a13,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
80000c9e:	19 58 04 00 	ld.w %d8,[%a5]4
80000ca2:	8f a8 00 20 	sh %d2,%d8,10
80000ca6:	1b 02 48 20 	addi %d2,%d2,1152
80000caa:	80 d3       	mov.d %d3,%a13
80000cac:	0b 23 00 90 	add %d9,%d3,%d2

    /* check for write access */
    group->group   = vadcG;
80000cb0:	59 49 04 00 	st.w [%a4]4,%d9
    group->module  = *config->module;
80000cb4:	d4 52       	ld.a %a2,[%a5]
80000cb6:	54 22       	ld.w %d2,[%a2]
80000cb8:	74 42       	st.w [%a4],%d2
    IfxVadc_GroupId groupIndex      = config->groupId;
80000cba:	19 5a 04 00 	ld.w %d10,[%a5]4
    group->groupId = groupIndex;
80000cbe:	59 4a 08 00 	st.w [%a4]8,%d10
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80000cc2:	40 d4       	mov.aa %a4,%a13
80000cc4:	6d ff 9e fd 	call 80000800 <IfxVadc_getAdcAnalogFrequency>
80000cc8:	02 2c       	mov %d12,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80000cca:	1b 0a 01 b0 	addi %d11,%d10,16
80000cce:	02 b4       	mov %d4,%d11
80000cd0:	40 d4       	mov.aa %a4,%a13
80000cd2:	6d ff 4b fd 	call 80000768 <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80000cd6:	39 c4 38 10 	ld.bu %d4,[%a12]120
80000cda:	df 14 7c 00 	jeq %d4,1,80000dd2 <IfxVadc_Adc_initGroup+0x13c>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
80000cde:	82 07       	mov %d7,0
80000ce0:	82 06       	mov %d6,0
80000ce2:	82 05       	mov %d5,0
80000ce4:	82 04       	mov %d4,0
80000ce6:	60 94       	mov.a %a4,%d9
80000ce8:	6d ff 50 fe 	call 80000988 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
80000cec:	39 c4 39 10 	ld.bu %d4,[%a12]121
80000cf0:	df 14 7b 00 	jeq %d4,1,80000de6 <IfxVadc_Adc_initGroup+0x150>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
80000cf4:	82 17       	mov %d7,1
80000cf6:	82 06       	mov %d6,0
80000cf8:	82 05       	mov %d5,0
80000cfa:	82 04       	mov %d4,0
80000cfc:	60 94       	mov.a %a4,%d9
80000cfe:	6d ff 45 fe 	call 80000988 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80000d02:	39 c4 3a 10 	ld.bu %d4,[%a12]122
80000d06:	df 14 7a 00 	jeq %d4,1,80000dfa <IfxVadc_Adc_initGroup+0x164>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
80000d0a:	82 27       	mov %d7,2
80000d0c:	82 06       	mov %d6,0
80000d0e:	82 05       	mov %d5,0
80000d10:	82 04       	mov %d4,0
80000d12:	60 94       	mov.a %a4,%d9
80000d14:	6d ff 3a fe 	call 80000988 <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
80000d18:	19 c2 08 00 	ld.w %d2,[%a12]8
80000d1c:	5f a2 22 00 	jeq %d2,%d10,80000d60 <IfxVadc_Adc_initGroup+0xca>
    return IfxVadc_Adc_masterIndex[slave][master];
80000d20:	8f 3a 00 30 	sh %d3,%d10,3
80000d24:	91 00 00 28 	movh.a %a2,32768
80000d28:	d9 22 24 b0 	lea %a2,[%a2]740 <800002e4 <IfxVadc_Adc_masterIndex>>
80000d2c:	80 24       	mov.d %d4,%a2
80000d2e:	42 34       	add %d4,%d3
80000d30:	60 42       	mov.a %a2,%d4
80000d32:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80000d36:	14 22       	ld.bu %d2,[%a2]
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
80000d38:	8f a8 00 30 	sh %d3,%d8,10
80000d3c:	01 d3 00 26 	addsc.a %a2,%a13,%d3,0
80000d40:	d9 23 40 30 	lea %a3,[%a2]1216
80000d44:	19 23 40 30 	ld.w %d3,[%a2]1216
80000d48:	37 23 02 30 	insert %d3,%d3,%d2,0,2
80000d4c:	74 33       	st.w [%a3],%d3
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
80000d4e:	54 33       	ld.w %d3,[%a3]
80000d50:	8f 32 00 21 	and %d2,%d2,3
80000d54:	3b 80 00 40 	mov %d4,8
80000d58:	0f 24 00 20 	sh %d2,%d4,%d2
80000d5c:	a6 32       	or %d2,%d3
80000d5e:	74 32       	st.w [%a3],%d2
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80000d60:	8f a8 00 20 	sh %d2,%d8,10
80000d64:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000d68:	d9 23 40 20 	lea %a3,[%a2]1152
80000d6c:	19 23 40 20 	ld.w %d3,[%a2]1152
80000d70:	8f 33 c0 31 	andn %d3,%d3,3
80000d74:	74 33       	st.w [%a3],%d3

    /* Setup arbiter */
    /* turn off the group during initialization, see UM for sync mode */
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);
80000d76:	19 c2 34 10 	ld.w %d2,[%a12]116
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
80000d7a:	d9 23 40 20 	lea %a3,[%a2]1152
80000d7e:	19 23 40 20 	ld.w %d3,[%a2]1152
80000d82:	37 23 02 32 	insert %d3,%d3,%d2,4,2
80000d86:	74 33       	st.w [%a3],%d3

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80000d88:	39 c2 38 10 	ld.bu %d2,[%a12]120
80000d8c:	df 12 41 00 	jeq %d2,1,80000e0e <IfxVadc_Adc_initGroup+0x178>
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
80000d90:	39 c2 39 10 	ld.bu %d2,[%a12]121
80000d94:	df 12 b0 00 	jeq %d2,1,80000ef4 <IfxVadc_Adc_initGroup+0x25e>
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80000d98:	39 c2 3a 10 	ld.bu %d2,[%a12]122
80000d9c:	df 12 1f 01 	jeq %d2,1,80000fda <IfxVadc_Adc_initGroup+0x344>
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80000da0:	19 c2 08 00 	ld.w %d2,[%a12]8
80000da4:	5f a2 76 01 	jeq %d2,%d10,80001090 <IfxVadc_Adc_initGroup+0x3fa>
80000da8:	82 04       	mov %d4,0
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80000daa:	8f a8 00 20 	sh %d2,%d8,10
80000dae:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000db2:	d9 23 40 20 	lea %a3,[%a2]1152
80000db6:	19 23 40 20 	ld.w %d3,[%a2]1152
80000dba:	37 43 02 30 	insert %d3,%d3,%d4,0,2
80000dbe:	74 33       	st.w [%a3],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
80000dc0:	39 c5 30 10 	ld.bu %d5,[%a12]112
80000dc4:	02 a4       	mov %d4,%d10
80000dc6:	40 d4       	mov.aa %a4,%a13
80000dc8:	6d ff f3 fc 	call 800007ae <IfxVadc_disablePostCalibration>

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80000dcc:	82 03       	mov %d3,0
80000dce:	1d 00 77 01 	j 800010bc <IfxVadc_Adc_initGroup+0x426>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
80000dd2:	82 07       	mov %d7,0
80000dd4:	19 c6 10 10 	ld.w %d6,[%a12]80
80000dd8:	19 c5 0c 10 	ld.w %d5,[%a12]76
80000ddc:	60 94       	mov.a %a4,%d9
80000dde:	6d ff d5 fd 	call 80000988 <IfxVadc_setArbiterPriority>
80000de2:	1d ff 85 ff 	j 80000cec <IfxVadc_Adc_initGroup+0x56>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
80000de6:	82 17       	mov %d7,1
80000de8:	19 c6 34 00 	ld.w %d6,[%a12]52
80000dec:	19 c5 30 00 	ld.w %d5,[%a12]48
80000df0:	60 94       	mov.a %a4,%d9
80000df2:	6d ff cb fd 	call 80000988 <IfxVadc_setArbiterPriority>
80000df6:	1d ff 86 ff 	j 80000d02 <IfxVadc_Adc_initGroup+0x6c>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
80000dfa:	82 27       	mov %d7,2
80000dfc:	19 c6 2c 10 	ld.w %d6,[%a12]108
80000e00:	19 c5 28 10 	ld.w %d5,[%a12]104
80000e04:	60 94       	mov.a %a4,%d9
80000e06:	6d ff c1 fd 	call 80000988 <IfxVadc_setArbiterPriority>
80000e0a:	1d ff 87 ff 	j 80000d18 <IfxVadc_Adc_initGroup+0x82>
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80000e0e:	19 c2 08 10 	ld.w %d2,[%a12]72
80000e12:	df 02 37 00 	jeq %d2,0,80000e80 <IfxVadc_Adc_initGroup+0x1ea>
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
80000e16:	8f a8 00 20 	sh %d2,%d8,10
80000e1a:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000e1e:	d9 23 44 40 	lea %a3,[%a2]1284
80000e22:	19 22 44 40 	ld.w %d2,[%a2]1284
80000e26:	b7 12 01 21 	insert %d2,%d2,1,2,1
80000e2a:	74 32       	st.w [%a3],%d2
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
80000e2c:	19 c5 08 10 	ld.w %d5,[%a12]72
80000e30:	19 c4 00 10 	ld.w %d4,[%a12]64
    qctrl0.U        = vadcG->QCTRL0.U;
80000e34:	d9 23 40 40 	lea %a3,[%a2]1280
80000e38:	19 22 40 40 	ld.w %d2,[%a2]1280
    qctrl0.B.XTWC   = 1;
80000e3c:	b7 12 81 27 	insert %d2,%d2,1,15,1
    qctrl0.B.XTMODE = triggerMode;
80000e40:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    qctrl0.B.XTSEL  = triggerSource;
80000e44:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadcG->QCTRL0.U = qctrl0.U;
80000e48:	74 32       	st.w [%a3],%d2
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
80000e4a:	19 c2 00 10 	ld.w %d2,[%a12]64
80000e4e:	8b f2 20 22 	ne %d2,%d2,15
80000e52:	df 02 22 80 	jne %d2,0,80000e96 <IfxVadc_Adc_initGroup+0x200>
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80000e56:	19 c3 3c 00 	ld.w %d3,[%a12]60
    qctrl0.U           = vadcG->QCTRL0.U;
80000e5a:	8f a8 00 20 	sh %d2,%d8,10
80000e5e:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000e62:	54 32       	ld.w %d2,[%a3]
    qctrl0.B.GTWC      = 1;
80000e64:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80000e68:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80000e6c:	74 32       	st.w [%a3],%d2
    vadcG->QMR0.B.ENGT = gatingMode;
80000e6e:	d9 23 44 40 	lea %a3,[%a2]1284
80000e72:	19 22 44 40 	ld.w %d2,[%a2]1284
80000e76:	b7 12 02 20 	insert %d2,%d2,1,0,2
80000e7a:	74 32       	st.w [%a3],%d2
}
80000e7c:	1d 00 0d 00 	j 80000e96 <IfxVadc_Adc_initGroup+0x200>
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
80000e80:	8f a8 00 20 	sh %d2,%d8,10
80000e84:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000e88:	d9 23 44 40 	lea %a3,[%a2]1284
80000e8c:	19 22 44 40 	ld.w %d2,[%a2]1284
80000e90:	8f 42 c0 21 	andn %d2,%d2,4
80000e94:	74 32       	st.w [%a3],%d2
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80000e96:	19 c2 00 10 	ld.w %d2,[%a12]64
80000e9a:	8b f2 00 22 	eq %d2,%d2,15
80000e9e:	df 02 1a 80 	jne %d2,0,80000ed2 <IfxVadc_Adc_initGroup+0x23c>
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80000ea2:	19 c5 3c 00 	ld.w %d5,[%a12]60
80000ea6:	19 c4 04 10 	ld.w %d4,[%a12]68
    qctrl0.U           = vadcG->QCTRL0.U;
80000eaa:	8f a8 00 20 	sh %d2,%d8,10
80000eae:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000eb2:	d9 23 40 40 	lea %a3,[%a2]1280
80000eb6:	19 22 40 40 	ld.w %d2,[%a2]1280
    qctrl0.B.GTWC      = 1;
80000eba:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80000ebe:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80000ec2:	74 32       	st.w [%a3],%d2
    vadcG->QMR0.B.ENGT = gatingMode;
80000ec4:	d9 23 44 40 	lea %a3,[%a2]1284
80000ec8:	19 22 44 40 	ld.w %d2,[%a2]1284
80000ecc:	37 42 02 20 	insert %d2,%d2,%d4,0,2
80000ed0:	74 32       	st.w [%a3],%d2
        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
80000ed2:	39 c3 38 00 	ld.bu %d3,[%a12]56
80000ed6:	8b 03 20 32 	ne %d3,%d3,0
    vadcG->QMR0.B.FLUSH = flushQueue;
80000eda:	8f a8 00 20 	sh %d2,%d8,10
80000ede:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000ee2:	d9 23 44 40 	lea %a3,[%a2]1284
80000ee6:	19 22 44 40 	ld.w %d2,[%a2]1284
80000eea:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
80000eee:	74 32       	st.w [%a3],%d2
}
80000ef0:	1d ff 50 ff 	j 80000d90 <IfxVadc_Adc_initGroup+0xfa>
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80000ef4:	19 c2 2c 00 	ld.w %d2,[%a12]44
80000ef8:	df 02 37 00 	jeq %d2,0,80000f66 <IfxVadc_Adc_initGroup+0x2d0>
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
80000efc:	8f a8 00 20 	sh %d2,%d8,10
80000f00:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000f04:	d9 23 64 40 	lea %a3,[%a2]1316
80000f08:	19 22 64 40 	ld.w %d2,[%a2]1316
80000f0c:	b7 12 01 21 	insert %d2,%d2,1,2,1
80000f10:	74 32       	st.w [%a3],%d2
            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
80000f12:	19 c5 2c 00 	ld.w %d5,[%a12]44
80000f16:	19 c4 24 00 	ld.w %d4,[%a12]36
    asctrl.U        = vadcG->ASCTRL.U;
80000f1a:	d9 23 60 40 	lea %a3,[%a2]1312
80000f1e:	19 22 60 40 	ld.w %d2,[%a2]1312
    asctrl.B.XTWC   = 1;
80000f22:	b7 12 81 27 	insert %d2,%d2,1,15,1
    asctrl.B.XTMODE = triggerMode;
80000f26:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    asctrl.B.XTSEL  = triggerSource;
80000f2a:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadcG->ASCTRL.U = asctrl.U;
80000f2e:	74 32       	st.w [%a3],%d2
            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
80000f30:	19 c2 24 00 	ld.w %d2,[%a12]36
80000f34:	8b f2 20 22 	ne %d2,%d2,15
80000f38:	df 02 22 80 	jne %d2,0,80000f7c <IfxVadc_Adc_initGroup+0x2e6>
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80000f3c:	19 c3 20 00 	ld.w %d3,[%a12]32
    asctrl.U           = vadcG->ASCTRL.U;
80000f40:	8f a8 00 20 	sh %d2,%d8,10
80000f44:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000f48:	54 32       	ld.w %d2,[%a3]
    asctrl.B.GTWC      = 1;
80000f4a:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80000f4e:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80000f52:	74 32       	st.w [%a3],%d2
    vadcG->ASMR.B.ENGT = gatingMode;
80000f54:	d9 23 64 40 	lea %a3,[%a2]1316
80000f58:	19 22 64 40 	ld.w %d2,[%a2]1316
80000f5c:	b7 12 02 20 	insert %d2,%d2,1,0,2
80000f60:	74 32       	st.w [%a3],%d2
}
80000f62:	1d 00 0d 00 	j 80000f7c <IfxVadc_Adc_initGroup+0x2e6>
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
80000f66:	8f a8 00 20 	sh %d2,%d8,10
80000f6a:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000f6e:	d9 23 64 40 	lea %a3,[%a2]1316
80000f72:	19 22 64 40 	ld.w %d2,[%a2]1316
80000f76:	8f 42 c0 21 	andn %d2,%d2,4
80000f7a:	74 32       	st.w [%a3],%d2
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80000f7c:	19 c2 24 00 	ld.w %d2,[%a12]36
80000f80:	8b f2 00 22 	eq %d2,%d2,15
80000f84:	df 02 1a 80 	jne %d2,0,80000fb8 <IfxVadc_Adc_initGroup+0x322>
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
80000f88:	19 c5 20 00 	ld.w %d5,[%a12]32
80000f8c:	19 c4 28 00 	ld.w %d4,[%a12]40
    asctrl.U           = vadcG->ASCTRL.U;
80000f90:	8f a8 00 20 	sh %d2,%d8,10
80000f94:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000f98:	d9 23 60 40 	lea %a3,[%a2]1312
80000f9c:	19 22 60 40 	ld.w %d2,[%a2]1312
    asctrl.B.GTWC      = 1;
80000fa0:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80000fa4:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80000fa8:	74 32       	st.w [%a3],%d2
    vadcG->ASMR.B.ENGT = gatingMode;
80000faa:	d9 23 64 40 	lea %a3,[%a2]1316
80000fae:	19 22 64 40 	ld.w %d2,[%a2]1316
80000fb2:	37 42 02 20 	insert %d2,%d2,%d4,0,2
80000fb6:	74 32       	st.w [%a3],%d2
        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
80000fb8:	39 c3 1c 00 	ld.bu %d3,[%a12]28
80000fbc:	8b 03 20 32 	ne %d3,%d3,0
    vadcG->ASMR.B.SCAN = autoscanEnable;
80000fc0:	8f a8 00 20 	sh %d2,%d8,10
80000fc4:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80000fc8:	d9 23 64 40 	lea %a3,[%a2]1316
80000fcc:	19 22 64 40 	ld.w %d2,[%a2]1316
80000fd0:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
80000fd4:	74 32       	st.w [%a3],%d2
}
80000fd6:	1d ff e1 fe 	j 80000d98 <IfxVadc_Adc_initGroup+0x102>
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
80000fda:	19 c2 24 10 	ld.w %d2,[%a12]100
80000fde:	df 02 1e 00 	jeq %d2,0,8000101a <IfxVadc_Adc_initGroup+0x384>
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
80000fe2:	d9 d2 04 80 	lea %a2,[%a13]516
80000fe6:	19 d2 04 80 	ld.w %d2,[%a13]516
80000fea:	b7 12 01 21 	insert %d2,%d2,1,2,1
80000fee:	74 22       	st.w [%a2],%d2
            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
80000ff0:	19 c5 24 10 	ld.w %d5,[%a12]100
80000ff4:	19 c4 1c 10 	ld.w %d4,[%a12]92
    brsctrl.U        = vadc->BRSCTRL.U;
80000ff8:	d9 d2 00 80 	lea %a2,[%a13]512
80000ffc:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.XTWC   = 1;
80001000:	b7 12 81 27 	insert %d2,%d2,1,15,1
    brsctrl.B.XTMODE = triggerMode;
80001004:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    brsctrl.B.XTSEL  = triggerSource;
80001008:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
8000100c:	74 22       	st.w [%a2],%d2
            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
8000100e:	19 c2 1c 10 	ld.w %d2,[%a12]92
80001012:	8b f2 20 22 	ne %d2,%d2,15
80001016:	df 02 29 00 	jeq %d2,0,80001068 <IfxVadc_Adc_initGroup+0x3d2>
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
8000101a:	19 c2 1c 10 	ld.w %d2,[%a12]92
8000101e:	8b f2 00 22 	eq %d2,%d2,15
80001022:	df 02 16 80 	jne %d2,0,8000104e <IfxVadc_Adc_initGroup+0x3b8>
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
80001026:	19 c5 18 10 	ld.w %d5,[%a12]88
8000102a:	19 c4 20 10 	ld.w %d4,[%a12]96
    brsctrl.U          = vadc->BRSCTRL.U;
8000102e:	d9 d2 00 80 	lea %a2,[%a13]512
80001032:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.GTWC     = 1;
80001036:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
8000103a:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
8000103e:	74 22       	st.w [%a2],%d2
    vadc->BRSMR.B.ENGT = gatingMode;
80001040:	d9 d2 04 80 	lea %a2,[%a13]516
80001044:	19 d2 04 80 	ld.w %d2,[%a13]516
80001048:	37 42 02 20 	insert %d2,%d2,%d4,0,2
8000104c:	74 22       	st.w [%a2],%d2
        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
8000104e:	39 c3 14 10 	ld.bu %d3,[%a12]84
80001052:	8b 03 20 32 	ne %d3,%d3,0
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
80001056:	d9 d2 04 80 	lea %a2,[%a13]516
8000105a:	19 d2 04 80 	ld.w %d2,[%a13]516
8000105e:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
80001062:	74 22       	st.w [%a2],%d2
}
80001064:	1d ff 9e fe 	j 80000da0 <IfxVadc_Adc_initGroup+0x10a>
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80001068:	19 c3 18 10 	ld.w %d3,[%a12]88
    brsctrl.U          = vadc->BRSCTRL.U;
8000106c:	d9 d2 00 80 	lea %a2,[%a13]512
80001070:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.GTWC     = 1;
80001074:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80001078:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
8000107c:	74 22       	st.w [%a2],%d2
    vadc->BRSMR.B.ENGT = gatingMode;
8000107e:	d9 d2 04 80 	lea %a2,[%a13]516
80001082:	19 d2 04 80 	ld.w %d2,[%a13]516
80001086:	b7 12 02 20 	insert %d2,%d2,1,0,2
8000108a:	74 22       	st.w [%a2],%d2
}
8000108c:	1d ff c7 ff 	j 8000101a <IfxVadc_Adc_initGroup+0x384>
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
80001090:	82 34       	mov %d4,3
80001092:	1d ff 8c fe 	j 80000daa <IfxVadc_Adc_initGroup+0x114>
80001096:	3b f0 0f 50 	mov %d5,255
8000109a:	0b 54 90 51 	min.u %d5,%d4,%d5
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
8000109e:	8f 88 00 20 	sh %d2,%d8,8
800010a2:	42 62       	add %d2,%d6
800010a4:	1b 82 12 40 	addi %d4,%d2,296
800010a8:	06 24       	sh %d4,2
800010aa:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800010ae:	54 24       	ld.w %d4,[%a2]
800010b0:	37 54 05 40 	insert %d4,%d4,%d5,0,5
800010b4:	74 24       	st.w [%a2],%d4
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
800010b6:	c2 13       	add %d3,1
800010b8:	8f f3 0f 31 	and %d3,%d3,255
800010bc:	ff 23 29 80 	jge.u %d3,2,8000110e <IfxVadc_Adc_initGroup+0x478>
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
800010c0:	02 36       	mov %d6,%d3
800010c2:	1b 23 00 40 	addi %d4,%d3,2
800010c6:	06 34       	sh %d4,3
800010c8:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
800010cc:	54 25       	ld.w %d5,[%a2]
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
800010ce:	8f 88 00 20 	sh %d2,%d8,8
800010d2:	42 32       	add %d2,%d3
800010d4:	1b 82 12 40 	addi %d4,%d2,296
800010d8:	06 24       	sh %d4,2
800010da:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800010de:	54 24       	ld.w %d4,[%a2]
800010e0:	37 54 03 44 	insert %d4,%d4,%d5,8,3
800010e4:	74 24       	st.w [%a2],%d4
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
800010e6:	8f 33 00 40 	sh %d4,%d3,3
800010ea:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
800010ee:	19 24 0c 00 	ld.w %d4,[%a2]12
    ticks = (uint32)(sampleTime * analogFrequency) - 2;
800010f2:	4b c4 41 40 	mul.f %d4,%d4,%d12
800010f6:	4b 04 71 41 	ftouz %d4,%d4
800010fa:	c2 e4       	add %d4,-2
    if (ticks > 31)
800010fc:	8b 04 62 52 	lt.u %d5,%d4,32
80001100:	df 05 cb ff 	jne %d5,0,80001096 <IfxVadc_Adc_initGroup+0x400>
        ticks = (ticks / 16) + 15;
80001104:	06 c4       	sh %d4,-4
80001106:	1b f4 00 40 	addi %d4,%d4,15
8000110a:	1d ff c6 ff 	j 80001096 <IfxVadc_Adc_initGroup+0x400>
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
8000110e:	02 b4       	mov %d4,%d11
80001110:	40 d4       	mov.aa %a4,%a13
80001112:	6d ff 08 fb 	call 80000722 <IfxVadc_disableAccess>

    return status;
}
80001116:	82 02       	mov %d2,0
80001118:	00 90       	ret 

8000111a <IfxVadc_Adc_initGroupConfig>:


void IfxVadc_Adc_initGroupConfig(IfxVadc_Adc_GroupConfig *config, IfxVadc_Adc *vadc)
{
8000111a:	40 ae       	mov.aa %a14,%sp
8000111c:	40 4c       	mov.aa %a12,%a4
8000111e:	80 58       	mov.d %d8,%a5
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
80001120:	3b c0 07 50 	mov %d5,124
80001124:	82 04       	mov %d4,0
80001126:	6d 00 21 10 	call 80003168 <memset>
8000112a:	7b 60 58 23 	movh %d2,13702
8000112e:	1b d2 7b 23 	addi %d2,%d2,14269
80001132:	59 c2 0c 00 	st.w [%a12]12,%d2
80001136:	59 c2 14 00 	st.w [%a12]20,%d2
8000113a:	82 12       	mov %d2,1
8000113c:	59 c2 30 00 	st.w [%a12]48,%d2
80001140:	e9 c2 38 00 	st.b [%a12]56,%d2
80001144:	59 c2 0c 10 	st.w [%a12]76,%d2
80001148:	59 c2 28 10 	st.w [%a12]104,%d2
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
8000114c:	74 c8       	st.w [%a12],%d8
    config->master                 = config->groupId;
    config->disablePostCalibration = FALSE;
}
8000114e:	00 90       	ret 

80001150 <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
80001150:	40 ae       	mov.aa %a14,%sp
80001152:	40 5d       	mov.aa %a13,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
80001154:	d4 5c       	ld.a %a12,[%a5]
    vadc->vadc = vadcSFR;
80001156:	f4 4c       	st.a [%a4],%a12
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80001158:	6d 00 0e 06 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
8000115c:	02 28       	mov %d8,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
8000115e:	02 24       	mov %d4,%d2
80001160:	6d 00 a1 04 	call 80001aa2 <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
80001164:	82 02       	mov %d2,0
80001166:	74 c2       	st.w [%a12],%d2
    IfxScuWdt_setCpuEndinit(passwd);
80001168:	02 84       	mov %d4,%d8
8000116a:	6d 00 22 06 	call 80001dae <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
8000116e:	19 d4 24 00 	ld.w %d4,[%a13]36
80001172:	40 c4       	mov.aa %a4,%a12
80001174:	6d ff f5 fb 	call 8000095e <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80001178:	19 d4 18 00 	ld.w %d4,[%a13]24
8000117c:	4b 04 71 41 	ftouz %d4,%d4
80001180:	40 c4       	mov.aa %a4,%a12
80001182:	6d ff b4 fb 	call 800008ea <IfxVadc_initializeFAdcI>
80001186:	df 02 04 80 	jne %d2,0,8000118e <IfxVadc_Adc_initModule+0x3e>
    {
        return IfxVadc_Status_notInitialised;
8000118a:	82 12       	mov %d2,1
        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
}
8000118c:	00 90       	ret 
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
8000118e:	19 d4 14 00 	ld.w %d4,[%a13]20
80001192:	4b 04 71 41 	ftouz %d4,%d4
80001196:	40 c4       	mov.aa %a4,%a12
80001198:	6d ff 92 fb 	call 800008bc <IfxVadc_initializeFAdcD>
    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
8000119c:	40 c4       	mov.aa %a4,%a12
8000119e:	6d ff 31 fb 	call 80000800 <IfxVadc_getAdcAnalogFrequency>
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
800011a2:	82 03       	mov %d3,0
800011a4:	1d 00 12 00 	j 800011c8 <IfxVadc_Adc_initModule+0x78>
800011a8:	3b f0 0f 50 	mov %d5,255
800011ac:	0b 54 90 51 	min.u %d5,%d4,%d5
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
800011b0:	1b 86 02 40 	addi %d4,%d6,40
800011b4:	06 24       	sh %d4,2
800011b6:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
800011ba:	54 24       	ld.w %d4,[%a2]
800011bc:	37 54 05 40 	insert %d4,%d4,%d5,0,5
800011c0:	74 24       	st.w [%a2],%d4
800011c2:	c2 13       	add %d3,1
800011c4:	8f f3 0f 31 	and %d3,%d3,255
800011c8:	ff 23 26 80 	jge.u %d3,2,80001214 <IfxVadc_Adc_initModule+0xc4>
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
800011cc:	02 36       	mov %d6,%d3
800011ce:	1b 13 00 40 	addi %d4,%d3,1
800011d2:	06 34       	sh %d4,3
800011d4:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800011d8:	54 25       	ld.w %d5,[%a2]
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
800011da:	1b 83 02 40 	addi %d4,%d3,40
800011de:	06 24       	sh %d4,2
800011e0:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
800011e4:	54 24       	ld.w %d4,[%a2]
800011e6:	37 54 03 44 	insert %d4,%d4,%d5,8,3
800011ea:	74 24       	st.w [%a2],%d4
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
800011ec:	8f 33 00 40 	sh %d4,%d3,3
800011f0:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800011f4:	19 24 04 00 	ld.w %d4,[%a2]4
    ticks = (uint32)(sampleTime * analogFrequency) - 2;
800011f8:	4b 24 41 40 	mul.f %d4,%d4,%d2
800011fc:	4b 04 71 41 	ftouz %d4,%d4
80001200:	c2 e4       	add %d4,-2
    if (ticks > 31)
80001202:	8b 04 62 52 	lt.u %d5,%d4,32
80001206:	df 05 d1 ff 	jne %d5,0,800011a8 <IfxVadc_Adc_initModule+0x58>
        ticks = (ticks / 16) + 15;
8000120a:	06 c4       	sh %d4,-4
8000120c:	1b f4 00 40 	addi %d4,%d4,15
80001210:	1d ff cc ff 	j 800011a8 <IfxVadc_Adc_initModule+0x58>
    if (config->startupCalibration == TRUE)
80001214:	39 d2 20 00 	ld.bu %d2,[%a13]32
80001218:	df 12 23 00 	jeq %d2,1,8000125e <IfxVadc_Adc_initModule+0x10e>
    return status;
8000121c:	82 02       	mov %d2,0
8000121e:	00 90       	ret 
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80001220:	1b 08 01 90 	addi %d9,%d8,16
80001224:	02 94       	mov %d4,%d9
80001226:	40 c4       	mov.aa %a4,%a12
80001228:	6d ff a0 fa 	call 80000768 <IfxVadc_enableAccess>
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
8000122c:	8f a8 00 20 	sh %d2,%d8,10
80001230:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80001234:	d9 23 40 20 	lea %a3,[%a2]1152
80001238:	19 22 40 20 	ld.w %d2,[%a2]1152
8000123c:	b7 32 02 20 	insert %d2,%d2,3,0,2
80001240:	74 32       	st.w [%a3],%d2
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80001242:	02 94       	mov %d4,%d9
80001244:	40 c4       	mov.aa %a4,%a12
80001246:	6d ff 6e fa 	call 80000722 <IfxVadc_disableAccess>
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
8000124a:	c2 18       	add %d8,1
8000124c:	8f f8 0f 81 	and %d8,%d8,255
80001250:	bf 88 e8 ff 	jlt.u %d8,8,80001220 <IfxVadc_Adc_initModule+0xd0>
        IfxVadc_startupCalibration(vadcSFR);
80001254:	40 c4       	mov.aa %a4,%a12
80001256:	6d ff da fb 	call 80000a0a <IfxVadc_startupCalibration>
    return status;
8000125a:	82 02       	mov %d2,0
8000125c:	00 90       	ret 
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
8000125e:	82 08       	mov %d8,0
80001260:	1d ff f8 ff 	j 80001250 <IfxVadc_Adc_initModule+0x100>

80001264 <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80001264:	40 ae       	mov.aa %a14,%sp
80001266:	40 4c       	mov.aa %a12,%a4
80001268:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
8000126a:	f4 c5       	st.a [%a12],%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
8000126c:	7b 90 b9 24 	movh %d2,19353
80001270:	1b 02 68 29 	addi %d2,%d2,-27008
80001274:	59 c2 18 00 	st.w [%a12]24,%d2

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
80001278:	6d ff d2 fa 	call 8000081c <IfxVadc_getAdcDigitalFrequency>
8000127c:	59 c2 14 00 	st.w [%a12]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
80001280:	6d 00 28 02 	call 800016d0 <IfxScuCcu_getSpbFrequency>
80001284:	59 c2 1c 00 	st.w [%a12]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80001288:	82 02       	mov %d2,0
8000128a:	59 c2 08 00 	st.w [%a12]8,%d2
    config->globalInputClass[0].sampleTime = 1.0e-6;
8000128e:	7b 60 58 33 	movh %d3,13702
80001292:	1b d3 7b 33 	addi %d3,%d3,14269
80001296:	59 c3 04 00 	st.w [%a12]4,%d3
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
8000129a:	59 c2 10 00 	st.w [%a12]16,%d2
    config->globalInputClass[1].sampleTime = 1.0e-6;
8000129e:	59 c3 0c 00 	st.w [%a12]12,%d3
    config->startupCalibration             = FALSE;
800012a2:	e9 c2 20 00 	st.b [%a12]32,%d2
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
800012a6:	59 c2 24 00 	st.w [%a12]36,%d2
}
800012aa:	00 90       	ret 

800012ac <IfxStm_clearCompareFlag>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxStm_clearCompareFlag(Ifx_STM *stm, IfxStm_Comparator comparator)
{
800012ac:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
800012ae:	df 04 0a 80 	jne %d4,0,800012c2 <IfxStm_clearCompareFlag+0x16>
    {
        stm->ISCR.B.CMP0IRR = 1U;
800012b2:	d9 42 00 10 	lea %a2,[%a4]64
800012b6:	19 42 00 10 	ld.w %d2,[%a4]64
800012ba:	b7 12 01 20 	insert %d2,%d2,1,0,1
800012be:	74 22       	st.w [%a2],%d2
800012c0:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
800012c2:	df 14 03 00 	jeq %d4,1,800012c8 <IfxStm_clearCompareFlag+0x1c>
    {
        stm->ISCR.B.CMP1IRR = 1U;
    }
}
800012c6:	00 90       	ret 
        stm->ISCR.B.CMP1IRR = 1U;
800012c8:	d9 42 00 10 	lea %a2,[%a4]64
800012cc:	19 42 00 10 	ld.w %d2,[%a4]64
800012d0:	b7 12 01 21 	insert %d2,%d2,1,2,1
800012d4:	74 22       	st.w [%a2],%d2
}
800012d6:	1d ff f8 ff 	j 800012c6 <IfxStm_clearCompareFlag+0x1a>

800012da <IfxStm_enableComparatorInterrupt>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxStm_enableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator)
{
800012da:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
800012dc:	df 04 0a 80 	jne %d4,0,800012f0 <IfxStm_enableComparatorInterrupt+0x16>
    {
        stm->ICR.B.CMP0EN = 1U;
800012e0:	d9 42 3c 00 	lea %a2,[%a4]60
800012e4:	19 42 3c 00 	ld.w %d2,[%a4]60
800012e8:	b7 12 01 20 	insert %d2,%d2,1,0,1
800012ec:	74 22       	st.w [%a2],%d2
800012ee:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
800012f0:	df 14 03 00 	jeq %d4,1,800012f6 <IfxStm_enableComparatorInterrupt+0x1c>
    {
        stm->ICR.B.CMP1EN = 1U;
    }
}
800012f4:	00 90       	ret 
        stm->ICR.B.CMP1EN = 1U;
800012f6:	d9 42 3c 00 	lea %a2,[%a4]60
800012fa:	19 42 3c 00 	ld.w %d2,[%a4]60
800012fe:	b7 12 01 22 	insert %d2,%d2,1,4,1
80001302:	74 22       	st.w [%a2],%d2
}
80001304:	1d ff f8 ff 	j 800012f4 <IfxStm_enableComparatorInterrupt+0x1a>

80001308 <IfxStm_enableOcdsSuspend>:


void IfxStm_enableOcdsSuspend(Ifx_STM *stm)
{
80001308:	40 ae       	mov.aa %a14,%sp
    Ifx_STM_OCS ocs = stm->OCS;
8000130a:	d9 42 28 30 	lea %a2,[%a4]232
8000130e:	19 42 28 30 	ld.w %d2,[%a4]232

    /* Only if OCDS is enabled write into the OCS register */
    if (MODULE_CBS.OSTATE.B.OEN == 1U)
80001312:	85 f3 40 20 	ld.w %d3,f0000480 <_SMALL_DATA4_+0x5fff8480>
80001316:	6f 03 03 80 	jnz.t %d3,0,8000131c <IfxStm_enableOcdsSuspend+0x14>
        ocs.B.SUS_P      = 1;
        ocs.B.SUS        = 2;
        stm->OCS         = ocs;
        stm->OCS.B.SUS_P = 0;
    }
}
8000131a:	00 90       	ret 
        ocs.B.SUS_P      = 1;
8000131c:	b7 12 01 2e 	insert %d2,%d2,1,28,1
        ocs.B.SUS        = 2;
80001320:	b7 22 04 2c 	insert %d2,%d2,2,24,4
        stm->OCS         = ocs;
80001324:	74 22       	st.w [%a2],%d2
        stm->OCS.B.SUS_P = 0;
80001326:	54 22       	ld.w %d2,[%a2]
80001328:	b7 02 01 2e 	insert %d2,%d2,0,28,1
8000132c:	74 22       	st.w [%a2],%d2
}
8000132e:	1d ff f6 ff 	j 8000131a <IfxStm_enableOcdsSuspend+0x12>

80001332 <IfxStm_getIndex>:
    return module;
}


IfxStm_Index IfxStm_getIndex(Ifx_STM *stm)
{
80001332:	40 ae       	mov.aa %a14,%sp
    uint32       index;
    IfxStm_Index result;

    result = IfxStm_Index_none;

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
80001334:	82 02       	mov %d2,0
80001336:	1d 00 03 00 	j 8000133c <IfxStm_getIndex+0xa>
8000133a:	c2 12       	add %d2,1
8000133c:	ff 32 18 80 	jge.u %d2,3,8000136c <IfxStm_getIndex+0x3a>
    {
        if (IfxStm_cfg_indexMap[index].module == stm)
80001340:	8f 32 00 30 	sh %d3,%d2,3
80001344:	91 00 00 28 	movh.a %a2,32768
80001348:	d9 22 2c 80 	lea %a2,[%a2]556 <8000022c <IfxStm_cfg_indexMap>>
8000134c:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80001350:	54 23       	ld.w %d3,[%a2]
80001352:	80 44       	mov.d %d4,%a4
80001354:	5f 43 f3 ff 	jne %d3,%d4,8000133a <IfxStm_getIndex+0x8>
        {
            result = (IfxStm_Index)IfxStm_cfg_indexMap[index].index;
80001358:	06 32       	sh %d2,3
8000135a:	91 00 00 28 	movh.a %a2,32768
8000135e:	d9 22 2c 80 	lea %a2,[%a2]556 <8000022c <IfxStm_cfg_indexMap>>
80001362:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001366:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
8000136a:	00 90       	ret 
    result = IfxStm_Index_none;
8000136c:	82 f2       	mov %d2,-1
        }
    }

    return result;
}
8000136e:	00 90       	ret 

80001370 <IfxStm_initCompare>:
    return comparator == IfxStm_Comparator_0 ? &MODULE_SRC.STM.STM[index].SR0 : &MODULE_SRC.STM.STM[index].SR1;
}


boolean IfxStm_initCompare(Ifx_STM *stm, const IfxStm_CompareConfig *config)
{
80001370:	40 ae       	mov.aa %a14,%sp
80001372:	40 4d       	mov.aa %a13,%a4
80001374:	40 5c       	mov.aa %a12,%a5
    sint32        index;
    boolean       result;
    Ifx_STM_CMCON comcon = stm->CMCON;
80001376:	19 42 38 00 	ld.w %d2,[%a4]56
    Ifx_STM_ICR   icr    = stm->ICR;
8000137a:	19 43 3c 00 	ld.w %d3,[%a4]60

    if (config->comparator == 0)
8000137e:	54 54       	ld.w %d4,[%a5]
80001380:	df 04 82 80 	jne %d4,0,80001484 <IfxStm_initCompare+0x114>
    {
        comcon.B.MSIZE0  = config->compareSize;
80001384:	19 54 0c 00 	ld.w %d4,[%a5]12
80001388:	37 42 05 20 	insert %d2,%d2,%d4,0,5
        comcon.B.MSTART0 = config->compareOffset;
8000138c:	19 54 08 00 	ld.w %d4,[%a5]8
80001390:	37 42 05 24 	insert %d2,%d2,%d4,8,5
        icr.B.CMP0OS     = config->comparatorInterrupt;
80001394:	19 54 04 00 	ld.w %d4,[%a5]4
80001398:	67 43 02 30 	ins.t %d3,%d3,2,%d4,0
        result           = TRUE;
8000139c:	82 18       	mov %d8,1
    {
        /*Invalid value */
        result = FALSE;
    }

    stm->ICR.U   = icr.U;
8000139e:	59 d3 3c 00 	st.w [%a13]60,%d3
    stm->CMCON.U = comcon.U;
800013a2:	59 d2 38 00 	st.w [%a13]56,%d2

    /* configure interrupt */
    index = IfxStm_getIndex(stm);
800013a6:	40 d4       	mov.aa %a4,%a13
800013a8:	6d ff c5 ff 	call 80001332 <IfxStm_getIndex>

    if (config->triggerPriority > 0)
800013ac:	b9 c3 14 00 	ld.hu %d3,[%a12]20
800013b0:	df 03 20 00 	jeq %d3,0,800013f0 <IfxStm_initCompare+0x80>
    {
        volatile Ifx_SRC_SRCR *srcr;

        if (config->comparatorInterrupt == IfxStm_ComparatorInterrupt_ir0)
800013b4:	19 c4 04 00 	ld.w %d4,[%a12]4
800013b8:	df 04 7a 80 	jne %d4,0,800014ac <IfxStm_initCompare+0x13c>
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR0);
800013bc:	06 32       	sh %d2,3
800013be:	7b 40 00 4f 	movh %d4,61444
800013c2:	1b 04 49 48 	addi %d4,%d4,-31600
800013c6:	60 42       	mov.a %a2,%d4
800013c8:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
        else
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
        }

        IfxSrc_init(srcr, config->typeOfService, config->triggerPriority);
800013cc:	19 c4 18 00 	ld.w %d4,[%a12]24
    src->B.SRPN = priority;
800013d0:	54 22       	ld.w %d2,[%a2]
800013d2:	37 32 08 20 	insert %d2,%d2,%d3,0,8
800013d6:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800013d8:	54 22       	ld.w %d2,[%a2]
800013da:	37 42 82 25 	insert %d2,%d2,%d4,11,2
800013de:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
800013e0:	54 22       	ld.w %d2,[%a2]
800013e2:	b7 12 81 2c 	insert %d2,%d2,1,25,1
800013e6:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
800013e8:	54 22       	ld.w %d2,[%a2]
800013ea:	b7 12 01 25 	insert %d2,%d2,1,10,1
800013ee:	74 22       	st.w [%a2],%d2
        IfxSrc_enable(srcr);
    }

    /*Configure the comparator ticks to current value to avoid any wrong triggering*/
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset);
800013f0:	39 c5 08 00 	ld.bu %d5,[%a12]8

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800013f4:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
800013f8:	19 d2 2c 00 	ld.w %d2,[%a13]44
800013fc:	8f 06 40 41 	or %d4,%d6,0
80001400:	02 23       	mov %d3,%d2
{
    uint64 now;

    now = IfxStm_get(stm);

    return (uint32)(now >> offset);
80001402:	8b 05 82 22 	ge %d2,%d5,32
80001406:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
8000140a:	ab 03 a0 32 	seln %d3,%d2,%d3,0
8000140e:	8f f5 01 21 	and %d2,%d5,31
80001412:	8b 02 02 51 	rsub %d5,%d2,32
80001416:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
8000141a:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
8000141e:	54 c2       	ld.w %d2,[%a12]
80001420:	1b c2 00 20 	addi %d2,%d2,12
80001424:	06 22       	sh %d2,2
80001426:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
8000142a:	74 23       	st.w [%a2],%d3

    /* clear the interrupt flag of the selected comparator before enabling the interrupt */
    /* this is to avaoid the unneccesary interrupt for the compare match of reset values of the registers */
    IfxStm_clearCompareFlag(stm, config->comparator);
8000142c:	54 c4       	ld.w %d4,[%a12]
8000142e:	40 d4       	mov.aa %a4,%a13
80001430:	6d ff 3e ff 	call 800012ac <IfxStm_clearCompareFlag>
    /* enable the interrupt for the selected comparator */
    IfxStm_enableComparatorInterrupt(stm, config->comparator);
80001434:	54 c4       	ld.w %d4,[%a12]
80001436:	40 d4       	mov.aa %a4,%a13
80001438:	6d ff 51 ff 	call 800012da <IfxStm_enableComparatorInterrupt>

    /*Configure the comparator ticks */
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset) + config->ticks;
8000143c:	39 c5 08 00 	ld.bu %d5,[%a12]8
    result  = stm->TIM0.U;
80001440:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
80001444:	19 d2 2c 00 	ld.w %d2,[%a13]44
80001448:	8f 06 40 41 	or %d4,%d6,0
8000144c:	02 23       	mov %d3,%d2
    return (uint32)(now >> offset);
8000144e:	8b 05 82 22 	ge %d2,%d5,32
80001452:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
80001456:	ab 03 a0 32 	seln %d3,%d2,%d3,0
8000145a:	8f f5 01 21 	and %d2,%d5,31
8000145e:	8b 02 02 51 	rsub %d5,%d2,32
80001462:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
80001466:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
8000146a:	02 34       	mov %d4,%d3
8000146c:	19 c3 10 00 	ld.w %d3,[%a12]16
80001470:	54 c2       	ld.w %d2,[%a12]
80001472:	42 43       	add %d3,%d4
80001474:	1b c2 00 20 	addi %d2,%d2,12
80001478:	06 22       	sh %d2,2
8000147a:	01 d2 00 d6 	addsc.a %a13,%a13,%d2,0
8000147e:	74 d3       	st.w [%a13],%d3

    return result;
}
80001480:	02 82       	mov %d2,%d8
80001482:	00 90       	ret 
    else if (config->comparator == 1)
80001484:	df 14 05 00 	jeq %d4,1,8000148e <IfxStm_initCompare+0x11e>
        result = FALSE;
80001488:	82 08       	mov %d8,0
8000148a:	1d ff 8a ff 	j 8000139e <IfxStm_initCompare+0x2e>
        comcon.B.MSIZE1  = config->compareSize;
8000148e:	19 54 0c 00 	ld.w %d4,[%a5]12
80001492:	37 42 05 28 	insert %d2,%d2,%d4,16,5
        comcon.B.MSTART1 = config->compareOffset;
80001496:	19 54 08 00 	ld.w %d4,[%a5]8
8000149a:	37 42 05 2c 	insert %d2,%d2,%d4,24,5
        icr.B.CMP1OS     = config->comparatorInterrupt;
8000149e:	19 54 04 00 	ld.w %d4,[%a5]4
800014a2:	67 43 06 30 	ins.t %d3,%d3,6,%d4,0
        result           = TRUE;
800014a6:	82 18       	mov %d8,1
800014a8:	1d ff 7b ff 	j 8000139e <IfxStm_initCompare+0x2e>
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
800014ac:	06 32       	sh %d2,3
800014ae:	c2 42       	add %d2,4
800014b0:	7b 40 00 4f 	movh %d4,61444
800014b4:	1b 04 49 48 	addi %d4,%d4,-31600
800014b8:	60 42       	mov.a %a2,%d4
800014ba:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800014be:	1d ff 87 ff 	j 800013cc <IfxStm_initCompare+0x5c>

800014c2 <IfxStm_initCompareConfig>:


void IfxStm_initCompareConfig(IfxStm_CompareConfig *config)
{
800014c2:	40 ae       	mov.aa %a14,%sp
    config->comparator          = IfxStm_Comparator_0;
800014c4:	82 02       	mov %d2,0
800014c6:	74 42       	st.w [%a4],%d2
    config->compareOffset       = IfxStm_ComparatorOffset_0;
800014c8:	59 42 08 00 	st.w [%a4]8,%d2
    config->compareSize         = IfxStm_ComparatorSize_32Bits;
800014cc:	3b f0 01 30 	mov %d3,31
800014d0:	59 43 0c 00 	st.w [%a4]12,%d3
    config->comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;     /*User must select the interrupt output */
800014d4:	59 42 04 00 	st.w [%a4]4,%d2
    config->ticks               = 0xFFFFFFFF;
800014d8:	82 f3       	mov %d3,-1
800014da:	59 43 10 00 	st.w [%a4]16,%d3
    config->triggerPriority     = 0;
800014de:	f9 42 14 00 	st.h [%a4]20,%d2
    config->typeOfService       = IfxSrc_Tos_cpu0;
800014e2:	59 42 18 00 	st.w [%a4]24,%d2
}
800014e6:	00 90       	ret 

800014e8 <IfxScuCcu_isOscillatorStable>:
    *cfg = IfxScuCcu_defaultErayPllConfig;
}


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
800014e8:	40 ae       	mov.aa %a14,%sp
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
800014ea:	6d 00 45 04 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
800014ee:	02 28       	mov %d8,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
800014f0:	91 30 00 2f 	movh.a %a2,61443
800014f4:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
800014f8:	54 23       	ld.w %d3,[%a2]
800014fa:	8f 03 c6 31 	andn %d3,%d3,96
800014fe:	74 23       	st.w [%a2],%d3

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80001500:	91 00 00 36 	movh.a %a3,24576
80001504:	19 33 00 00 	ld.w %d3,[%a3]0 <60000000 <IfxScuCcu_xtalFrequency>>
80001508:	7b 00 b6 26 	movh %d2,27488
8000150c:	1b b2 a6 2c 	addi %d2,%d2,-13717
80001510:	73 23 68 20 	mul.u %e2,%d3,%d2
80001514:	8f c3 1e 20 	sh %d2,%d3,-20
80001518:	c2 f2       	add %d2,-1
8000151a:	54 23       	ld.w %d3,[%a2]
8000151c:	37 23 05 38 	insert %d3,%d3,%d2,16,5
80001520:	74 23       	st.w [%a2],%d3

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
80001522:	54 23       	ld.w %d3,[%a2]
80001524:	b7 13 01 31 	insert %d3,%d3,1,2,1
80001528:	74 23       	st.w [%a2],%d3
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
8000152a:	3b 00 28 30 	mov %d3,640

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
8000152e:	1d 00 05 00 	j 80001538 <IfxScuCcu_isOscillatorStable+0x50>
    {
        TimeoutCtr--;
80001532:	c2 f3       	add %d3,-1

        if (TimeoutCtr == 0)
80001534:	df 03 25 00 	jeq %d3,0,8000157e <IfxScuCcu_isOscillatorStable+0x96>
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80001538:	91 30 00 2f 	movh.a %a2,61443
8000153c:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
80001540:	54 25       	ld.w %d5,[%a2]
80001542:	6f 15 f8 7f 	jz.t %d5,1,80001532 <IfxScuCcu_isOscillatorStable+0x4a>
80001546:	54 25       	ld.w %d5,[%a2]
80001548:	6f 85 f5 7f 	jz.t %d5,8,80001532 <IfxScuCcu_isOscillatorStable+0x4a>
    boolean status     = 0;
8000154c:	82 09       	mov %d9,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
8000154e:	02 84       	mov %d4,%d8
80001550:	6d 00 a9 02 	call 80001aa2 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80001554:	91 30 00 2f 	movh.a %a2,61443
80001558:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
8000155c:	54 23       	ld.w %d3,[%a2]
8000155e:	b7 13 81 31 	insert %d3,%d3,1,3,1
80001562:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
80001564:	91 30 00 2f 	movh.a %a2,61443
80001568:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
8000156c:	54 23       	ld.w %d3,[%a2]
8000156e:	b7 13 81 31 	insert %d3,%d3,1,3,1
80001572:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinitPw);
80001574:	02 84       	mov %d4,%d8
80001576:	6d 00 1c 04 	call 80001dae <IfxScuWdt_setCpuEndinit>
    }

    return status;
}
8000157a:	02 92       	mov %d2,%d9
8000157c:	00 90       	ret 
            status = 1;
8000157e:	82 19       	mov %d9,1
80001580:	1d ff e7 ff 	j 8000154e <IfxScuCcu_isOscillatorStable+0x66>

80001584 <IfxScuCcu_getOscFrequency>:
{
80001584:	40 ae       	mov.aa %a14,%sp
    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80001586:	91 30 00 2f 	movh.a %a2,61443
8000158a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000158e:	54 22       	ld.w %d2,[%a2]
80001590:	37 02 62 2e 	extr.u %d2,%d2,28,2
80001594:	df 02 10 00 	jeq %d2,0,800015b4 <IfxScuCcu_getOscFrequency+0x30>
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80001598:	54 22       	ld.w %d2,[%a2]
8000159a:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000159e:	df 12 04 00 	jeq %d2,1,800015a6 <IfxScuCcu_getOscFrequency+0x22>
        freq = 0.0f;
800015a2:	82 02       	mov %d2,0
}
800015a4:	00 90       	ret 
        freq = (float32)IfxScuCcu_xtalFrequency;
800015a6:	91 00 00 26 	movh.a %a2,24576
800015aa:	19 22 00 00 	ld.w %d2,[%a2]0 <60000000 <IfxScuCcu_xtalFrequency>>
800015ae:	4b 02 61 21 	utof %d2,%d2
800015b2:	00 90       	ret 
        freq = IFXSCU_EVR_OSC_FREQUENCY;
800015b4:	7b f0 cb 24 	movh %d2,19647
800015b8:	1b 02 c2 2b 	addi %d2,%d2,-17376
800015bc:	00 90       	ret 

800015be <IfxScuCcu_getPllFrequency>:
{
800015be:	40 ae       	mov.aa %a14,%sp
    oscFreq = IfxScuCcu_getOscFrequency();
800015c0:	6d ff e2 ff 	call 80001584 <IfxScuCcu_getOscFrequency>
800015c4:	02 24       	mov %d4,%d2
    if (scu->PLLSTAT.B.VCOBYST == 1)
800015c6:	91 30 00 2f 	movh.a %a2,61443
800015ca:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
800015ce:	19 23 14 00 	ld.w %d3,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
800015d2:	6f 03 27 80 	jnz.t %d3,0,80001620 <IfxScuCcu_getPllFrequency+0x62>
    else if (scu->PLLSTAT.B.FINDIS == 1)
800015d6:	91 30 00 2f 	movh.a %a2,61443
800015da:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
800015de:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
800015e2:	6f 32 2d 80 	jnz.t %d2,3,8000163c <IfxScuCcu_getPllFrequency+0x7e>
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
800015e6:	91 30 00 2f 	movh.a %a2,61443
800015ea:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
800015ee:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
800015f2:	37 02 e7 24 	extr.u %d2,%d2,9,7
800015f6:	c2 12       	add %d2,1
800015f8:	4b 02 41 21 	itof %d2,%d2
800015fc:	4b 42 41 30 	mul.f %d3,%d2,%d4
80001600:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80001604:	8f f4 07 41 	and %d4,%d4,127
80001608:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
8000160c:	37 02 64 2c 	extr.u %d2,%d2,24,4
80001610:	c2 12       	add %d2,1
80001612:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
80001616:	4b 02 41 21 	itof %d2,%d2
8000161a:	4b 23 51 20 	div.f %d2,%d3,%d2
}
8000161e:	00 90       	ret 
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80001620:	91 30 00 2f 	movh.a %a2,61443
80001624:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001628:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
8000162c:	37 02 67 28 	extr.u %d2,%d2,16,7
80001630:	c2 12       	add %d2,1
80001632:	4b 02 41 21 	itof %d2,%d2
80001636:	4b 24 51 20 	div.f %d2,%d4,%d2
8000163a:	00 90       	ret 
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
8000163c:	91 30 00 2f 	movh.a %a2,61443
80001640:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80001644:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80001648:	8f f4 07 41 	and %d4,%d4,127
8000164c:	c2 14       	add %d4,1
8000164e:	6d 00 3e 0e 	call 800032ca <__floatsidf>
80001652:	0b 23 10 68 	mov %e6,%d3,%d2
80001656:	82 04       	mov %d4,0
80001658:	7b 80 19 54 	movh %d5,16792
8000165c:	1b 45 78 5d 	addi %d5,%d5,-10364
80001660:	6d 00 8d 0d 	call 8000317a <__divdf3>
80001664:	0b 23 10 48 	mov %e4,%d3,%d2
80001668:	6d 00 6c 0e 	call 80003340 <__truncdfsf2>
8000166c:	00 90       	ret 

8000166e <IfxScuCcu_getSourceFrequency>:
{
8000166e:	40 ae       	mov.aa %a14,%sp
    switch (SCU_CCUCON0.B.CLKSEL)
80001670:	91 30 00 2f 	movh.a %a2,61443
80001674:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001678:	54 22       	ld.w %d2,[%a2]
8000167a:	37 02 62 2e 	extr.u %d2,%d2,28,2
8000167e:	df 02 07 00 	jeq %d2,0,8000168c <IfxScuCcu_getSourceFrequency+0x1e>
80001682:	df 12 0a 80 	jne %d2,1,80001696 <IfxScuCcu_getSourceFrequency+0x28>
        sourcefreq = IfxScuCcu_getPllFrequency();
80001686:	6d ff 9c ff 	call 800015be <IfxScuCcu_getPllFrequency>
        break;
8000168a:	00 90       	ret 
    switch (SCU_CCUCON0.B.CLKSEL)
8000168c:	7b f0 cb 24 	movh %d2,19647
80001690:	1b 02 c2 2b 	addi %d2,%d2,-17376
80001694:	00 90       	ret 
        sourcefreq = 0;
80001696:	82 02       	mov %d2,0
}
80001698:	00 90       	ret 

8000169a <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
8000169a:	40 ae       	mov.aa %a14,%sp
8000169c:	02 48       	mov %d8,%d4
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
8000169e:	6d ff e8 ff 	call 8000166e <IfxScuCcu_getSourceFrequency>
800016a2:	91 30 00 2f 	movh.a %a2,61443
800016a6:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
800016aa:	54 23       	ld.w %d3,[%a2]
800016ac:	37 03 64 34 	extr.u %d3,%d3,8,4
800016b0:	4b 03 41 31 	itof %d3,%d3
800016b4:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
800016b8:	4b 28 41 40 	mul.f %d4,%d8,%d2
800016bc:	4b 04 71 41 	ftouz %d4,%d4
    uint32 stmCountBegin = STM0_TIM0.U;
800016c0:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
800016c4:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
800016c8:	a2 32       	sub %d2,%d3
800016ca:	3f 42 fd ff 	jlt.u %d2,%d4,800016c4 <IfxScuCcu_wait+0x2a>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
800016ce:	00 90       	ret 

800016d0 <IfxScuCcu_getSpbFrequency>:
{
800016d0:	40 ae       	mov.aa %a14,%sp
    sourceFrequency = IfxScuCcu_getSourceFrequency();
800016d2:	6d ff ce ff 	call 8000166e <IfxScuCcu_getSourceFrequency>
    switch (SCU_CCUCON0.B.LPDIV)
800016d6:	91 30 00 2f 	movh.a %a2,61443
800016da:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
800016de:	54 23       	ld.w %d3,[%a2]
800016e0:	37 03 64 36 	extr.u %d3,%d3,12,4
800016e4:	ff 53 39 80 	jge.u %d3,5,80001756 <IfxScuCcu_getSpbFrequency+0x86>
800016e8:	91 00 00 28 	movh.a %a2,32768
800016ec:	d9 22 78 b1 	lea %a2,[%a2]5880 <800016f8 <IfxScuCcu_getSpbFrequency+0x28>>
800016f0:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
800016f4:	dc 02       	ji %a2
800016f6:	00 00       	nop 
800016f8:	1d 00 0a 00 	j 8000170c <IfxScuCcu_getSpbFrequency+0x3c>
800016fc:	1d 00 19 00 	j 8000172e <IfxScuCcu_getSpbFrequency+0x5e>
80001700:	1d 00 1c 00 	j 80001738 <IfxScuCcu_getSpbFrequency+0x68>
80001704:	1d 00 1f 00 	j 80001742 <IfxScuCcu_getSpbFrequency+0x72>
80001708:	1d 00 22 00 	j 8000174c <IfxScuCcu_getSpbFrequency+0x7c>
        if (SCU_CCUCON0.B.SPBDIV == 0)
8000170c:	91 30 00 2f 	movh.a %a2,61443
80001710:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001714:	54 23       	ld.w %d3,[%a2]
80001716:	37 03 64 38 	extr.u %d3,%d3,16,4
8000171a:	df 03 20 00 	jeq %d3,0,8000175a <IfxScuCcu_getSpbFrequency+0x8a>
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
8000171e:	54 23       	ld.w %d3,[%a2]
80001720:	37 03 64 38 	extr.u %d3,%d3,16,4
80001724:	4b 03 41 31 	itof %d3,%d3
80001728:	4b 32 51 20 	div.f %d2,%d2,%d3
8000172c:	00 90       	ret 
        spbFrequency = sourceFrequency / 30;
8000172e:	7b 00 1f 34 	movh %d3,16880
80001732:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001736:	00 90       	ret 
        spbFrequency = sourceFrequency / 60;
80001738:	7b 00 27 34 	movh %d3,17008
8000173c:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001740:	00 90       	ret 
        spbFrequency = sourceFrequency / 120;
80001742:	7b 00 2f 34 	movh %d3,17136
80001746:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
8000174a:	00 90       	ret 
        spbFrequency = sourceFrequency / 240;
8000174c:	7b 00 37 34 	movh %d3,17264
80001750:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80001754:	00 90       	ret 
    switch (SCU_CCUCON0.B.LPDIV)
80001756:	82 02       	mov %d2,0
80001758:	00 90       	ret 
            spbFrequency = 0.0f;
8000175a:	82 02       	mov %d2,0
}
8000175c:	00 90       	ret 

8000175e <IfxScuCcu_getSpbFrequency_end>:
	...

80001760 <IfxScuCcu_init>:
{
80001760:	40 ae       	mov.aa %a14,%sp
80001762:	40 4c       	mov.aa %a12,%a4
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80001764:	19 42 10 10 	ld.w %d2,[%a4]80
80001768:	91 00 00 26 	movh.a %a2,24576
8000176c:	59 22 00 00 	st.w [%a2]0 <60000000 <IfxScuCcu_xtalFrequency>>,%d2
    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
80001770:	6d 00 02 03 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
80001774:	02 2a       	mov %d10,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80001776:	6d 00 11 03 	call 80001d98 <IfxScuWdt_getSafetyWatchdogPassword>
8000177a:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000177c:	02 a4       	mov %d4,%d10
8000177e:	6d 00 92 01 	call 80001aa2 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80001782:	91 30 00 2f 	movh.a %a2,61443
80001786:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
8000178a:	54 2d       	ld.w %d13,[%a2]
8000178c:	37 0d e1 d1 	extr.u %d13,%d13,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
80001790:	54 22       	ld.w %d2,[%a2]
80001792:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001796:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
80001798:	02 a4       	mov %d4,%d10
8000179a:	6d 00 0a 03 	call 80001dae <IfxScuWdt_setCpuEndinit>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000179e:	02 84       	mov %d4,%d8
800017a0:	6d 00 a6 01 	call 80001aec <IfxScuWdt_clearSafetyEndinit>
        while (SCU_CCUCON0.B.LCK != 0U)
800017a4:	91 30 00 2f 	movh.a %a2,61443
800017a8:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
800017ac:	54 23       	ld.w %d3,[%a2]
800017ae:	bf 03 fb 7f 	jlt %d3,0,800017a4 <IfxScuCcu_init+0x44>
        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
800017b2:	54 22       	ld.w %d2,[%a2]
800017b4:	b7 02 02 2e 	insert %d2,%d2,0,28,2
800017b8:	74 22       	st.w [%a2],%d2
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
800017ba:	54 22       	ld.w %d2,[%a2]
800017bc:	b7 12 01 2f 	insert %d2,%d2,1,30,1
800017c0:	74 22       	st.w [%a2],%d2
        SCU_PLLCON0.B.SETFINDIS = 1;
800017c2:	91 30 00 2f 	movh.a %a2,61443
800017c6:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
800017ca:	54 22       	ld.w %d2,[%a2]
800017cc:	b7 12 01 22 	insert %d2,%d2,1,4,1
800017d0:	74 22       	st.w [%a2],%d2
        while (SCU_CCUCON1.B.LCK != 0U)
800017d2:	91 30 00 2f 	movh.a %a2,61443
800017d6:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
800017da:	54 23       	ld.w %d3,[%a2]
800017dc:	bf 03 fb 7f 	jlt %d3,0,800017d2 <IfxScuCcu_init+0x72>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
800017e0:	54 22       	ld.w %d2,[%a2]
800017e2:	b7 12 02 2e 	insert %d2,%d2,1,28,2
800017e6:	74 22       	st.w [%a2],%d2
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
800017e8:	54 22       	ld.w %d2,[%a2]
800017ea:	b7 12 01 2f 	insert %d2,%d2,1,30,1
800017ee:	74 22       	st.w [%a2],%d2
        status             |= IfxScuCcu_isOscillatorStable();
800017f0:	6d ff 7c fe 	call 800014e8 <IfxScuCcu_isOscillatorStable>
800017f4:	02 2c       	mov %d12,%d2
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800017f6:	02 84       	mov %d4,%d8
800017f8:	6d 00 00 03 	call 80001df8 <IfxScuWdt_setSafetyEndinit>
    if (status == 0)
800017fc:	df 0c 28 00 	jeq %d12,0,8000184c <IfxScuCcu_init+0xec>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001800:	02 84       	mov %d4,%d8
80001802:	6d 00 75 01 	call 80001aec <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80001806:	91 30 00 2f 	movh.a %a2,61443
8000180a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
8000180e:	54 23       	ld.w %d3,[%a2]
80001810:	8f 03 c4 31 	andn %d3,%d3,64
80001814:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001816:	02 84       	mov %d4,%d8
80001818:	6d 00 f0 02 	call 80001df8 <IfxScuWdt_setSafetyEndinit>
        IfxScuWdt_clearCpuEndinit(endinit_pw);
8000181c:	02 a4       	mov %d4,%d10
8000181e:	6d 00 42 01 	call 80001aa2 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80001822:	91 30 00 2f 	movh.a %a2,61443
80001826:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
8000182a:	54 23       	ld.w %d3,[%a2]
8000182c:	b7 13 81 31 	insert %d3,%d3,1,3,1
80001830:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80001832:	91 30 00 2f 	movh.a %a2,61443
80001836:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
8000183a:	54 23       	ld.w %d3,[%a2]
8000183c:	67 d3 03 30 	ins.t %d3,%d3,3,%d13,0
80001840:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinit_pw);
80001842:	02 a4       	mov %d4,%d10
80001844:	6d 00 b5 02 	call 80001dae <IfxScuWdt_setCpuEndinit>
}
80001848:	02 c2       	mov %d2,%d12
8000184a:	00 90       	ret 
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
8000184c:	02 84       	mov %d4,%d8
8000184e:	6d 00 4f 01 	call 80001aec <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80001852:	91 30 00 2f 	movh.a %a2,61443
80001856:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
8000185a:	54 23       	ld.w %d3,[%a2]
8000185c:	6f 53 fb 7f 	jz.t %d3,5,80001852 <IfxScuCcu_init+0xf2>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80001860:	39 c3 0a 00 	ld.bu %d3,[%a12]10
80001864:	91 30 00 2f 	movh.a %a2,61443
80001868:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
8000186c:	54 22       	ld.w %d2,[%a2]
8000186e:	37 32 07 20 	insert %d2,%d2,%d3,0,7
80001872:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
80001874:	39 c3 08 00 	ld.bu %d3,[%a12]8
80001878:	91 30 00 2f 	movh.a %a2,61443
8000187c:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80001880:	54 22       	ld.w %d2,[%a2]
80001882:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
80001886:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
80001888:	39 c3 09 00 	ld.bu %d3,[%a12]9
8000188c:	54 22       	ld.w %d2,[%a2]
8000188e:	37 32 87 24 	insert %d2,%d2,%d3,9,7
80001892:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
80001894:	54 22       	ld.w %d2,[%a2]
80001896:	b7 12 01 23 	insert %d2,%d2,1,6,1
8000189a:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
8000189c:	54 22       	ld.w %d2,[%a2]
8000189e:	b7 02 01 28 	insert %d2,%d2,0,16,1
800018a2:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
800018a4:	54 22       	ld.w %d2,[%a2]
800018a6:	b7 12 81 22 	insert %d2,%d2,1,5,1
800018aa:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
800018ac:	54 22       	ld.w %d2,[%a2]
800018ae:	b7 12 01 28 	insert %d2,%d2,1,16,1
800018b2:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.RESLD = 1;
800018b4:	54 22       	ld.w %d2,[%a2]
800018b6:	b7 12 01 29 	insert %d2,%d2,1,18,1
800018ba:	74 22       	st.w [%a2],%d2
                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
800018bc:	7b 20 85 43 	movh %d4,14418
800018c0:	1b 74 71 4b 	addi %d4,%d4,-18665
800018c4:	6d ff eb fe 	call 8000169a <IfxScuCcu_wait>
                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
800018c8:	91 30 00 2f 	movh.a %a2,61443
800018cc:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
800018d0:	54 23       	ld.w %d3,[%a2]
800018d2:	6f 23 fb 7f 	jz.t %d3,2,800018c8 <IfxScuCcu_init+0x168>
                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
800018d6:	91 30 00 2f 	movh.a %a2,61443
800018da:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
800018de:	54 22       	ld.w %d2,[%a2]
800018e0:	8f 12 c0 21 	andn %d2,%d2,1
800018e4:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
800018e6:	91 30 00 2f 	movh.a %a2,61443
800018ea:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
800018ee:	54 23       	ld.w %d3,[%a2]
800018f0:	bf 03 fb 7f 	jlt %d3,0,800018e6 <IfxScuCcu_init+0x186>
                    SCU_CCUCON0.B.CLKSEL = 0x01;
800018f4:	54 22       	ld.w %d2,[%a2]
800018f6:	b7 12 02 2e 	insert %d2,%d2,1,28,2
800018fa:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
800018fc:	91 30 00 2f 	movh.a %a2,61443
80001900:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001904:	54 23       	ld.w %d3,[%a2]
80001906:	bf 03 fb 7f 	jlt %d3,0,800018fc <IfxScuCcu_init+0x19c>
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
8000190a:	19 c4 0c 00 	ld.w %d4,[%a12]12
8000190e:	6d ff c6 fe 	call 8000169a <IfxScuCcu_wait>
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80001912:	91 30 00 2f 	movh.a %a2,61443
80001916:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
8000191a:	54 23       	ld.w %d3,[%a2]
8000191c:	19 c4 14 00 	ld.w %d4,[%a12]20 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80001920:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
80001924:	19 c2 10 00 	ld.w %d2,[%a12]16
80001928:	26 42       	and %d2,%d4
8000192a:	a6 23       	or %d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
8000192c:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon0.B.UP     = 1;
80001930:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
80001934:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON1.B.LCK != 0U)
80001936:	91 30 00 2f 	movh.a %a2,61443
8000193a:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000193e:	54 23       	ld.w %d3,[%a2]
80001940:	bf 03 fb 7f 	jlt %d3,0,80001936 <IfxScuCcu_init+0x1d6>
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
80001944:	54 23       	ld.w %d3,[%a2]
80001946:	19 c4 1c 00 	ld.w %d4,[%a12]28
8000194a:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
8000194e:	19 c2 18 00 	ld.w %d2,[%a12]24
80001952:	26 42       	and %d2,%d4
80001954:	a6 23       	or %d3,%d2
                        ccucon1.B.INSEL = 1;
80001956:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon1.B.UP    = 1;
8000195a:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON1     = ccucon1;
8000195e:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON2.B.LCK != 0U)
80001960:	91 30 00 2f 	movh.a %a2,61443
80001964:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x6002e040>>
80001968:	54 23       	ld.w %d3,[%a2]
8000196a:	bf 03 fb 7f 	jlt %d3,0,80001960 <IfxScuCcu_init+0x200>
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
8000196e:	54 23       	ld.w %d3,[%a2]
80001970:	19 c4 24 00 	ld.w %d4,[%a12]36
80001974:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
80001978:	19 c2 20 00 	ld.w %d2,[%a12]32
8000197c:	26 42       	and %d2,%d4
8000197e:	a6 32       	or %d2,%d3
                        ccucon2.B.UP = 1;
80001980:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON2  = ccucon2;
80001984:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON5.B.LCK != 0U)
80001986:	91 30 00 2f 	movh.a %a2,61443
8000198a:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x6002e04c>>
8000198e:	54 23       	ld.w %d3,[%a2]
80001990:	bf 03 fb 7f 	jlt %d3,0,80001986 <IfxScuCcu_init+0x226>
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80001994:	54 23       	ld.w %d3,[%a2]
80001996:	19 c4 2c 00 	ld.w %d4,[%a12]44
8000199a:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000199e:	19 c2 28 00 	ld.w %d2,[%a12]40
800019a2:	26 42       	and %d2,%d4
800019a4:	a6 32       	or %d2,%d3
                        ccucon5.B.UP = 1;
800019a6:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON5  = ccucon5;
800019aa:	74 22       	st.w [%a2],%d2
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
800019ac:	91 30 00 2f 	movh.a %a2,61443
800019b0:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x6002e080>>
800019b4:	54 23       	ld.w %d3,[%a2]
800019b6:	19 c4 34 00 	ld.w %d4,[%a12]52 <f0036080 <_SMALL_DATA4_+0x6002e080>>
800019ba:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
800019be:	19 c2 30 00 	ld.w %d2,[%a12]48
800019c2:	26 42       	and %d2,%d4
800019c4:	a6 32       	or %d2,%d3
                        SCU_CCUCON6 = ccucon6;
800019c6:	74 22       	st.w [%a2],%d2
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
800019c8:	91 30 00 2f 	movh.a %a2,61443
800019cc:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x6002e084>>
800019d0:	54 23       	ld.w %d3,[%a2]
800019d2:	19 c4 3c 00 	ld.w %d4,[%a12]60 <f0036084 <_SMALL_DATA4_+0x6002e084>>
800019d6:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
800019da:	19 c2 38 00 	ld.w %d2,[%a12]56
800019de:	26 42       	and %d2,%d4
800019e0:	a6 32       	or %d2,%d3
                        SCU_CCUCON7 = ccucon7;
800019e2:	74 22       	st.w [%a2],%d2
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
800019e4:	91 30 00 2f 	movh.a %a2,61443
800019e8:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x6002e088>>
800019ec:	54 23       	ld.w %d3,[%a2]
800019ee:	19 c4 04 10 	ld.w %d4,[%a12]68 <f0036088 <_SMALL_DATA4_+0x6002e088>>
800019f2:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
800019f6:	19 c2 00 10 	ld.w %d2,[%a12]64
800019fa:	26 42       	and %d2,%d4
800019fc:	a6 32       	or %d2,%d3
                        SCU_CCUCON8 = ccucon8;
800019fe:	74 22       	st.w [%a2],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001a00:	02 84       	mov %d4,%d8
80001a02:	6d 00 fb 01 	call 80001df8 <IfxScuWdt_setSafetyEndinit>
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
80001a06:	91 00 80 df 	movh.a %a13,63488
80001a0a:	d9 dd 14 02 	lea %a13,[%a13]8212 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
80001a0e:	54 d9       	ld.w %d9,[%a13]
80001a10:	19 c4 0c 10 	ld.w %d4,[%a12]76 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
80001a14:	0f 49 e0 90 	andn %d9,%d9,%d4
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80001a18:	19 c2 08 10 	ld.w %d2,[%a12]72
80001a1c:	26 42       	and %d2,%d4
80001a1e:	a6 29       	or %d9,%d2
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80001a20:	02 a4       	mov %d4,%d10
80001a22:	6d 00 40 00 	call 80001aa2 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
80001a26:	74 d9       	st.w [%a13],%d9
                IfxScuWdt_setCpuEndinit(endinit_pw);
80001a28:	02 a4       	mov %d4,%d10
80001a2a:	6d 00 c2 01 	call 80001dae <IfxScuWdt_setCpuEndinit>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80001a2e:	02 c9       	mov %d9,%d12
80001a30:	1d 00 0d 00 	j 80001a4a <IfxScuCcu_init+0x2ea>
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
80001a34:	99 c2 04 00 	ld.a %a2,[%a12]4
80001a38:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80001a3c:	19 24 04 00 	ld.w %d4,[%a2]4
80001a40:	6d ff 2d fe 	call 8000169a <IfxScuCcu_wait>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
80001a44:	c2 19       	add %d9,1
80001a46:	8f f9 0f 91 	and %d9,%d9,255
80001a4a:	14 c3       	ld.bu %d3,[%a12]
80001a4c:	7f 39 da fe 	jge.u %d9,%d3,80001800 <IfxScuCcu_init+0xa0>
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80001a50:	02 84       	mov %d4,%d8
80001a52:	6d 00 4d 00 	call 80001aec <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80001a56:	91 30 00 2f 	movh.a %a2,61443
80001a5a:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
80001a5e:	54 23       	ld.w %d3,[%a2]
80001a60:	6f 53 fb 7f 	jz.t %d3,5,80001a56 <IfxScuCcu_init+0x2f6>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
80001a64:	53 c9 20 b0 	mul %d11,%d9,12
80001a68:	99 c2 04 00 	ld.a %a2,[%a12]4
80001a6c:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80001a70:	14 24       	ld.bu %d4,[%a2]
80001a72:	91 30 00 2f 	movh.a %a2,61443
80001a76:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
80001a7a:	54 23       	ld.w %d3,[%a2]
80001a7c:	37 43 07 30 	insert %d3,%d3,%d4,0,7
80001a80:	74 23       	st.w [%a2],%d3
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80001a82:	02 84       	mov %d4,%d8
80001a84:	6d 00 ba 01 	call 80001df8 <IfxScuWdt_setSafetyEndinit>
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
80001a88:	99 c2 04 00 	ld.a %a2,[%a12]4
80001a8c:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80001a90:	d9 22 08 00 	lea %a2,[%a2]8
80001a94:	d4 22       	ld.a %a2,[%a2]
80001a96:	bd 02 cf 7f 	jz.a %a2,80001a34 <IfxScuCcu_init+0x2d4>
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
80001a9a:	2d 02 00 00 	calli %a2
80001a9e:	1d ff cb ff 	j 80001a34 <IfxScuCcu_init+0x2d4>

80001aa2 <IfxScuWdt_clearCpuEndinit>:
    {}
}


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
80001aa2:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001aa4:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001aa8:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80001aac:	7b 30 00 3f 	movh %d3,61443
80001ab0:	1b 03 10 36 	addi %d3,%d3,24832
80001ab4:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001ab8:	60 22       	mov.a %a2,%d2
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80001aba:	54 22       	ld.w %d2,[%a2]
80001abc:	6f 12 0b 00 	jz.t %d2,1,80001ad2 <IfxScuWdt_clearCpuEndinit+0x30>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001ac0:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001ac4:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001ac8:	54 22       	ld.w %d2,[%a2]
80001aca:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001ace:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ad0:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001ad2:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001ad6:	8f 23 40 31 	or %d3,%d3,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001ada:	54 22       	ld.w %d2,[%a2]
80001adc:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001ae0:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ae2:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80001ae4:	54 22       	ld.w %d2,[%a2]
80001ae6:	6f 02 ff ff 	jnz.t %d2,0,80001ae4 <IfxScuWdt_clearCpuEndinit+0x42>
}
80001aea:	00 90       	ret 

80001aec <IfxScuWdt_clearSafetyEndinit>:


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
80001aec:	40 ae       	mov.aa %a14,%sp
80001aee:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80001af2:	91 30 00 2f 	movh.a %a2,61443
80001af6:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001afa:	54 22       	ld.w %d2,[%a2]
80001afc:	6f 12 0b 00 	jz.t %d2,1,80001b12 <IfxScuWdt_clearSafetyEndinit+0x26>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001b00:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001b04:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001b08:	54 22       	ld.w %d2,[%a2]
80001b0a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001b0e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001b10:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001b12:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001b16:	8f 23 40 31 	or %d3,%d3,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001b1a:	91 30 00 2f 	movh.a %a2,61443
80001b1e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001b22:	54 22       	ld.w %d2,[%a2]
80001b24:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001b28:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001b2a:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001b2c:	91 30 00 2f 	movh.a %a2,61443
80001b30:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001b34:	54 22       	ld.w %d2,[%a2]
80001b36:	6f 02 fb ff 	jnz.t %d2,0,80001b2c <IfxScuWdt_clearSafetyEndinit+0x40>
    IfxScuWdt_clearSafetyEndinitInline(password);
}
80001b3a:	00 90       	ret 

80001b3c <IfxScuWdt_disableCpuWatchdog>:


void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
80001b3c:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001b3e:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001b42:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80001b46:	7b 30 00 3f 	movh %d3,61443
80001b4a:	1b 03 10 36 	addi %d3,%d3,24832
80001b4e:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001b52:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001b54:	54 22       	ld.w %d2,[%a2]
80001b56:	6f 12 0b 00 	jz.t %d2,1,80001b6c <IfxScuWdt_disableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001b5a:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001b5e:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001b62:	54 22       	ld.w %d2,[%a2]
80001b64:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001b68:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001b6a:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001b6c:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001b6e:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001b72:	54 22       	ld.w %d2,[%a2]
80001b74:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001b78:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001b7a:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80001b7c:	54 22       	ld.w %d2,[%a2]
80001b7e:	6f 02 ff ff 	jnz.t %d2,0,80001b7c <IfxScuWdt_disableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
80001b82:	d9 23 04 00 	lea %a3,[%a2]4
80001b86:	19 22 04 00 	ld.w %d2,[%a2]4
80001b8a:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001b8e:	74 32       	st.w [%a3],%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80001b90:	54 22       	ld.w %d2,[%a2]
80001b92:	6f 12 09 00 	jz.t %d2,1,80001ba4 <IfxScuWdt_disableCpuWatchdog+0x68>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001b96:	8f 14 40 31 	or %d3,%d4,1
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001b9a:	54 22       	ld.w %d2,[%a2]
80001b9c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001ba0:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ba2:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001ba4:	8f 34 40 41 	or %d4,%d4,3
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001ba8:	54 22       	ld.w %d2,[%a2]
80001baa:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001bae:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001bb0:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80001bb2:	54 22       	ld.w %d2,[%a2]
80001bb4:	6f 02 ff 7f 	jz.t %d2,0,80001bb2 <IfxScuWdt_disableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80001bb8:	00 90       	ret 

80001bba <IfxScuWdt_disableSafetyWatchdog>:


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
80001bba:	40 ae       	mov.aa %a14,%sp
80001bbc:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001bc0:	91 30 00 2f 	movh.a %a2,61443
80001bc4:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001bc8:	54 22       	ld.w %d2,[%a2]
80001bca:	6f 12 0b 00 	jz.t %d2,1,80001be0 <IfxScuWdt_disableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001bce:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001bd2:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001bd6:	54 22       	ld.w %d2,[%a2]
80001bd8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001bdc:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001bde:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001be0:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001be2:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001be6:	91 30 00 2f 	movh.a %a2,61443
80001bea:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001bee:	54 22       	ld.w %d2,[%a2]
80001bf0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001bf4:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001bf6:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001bf8:	91 30 00 2f 	movh.a %a2,61443
80001bfc:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001c00:	54 22       	ld.w %d2,[%a2]
80001c02:	6f 02 fb ff 	jnz.t %d2,0,80001bf8 <IfxScuWdt_disableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
80001c06:	91 30 00 2f 	movh.a %a2,61443
80001c0a:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
80001c0e:	54 22       	ld.w %d2,[%a2]
80001c10:	b7 12 81 21 	insert %d2,%d2,1,3,1
80001c14:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80001c16:	91 30 00 2f 	movh.a %a2,61443
80001c1a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001c1e:	54 22       	ld.w %d2,[%a2]
80001c20:	6f 12 09 00 	jz.t %d2,1,80001c32 <IfxScuWdt_disableSafetyWatchdog+0x78>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001c24:	8f 14 40 31 	or %d3,%d4,1
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001c28:	54 22       	ld.w %d2,[%a2]
80001c2a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001c2e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001c30:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001c32:	8f 34 40 41 	or %d4,%d4,3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001c36:	91 30 00 2f 	movh.a %a2,61443
80001c3a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001c3e:	54 22       	ld.w %d2,[%a2]
80001c40:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001c44:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001c46:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001c48:	91 30 00 2f 	movh.a %a2,61443
80001c4c:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001c50:	54 22       	ld.w %d2,[%a2]
80001c52:	6f 02 fb 7f 	jz.t %d2,0,80001c48 <IfxScuWdt_disableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80001c56:	00 90       	ret 

80001c58 <IfxScuWdt_enableCpuWatchdog>:


void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
80001c58:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001c5a:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001c5e:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
80001c62:	7b 30 00 3f 	movh %d3,61443
80001c66:	1b 03 10 36 	addi %d3,%d3,24832
80001c6a:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001c6e:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001c70:	54 22       	ld.w %d2,[%a2]
80001c72:	6f 12 0b 00 	jz.t %d2,1,80001c88 <IfxScuWdt_enableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001c76:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001c7a:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001c7e:	54 22       	ld.w %d2,[%a2]
80001c80:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001c84:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001c86:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001c88:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001c8a:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001c8e:	54 22       	ld.w %d2,[%a2]
80001c90:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001c94:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001c96:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80001c98:	54 22       	ld.w %d2,[%a2]
80001c9a:	6f 02 ff ff 	jnz.t %d2,0,80001c98 <IfxScuWdt_enableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
80001c9e:	d9 23 04 00 	lea %a3,[%a2]4
80001ca2:	19 22 04 00 	ld.w %d2,[%a2]4
80001ca6:	8f 82 c0 21 	andn %d2,%d2,8
80001caa:	74 32       	st.w [%a3],%d2
    if (watchdog->CON0.B.LCK)
80001cac:	54 22       	ld.w %d2,[%a2]
80001cae:	6f 12 09 00 	jz.t %d2,1,80001cc0 <IfxScuWdt_enableCpuWatchdog+0x68>
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001cb2:	8f 14 40 31 	or %d3,%d4,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001cb6:	54 22       	ld.w %d2,[%a2]
80001cb8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001cbc:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001cbe:	74 22       	st.w [%a2],%d2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001cc0:	8f 34 40 41 	or %d4,%d4,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001cc4:	54 22       	ld.w %d2,[%a2]
80001cc6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001cca:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ccc:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80001cce:	54 22       	ld.w %d2,[%a2]
80001cd0:	6f 02 ff 7f 	jz.t %d2,0,80001cce <IfxScuWdt_enableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80001cd4:	00 90       	ret 

80001cd6 <IfxScuWdt_enableSafetyWatchdog>:


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
80001cd6:	40 ae       	mov.aa %a14,%sp
80001cd8:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001cdc:	91 30 00 2f 	movh.a %a2,61443
80001ce0:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001ce4:	54 22       	ld.w %d2,[%a2]
80001ce6:	6f 12 0b 00 	jz.t %d2,1,80001cfc <IfxScuWdt_enableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001cea:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001cee:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001cf2:	54 22       	ld.w %d2,[%a2]
80001cf4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001cf8:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001cfa:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001cfc:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001cfe:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001d02:	91 30 00 2f 	movh.a %a2,61443
80001d06:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001d0a:	54 22       	ld.w %d2,[%a2]
80001d0c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001d10:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001d12:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80001d14:	91 30 00 2f 	movh.a %a2,61443
80001d18:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001d1c:	54 22       	ld.w %d2,[%a2]
80001d1e:	6f 02 fb ff 	jnz.t %d2,0,80001d14 <IfxScuWdt_enableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
80001d22:	91 30 00 2f 	movh.a %a2,61443
80001d26:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
80001d2a:	54 22       	ld.w %d2,[%a2]
80001d2c:	8f 82 c0 21 	andn %d2,%d2,8
80001d30:	74 22       	st.w [%a2],%d2
    if (SCU_WDTS_CON0.B.LCK)
80001d32:	91 30 00 2f 	movh.a %a2,61443
80001d36:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001d3a:	54 22       	ld.w %d2,[%a2]
80001d3c:	6f 12 09 00 	jz.t %d2,1,80001d4e <IfxScuWdt_enableSafetyWatchdog+0x78>
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001d40:	8f 14 40 31 	or %d3,%d4,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001d44:	54 22       	ld.w %d2,[%a2]
80001d46:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001d4a:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001d4c:	74 22       	st.w [%a2],%d2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001d4e:	8f 34 40 41 	or %d4,%d4,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001d52:	91 30 00 2f 	movh.a %a2,61443
80001d56:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001d5a:	54 22       	ld.w %d2,[%a2]
80001d5c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001d60:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001d62:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001d64:	91 30 00 2f 	movh.a %a2,61443
80001d68:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001d6c:	54 22       	ld.w %d2,[%a2]
80001d6e:	6f 02 fb 7f 	jz.t %d2,0,80001d64 <IfxScuWdt_enableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80001d72:	00 90       	ret 

80001d74 <IfxScuWdt_getCpuWatchdogPassword>:


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
80001d74:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001d76:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001d7a:	8f 72 00 21 	and %d2,%d2,7
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
80001d7e:	7b 30 00 3f 	movh %d3,61443
80001d82:	1b 03 10 36 	addi %d3,%d3,24832
80001d86:	13 c2 20 23 	madd %d2,%d3,%d2,12
    password  = watchdog->CON0.B.PW;
80001d8a:	60 22       	mov.a %a2,%d2
80001d8c:	54 22       	ld.w %d2,[%a2]
80001d8e:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
80001d92:	8f f2 83 21 	xor %d2,%d2,63
80001d96:	00 90       	ret 

80001d98 <IfxScuWdt_getSafetyWatchdogPassword>:
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
}


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
80001d98:	40 ae       	mov.aa %a14,%sp
    password  = watchdog->CON0.B.PW;
80001d9a:	91 30 00 2f 	movh.a %a2,61443
80001d9e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001da2:	54 22       	ld.w %d2,[%a2]
80001da4:	37 02 6e 21 	extr.u %d2,%d2,2,14
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
80001da8:	8f f2 83 21 	xor %d2,%d2,63
80001dac:	00 90       	ret 

80001dae <IfxScuWdt_setCpuEndinit>:
    IfxScuWdt_setSafetyEndinit(password);
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
80001dae:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80001db0:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80001db4:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80001db8:	7b 30 00 3f 	movh %d3,61443
80001dbc:	1b 03 10 36 	addi %d3,%d3,24832
80001dc0:	13 c2 20 23 	madd %d2,%d3,%d2,12
80001dc4:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80001dc6:	54 22       	ld.w %d2,[%a2]
80001dc8:	6f 12 0b 00 	jz.t %d2,1,80001dde <IfxScuWdt_setCpuEndinit+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001dcc:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001dd0:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001dd4:	54 22       	ld.w %d2,[%a2]
80001dd6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001dda:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001ddc:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001dde:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80001de2:	8f 33 40 31 	or %d3,%d3,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80001de6:	54 22       	ld.w %d2,[%a2]
80001de8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80001dec:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80001dee:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80001df0:	54 22       	ld.w %d2,[%a2]
80001df2:	6f 02 ff 7f 	jz.t %d2,0,80001df0 <IfxScuWdt_setCpuEndinit+0x42>
}
80001df6:	00 90       	ret 

80001df8 <IfxScuWdt_setSafetyEndinit>:


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
80001df8:	40 ae       	mov.aa %a14,%sp
80001dfa:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80001dfe:	91 30 00 2f 	movh.a %a2,61443
80001e02:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001e06:	54 22       	ld.w %d2,[%a2]
80001e08:	6f 12 0b 00 	jz.t %d2,1,80001e1e <IfxScuWdt_setSafetyEndinit+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001e0c:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001e10:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001e14:	54 22       	ld.w %d2,[%a2]
80001e16:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001e1a:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001e1c:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001e1e:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80001e22:	8f 33 40 31 	or %d3,%d3,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80001e26:	91 30 00 2f 	movh.a %a2,61443
80001e2a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001e2e:	54 22       	ld.w %d2,[%a2]
80001e30:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80001e34:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80001e36:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
80001e38:	91 30 00 2f 	movh.a %a2,61443
80001e3c:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80001e40:	54 22       	ld.w %d2,[%a2]
80001e42:	6f 02 fb 7f 	jz.t %d2,0,80001e38 <IfxScuWdt_setSafetyEndinit+0x40>
    IfxScuWdt_setSafetyEndinitInline(password);
}
80001e46:	00 90       	ret 

80001e48 <IfxPort_setPinMode>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
80001e48:	40 ae       	mov.aa %a14,%sp
80001e4a:	40 4c       	mov.aa %a12,%a4
80001e4c:	02 5a       	mov %d10,%d5
80001e4e:	8f f4 0f c1 	and %d12,%d4,255
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
80001e52:	80 42       	mov.d %d2,%a4
80001e54:	1b 02 01 b0 	addi %d11,%d2,16
    uint8                 iocrIndex = (pinIndex / 4);
80001e58:	37 04 66 91 	extr.u %d9,%d4,2,6
    uint8                 shift     = (pinIndex & 0x3U) * 8;
80001e5c:	8f 34 00 41 	and %d4,%d4,3
80001e60:	8f 34 00 80 	sh %d8,%d4,3

    if (port == &MODULE_P40)
80001e64:	7b 40 00 2f 	movh %d2,61444
80001e68:	1b 02 00 2e 	addi %d2,%d2,-8192
80001e6c:	80 43       	mov.d %d3,%a4
80001e6e:	5f 23 12 00 	jeq %d3,%d2,80001e92 <IfxPort_setPinMode+0x4a>
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
        IfxScuWdt_setCpuEndinit(passwd);
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
80001e72:	8f 29 00 20 	sh %d2,%d9,2
80001e76:	60 b2       	mov.a %a2,%d11
80001e78:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80001e7c:	3b f0 0f 40 	mov %d4,255
80001e80:	0f 84 00 40 	sh %d4,%d4,%d8
80001e84:	0f 8a 00 20 	sh %d2,%d10,%d8
                     ::"a"(address), "d"(mask), "d"((long long)value));
80001e88:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
80001e8a:	02 43       	mov %d3,%d4
80001e8c:	49 22 40 08 	ldmst [%a2]0,%e2
}
80001e90:	00 90       	ret 
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80001e92:	6d ff 71 ff 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
80001e96:	02 2d       	mov %d13,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80001e98:	02 24       	mov %d4,%d2
80001e9a:	6d ff 04 fe 	call 80001aa2 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
80001e9e:	d9 c2 20 10 	lea %a2,[%a12]96
80001ea2:	19 c2 20 10 	ld.w %d2,[%a12]96
80001ea6:	d7 02 01 2c 	insert %d2,%d2,0,%d12,1
80001eaa:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(passwd);
80001eac:	02 d4       	mov %d4,%d13
80001eae:	6d ff 80 ff 	call 80001dae <IfxScuWdt_setCpuEndinit>
80001eb2:	1d ff e0 ff 	j 80001e72 <IfxPort_setPinMode+0x2a>

80001eb6 <IfxMultican_MsgObj_clearStatusFlag>:
    return result;
}


void IfxMultican_MsgObj_clearStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
80001eb6:	40 ae       	mov.aa %a14,%sp
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;
    ctr.U        = 1U << flag;
80001eb8:	82 12       	mov %d2,1
80001eba:	0f 42 00 20 	sh %d2,%d2,%d4

    hwObj->CTR.U = ctr.U;
80001ebe:	59 42 1c 00 	st.w [%a4]28,%d2
}
80001ec2:	00 90       	ret 

80001ec4 <IfxMultican_MsgObj_doReadMessage>:
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
}


IFX_STATIC void IfxMultican_MsgObj_doReadMessage(Ifx_CAN_MO *hwObj, IfxMultican_Message *msg)
{
80001ec4:	40 ae       	mov.aa %a14,%sp
80001ec6:	40 4d       	mov.aa %a13,%a4
80001ec8:	40 5c       	mov.aa %a12,%a5
    /* for standard message object and FIFO message objects*/
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);
80001eca:	82 34       	mov %d4,3
80001ecc:	6d ff f5 ff 	call 80001eb6 <IfxMultican_MsgObj_clearStatusFlag>

    /* read the data from the data registers */
    msg->data[0] = hwObj->DATAL.U;
80001ed0:	19 d2 10 00 	ld.w %d2,[%a13]16
80001ed4:	59 c2 08 00 	st.w [%a12]8,%d2
    msg->data[1] = hwObj->DATAH.U;
80001ed8:	19 d2 14 00 	ld.w %d2,[%a13]20
80001edc:	59 c2 0c 00 	st.w [%a12]12,%d2
}


IFX_INLINE IfxMultican_DataLengthCode IfxMultican_MsgObj_getDataLengthCode(Ifx_CAN_MO *hwObj)
{
    return (IfxMultican_DataLengthCode)(hwObj->FCR.B.DLC);
80001ee0:	54 d2       	ld.w %d2,[%a13]
80001ee2:	37 02 64 2c 	extr.u %d2,%d2,24,4

    /* copy the length code from hardware */
    msg->lengthCode = IfxMultican_MsgObj_getDataLengthCode(hwObj);
80001ee6:	59 c2 04 00 	st.w [%a12]4,%d2


IFX_INLINE uint32 IfxMultican_MsgObj_getMessageId(Ifx_CAN_MO *hwObj)
{
    Ifx_CAN_MO_AR ar;
    ar.U = hwObj->AR.U;
80001eea:	19 d2 18 00 	ld.w %d2,[%a13]24
    return ar.B.ID >> ((ar.B.IDE != 0) ? 0 : 18);
80001eee:	37 02 7d 30 	extr.u %d3,%d2,0,29
80001ef2:	ef d2 09 00 	jz.t %d2,29,80001f04 <IfxMultican_MsgObj_doReadMessage+0x40>
80001ef6:	82 04       	mov %d4,0
80001ef8:	8b 04 00 21 	rsub %d2,%d4,0
80001efc:	0f 23 20 20 	shas %d2,%d3,%d2

    /* copy the ID from the hardware */
    msg->id = IfxMultican_MsgObj_getMessageId(hwObj);
80001f00:	74 c2       	st.w [%a12],%d2
}
80001f02:	00 90       	ret 
80001f04:	3b 20 01 40 	mov %d4,18
80001f08:	1d ff f8 ff 	j 80001ef8 <IfxMultican_MsgObj_doReadMessage+0x34>

80001f0c <IfxMultican_MsgObj_readMessage>:
    return status;
}


IfxMultican_Status IfxMultican_MsgObj_readMessage(Ifx_CAN_MO *hwObj, IfxMultican_Message *msg)
{
80001f0c:	40 ae       	mov.aa %a14,%sp
80001f0e:	40 4c       	mov.aa %a12,%a4
80001f10:	80 58       	mov.d %d8,%a5
    IfxMultican_Status status = IfxMultican_Status_ok;

    /* if new data available in the message object */
    if (hwObj->STAT.B.NEWDAT != 0)
80001f12:	19 42 1c 00 	ld.w %d2,[%a4]28
80001f16:	6f 32 06 80 	jnz.t %d2,3,80001f22 <IfxMultican_MsgObj_readMessage+0x16>
            status |= IfxMultican_Status_messageLost;
        }
    }
    else
    {
        status = IfxMultican_Status_receiveEmpty;
80001f1a:	3b 00 04 80 	mov %d8,64
    }

    return status;
}
80001f1e:	02 82       	mov %d2,%d8
80001f20:	00 90       	ret 
        IfxMultican_MsgObj_doReadMessage(hwObj, msg);
80001f22:	6d ff d1 ff 	call 80001ec4 <IfxMultican_MsgObj_doReadMessage>
        stat = hwObj->STAT; /* Cache the status after reading to reduce message lost propability */
80001f26:	19 c9 1c 00 	ld.w %d9,[%a12]28
        if (stat.B.RXUPD != 0)
80001f2a:	6f 29 1a 80 	jnz.t %d9,2,80001f5e <IfxMultican_MsgObj_readMessage+0x52>
        else if (stat.B.NEWDAT != 0)
80001f2e:	6f 39 06 80 	jnz.t %d9,3,80001f3a <IfxMultican_MsgObj_readMessage+0x2e>
            status = IfxMultican_Status_newData;
80001f32:	3b 00 10 80 	mov %d8,256
80001f36:	1d 00 16 00 	j 80001f62 <IfxMultican_MsgObj_readMessage+0x56>
            IfxMultican_MsgObj_doReadMessage(hwObj, msg);
80001f3a:	60 85       	mov.a %a5,%d8
80001f3c:	40 c4       	mov.aa %a4,%a12
80001f3e:	6d ff c3 ff 	call 80001ec4 <IfxMultican_MsgObj_doReadMessage>
            stat2 = hwObj->STAT; /* Cache the status after reading */
80001f42:	19 c2 1c 00 	ld.w %d2,[%a12]28
            if ((stat2.B.NEWDAT == 0) && (stat2.B.RXUPD == 0))
80001f46:	8f c2 00 21 	and %d2,%d2,12
80001f4a:	df 02 06 00 	jeq %d2,0,80001f56 <IfxMultican_MsgObj_readMessage+0x4a>
            status = IfxMultican_Status_messageLost;
80001f4e:	3b 00 08 80 	mov %d8,128
80001f52:	1d 00 08 00 	j 80001f62 <IfxMultican_MsgObj_readMessage+0x56>
                status |= IfxMultican_Status_newData;
80001f56:	3b 00 18 80 	mov %d8,384
            }
80001f5a:	1d 00 04 00 	j 80001f62 <IfxMultican_MsgObj_readMessage+0x56>
            status = IfxMultican_Status_messageLost;
80001f5e:	3b 00 08 80 	mov %d8,128
        if (stat.B.MSGLST != 0)
80001f62:	6f 49 de 7f 	jz.t %d9,4,80001f1e <IfxMultican_MsgObj_readMessage+0x12>
            IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageLost);
80001f66:	82 44       	mov %d4,4
80001f68:	40 c4       	mov.aa %a4,%a12
80001f6a:	6d ff a6 ff 	call 80001eb6 <IfxMultican_MsgObj_clearStatusFlag>
            status |= IfxMultican_Status_messageLost;
80001f6e:	8f 08 48 81 	or %d8,%d8,128
80001f72:	1d ff d6 ff 	j 80001f1e <IfxMultican_MsgObj_readMessage+0x12>

80001f76 <IfxMultican_MsgObj_setStatusFlag>:
    hwObj->CTR.U    = ctr.U;
}


void IfxMultican_MsgObj_setStatusFlag(Ifx_CAN_MO *hwObj, IfxMultican_MsgObjStatusFlag flag)
{
80001f76:	40 ae       	mov.aa %a14,%sp
    Ifx_CAN_MO_CTR ctr;
    ctr.U        = 0;

    ctr.U        = 1U << (flag + 16);
80001f78:	1b 04 01 40 	addi %d4,%d4,16
80001f7c:	82 13       	mov %d3,1
80001f7e:	0f 43 00 30 	sh %d3,%d3,%d4

    hwObj->CTR.U = ctr.U;
80001f82:	59 43 1c 00 	st.w [%a4]28,%d3
}
80001f86:	00 90       	ret 

80001f88 <IfxMultican_MsgObj_sendMessage>:
{
80001f88:	40 ae       	mov.aa %a14,%sp
80001f8a:	40 4c       	mov.aa %a12,%a4
80001f8c:	40 5d       	mov.aa %a13,%a5
    if (hwObj->STAT.B.TXRQ)
80001f8e:	19 42 1c 00 	ld.w %d2,[%a4]28
80001f92:	6f 82 05 00 	jz.t %d2,8,80001f9c <IfxMultican_MsgObj_sendMessage+0x14>
        status = IfxMultican_Status_notSentBusy;
80001f96:	3b 00 02 20 	mov %d2,32
}
80001f9a:	00 90       	ret 
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80001f9c:	82 54       	mov %d4,5
80001f9e:	6d ff 8c ff 	call 80001eb6 <IfxMultican_MsgObj_clearStatusFlag>
        hwObj->DATAL.U = msg->data[0];  /* Set the new data */
80001fa2:	19 d2 08 00 	ld.w %d2,[%a13]8
80001fa6:	59 c2 10 00 	st.w [%a12]16,%d2
        hwObj->DATAH.U = msg->data[1];  /* Set the new data */
80001faa:	19 d2 0c 00 	ld.w %d2,[%a13]12
80001fae:	59 c2 14 00 	st.w [%a12]20,%d2
}


IFX_INLINE boolean IfxMultican_MsgObj_isExtendedFrame(Ifx_CAN_MO *hwObj)
{
    return hwObj->AR.B.IDE != 0;
80001fb2:	19 c3 18 00 	ld.w %d3,[%a12]24
            IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
80001fb6:	54 d2       	ld.w %d2,[%a13]
}


IFX_INLINE void IfxMultican_MsgObj_setMessageId(Ifx_CAN_MO *hwObj, uint32 messageId, boolean extendedFrame)
{
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80001fb8:	ef d3 21 00 	jz.t %d3,29,80001ffa <IfxMultican_MsgObj_sendMessage+0x72>
80001fbc:	82 03       	mov %d3,0
80001fbe:	0f 32 00 30 	sh %d3,%d2,%d3
80001fc2:	d9 c2 18 00 	lea %a2,[%a12]24
80001fc6:	19 c2 18 00 	ld.w %d2,[%a12]24
80001fca:	37 32 1d 20 	insert %d2,%d2,%d3,0,29
80001fce:	74 22       	st.w [%a2],%d2
            IfxMultican_MsgObj_setDataLengthCode(hwObj, msg->lengthCode);
80001fd0:	19 d3 04 00 	ld.w %d3,[%a13]4
    hwObj->FCR.B.DLC = code;
80001fd4:	54 c2       	ld.w %d2,[%a12]
80001fd6:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
80001fda:	74 c2       	st.w [%a12],%d2
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);
80001fdc:	82 34       	mov %d4,3
80001fde:	40 c4       	mov.aa %a4,%a12
80001fe0:	6d ff cb ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
80001fe4:	82 54       	mov %d4,5
80001fe6:	40 c4       	mov.aa %a4,%a12
80001fe8:	6d ff c7 ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
80001fec:	3b 80 00 40 	mov %d4,8
80001ff0:	40 c4       	mov.aa %a4,%a12
80001ff2:	6d ff c2 ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
    IfxMultican_Status status = IfxMultican_Status_ok;
80001ff6:	82 02       	mov %d2,0
80001ff8:	00 90       	ret 
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80001ffa:	3b 20 01 30 	mov %d3,18
80001ffe:	1d ff e0 ff 	j 80001fbe <IfxMultican_MsgObj_sendMessage+0x36>

80002002 <IfxMultican_MsgObj_writeTxfifo>:
{
80002002:	40 ae       	mov.aa %a14,%sp
80002004:	40 4c       	mov.aa %a12,%a4
80002006:	40 5d       	mov.aa %a13,%a5
    if (hwObj->STAT.B.TXRQ)
80002008:	19 42 1c 00 	ld.w %d2,[%a4]28
8000200c:	6f 82 05 00 	jz.t %d2,8,80002016 <IfxMultican_MsgObj_writeTxfifo+0x14>
        status = IfxMultican_Status_notSentBusy;
80002010:	3b 00 02 20 	mov %d2,32
}
80002014:	00 90       	ret 
        IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
80002016:	3b 90 00 40 	mov %d4,9
8000201a:	6d ff 4e ff 	call 80001eb6 <IfxMultican_MsgObj_clearStatusFlag>
        hwObj->DATAL.U = msg->data[0];      /* Set the new data */
8000201e:	19 d2 08 00 	ld.w %d2,[%a13]8
80002022:	59 c2 10 00 	st.w [%a12]16,%d2
        hwObj->DATAH.U = msg->data[1];      /* Set the new data */
80002026:	19 d2 0c 00 	ld.w %d2,[%a13]12
8000202a:	59 c2 14 00 	st.w [%a12]20,%d2
        IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitEnable0);
8000202e:	3b 90 00 40 	mov %d4,9
80002032:	40 c4       	mov.aa %a4,%a12
80002034:	6d ff a1 ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
    return hwObj->AR.B.IDE != 0;
80002038:	19 c3 18 00 	ld.w %d3,[%a12]24
            IfxMultican_MsgObj_setMessageId(hwObj, msg->id, extendedFrame);
8000203c:	54 d2       	ld.w %d2,[%a13]
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
8000203e:	ef d3 21 00 	jz.t %d3,29,80002080 <IfxMultican_MsgObj_writeTxfifo+0x7e>
80002042:	82 03       	mov %d3,0
80002044:	0f 32 00 30 	sh %d3,%d2,%d3
80002048:	d9 c2 18 00 	lea %a2,[%a12]24
8000204c:	19 c2 18 00 	ld.w %d2,[%a12]24
80002050:	37 32 1d 20 	insert %d2,%d2,%d3,0,29
80002054:	74 22       	st.w [%a2],%d2
            IfxMultican_MsgObj_setDataLengthCode(hwObj, msg->lengthCode);
80002056:	19 d3 04 00 	ld.w %d3,[%a13]4
    hwObj->FCR.B.DLC = code;
8000205a:	54 c2       	ld.w %d2,[%a12]
8000205c:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
80002060:	74 c2       	st.w [%a12],%d2
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_newData);
80002062:	82 34       	mov %d4,3
80002064:	40 c4       	mov.aa %a4,%a12
80002066:	6d ff 88 ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_messageValid);
8000206a:	82 54       	mov %d4,5
8000206c:	40 c4       	mov.aa %a4,%a12
8000206e:	6d ff 84 ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
            IfxMultican_MsgObj_setStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_transmitRequest);
80002072:	3b 80 00 40 	mov %d4,8
80002076:	40 c4       	mov.aa %a4,%a12
80002078:	6d ff 7f ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
    IfxMultican_Status status = IfxMultican_Status_ok;
8000207c:	82 02       	mov %d2,0
8000207e:	00 90       	ret 
    hwObj->AR.B.ID = messageId << ((extendedFrame != 0) ? 0 : 18);
80002080:	3b 20 01 30 	mov %d3,18
80002084:	1d ff e0 ff 	j 80002044 <IfxMultican_MsgObj_writeTxfifo+0x42>

80002088 <IfxMultican_Can_MsgObj_readMessage>:
    }
}


IfxMultican_Status IfxMultican_Can_MsgObj_readMessage(IfxMultican_Can_MsgObj *msgObj, IfxMultican_Message *msg)
{
80002088:	40 ae       	mov.aa %a14,%sp
8000208a:	40 4c       	mov.aa %a12,%a4
8000208c:	80 5a       	mov.d %d10,%a5
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
8000208e:	b9 42 08 00 	ld.hu %d2,[%a4]8
80002092:	bf 22 24 80 	jlt.u %d2,2,800020da <IfxMultican_Can_MsgObj_readMessage+0x52>
    {
        /* for FIFO message Objects */
        objId = msgObj->fifoPointer;
80002096:	19 49 0c 00 	ld.w %d9,[%a4]12
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
8000209a:	d4 c2       	ld.a %a2,[%a12]
8000209c:	54 2b       	ld.w %d11,[%a2]
}


IFX_INLINE Ifx_CAN_MO *IfxMultican_MsgObj_getPointer(Ifx_CAN *mcan, IfxMultican_MsgObjId msgObjId)
{
    return &(mcan->MO[msgObjId]);
8000209e:	1b 09 08 20 	addi %d2,%d9,128
800020a2:	06 52       	sh %d2,5
800020a4:	0b 2b 00 80 	add %d8,%d11,%d2
    IfxMultican_MsgObj_clearStatusFlag(hwObj, IfxMultican_MsgObjStatusFlag_receivePending);
800020a8:	82 04       	mov %d4,0
800020aa:	60 84       	mov.a %a4,%d8
800020ac:	6d ff 05 ff 	call 80001eb6 <IfxMultican_MsgObj_clearStatusFlag>

    /* clear pending flag */
    IfxMultican_MsgObj_clearRxPending(hwObj);

    /* read the message object */
    status = IfxMultican_MsgObj_readMessage(hwObj, msg);
800020b0:	60 a5       	mov.a %a5,%d10
800020b2:	60 84       	mov.a %a4,%d8
800020b4:	6d ff 2c ff 	call 80001f0c <IfxMultican_MsgObj_readMessage>

    /* if successfull: */
    if (status & IfxMultican_Status_newData)
800020b8:	6f 82 10 00 	jz.t %d2,8,800020d8 <IfxMultican_Can_MsgObj_readMessage+0x50>
    {
        if (msgObj->msgObjCount > 1)
800020bc:	b9 c3 08 00 	ld.hu %d3,[%a12]8
800020c0:	bf 23 0c 80 	jlt.u %d3,2,800020d8 <IfxMultican_Can_MsgObj_readMessage+0x50>
    return (IfxMultican_MsgObjId)(hwObj->FGPR.B.BOT);
800020c4:	06 59       	sh %d9,5
800020c6:	60 b2       	mov.a %a2,%d11
800020c8:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
800020cc:	19 23 04 01 	ld.w %d3,[%a2]4100
800020d0:	8f f3 0f 31 	and %d3,%d3,255
        {
            /* set next message object(MOSTAT.PNEXT) of the current object as the next txFIFO slave object */
            msgObj->fifoPointer = IfxMultican_MsgObj_getBottomObjectPointer(hwObj);
800020d4:	59 c3 0c 00 	st.w [%a12]12,%d3
        else
        {}
    }

    return status;
}
800020d8:	00 90       	ret 
        objId = msgObj->msgObjId;
800020da:	19 49 04 00 	ld.w %d9,[%a4]4
800020de:	1d ff de ff 	j 8000209a <IfxMultican_Can_MsgObj_readMessage+0x12>

800020e2 <IfxMultican_Can_MsgObj_sendMessage>:


IfxMultican_Status IfxMultican_Can_MsgObj_sendMessage(IfxMultican_Can_MsgObj *msgObj, const IfxMultican_Message *msg)
{
800020e2:	40 ae       	mov.aa %a14,%sp
800020e4:	40 4c       	mov.aa %a12,%a4
800020e6:	80 59       	mov.d %d9,%a5
    IfxMultican_Status   status = IfxMultican_Status_ok;
    IfxMultican_MsgObjId objId;

    if (msgObj->msgObjCount > 1)
800020e8:	b9 42 08 00 	ld.hu %d2,[%a4]8
800020ec:	ff 22 24 80 	jge.u %d2,2,80002134 <IfxMultican_Can_MsgObj_sendMessage+0x52>
        IfxMultican_MsgObj_setStatusFlag(hwBaseObj, IfxMultican_MsgObjStatusFlag_messageValid);
    }
    else
    {
        /* for standard message Objects */
        objId = msgObj->msgObjId;
800020f0:	19 48 04 00 	ld.w %d8,[%a4]4
    }

    Ifx_CAN_MO *hwObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, objId);
800020f4:	d4 c2       	ld.a %a2,[%a12]
800020f6:	54 2a       	ld.w %d10,[%a2]
    return &(mcan->MO[msgObjId]);
800020f8:	1b 08 08 20 	addi %d2,%d8,128
800020fc:	06 52       	sh %d2,5
800020fe:	60 a2       	mov.a %a2,%d10
80002100:	01 22 00 46 	addsc.a %a4,%a2,%d2,0

    if (msgObj->msgObjCount > 1)
80002104:	b9 c2 08 00 	ld.hu %d2,[%a12]8
80002108:	bf 22 26 80 	jlt.u %d2,2,80002154 <IfxMultican_Can_MsgObj_sendMessage+0x72>
    {
        /* send the message */
        status = IfxMultican_MsgObj_writeTxfifo(hwObj, msg);
8000210c:	60 95       	mov.a %a5,%d9
8000210e:	6d ff 7a ff 	call 80002002 <IfxMultican_MsgObj_writeTxfifo>
        /* send the message */
        status = IfxMultican_MsgObj_sendMessage(hwObj, msg);
    }

    /* if successfull: */
    if (status == IfxMultican_Status_ok)
80002112:	df 02 10 80 	jne %d2,0,80002132 <IfxMultican_Can_MsgObj_sendMessage+0x50>
    {
        if (msgObj->msgObjCount > 1)
80002116:	b9 c3 08 00 	ld.hu %d3,[%a12]8
8000211a:	bf 23 0c 80 	jlt.u %d3,2,80002132 <IfxMultican_Can_MsgObj_sendMessage+0x50>
    return (IfxMultican_MsgObjId)(hwObj->FGPR.B.BOT);
8000211e:	06 58       	sh %d8,5
80002120:	60 a2       	mov.a %a2,%d10
80002122:	01 28 00 26 	addsc.a %a2,%a2,%d8,0
80002126:	19 23 04 01 	ld.w %d3,[%a2]4100
8000212a:	8f f3 0f 31 	and %d3,%d3,255
        {
            /* set next message object(MOSTAT.PNEXT) of the current object as the next txFIFO slave object */
            msgObj->fifoPointer = IfxMultican_MsgObj_getBottomObjectPointer(hwObj);
8000212e:	59 c3 0c 00 	st.w [%a12]12,%d3
        else
        {}
    }

    return status;
}
80002132:	00 90       	ret 
        objId = msgObj->fifoPointer;
80002134:	19 48 0c 00 	ld.w %d8,[%a4]12
        Ifx_CAN_MO *hwBaseObj = IfxMultican_MsgObj_getPointer(msgObj->node->mcan, msgObj->msgObjId);
80002138:	d4 42       	ld.a %a2,[%a4]
8000213a:	d4 24       	ld.a %a4,[%a2]
    return &(mcan->MO[msgObjId]);
8000213c:	19 c2 04 00 	ld.w %d2,[%a12]4
80002140:	1b 02 08 20 	addi %d2,%d2,128
80002144:	06 52       	sh %d2,5
        IfxMultican_MsgObj_setStatusFlag(hwBaseObj, IfxMultican_MsgObjStatusFlag_messageValid);
80002146:	82 54       	mov %d4,5
80002148:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
8000214c:	6d ff 15 ff 	call 80001f76 <IfxMultican_MsgObj_setStatusFlag>
80002150:	1d ff d2 ff 	j 800020f4 <IfxMultican_Can_MsgObj_sendMessage+0x12>
        status = IfxMultican_MsgObj_sendMessage(hwObj, msg);
80002154:	60 95       	mov.a %a5,%d9
80002156:	6d ff 19 ff 	call 80001f88 <IfxMultican_MsgObj_sendMessage>
8000215a:	1d ff dc ff 	j 80002112 <IfxMultican_Can_MsgObj_sendMessage+0x30>

8000215e <IfxCpu_Trap_memoryManagementError>:
{
8000215e:	40 ae       	mov.aa %a14,%sp
80002160:	20 08       	sub.a %sp,8
}

IFX_INLINE void* Ifx__getA11(void)
{
    uint32 *res;
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80002162:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80002164:	8f f4 0f 41 	and %d4,%d4,255
    reg.U = __mfcr(CPU_CORE_ID);
80002168:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000216c:	8f 72 00 21 	and %d2,%d2,7
80002170:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80002174:	80 22       	mov.d %d2,%a2
80002176:	0f 54 a0 30 	or %d3,%d4,%d5
8000217a:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_MME_HOOK(trapWatch);
8000217e:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80002182:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80002184:	0d 00 40 02 	rslcx 
    __asm("rfe");
80002188:	00 80       	rfe 
}
8000218a:	00 90       	ret 

8000218c <IfxCpu_Trap_internalProtectionError>:
{
8000218c:	40 ae       	mov.aa %a14,%sp
8000218e:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80002190:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80002192:	b7 14 18 44 	insert %d4,%d4,1,8,24
80002196:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000219a:	8f 72 00 21 	and %d2,%d2,7
8000219e:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
800021a2:	80 22       	mov.d %d2,%a2
800021a4:	0f 54 a0 30 	or %d3,%d4,%d5
800021a8:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IPE_HOOK(trapWatch);
800021ac:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
800021b0:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
800021b2:	0d 00 40 02 	rslcx 
    __asm("rfe");
800021b6:	00 80       	rfe 
}
800021b8:	00 90       	ret 

800021ba <IfxCpu_Trap_instructionError>:
{
800021ba:	40 ae       	mov.aa %a14,%sp
800021bc:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
800021be:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
800021c0:	b7 24 18 44 	insert %d4,%d4,2,8,24
800021c4:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
800021c8:	8f 72 00 21 	and %d2,%d2,7
800021cc:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
800021d0:	80 22       	mov.d %d2,%a2
800021d2:	0f 54 a0 30 	or %d3,%d4,%d5
800021d6:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IE_HOOK(trapWatch);
800021da:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
800021de:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
800021e0:	0d 00 40 02 	rslcx 
    __asm("rfe");
800021e4:	00 80       	rfe 
}
800021e6:	00 90       	ret 

800021e8 <IfxCpu_Trap_contextManagementError>:
{
800021e8:	40 ae       	mov.aa %a14,%sp
800021ea:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
800021ec:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
800021ee:	b7 34 18 44 	insert %d4,%d4,3,8,24
800021f2:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
800021f6:	8f 72 00 21 	and %d2,%d2,7
800021fa:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
800021fe:	80 22       	mov.d %d2,%a2
80002200:	0f 54 a0 30 	or %d3,%d4,%d5
80002204:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_CME_HOOK(trapWatch);
80002208:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
8000220c:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000220e:	0d 00 40 02 	rslcx 
    __asm("rfe");
80002212:	00 80       	rfe 
}
80002214:	00 90       	ret 

80002216 <IfxCpu_Trap_busError>:
{
80002216:	40 ae       	mov.aa %a14,%sp
80002218:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000221a:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
8000221c:	b7 44 18 44 	insert %d4,%d4,4,8,24
80002220:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80002224:	8f 72 00 21 	and %d2,%d2,7
80002228:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
8000222c:	80 22       	mov.d %d2,%a2
8000222e:	0f 54 a0 30 	or %d3,%d4,%d5
80002232:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_BE_HOOK(trapWatch);
80002236:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
8000223a:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000223c:	0d 00 40 02 	rslcx 
    __asm("rfe");
80002240:	00 80       	rfe 
}
80002242:	00 90       	ret 

80002244 <IfxCpu_Trap_assertion>:
{
80002244:	40 ae       	mov.aa %a14,%sp
80002246:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80002248:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
8000224a:	8f f4 0f 41 	and %d4,%d4,255
8000224e:	3b 00 50 20 	mov %d2,1280
80002252:	a6 24       	or %d4,%d2
80002254:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80002258:	8f 72 00 21 	and %d2,%d2,7
8000225c:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80002260:	80 22       	mov.d %d2,%a2
80002262:	0f 54 a0 30 	or %d3,%d4,%d5
80002266:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_ASSERT_HOOK(trapWatch);
8000226a:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
8000226e:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80002270:	0d 00 40 02 	rslcx 
    __asm("rfe");
80002274:	00 80       	rfe 
}
80002276:	00 90       	ret 

80002278 <IfxCpu_Trap_systemCall_Cpu0>:
{
80002278:	40 ae       	mov.aa %a14,%sp
8000227a:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
8000227c:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
8000227e:	b7 64 18 44 	insert %d4,%d4,6,8,24
80002282:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80002286:	8f 72 00 21 	and %d2,%d2,7
8000228a:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
8000228e:	80 22       	mov.d %d2,%a2
80002290:	0f 54 a0 30 	or %d3,%d4,%d5
80002294:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU0_HOOK(trapWatch);
80002298:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
8000229c:	0d 00 40 02 	rslcx 
    __asm("rfe");
800022a0:	00 80       	rfe 
}
800022a2:	00 90       	ret 

800022a4 <IfxCpu_Trap_systemCall_Cpu1>:
{
800022a4:	40 ae       	mov.aa %a14,%sp
800022a6:	20 08       	sub.a %sp,8
800022a8:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
800022aa:	b7 64 18 44 	insert %d4,%d4,6,8,24
800022ae:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
800022b2:	8f 72 00 21 	and %d2,%d2,7
800022b6:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
800022ba:	80 22       	mov.d %d2,%a2
800022bc:	0f 54 a0 30 	or %d3,%d4,%d5
800022c0:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU1_HOOK(trapWatch);
800022c4:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
800022c8:	0d 00 40 02 	rslcx 
    __asm("rfe");
800022cc:	00 80       	rfe 
}
800022ce:	00 90       	ret 

800022d0 <IfxCpu_Trap_systemCall_Cpu2>:
{
800022d0:	40 ae       	mov.aa %a14,%sp
800022d2:	20 08       	sub.a %sp,8
800022d4:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
800022d6:	b7 64 18 44 	insert %d4,%d4,6,8,24
800022da:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
800022de:	8f 72 00 21 	and %d2,%d2,7
800022e2:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
800022e6:	80 22       	mov.d %d2,%a2
800022e8:	0f 54 a0 30 	or %d3,%d4,%d5
800022ec:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU2_HOOK(trapWatch);
800022f0:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
800022f4:	0d 00 40 02 	rslcx 
    __asm("rfe");
800022f8:	00 80       	rfe 
}
800022fa:	00 90       	ret 

800022fc <IfxCpu_Trap_nonMaskableInterrupt>:
{
800022fc:	40 ae       	mov.aa %a14,%sp
800022fe:	20 08       	sub.a %sp,8
80002300:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80002302:	b7 74 18 44 	insert %d4,%d4,7,8,24
80002306:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
8000230a:	8f 72 00 21 	and %d2,%d2,7
8000230e:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80002312:	80 22       	mov.d %d2,%a2
80002314:	0f 54 a0 30 	or %d3,%d4,%d5
80002318:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_NMI_HOOK(trapWatch);    
8000231c:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80002320:	0d 00 40 02 	rslcx 
    __asm("rfe");
80002324:	00 80       	rfe 
}
80002326:	00 90       	ret 

80002328 <IfxCpu_getIndex>:
    return cpuMode;
}


IfxCpu_ResourceCpu IfxCpu_getIndex(Ifx_CPU *cpu)
{
80002328:	40 ae       	mov.aa %a14,%sp
    IfxCpu_ResourceCpu result;
    uint32             index;
    result = IfxCpu_ResourceCpu_none;

    for (index = 0; index < IFXCPU_NUM_MODULES; index++)
8000232a:	82 02       	mov %d2,0
8000232c:	1d 00 03 00 	j 80002332 <IfxCpu_getIndex+0xa>
80002330:	c2 12       	add %d2,1
80002332:	ff 32 18 80 	jge.u %d2,3,80002362 <IfxCpu_getIndex+0x3a>
    {
        if (IfxCpu_cfg_indexMap[index].module == cpu)
80002336:	8f 32 00 30 	sh %d3,%d2,3
8000233a:	91 00 00 28 	movh.a %a2,32768
8000233e:	d9 22 14 80 	lea %a2,[%a2]532 <80000214 <IfxCpu_cfg_indexMap>>
80002342:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80002346:	54 23       	ld.w %d3,[%a2]
80002348:	80 44       	mov.d %d4,%a4
8000234a:	5f 43 f3 ff 	jne %d3,%d4,80002330 <IfxCpu_getIndex+0x8>
        {
            result = (IfxCpu_ResourceCpu)IfxCpu_cfg_indexMap[index].index;
8000234e:	06 32       	sh %d2,3
80002350:	91 00 00 28 	movh.a %a2,32768
80002354:	d9 22 14 80 	lea %a2,[%a2]532 <80000214 <IfxCpu_cfg_indexMap>>
80002358:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000235c:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80002360:	00 90       	ret 
    result = IfxCpu_ResourceCpu_none;
80002362:	82 32       	mov %d2,3
        }
    }

    return result;
}
80002364:	00 90       	ret 

80002366 <IfxCpu_getCoreMode>:
{
80002366:	40 ae       	mov.aa %a14,%sp
80002368:	80 48       	mov.d %d8,%a4
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
8000236a:	6d ff df ff 	call 80002328 <IfxCpu_getIndex>


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
8000236e:	4d c0 e1 3f 	mfcr %d3,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002372:	8f 73 00 31 	and %d3,%d3,7
    if (IfxCpu_getCoreIndex() != index)
80002376:	5f 32 22 00 	jeq %d2,%d3,800023ba <IfxCpu_getCoreMode+0x54>
        dbgsr = cpu->DBGSR;
8000237a:	bb 00 d0 3f 	mov.u %d3,64768
8000237e:	60 82       	mov.a %a2,%d8
80002380:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80002384:	54 23       	ld.w %d3,[%a2]
    if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_halt)
80002386:	37 03 e2 40 	extr.u %d4,%d3,1,2
8000238a:	df 14 1c 00 	jeq %d4,1,800023c2 <IfxCpu_getCoreMode+0x5c>
        if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_run)
8000238e:	df 04 1c 80 	jne %d4,0,800023c6 <IfxCpu_getCoreMode+0x60>
            pmcsr_val = &MODULE_SCU.PMCSR[index];
80002392:	06 22       	sh %d2,2
80002394:	7b 30 00 3f 	movh %d3,61443
80002398:	1b 43 0d 36 	addi %d3,%d3,24788
8000239c:	60 32       	mov.a %a2,%d3
8000239e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
            if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
800023a2:	54 22       	ld.w %d2,[%a2]
800023a4:	37 02 63 24 	extr.u %d2,%d2,8,3
800023a8:	df 12 11 00 	jeq %d2,1,800023ca <IfxCpu_getCoreMode+0x64>
                if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
800023ac:	54 22       	ld.w %d2,[%a2]
800023ae:	37 02 63 24 	extr.u %d2,%d2,8,3
800023b2:	df 32 0e 00 	jeq %d2,3,800023ce <IfxCpu_getCoreMode+0x68>
    cpuMode = IfxCpu_CoreMode_unknown;
800023b6:	82 52       	mov %d2,5
800023b8:	00 90       	ret 
        dbgsr.U = __mfcr(CPU_DBGSR);
800023ba:	4d 00 d0 3f 	mfcr %d3,$dbgsr
800023be:	1d ff e4 ff 	j 80002386 <IfxCpu_getCoreMode+0x20>
        cpuMode = IfxCpu_CoreMode_halt;
800023c2:	82 02       	mov %d2,0
800023c4:	00 90       	ret 
            cpuMode = IfxCpu_CoreMode_unknown;
800023c6:	82 52       	mov %d2,5
800023c8:	00 90       	ret 
                cpuMode = IfxCpu_CoreMode_run;
800023ca:	82 12       	mov %d2,1
800023cc:	00 90       	ret 
                    cpuMode = IfxCpu_CoreMode_idle;
800023ce:	82 22       	mov %d2,2
}
800023d0:	00 90       	ret 

800023d2 <IfxCpu_setCoreMode>:
    *lock = 0;
}


boolean IfxCpu_setCoreMode(Ifx_CPU *cpu, IfxCpu_CoreMode mode)
{
800023d2:	40 ae       	mov.aa %a14,%sp
800023d4:	80 4c       	mov.d %d12,%a4
800023d6:	02 48       	mov %d8,%d4
    uint8              reqslp;
    boolean            retValue;
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
800023d8:	6d ff a8 ff 	call 80002328 <IfxCpu_getIndex>
800023dc:	02 2a       	mov %d10,%d2

    /*Modes such as HALT, SLEEP and STBY are not handled at CPU level */
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
800023de:	8b 08 20 42 	ne %d4,%d8,0
800023e2:	8b 38 20 32 	ne %d3,%d8,3
800023e6:	26 43       	and %d3,%d4
                || (mode == IfxCpu_CoreMode_stby)) ? FALSE : TRUE;
800023e8:	df 03 0a 00 	jeq %d3,0,800023fc <IfxCpu_setCoreMode+0x2a>
800023ec:	df 48 05 00 	jeq %d8,4,800023f6 <IfxCpu_setCoreMode+0x24>
800023f0:	82 19       	mov %d9,1
800023f2:	1d 00 06 00 	j 800023fe <IfxCpu_setCoreMode+0x2c>
800023f6:	82 09       	mov %d9,0
800023f8:	1d 00 03 00 	j 800023fe <IfxCpu_setCoreMode+0x2c>
800023fc:	82 09       	mov %d9,0
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
800023fe:	8f f9 0f 91 	and %d9,%d9,255

    reqslp = (mode == IfxCpu_CoreMode_idle) ? IfxScu_PMCSR_REQSLP_Idle : IfxScu_PMCSR_REQSLP_Run;
80002402:	8b 28 00 82 	eq %d8,%d8,2

    if (retValue == TRUE)
80002406:	df 09 04 80 	jne %d9,0,8000240e <IfxCpu_setCoreMode+0x3c>
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
        }
    }

    return retValue;
}
8000240a:	02 92       	mov %d2,%d9
8000240c:	00 90       	ret 
    reg.U = __mfcr(CPU_CORE_ID);
8000240e:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002412:	8f 72 00 21 	and %d2,%d2,7
        if (IfxCpu_getCoreIndex() != index)
80002416:	5f 2a 24 00 	jeq %d10,%d2,8000245e <IfxCpu_setCoreMode+0x8c>
            uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
8000241a:	6d ff bf fc 	call 80001d98 <IfxScuWdt_getSafetyWatchdogPassword>
8000241e:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
80002420:	02 24       	mov %d4,%d2
80002422:	6d ff 65 fb 	call 80001aec <IfxScuWdt_clearSafetyEndinit>
            MODULE_SCU.PMCSR[(uint32)IfxCpu_getIndex(cpu)].B.REQSLP = reqslp;
80002426:	1b 5a 03 20 	addi %d2,%d10,53
8000242a:	06 22       	sh %d2,2
8000242c:	7b 30 00 3f 	movh %d3,61443
80002430:	1b 03 00 36 	addi %d3,%d3,24576
80002434:	60 32       	mov.a %a2,%d3
80002436:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000243a:	54 23       	ld.w %d3,[%a2]
8000243c:	37 83 02 30 	insert %d3,%d3,%d8,0,2
80002440:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setSafetyEndinit(safetyWdtPw);
80002442:	02 b4       	mov %d4,%d11
80002444:	6d ff da fc 	call 80001df8 <IfxScuWdt_setSafetyEndinit>
            cpu->DBGSR.B.HALT = 2; /*reset the HALT bit, if it is already done it is no harm in writing again */
80002448:	bb 00 d0 2f 	mov.u %d2,64768
8000244c:	60 c2       	mov.a %a2,%d12
8000244e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80002452:	54 22       	ld.w %d2,[%a2]
80002454:	b7 22 82 20 	insert %d2,%d2,2,1,2
80002458:	74 22       	st.w [%a2],%d2
8000245a:	1d ff d8 ff 	j 8000240a <IfxCpu_setCoreMode+0x38>
            uint16 cpuWdtPw = IfxScuWdt_getCpuWatchdogPassword();
8000245e:	6d ff 8b fc 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
80002462:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearCpuEndinit(cpuWdtPw);
80002464:	02 24       	mov %d4,%d2
80002466:	6d ff 1e fb 	call 80001aa2 <IfxScuWdt_clearCpuEndinit>
            MODULE_SCU.PMCSR[(uint32)index].B.REQSLP = reqslp;
8000246a:	1b 5a 03 20 	addi %d2,%d10,53
8000246e:	06 22       	sh %d2,2
80002470:	7b 30 00 3f 	movh %d3,61443
80002474:	1b 03 00 36 	addi %d3,%d3,24576
80002478:	60 32       	mov.a %a2,%d3
8000247a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000247e:	54 23       	ld.w %d3,[%a2]
80002480:	37 83 02 30 	insert %d3,%d3,%d8,0,2
80002484:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
80002486:	02 b4       	mov %d4,%d11
80002488:	6d ff 93 fc 	call 80001dae <IfxScuWdt_setCpuEndinit>
8000248c:	1d ff bf ff 	j 8000240a <IfxCpu_setCoreMode+0x38>

80002490 <IfxCpu_setProgramCounter>:


boolean IfxCpu_setProgramCounter(Ifx_CPU *cpu, uint32 programCounter)
{
80002490:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80002492:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002496:	8f 72 00 21 	and %d2,%d2,7
    if (cpu < IfxCpu_ResourceCpu_none)
8000249a:	ff 32 17 80 	jge.u %d2,3,800024c8 <IfxCpu_setProgramCounter+0x38>
        module = (Ifx_CPU *)IfxCpu_cfg_indexMap[cpu].module;
8000249e:	06 32       	sh %d2,3
800024a0:	91 00 00 28 	movh.a %a2,32768
800024a4:	d9 22 14 80 	lea %a2,[%a2]532 <80000214 <IfxCpu_cfg_indexMap>>
800024a8:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800024ac:	54 22       	ld.w %d2,[%a2]
    boolean retVal = TRUE;

    if (cpu == IfxCpu_getAddress(IfxCpu_getCoreIndex()))
800024ae:	80 43       	mov.d %d3,%a4
800024b0:	5f 23 0f 00 	jeq %d3,%d2,800024ce <IfxCpu_setProgramCounter+0x3e>
    {
        retVal = FALSE;
    }
    else
    {
        cpu->PC.B.PC = programCounter >> 1;
800024b4:	bb 80 e0 2f 	mov.u %d2,65032
800024b8:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
800024bc:	54 42       	ld.w %d2,[%a4]
800024be:	37 24 01 20 	insert %d2,%d4,%d2,0,1
800024c2:	74 42       	st.w [%a4],%d2
    boolean retVal = TRUE;
800024c4:	82 12       	mov %d2,1
800024c6:	00 90       	ret 
        module = NULL_PTR;
800024c8:	82 02       	mov %d2,0
800024ca:	1d ff f2 ff 	j 800024ae <IfxCpu_setProgramCounter+0x1e>
        retVal = FALSE;
800024ce:	82 02       	mov %d2,0
    }

    return retVal;
}
800024d0:	00 90       	ret 

800024d2 <IfxCpu_startCore>:
    return retVal;
}


boolean IfxCpu_startCore(Ifx_CPU *cpu, uint32 programCounter)
{
800024d2:	40 ae       	mov.aa %a14,%sp
800024d4:	80 49       	mov.d %d9,%a4
    boolean retVal = TRUE;

    /* Set the PC for Core 1 */
    retVal &= IfxCpu_setProgramCounter(cpu, programCounter);
800024d6:	6d ff dd ff 	call 80002490 <IfxCpu_setProgramCounter>
800024da:	8f 12 00 81 	and %d8,%d2,1
    /* Get the mode for Core 1 and set it to RUNNING */

    /* Core not running already */
    if (IfxCpu_getCoreMode(cpu) == IfxCpu_CoreMode_halt)
800024de:	60 94       	mov.a %a4,%d9
800024e0:	6d ff 43 ff 	call 80002366 <IfxCpu_getCoreMode>
800024e4:	df 02 04 00 	jeq %d2,0,800024ec <IfxCpu_startCore+0x1a>
    {
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
    }

    return retVal;
}
800024e8:	02 82       	mov %d2,%d8
800024ea:	00 90       	ret 
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
800024ec:	82 14       	mov %d4,1
800024ee:	60 94       	mov.a %a4,%d9
800024f0:	6d ff 71 ff 	call 800023d2 <IfxCpu_setCoreMode>
800024f4:	26 28       	and %d8,%d2
800024f6:	1d ff f9 ff 	j 800024e8 <IfxCpu_startCore+0x16>

800024fa <IfxCpu_waitEvent>:


boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec)
{
800024fa:	40 ae       	mov.aa %a14,%sp
800024fc:	40 4c       	mov.aa %a12,%a4
800024fe:	02 48       	mov %d8,%d4
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80002500:	80 42       	mov.d %d2,%a4
80002502:	b7 02 1c 20 	insert %d2,%d2,0,0,28
80002506:	7b 00 00 3d 	movh %d3,53248
8000250a:	5f 32 28 00 	jeq %d2,%d3,8000255a <IfxCpu_waitEvent+0x60>
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
8000250e:	6d ff b0 f8 	call 8000166e <IfxScuCcu_getSourceFrequency>
80002512:	91 30 00 2f 	movh.a %a2,61443
80002516:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000251a:	54 23       	ld.w %d3,[%a2]
8000251c:	37 03 64 34 	extr.u %d3,%d3,8,4
80002520:	4b 03 41 31 	itof %d3,%d3
80002524:	4b 32 51 20 	div.f %d2,%d2,%d3

    boolean          errorcnt      = 0U;
    /* Divide with 1000, gives the count value equivalent to milliseconds */
    uint32           stmCount      = (uint32)((IfxScuCcu_getStmFrequency() / 1000) * timeoutMilliSec);
80002528:	7b a0 47 34 	movh %d3,17530
8000252c:	4b 32 51 20 	div.f %d2,%d2,%d3
80002530:	4b 08 61 41 	utof %d4,%d8
80002534:	4b 24 41 40 	mul.f %d4,%d4,%d2
80002538:	4b 04 71 31 	ftouz %d3,%d4
    uint32           stmCountBegin = STM0_TIM0.U;
8000253c:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((*sync & IFXCPU_CFG_ALLCORE_DONE) != IFXCPU_CFG_ALLCORE_DONE)
80002540:	54 c2       	ld.w %d2,[%a12]
80002542:	8f 72 00 21 	and %d2,%d2,7
80002546:	df 72 18 00 	jeq %d2,7,80002576 <IfxCpu_waitEvent+0x7c>
    __asm__ volatile ("nop" : : : "memory");
8000254a:	00 00       	nop 
    {
        __nop();

        if ((uint32)(STM0_TIM0.U - stmCountBegin) >= stmCount)
8000254c:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
80002550:	a2 42       	sub %d2,%d4
80002552:	3f 32 f7 ff 	jlt.u %d2,%d3,80002540 <IfxCpu_waitEvent+0x46>
        {
            errorcnt = 1;
80002556:	82 12       	mov %d2,1
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

    return errorcnt;
}
80002558:	00 90       	ret 
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
8000255a:	80 42       	mov.d %d2,%a4
8000255c:	b7 02 0c 3a 	insert %d3,%d2,0,20,12
80002560:	b7 f3 03 3e 	insert %d3,%d3,15,28,3
80002564:	4d c0 e1 2f 	mfcr %d2,$core_id
80002568:	8f c2 01 20 	sh %d2,%d2,28
8000256c:	0b 23 80 20 	sub %d2,%d3,%d2
80002570:	60 2c       	mov.a %a12,%d2
80002572:	1d ff ce ff 	j 8000250e <IfxCpu_waitEvent+0x14>
    boolean          errorcnt      = 0U;
80002576:	82 02       	mov %d2,0
80002578:	00 90       	ret 

8000257a <IfxCpu_emitEvent>:


void IfxCpu_emitEvent(IfxCpu_syncEvent *event)
{
8000257a:	40 ae       	mov.aa %a14,%sp
    Ifx__imaskldmst(event, 1, __mfcr(CPU_CORE_ID), 1);
8000257c:	4d c0 e1 2f 	mfcr %d2,$core_id
80002580:	82 13       	mov %d3,1
80002582:	57 30 21 22 	imask %e2,%d3,%d2,1
80002586:	49 42 40 08 	ldmst [%a4]0,%e2
}
8000258a:	00 90       	ret 

8000258c <Ifx_Cpp_Init>:
#pragma section
#elif defined(__DCC__)
#pragma section CONST
#endif
static void Ifx_Cpp_Init(void)
{
8000258c:	40 ae       	mov.aa %a14,%sp
    Ifx_C_Init();           /*Initialization of C runtime variables */
8000258e:	6d 00 1f 04 	call 80002dcc <Ifx_C_Init>
#elif defined (__HIGHTEC__)
extern void _init(void); /* cpp initialization */
    _init();
#elif defined (__GNUC__) && !defined(__HIGHTEC__)
    extern void _init(void); /* cpp initialization */
    _init();
80002592:	6d 00 cb 08 	call 80003728 <_init>
#endif
}
80002596:	00 90       	ret 

80002598 <hardware_init_hook>:
{}
80002598:	00 90       	ret 

8000259a <software_init_hook>:
{}
8000259a:	00 90       	ret 

8000259c <_Core0_start>:
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
8000259c:	91 30 00 2f 	movh.a %a2,61443
800025a0:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
    __setareg(sp, __USTACK(0));
800025a4:	91 20 00 37 	movh.a %a3,28674
800025a8:	37 02 6e 21 	extr.u %d2,%d2,2,14
800025ac:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800025b0:	8f f2 83 81 	xor %d8,%d2,63
800025b4:	80 32       	mov.d %d2,%a3
800025b6:	1b 02 60 29 	addi %d2,%d2,-27136
800025ba:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
800025bc:	0d 00 80 04 	dsync 
    __mtcr(CPU_PSW, IFXCSTART0_PSW_DEFAULT);
800025c0:	3b 00 98 20 	mov %d2,2432
800025c4:	cd 42 e0 0f 	mtcr $psw,%d2
    pcxi  = __mfcr(CPU_PCXI);
800025c8:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART0_PCX_O_S_DEFAULT; /*0xfff00000; */
800025cc:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
800025d0:	cd 02 e0 0f 	mtcr $pcxi,%d2
    if (enable)
    {                           /* Step 3: Initiate invalidation of current cache contents if any */
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = 0;
        pcon1.B.PCINV = 1;
        __mtcr(CPU_PCON1, pcon1.U);
800025d4:	82 12       	mov %d2,1
800025d6:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
800025da:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800025de:	8f 72 00 21 	and %d2,%d2,7
    }

    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800025e2:	01 22 03 26 	addsc.a %a2,%a2,%d2,3
800025e6:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
800025ea:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
800025ec:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
800025ee:	37 02 6e 21 	extr.u %d2,%d2,2,14
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
800025f2:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800025f6:	6f 13 41 81 	jnz.t %d3,1,80002878 <_Core0_start+0x2dc>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800025fa:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800025fe:	54 22       	ld.w %d2,[%a2]
80002600:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002604:	a6 32       	or %d2,%d3
80002606:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000260a:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000260c:	54 22       	ld.w %d2,[%a2]
8000260e:	6f 02 ff ff 	jnz.t %d2,0,8000260c <_Core0_start+0x70>
        Ifx_CPU_PCON0 pcon0;
        pcon0.U       = 0;
        pcon0.B.PCBYP = enable ? 0 : 1; /*depending on the enable bypass bit is reset/set */
        __mtcr(CPU_PCON0, pcon0.U);
80002612:	82 02       	mov %d2,0
80002614:	cd c2 20 09 	mtcr $pcon0,%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80002618:	54 22       	ld.w %d2,[%a2]
8000261a:	6f 12 09 00 	jz.t %d2,1,8000262c <_Core0_start+0x90>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000261e:	54 22       	ld.w %d2,[%a2]
80002620:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002624:	a6 32       	or %d2,%d3
80002626:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000262a:	74 22       	st.w [%a2],%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000262c:	54 22       	ld.w %d2,[%a2]
8000262e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002632:	a6 32       	or %d2,%d3
80002634:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002638:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000263a:	54 22       	ld.w %d2,[%a2]
8000263c:	6f 02 ff 7f 	jz.t %d2,0,8000263a <_Core0_start+0x9e>
    __asm__ volatile ("isync" : : : "memory");
80002640:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80002644:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002648:	7b 30 00 3f 	movh %d3,61443
8000264c:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002650:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002654:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002658:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
8000265a:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000265c:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000265e:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80002662:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80002666:	6f 13 fd 80 	jnz.t %d3,1,80002860 <_Core0_start+0x2c4>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000266a:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000266e:	54 22       	ld.w %d2,[%a2]
80002670:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002674:	a6 32       	or %d2,%d3
80002676:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000267a:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000267c:	54 22       	ld.w %d2,[%a2]
8000267e:	6f 02 ff ff 	jnz.t %d2,0,8000267c <_Core0_start+0xe0>
        __mtcr(CPU_DCON0, dcon0.U);
80002682:	82 22       	mov %d2,2
80002684:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80002688:	54 22       	ld.w %d2,[%a2]
8000268a:	6f 12 09 00 	jz.t %d2,1,8000269c <_Core0_start+0x100>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000268e:	54 22       	ld.w %d2,[%a2]
80002690:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002694:	a6 32       	or %d2,%d3
80002696:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000269a:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000269c:	54 22       	ld.w %d2,[%a2]
8000269e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800026a2:	a6 32       	or %d2,%d3
800026a4:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800026a8:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
800026aa:	54 22       	ld.w %d2,[%a2]
800026ac:	6f 02 ff 7f 	jz.t %d2,0,800026aa <_Core0_start+0x10e>
800026b0:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
800026b4:	91 30 00 2f 	movh.a %a2,61443
800026b8:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800026bc:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800026c0:	8f 28 00 30 	sh %d3,%d8,2
    if (watchdog->CON0.B.LCK)
800026c4:	6f 12 09 00 	jz.t %d2,1,800026d6 <_Core0_start+0x13a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800026c8:	54 22       	ld.w %d2,[%a2]
800026ca:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800026ce:	a6 32       	or %d2,%d3
800026d0:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800026d4:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800026d6:	91 30 00 2f 	movh.a %a2,61443
800026da:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800026de:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800026e2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800026e6:	a6 32       	or %d2,%d3
800026e8:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800026ec:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800026ee:	54 22       	ld.w %d2,[%a2]
800026f0:	6f 02 ff ff 	jnz.t %d2,0,800026ee <_Core0_start+0x152>
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(0));
800026f4:	91 00 00 38 	movh.a %a3,32768
800026f8:	80 32       	mov.d %d2,%a3
800026fa:	1b 02 10 20 	addi %d2,%d2,256
800026fe:	cd 42 e2 0f 	mtcr $btv,%d2
    __mtcr(CPU_BIV, (uint32)__INTTAB(0));
80002702:	91 f0 01 38 	movh.a %a3,32799
80002706:	80 32       	mov.d %d2,%a3
80002708:	1b 02 00 24 	addi %d2,%d2,16384
8000270c:	cd 02 e2 0f 	mtcr $biv,%d2
    __mtcr(CPU_ISP, (uint32)__ISTACK(0));
80002710:	91 20 00 37 	movh.a %a3,28674
80002714:	80 32       	mov.d %d2,%a3
80002716:	1b 02 b0 29 	addi %d2,%d2,-25856
8000271a:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
8000271e:	54 22       	ld.w %d2,[%a2]
80002720:	6f 12 09 00 	jz.t %d2,1,80002732 <_Core0_start+0x196>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002724:	54 22       	ld.w %d2,[%a2]
80002726:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000272a:	a6 32       	or %d2,%d3
8000272c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002730:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002732:	91 30 00 2f 	movh.a %a2,61443
80002736:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
8000273a:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
8000273e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002742:	a6 32       	or %d2,%d3
80002744:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002748:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
8000274a:	54 22       	ld.w %d2,[%a2]
8000274c:	6f 02 ff 7f 	jz.t %d2,0,8000274a <_Core0_start+0x1ae>
    __setareg(a0, __SDATA1(0));
80002750:	91 10 00 26 	movh.a %a2,24577
80002754:	80 22       	mov.d %d2,%a2
80002756:	1b 02 00 28 	addi %d2,%d2,-32768
8000275a:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(0));
8000275c:	91 10 00 28 	movh.a %a2,32769
80002760:	80 22       	mov.d %d2,%a2
80002762:	1b 02 00 28 	addi %d2,%d2,-32768
80002766:	60 21       	mov.a %a1,%d2
    __setareg(a8, __SDATA3(0));
80002768:	91 10 00 28 	movh.a %a2,32769
8000276c:	80 22       	mov.d %d2,%a2
8000276e:	1b 02 00 28 	addi %d2,%d2,-32768
80002772:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(0));
80002774:	91 10 00 29 	movh.a %a2,36865
80002778:	80 22       	mov.d %d2,%a2
8000277a:	1b 02 00 28 	addi %d2,%d2,-32768
8000277e:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
80002780:	91 20 00 37 	movh.a %a3,28674
80002784:	91 20 00 27 	movh.a %a2,28674
80002788:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70019c00 <__CSA0>>
8000278c:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7001bc00 <__CSA0_END>>
80002790:	01 32 20 20 	sub.a %a2,%a2,%a3
80002794:	80 22       	mov.d %d2,%a2
80002796:	8f a2 1f 70 	sh %d7,%d2,-6
    uint32 *prvCsa      = csaBegin;
8000279a:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
8000279c:	1b d7 ff 0f 	addi %d0,%d7,-3
    for (k = 0U; k < numOfCsa; k++)
800027a0:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
800027a2:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800027a4:	7b f0 00 40 	movh %d4,15
    for (k = 0U; k < numOfCsa; k++)
800027a8:	df 07 27 00 	jeq %d7,0,800027f6 <_Core0_start+0x25a>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800027ac:	37 02 70 53 	extr.u %d5,%d2,6,16
800027b0:	8f 42 1f 60 	sh %d6,%d2,-12
800027b4:	26 46       	and %d6,%d4
800027b6:	a6 65       	or %d5,%d6
        if (k == 0U)
800027b8:	df 03 16 00 	jeq %d3,0,800027e4 <_Core0_start+0x248>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
800027bc:	74 25       	st.w [%a2],%d5
        if (k == (numOfCsa - 3U))
800027be:	5f 03 04 80 	jne %d3,%d0,800027c6 <_Core0_start+0x22a>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800027c2:	cd c5 e3 0f 	mtcr $lcx,%d5
    for (k = 0U; k < numOfCsa; k++)
800027c6:	c2 13       	add %d3,1
800027c8:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
800027ca:	1b 02 04 50 	addi %d5,%d2,64
    for (k = 0U; k < numOfCsa; k++)
800027ce:	5f 37 0f 00 	jeq %d7,%d3,800027ec <_Core0_start+0x250>
        nxtCsa += 16U;           /* next CSA */
800027d2:	02 52       	mov %d2,%d5
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800027d4:	37 02 70 53 	extr.u %d5,%d2,6,16
800027d8:	8f 42 1f 60 	sh %d6,%d2,-12
800027dc:	26 46       	and %d6,%d4
800027de:	a6 65       	or %d5,%d6
        if (k == 0U)
800027e0:	df 03 ee ff 	jne %d3,0,800027bc <_Core0_start+0x220>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
800027e4:	cd 85 e3 0f 	mtcr $fcx,%d5
800027e8:	1d ff eb ff 	j 800027be <_Core0_start+0x222>
800027ec:	1b f7 ff 2f 	addi %d2,%d7,-1
800027f0:	06 62       	sh %d2,6
800027f2:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
800027f6:	82 02       	mov %d2,0
800027f8:	74 22       	st.w [%a2],%d2
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
800027fa:	6d ff cf fa 	call 80001d98 <IfxScuWdt_getSafetyWatchdogPassword>
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
800027fe:	02 84       	mov %d4,%d8
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
80002800:	02 29       	mov %d9,%d2
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
80002802:	6d ff 9d f9 	call 80001b3c <IfxScuWdt_disableCpuWatchdog>
        IfxScuWdt_disableSafetyWatchdog(safetyWdtPassword);
80002806:	02 94       	mov %d4,%d9
80002808:	6d ff d9 f9 	call 80001bba <IfxScuWdt_disableSafetyWatchdog>
       	hardware_init_hook();
8000280c:	6d ff c6 fe 	call 80002598 <hardware_init_hook>
        Ifx_Cpp_Init();
80002810:	6d ff be fe 	call 8000258c <Ifx_Cpp_Init>
       	software_init_hook();
80002814:	6d ff c3 fe 	call 8000259a <software_init_hook>
        IfxScuWdt_enableCpuWatchdog(cpuWdtPassword);
80002818:	02 84       	mov %d4,%d8
8000281a:	6d ff 1f fa 	call 80001c58 <IfxScuWdt_enableCpuWatchdog>
        IfxScuWdt_enableSafetyWatchdog(safetyWdtPassword);
8000281e:	02 94       	mov %d4,%d9
80002820:	6d ff 5b fa 	call 80001cd6 <IfxScuWdt_enableSafetyWatchdog>
    IFXCPU_CSTART_CCU_INIT_HOOK();
80002824:	91 00 00 48 	movh.a %a4,32768
80002828:	d9 44 24 c0 	lea %a4,[%a4]804 <80000324 <IfxScuCcu_defaultClockConfig>>
8000282c:	6d ff 9a f7 	call 80001760 <IfxScuCcu_init>
    (void)IfxCpu_startCore(&MODULE_CPU1, (uint32)&_Core1_start);       /*The status returned by function call is ignored */
80002830:	91 00 00 28 	movh.a %a2,32768
80002834:	80 22       	mov.d %d2,%a2
80002836:	1b 02 89 42 	addi %d4,%d2,10384
8000283a:	91 30 88 4f 	movh.a %a4,63619
8000283e:	6d ff 4a fe 	call 800024d2 <IfxCpu_startCore>
    (void)IfxCpu_startCore(&MODULE_CPU2, (uint32)&_Core2_start);       /*The status returned by function call is ignored */
80002842:	91 00 00 28 	movh.a %a2,32768
80002846:	80 22       	mov.d %d2,%a2
80002848:	1b e2 b2 42 	addi %d4,%d2,11054
8000284c:	91 50 88 4f 	movh.a %a4,63621
80002850:	6d ff 41 fe 	call 800024d2 <IfxCpu_startCore>
    __non_return_call(core0_main);
80002854:	91 00 00 28 	movh.a %a2,32768
80002858:	d9 22 0c 33 	lea %a2,[%a2]12492 <800030cc <core0_main>>
8000285c:	dc 02       	ji %a2
}
8000285e:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002860:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002862:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002866:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000286a:	0f 34 a0 20 	or %d2,%d4,%d3
8000286e:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002872:	74 22       	st.w [%a2],%d2
80002874:	1d ff fd fe 	j 8000266e <_Core0_start+0xd2>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002878:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000287a:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000287e:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002882:	0f 34 a0 20 	or %d2,%d4,%d3
80002886:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000288a:	74 22       	st.w [%a2],%d2
8000288c:	1d ff b9 fe 	j 800025fe <_Core0_start+0x62>

80002890 <_Core1_start>:
    password  = watchdog->CON0.B.PW;
80002890:	91 30 00 2f 	movh.a %a2,61443
80002894:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80002898:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
8000289c:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[1]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(1);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(1));
800028a0:	91 20 00 26 	movh.a %a2,24578
800028a4:	8f f2 83 41 	xor %d4,%d2,63
800028a8:	80 22       	mov.d %d2,%a2
800028aa:	1b 02 60 2b 	addi %d2,%d2,-18944
800028ae:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
800028b0:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART1_PSW_DEFAULT);    /* 0x00000980 */
800028b4:	3b 00 98 20 	mov %d2,2432
800028b8:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
800028bc:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART1_PCX_O_S_DEFAULT; /*0xfff00000; */
800028c0:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
800028c4:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
800028c8:	82 12       	mov %d2,1
800028ca:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
800028ce:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800028d2:	7b 30 00 3f 	movh %d3,61443
800028d6:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800028da:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800028de:	13 c2 20 23 	madd %d2,%d3,%d2,12
800028e2:	60 22       	mov.a %a2,%d2
800028e4:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
800028e6:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
800028e8:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
800028ec:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800028f0:	6f 13 13 81 	jnz.t %d3,1,80002b16 <_Core1_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800028f4:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800028f8:	54 22       	ld.w %d2,[%a2]
800028fa:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800028fe:	a6 32       	or %d2,%d3
80002900:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002904:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80002906:	54 22       	ld.w %d2,[%a2]
80002908:	6f 02 ff ff 	jnz.t %d2,0,80002906 <_Core1_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
8000290c:	82 02       	mov %d2,0
8000290e:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
80002912:	54 22       	ld.w %d2,[%a2]
80002914:	6f 12 09 00 	jz.t %d2,1,80002926 <_Core1_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002918:	54 22       	ld.w %d2,[%a2]
8000291a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000291e:	a6 32       	or %d2,%d3
80002920:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002924:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002926:	54 22       	ld.w %d2,[%a2]
80002928:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000292c:	a6 32       	or %d2,%d3
8000292e:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002932:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002934:	54 22       	ld.w %d2,[%a2]
80002936:	6f 02 ff 7f 	jz.t %d2,0,80002934 <_Core1_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
8000293a:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
8000293e:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002942:	7b 30 00 3f 	movh %d3,61443
80002946:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000294a:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
8000294e:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002952:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
80002954:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80002956:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80002958:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
8000295c:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80002960:	6f 13 cf 80 	jnz.t %d3,1,80002afe <_Core1_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002964:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002968:	54 22       	ld.w %d2,[%a2]
8000296a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000296e:	a6 32       	or %d2,%d3
80002970:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002974:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80002976:	54 22       	ld.w %d2,[%a2]
80002978:	6f 02 ff ff 	jnz.t %d2,0,80002976 <_Core1_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
8000297c:	82 02       	mov %d2,0
8000297e:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80002982:	54 22       	ld.w %d2,[%a2]
80002984:	6f 12 09 00 	jz.t %d2,1,80002996 <_Core1_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002988:	54 22       	ld.w %d2,[%a2]
8000298a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000298e:	a6 32       	or %d2,%d3
80002990:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002994:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002996:	54 22       	ld.w %d2,[%a2]
80002998:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000299c:	a6 32       	or %d2,%d3
8000299e:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800029a2:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
800029a4:	54 22       	ld.w %d2,[%a2]
800029a6:	6f 02 ff 7f 	jz.t %d2,0,800029a4 <_Core1_start+0x114>
800029aa:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
800029ae:	91 30 00 2f 	movh.a %a2,61443
800029b2:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800029b6:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800029ba:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
800029bc:	6f 12 09 00 	jz.t %d2,1,800029ce <_Core1_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800029c0:	54 22       	ld.w %d2,[%a2]
800029c2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800029c6:	a6 42       	or %d2,%d4
800029c8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800029cc:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800029ce:	91 30 00 2f 	movh.a %a2,61443
800029d2:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800029d6:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800029da:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800029de:	a6 42       	or %d2,%d4
800029e0:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800029e4:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800029e6:	54 22       	ld.w %d2,[%a2]
800029e8:	6f 02 ff ff 	jnz.t %d2,0,800029e6 <_Core1_start+0x156>

    /* Clear the ENDINIT bit in the WDT_CON1 register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(1));
800029ec:	91 f0 01 38 	movh.a %a3,32799
800029f0:	80 32       	mov.d %d2,%a3
800029f2:	1b 02 20 26 	addi %d2,%d2,25088
800029f6:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(1));
800029fa:	91 f0 01 38 	movh.a %a3,32799
800029fe:	80 32       	mov.d %d2,%a3
80002a00:	1b 02 00 24 	addi %d2,%d2,16384
80002a04:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(1));
80002a08:	91 20 00 36 	movh.a %a3,24578
80002a0c:	80 32       	mov.d %d2,%a3
80002a0e:	1b 02 b0 2b 	addi %d2,%d2,-17664
80002a12:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
80002a16:	54 22       	ld.w %d2,[%a2]
80002a18:	6f 12 09 00 	jz.t %d2,1,80002a2a <_Core1_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002a1c:	54 22       	ld.w %d2,[%a2]
80002a1e:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002a22:	a6 42       	or %d2,%d4
80002a24:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002a28:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002a2a:	91 30 00 2f 	movh.a %a2,61443
80002a2e:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80002a32:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80002a36:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002a3a:	a6 42       	or %d2,%d4
80002a3c:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002a40:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002a42:	54 22       	ld.w %d2,[%a2]
80002a44:	6f 02 ff 7f 	jz.t %d2,0,80002a42 <_Core1_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(1));
80002a48:	91 10 00 26 	movh.a %a2,24577
80002a4c:	80 22       	mov.d %d2,%a2
80002a4e:	1b 02 00 28 	addi %d2,%d2,-32768
80002a52:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(1));
80002a54:	91 10 00 28 	movh.a %a2,32769
80002a58:	80 22       	mov.d %d2,%a2
80002a5a:	1b 02 00 28 	addi %d2,%d2,-32768
80002a5e:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialised */
    __setareg(a8, __SDATA3(1));
80002a60:	91 10 00 28 	movh.a %a2,32769
80002a64:	80 22       	mov.d %d2,%a2
80002a66:	1b 02 00 28 	addi %d2,%d2,-32768
80002a6a:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(1));
80002a6c:	91 10 00 29 	movh.a %a2,36865
80002a70:	80 22       	mov.d %d2,%a2
80002a72:	1b 02 00 28 	addi %d2,%d2,-32768
80002a76:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
80002a78:	91 20 00 36 	movh.a %a3,24578
80002a7c:	91 20 00 26 	movh.a %a2,24578
80002a80:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <6001bc00 <__CSA1>>
80002a84:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <6001dc00 <__CSA1_END>>
80002a88:	01 32 20 20 	sub.a %a2,%a2,%a3
80002a8c:	80 22       	mov.d %d2,%a2
80002a8e:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
80002a92:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
80002a94:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
80002a98:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
80002a9a:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002a9c:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80002aa0:	df 06 27 00 	jeq %d6,0,80002aee <_Core1_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002aa4:	37 02 70 43 	extr.u %d4,%d2,6,16
80002aa8:	8f 42 1f 50 	sh %d5,%d2,-12
80002aac:	26 75       	and %d5,%d7
80002aae:	a6 54       	or %d4,%d5
        if (k == 0U)
80002ab0:	df 03 16 00 	jeq %d3,0,80002adc <_Core1_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
80002ab4:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80002ab6:	5f 03 04 80 	jne %d3,%d0,80002abe <_Core1_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
80002aba:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80002abe:	c2 13       	add %d3,1
80002ac0:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
80002ac2:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80002ac6:	5f 36 0f 00 	jeq %d6,%d3,80002ae4 <_Core1_start+0x254>
        nxtCsa += 16U;           /* next CSA */
80002aca:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002acc:	37 02 70 43 	extr.u %d4,%d2,6,16
80002ad0:	8f 42 1f 50 	sh %d5,%d2,-12
80002ad4:	26 75       	and %d5,%d7
80002ad6:	a6 54       	or %d4,%d5
        if (k == 0U)
80002ad8:	df 03 ee ff 	jne %d3,0,80002ab4 <_Core1_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80002adc:	cd 84 e3 0f 	mtcr $fcx,%d4
80002ae0:	1d ff eb ff 	j 80002ab6 <_Core1_start+0x226>
80002ae4:	1b f6 ff 2f 	addi %d2,%d6,-1
80002ae8:	06 62       	sh %d2,6
80002aea:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
80002aee:	82 02       	mov %d2,0
80002af0:	74 22       	st.w [%a2],%d2

    IfxCpu_initCSA((uint32 *)__CSA(1), (uint32 *)__CSA_END(1));

    /*Call main function of Cpu0 */
    __non_return_call(core1_main);
80002af2:	91 00 00 28 	movh.a %a2,32768
80002af6:	d9 22 14 43 	lea %a2,[%a2]12564 <80003114 <core1_main>>
80002afa:	dc 02       	ji %a2
}
80002afc:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002afe:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002b00:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002b04:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002b08:	0f 35 a0 20 	or %d2,%d5,%d3
80002b0c:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002b10:	74 22       	st.w [%a2],%d2
80002b12:	1d ff 2b ff 	j 80002968 <_Core1_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002b16:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002b18:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002b1c:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002b20:	0f 35 a0 20 	or %d2,%d5,%d3
80002b24:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002b28:	74 22       	st.w [%a2],%d2
80002b2a:	1d ff e7 fe 	j 800028f8 <_Core1_start+0x68>

80002b2e <_Core2_start>:
    password  = watchdog->CON0.B.PW;
80002b2e:	91 30 00 2f 	movh.a %a2,61443
80002b32:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002b36:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002b3a:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[2]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(2);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(2));
80002b3e:	91 20 00 25 	movh.a %a2,20482
80002b42:	8f f2 83 41 	xor %d4,%d2,63
80002b46:	80 22       	mov.d %d2,%a2
80002b48:	1b 02 60 2b 	addi %d2,%d2,-18944
80002b4c:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
80002b4e:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART2_PSW_DEFAULT);    /* 0x00000980 */
80002b52:	3b 00 98 20 	mov %d2,2432
80002b56:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
80002b5a:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART2_PCX_O_S_DEFAULT; /*0xfff00000; */
80002b5e:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
80002b62:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
80002b66:	82 12       	mov %d2,1
80002b68:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
80002b6c:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002b70:	7b 30 00 3f 	movh %d3,61443
80002b74:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002b78:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002b7c:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002b80:	60 22       	mov.a %a2,%d2
80002b82:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80002b84:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80002b86:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80002b8a:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80002b8e:	6f 13 13 81 	jnz.t %d3,1,80002db4 <_Core2_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002b92:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002b96:	54 22       	ld.w %d2,[%a2]
80002b98:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002b9c:	a6 32       	or %d2,%d3
80002b9e:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002ba2:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80002ba4:	54 22       	ld.w %d2,[%a2]
80002ba6:	6f 02 ff ff 	jnz.t %d2,0,80002ba4 <_Core2_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
80002baa:	82 02       	mov %d2,0
80002bac:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
80002bb0:	54 22       	ld.w %d2,[%a2]
80002bb2:	6f 12 09 00 	jz.t %d2,1,80002bc4 <_Core2_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002bb6:	54 22       	ld.w %d2,[%a2]
80002bb8:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002bbc:	a6 32       	or %d2,%d3
80002bbe:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002bc2:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002bc4:	54 22       	ld.w %d2,[%a2]
80002bc6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002bca:	a6 32       	or %d2,%d3
80002bcc:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002bd0:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002bd2:	54 22       	ld.w %d2,[%a2]
80002bd4:	6f 02 ff 7f 	jz.t %d2,0,80002bd2 <_Core2_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
80002bd8:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80002bdc:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002be0:	7b 30 00 3f 	movh %d3,61443
80002be4:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80002be8:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80002bec:	13 c2 20 23 	madd %d2,%d3,%d2,12
80002bf0:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
80002bf2:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80002bf4:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80002bf6:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80002bfa:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80002bfe:	6f 13 cf 80 	jnz.t %d3,1,80002d9c <_Core2_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002c02:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002c06:	54 22       	ld.w %d2,[%a2]
80002c08:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002c0c:	a6 32       	or %d2,%d3
80002c0e:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002c12:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80002c14:	54 22       	ld.w %d2,[%a2]
80002c16:	6f 02 ff ff 	jnz.t %d2,0,80002c14 <_Core2_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
80002c1a:	82 02       	mov %d2,0
80002c1c:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80002c20:	54 22       	ld.w %d2,[%a2]
80002c22:	6f 12 09 00 	jz.t %d2,1,80002c34 <_Core2_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002c26:	54 22       	ld.w %d2,[%a2]
80002c28:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002c2c:	a6 32       	or %d2,%d3
80002c2e:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002c32:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002c34:	54 22       	ld.w %d2,[%a2]
80002c36:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002c3a:	a6 32       	or %d2,%d3
80002c3c:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002c40:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002c42:	54 22       	ld.w %d2,[%a2]
80002c44:	6f 02 ff 7f 	jz.t %d2,0,80002c42 <_Core2_start+0x114>
80002c48:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
80002c4c:	91 30 00 2f 	movh.a %a2,61443
80002c50:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002c54:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002c58:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
80002c5a:	6f 12 09 00 	jz.t %d2,1,80002c6c <_Core2_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002c5e:	54 22       	ld.w %d2,[%a2]
80002c60:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002c64:	a6 42       	or %d2,%d4
80002c66:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002c6a:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002c6c:	91 30 00 2f 	movh.a %a2,61443
80002c70:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002c74:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002c78:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002c7c:	a6 42       	or %d2,%d4
80002c7e:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002c82:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80002c84:	54 22       	ld.w %d2,[%a2]
80002c86:	6f 02 ff ff 	jnz.t %d2,0,80002c84 <_Core2_start+0x156>

    /* Clear the ENDINIT bit in the Password register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(2));
80002c8a:	91 f0 01 38 	movh.a %a3,32799
80002c8e:	80 32       	mov.d %d2,%a3
80002c90:	1b 02 10 26 	addi %d2,%d2,24832
80002c94:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(2));
80002c98:	91 f0 01 38 	movh.a %a3,32799
80002c9c:	80 32       	mov.d %d2,%a3
80002c9e:	1b 02 00 24 	addi %d2,%d2,16384
80002ca2:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(2));
80002ca6:	91 20 00 35 	movh.a %a3,20482
80002caa:	80 32       	mov.d %d2,%a3
80002cac:	1b 02 b0 2b 	addi %d2,%d2,-17664
80002cb0:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
80002cb4:	54 22       	ld.w %d2,[%a2]
80002cb6:	6f 12 09 00 	jz.t %d2,1,80002cc8 <_Core2_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002cba:	54 22       	ld.w %d2,[%a2]
80002cbc:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002cc0:	a6 42       	or %d2,%d4
80002cc2:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002cc6:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002cc8:	91 30 00 2f 	movh.a %a2,61443
80002ccc:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002cd0:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80002cd4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002cd8:	a6 42       	or %d2,%d4
80002cda:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002cde:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80002ce0:	54 22       	ld.w %d2,[%a2]
80002ce2:	6f 02 ff 7f 	jz.t %d2,0,80002ce0 <_Core2_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(2));
80002ce6:	91 10 00 26 	movh.a %a2,24577
80002cea:	80 22       	mov.d %d2,%a2
80002cec:	1b 02 00 28 	addi %d2,%d2,-32768
80002cf0:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(2));
80002cf2:	91 10 00 28 	movh.a %a2,32769
80002cf6:	80 22       	mov.d %d2,%a2
80002cf8:	1b 02 00 28 	addi %d2,%d2,-32768
80002cfc:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialized */
    __setareg(a8, __SDATA3(2));
80002cfe:	91 10 00 28 	movh.a %a2,32769
80002d02:	80 22       	mov.d %d2,%a2
80002d04:	1b 02 00 28 	addi %d2,%d2,-32768
80002d08:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(2));
80002d0a:	91 10 00 29 	movh.a %a2,36865
80002d0e:	80 22       	mov.d %d2,%a2
80002d10:	1b 02 00 28 	addi %d2,%d2,-32768
80002d14:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
80002d16:	91 20 00 35 	movh.a %a3,20482
80002d1a:	91 20 00 25 	movh.a %a2,20482
80002d1e:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <5001bc00 <__CSA2>>
80002d22:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <5001dc00 <__CSA2_END>>
80002d26:	01 32 20 20 	sub.a %a2,%a2,%a3
80002d2a:	80 22       	mov.d %d2,%a2
80002d2c:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
80002d30:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
80002d32:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
80002d36:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
80002d38:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002d3a:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80002d3e:	df 06 27 00 	jeq %d6,0,80002d8c <_Core2_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002d42:	37 02 70 43 	extr.u %d4,%d2,6,16
80002d46:	8f 42 1f 50 	sh %d5,%d2,-12
80002d4a:	26 75       	and %d5,%d7
80002d4c:	a6 54       	or %d4,%d5
        if (k == 0U)
80002d4e:	df 03 16 00 	jeq %d3,0,80002d7a <_Core2_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
80002d52:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80002d54:	5f 03 04 80 	jne %d3,%d0,80002d5c <_Core2_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
80002d58:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80002d5c:	c2 13       	add %d3,1
80002d5e:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
80002d60:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80002d64:	5f 36 0f 00 	jeq %d6,%d3,80002d82 <_Core2_start+0x254>
        nxtCsa += 16U;           /* next CSA */
80002d68:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80002d6a:	37 02 70 43 	extr.u %d4,%d2,6,16
80002d6e:	8f 42 1f 50 	sh %d5,%d2,-12
80002d72:	26 75       	and %d5,%d7
80002d74:	a6 54       	or %d4,%d5
        if (k == 0U)
80002d76:	df 03 ee ff 	jne %d3,0,80002d52 <_Core2_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80002d7a:	cd 84 e3 0f 	mtcr $fcx,%d4
80002d7e:	1d ff eb ff 	j 80002d54 <_Core2_start+0x226>
80002d82:	1b f6 ff 2f 	addi %d2,%d6,-1
80002d86:	06 62       	sh %d2,6
80002d88:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
80002d8c:	82 02       	mov %d2,0
80002d8e:	74 22       	st.w [%a2],%d2
    /* Setup the context save area linked list. */

    IfxCpu_initCSA((uint32 *)__CSA(2), (uint32 *)__CSA_END(2));

    /*Call main function of Cpu0 */
    __non_return_call(core2_main);
80002d90:	91 00 00 28 	movh.a %a2,32768
80002d94:	d9 22 3e 43 	lea %a2,[%a2]12606 <8000313e <core2_main>>
80002d98:	dc 02       	ji %a2
}
80002d9a:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002d9c:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002d9e:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002da2:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002da6:	0f 35 a0 20 	or %d2,%d5,%d3
80002daa:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002dae:	74 22       	st.w [%a2],%d2
80002db0:	1d ff 2b ff 	j 80002c06 <_Core2_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002db4:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002db6:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80002dba:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80002dbe:	0f 35 a0 20 	or %d2,%d5,%d3
80002dc2:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80002dc6:	74 22       	st.w [%a2],%d2
80002dc8:	1d ff e7 fe 	j 80002b96 <_Core2_start+0x68>

80002dcc <Ifx_C_Init>:
 *
 * Parameters: Nil
 * Return: Nil
 */
void Ifx_C_Init(void)
{
80002dcc:	40 ae       	mov.aa %a14,%sp
80002dce:	20 08       	sub.a %sp,8
    IfxStart_CTablePtr pBlockDest, pBlockSrc;
    uint32             uiLength, uiCnt;
    uint32            *pTable;
    /* clear table */
    pTable = (uint32 *)&__clear_table;
80002dd0:	91 00 00 28 	movh.a %a2,32768
80002dd4:	d9 22 1c e0 	lea %a2,[%a2]924 <8000039c <__clear_table>>

    while (pTable)
80002dd8:	1d 00 32 00 	j 80002e3c <Ifx_C_Init+0x70>
            break;
        }

        uiCnt = uiLength / 8;

        while (uiCnt--)
80002ddc:	91 00 00 28 	movh.a %a2,32768
80002de0:	d9 22 44 00 	lea %a2,[%a2]1028 <80000404 <__copy_table>>
80002de4:	1d 00 7c 00 	j 80002edc <Ifx_C_Init+0x110>
            *pBlockDest.ullPtr++ = 0;
80002de8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80002dec:	80 22       	mov.d %d2,%a2
80002dee:	1b 82 00 20 	addi %d2,%d2,8
80002df2:	59 e2 fc ff 	st.w [%a14]-4,%d2
80002df6:	d2 02       	mov %e2,0
80002df8:	89 22 40 09 	st.d [%a2],%e2
        while (uiCnt--)
80002dfc:	02 52       	mov %d2,%d5
80002dfe:	1b f2 ff 5f 	addi %d5,%d2,-1
80002e02:	df 02 f3 ff 	jne %d2,0,80002de8 <Ifx_C_Init+0x1c>
        if (uiLength & 0x4)
80002e06:	6f 24 0a 00 	jz.t %d4,2,80002e1a <Ifx_C_Init+0x4e>
            *pBlockDest.uiPtr++ = 0;
80002e0a:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80002e0e:	80 22       	mov.d %d2,%a2
80002e10:	c2 42       	add %d2,4
80002e12:	59 e2 fc ff 	st.w [%a14]-4,%d2
80002e16:	82 02       	mov %d2,0
80002e18:	74 22       	st.w [%a2],%d2
        if (uiLength & 0x2)
80002e1a:	6f 14 0a 00 	jz.t %d4,1,80002e2e <Ifx_C_Init+0x62>
            *pBlockDest.usPtr++ = 0;
80002e1e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80002e22:	80 22       	mov.d %d2,%a2
80002e24:	c2 22       	add %d2,2
80002e26:	59 e2 fc ff 	st.w [%a14]-4,%d2
80002e2a:	82 02       	mov %d2,0
80002e2c:	b4 22       	st.h [%a2],%d2
        if (uiLength & 0x1)
80002e2e:	6f 04 06 00 	jz.t %d4,0,80002e3a <Ifx_C_Init+0x6e>
            *pBlockDest.ucPtr = 0;
80002e32:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80002e36:	82 02       	mov %d2,0
80002e38:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
80002e3a:	40 32       	mov.aa %a2,%a3
    while (pTable)
80002e3c:	bd 02 d0 7f 	jz.a %a2,80002ddc <Ifx_C_Init+0x10>
        pBlockDest.uiPtr = (uint32 *)*pTable++;
80002e40:	d9 23 08 00 	lea %a3,[%a2]8
80002e44:	54 22       	ld.w %d2,[%a2]
80002e46:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
80002e4a:	19 24 04 00 	ld.w %d4,[%a2]4
        if (uiLength == 0xFFFFFFFF)
80002e4e:	df f4 c7 7f 	jeq %d4,-1,80002ddc <Ifx_C_Init+0x10>
        uiCnt = uiLength / 8;
80002e52:	8f d4 1f 20 	sh %d2,%d4,-3
        while (uiCnt--)
80002e56:	1d ff d4 ff 	j 80002dfe <Ifx_C_Init+0x32>
        {
            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;
80002e5a:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80002e5e:	80 22       	mov.d %d2,%a2
80002e60:	1b 82 00 20 	addi %d2,%d2,8
80002e64:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80002e68:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80002e6c:	80 32       	mov.d %d2,%a3
80002e6e:	1b 82 00 20 	addi %d2,%d2,8
80002e72:	59 e2 fc ff 	st.w [%a14]-4,%d2
80002e76:	09 26 40 09 	ld.d %e6,[%a2]
80002e7a:	89 36 40 09 	st.d [%a3],%e6
        while (uiCnt--)
80002e7e:	02 42       	mov %d2,%d4
80002e80:	1b f2 ff 4f 	addi %d4,%d2,-1
80002e84:	df 02 eb ff 	jne %d2,0,80002e5a <Ifx_C_Init+0x8e>
        }

        if (uiLength & 0x4)
80002e88:	6f 23 10 00 	jz.t %d3,2,80002ea8 <Ifx_C_Init+0xdc>
        {
            *pBlockDest.uiPtr++ = *pBlockSrc.uiPtr++;
80002e8c:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80002e90:	80 22       	mov.d %d2,%a2
80002e92:	c2 42       	add %d2,4
80002e94:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80002e98:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80002e9c:	80 32       	mov.d %d2,%a3
80002e9e:	c2 42       	add %d2,4
80002ea0:	59 e2 fc ff 	st.w [%a14]-4,%d2
80002ea4:	54 22       	ld.w %d2,[%a2]
80002ea6:	74 32       	st.w [%a3],%d2
        }

        if (uiLength & 0x2)
80002ea8:	6f 13 11 00 	jz.t %d3,1,80002eca <Ifx_C_Init+0xfe>
        {
            *pBlockDest.usPtr++ = *pBlockSrc.usPtr++;
80002eac:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80002eb0:	80 32       	mov.d %d2,%a3
80002eb2:	c2 22       	add %d2,2
80002eb4:	59 e2 f8 ff 	st.w [%a14]-8,%d2
80002eb8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80002ebc:	80 22       	mov.d %d2,%a2
80002ebe:	c2 22       	add %d2,2
80002ec0:	59 e2 fc ff 	st.w [%a14]-4,%d2
80002ec4:	b9 32 00 00 	ld.hu %d2,[%a3]0
80002ec8:	b4 22       	st.h [%a2],%d2
        }

        if (uiLength & 0x1)
80002eca:	6f 03 08 00 	jz.t %d3,0,80002eda <Ifx_C_Init+0x10e>
        {
            *pBlockDest.ucPtr = *pBlockSrc.ucPtr;
80002ece:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80002ed2:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80002ed6:	14 32       	ld.bu %d2,[%a3]
80002ed8:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
80002eda:	60 52       	mov.a %a2,%d5
    while (pTable)
80002edc:	bd 02 14 00 	jz.a %a2,80002f04 <Ifx_C_Init+0x138>
        pBlockSrc.uiPtr  = (uint32 *)*pTable++;
80002ee0:	54 22       	ld.w %d2,[%a2]
80002ee2:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        pBlockDest.uiPtr = (uint32 *)*pTable++;
80002ee6:	19 22 04 00 	ld.w %d2,[%a2]4
80002eea:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
80002eee:	80 22       	mov.d %d2,%a2
80002ef0:	1b c2 00 50 	addi %d5,%d2,12
80002ef4:	19 23 08 00 	ld.w %d3,[%a2]8
        if (uiLength == 0xFFFFFFFF)
80002ef8:	df f3 06 00 	jeq %d3,-1,80002f04 <Ifx_C_Init+0x138>
        uiCnt = uiLength / 8;
80002efc:	8f d3 1f 20 	sh %d2,%d3,-3
        while (uiCnt--)
80002f00:	1d ff c0 ff 	j 80002e80 <Ifx_C_Init+0xb4>
        }
    }
}
80002f04:	00 90       	ret 

80002f06 <init_GPIO>:
#include "GPIO.h"



void init_GPIO(void)
{
80002f06:	40 ae       	mov.aa %a14,%sp
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80002f08:	3b 00 08 50 	mov %d5,128
80002f0c:	82 54       	mov %d4,5
80002f0e:	91 40 00 4f 	movh.a %a4,61444
80002f12:	d9 44 00 0a 	lea %a4,[%a4]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80002f16:	6d ff 99 f7 	call 80001e48 <IfxPort_setPinMode>
80002f1a:	3b 00 08 50 	mov %d5,128
80002f1e:	82 24       	mov %d4,2
80002f20:	91 40 00 4f 	movh.a %a4,61444
80002f24:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80002f28:	6d ff 90 f7 	call 80001e48 <IfxPort_setPinMode>
80002f2c:	3b 00 08 50 	mov %d5,128
80002f30:	82 14       	mov %d4,1
80002f32:	91 40 00 4f 	movh.a %a4,61444
80002f36:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80002f3a:	6d ff 87 f7 	call 80001e48 <IfxPort_setPinMode>
80002f3e:	3b 00 08 50 	mov %d5,128
80002f42:	82 54       	mov %d4,5
80002f44:	91 40 00 4f 	movh.a %a4,61444
80002f48:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80002f4c:	6d ff 7e f7 	call 80001e48 <IfxPort_setPinMode>
80002f50:	3b 00 08 50 	mov %d5,128
80002f54:	82 64       	mov %d4,6
80002f56:	91 40 00 4f 	movh.a %a4,61444
80002f5a:	d9 44 00 0c 	lea %a4,[%a4]-16384 <f003c000 <_SMALL_DATA4_+0x60034000>>
80002f5e:	6d ff 75 f7 	call 80001e48 <IfxPort_setPinMode>
    port->OMR.U = action << pinIndex;
80002f62:	91 40 00 2f 	movh.a %a2,61444
80002f66:	d9 22 00 0c 	lea %a2,[%a2]-16384 <f003c000 <_SMALL_DATA4_+0x60034000>>
80002f6a:	7b 00 04 20 	movh %d2,64
80002f6e:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
    IfxPort_setPinModeOutput(PORT_102, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(PORT_101, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(PORT_105, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(PORT_206, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinLow(PORT_206); /*CAN 트랜시버 활성화를 위해 LOW로 설정*/
}
80002f72:	00 90       	ret 

80002f74 <CAN_TX>:
    /* initialize message object */
    IfxMultican_Can_MsgObj_init(pArrObjNum, &canMsgObjConfig);
}

void CAN_TX(void)
{
80002f74:	40 ae       	mov.aa %a14,%sp
80002f76:	20 18       	sub.a %sp,24
    msg->id          = id;
80002f78:	3b 00 10 20 	mov %d2,256
80002f7c:	59 e2 ec ff 	st.w [%a14]-20,%d2
    msg->data[0]     = dataLow;
80002f80:	7b 40 23 21 	movh %d2,4660
80002f84:	59 e2 f4 ff 	st.w [%a14]-12,%d2
    msg->data[1]     = dataHigh;
80002f88:	7b c0 ab 29 	movh %d2,39612
80002f8c:	59 e2 f8 ff 	st.w [%a14]-8,%d2
    msg->lengthCode  = lengthCode;
80002f90:	3b 80 00 20 	mov %d2,8
80002f94:	59 e2 f0 ff 	st.w [%a14]-16,%d2
    msg->fastBitRate = FALSE;
80002f98:	82 02       	mov %d2,0
80002f9a:	e9 e2 fc ff 	st.b [%a14]-4,%d2
    const uint32 dataHigh   = 0x9abc0000;

    {
        IfxMultican_Message     msg;
        IfxMultican_Message_init(&msg, 0x100, dataLow, dataHigh, IfxMultican_DataLengthCode_8);
        while (IfxMultican_Can_MsgObj_sendMessage(&CANstr01.CanEcu1MsgTxObj[0], &msg) == IfxMultican_Status_notSentBusy)
80002f9e:	d9 e5 ec ff 	lea %a5,[%a14]-20
80002fa2:	91 00 00 46 	movh.a %a4,24576
80002fa6:	d9 44 34 10 	lea %a4,[%a4]116 <60000074 <CANstr01+0x14>>
80002faa:	6d ff 9c f8 	call 800020e2 <IfxMultican_Can_MsgObj_sendMessage>
80002fae:	8b 02 02 22 	eq %d2,%d2,32
80002fb2:	df 02 f6 ff 	jne %d2,0,80002f9e <CAN_TX+0x2a>
        {}
    }
}
80002fb6:	00 90       	ret 

80002fb8 <ISR_CAN_RX>:

IFX_INTERRUPT(ISR_CAN_RX, 0, 30);
void ISR_CAN_RX(void)
{
80002fb8:	40 ae       	mov.aa %a14,%sp
    __enable();
80002fba:	0d 00 00 03 	enable 
    IfxMultican_Status      readStatus;

    IfxCpu_enableInterrupts();

    readStatus = IfxMultican_Can_MsgObj_readMessage(&CANstr01.CanEcu1MsgRxObj[0], &RxData[0]);
80002fbe:	91 00 00 56 	movh.a %a5,24576
80002fc2:	d9 55 24 00 	lea %a5,[%a5]36 <60000024 <RxData>>
80002fc6:	91 00 00 46 	movh.a %a4,24576
80002fca:	d9 44 04 30 	lea %a4,[%a4]196 <600000c4 <CANstr01+0x64>>
80002fce:	6d ff 5d f8 	call 80002088 <IfxMultican_Can_MsgObj_readMessage>
}
80002fd2:	0d 00 40 02 	rslcx 
80002fd6:	00 80       	rfe 

80002fd8 <init_ADC_Group>:
#include "ADC.h"
#include "STM.h"
#include "GPIO.h"

void init_ADC_Group(void)
{
80002fd8:	40 ae       	mov.aa %a14,%sp
80002fda:	20 a8       	sub.a %sp,168
    IfxVadc_Adc_Config      adcConf;                        /* Define a configuration structure for the VADC module */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);   /* adcConf 값을 디폴트 값(MODULE_VADC)오로 초기화 */
80002fdc:	91 20 00 5f 	movh.a %a5,61442
80002fe0:	d9 e4 d8 ff 	lea %a4,[%a14]-40
80002fe4:	6d ff 40 f1 	call 80001264 <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&Vadc, &adcConf);                /* Vadc를 adcConf 값으로 초기화 */
80002fe8:	91 00 00 c6 	movh.a %a12,24576
80002fec:	d9 cc 00 60 	lea %a12,[%a12]384 <60000180 <Vadc>>
80002ff0:	d9 e5 d8 ff 	lea %a5,[%a14]-40 <60000180 <Vadc>>
80002ff4:	40 c4       	mov.aa %a4,%a12
80002ff6:	6d ff ad f0 	call 80001150 <IfxVadc_Adc_initModule>

    IfxVadc_Adc_GroupConfig     adcGroupConf;               /* Define a configuration structure for the VADC group */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &Vadc);      /* adc 그룹 구조체 초기화 및 Vadc 값 반영 */
80002ffa:	40 c5       	mov.aa %a5,%a12
80002ffc:	d9 e4 dc df 	lea %a4,[%a14]-164
80003000:	6d ff 8d f0 	call 8000111a <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_3;               /* Select the group 다른 아이디로는 그룹2, 그룹3으로 지정*/
80003004:	82 32       	mov %d2,3
80003006:	59 e2 e0 df 	st.w [%a14]-160,%d2
    adcGroupConf.master = adcGroupConf.groupId;             /* Select the master group */
8000300a:	59 e2 e4 df 	st.w [%a14]-156,%d2

    adcGroupConf.arbiter.requestSlotScanEnabled = TRUE;     /* Enabled scan source 별도의 설정없이 ADC변환*/
8000300e:	82 12       	mov %d2,1
80003010:	e9 e2 d5 ff 	st.b [%a14]-43,%d2
    adcGroupConf.scanRequest.autoscanEnabled    = TRUE;     /* Enabled auto scan mode */
80003014:	e9 e2 f8 df 	st.b [%a14]-136,%d2

    adcGroupConf.scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;  /* 특정 트리거 조건 없이 항상 변환 수행/인터럽트일 때는 다른 모드 */
80003018:	82 12       	mov %d2,1
8000301a:	59 e2 c4 ef 	st.w [%a14]-124,%d2

    IfxVadc_Adc_initGroup(&adcGroup3, &adcGroupConf);       /* adc 그룹 설정 값 반영 */
8000301e:	d9 e5 dc df 	lea %a5,[%a14]-164
80003022:	91 00 00 46 	movh.a %a4,24576
80003026:	d9 44 34 50 	lea %a4,[%a4]372 <60000174 <adcGroup3>>
8000302a:	6d ff 36 ee 	call 80000c96 <IfxVadc_Adc_initGroup>
}
8000302e:	00 90       	ret 

80003030 <init_ADC_G3_SingleCh>:

void init_ADC_G3_SingleCh(uint8 Channel)
{
80003030:	40 ae       	mov.aa %a14,%sp
80003032:	20 40       	sub.a %sp,64
80003034:	8f f4 0f 81 	and %d8,%d4,255
    IfxVadc_Adc_ChannelConfig   adcChannelConfigInfo;
    uint32 ulTemp = ((uint32)1u << Channel);
80003038:	82 19       	mov %d9,1
8000303a:	0f 89 00 90 	sh %d9,%d9,%d8

    IfxVadc_Adc_initChannelConfig(&adcChannelConfigInfo, &adcGroup3);           /* Fill it with default values */
8000303e:	91 00 00 c6 	movh.a %a12,24576
80003042:	d9 cc 34 50 	lea %a12,[%a12]372 <60000174 <adcGroup3>>
80003046:	40 c5       	mov.aa %a5,%a12
80003048:	d9 e4 c4 ff 	lea %a4,[%a14]-60
8000304c:	6d ff 1a ee 	call 80000c80 <IfxVadc_Adc_initChannelConfig>

    adcChannelConfigInfo.channelId      = (IfxVadc_ChannelId) Channel;          /* Select the channel ID */
80003050:	59 e8 dc ff 	st.w [%a14]-36,%d8
    adcChannelConfigInfo.resultRegister = (IfxVadc_ChannelResult) (Channel);    /* Use dedicated result register */
80003054:	59 e8 e8 ff 	st.w [%a14]-24,%d8

    /* Initialize the channel */
    IfxVadc_Adc_initChannel(&adcG3Channel[Channel], &adcChannelConfigInfo);     /* 채널 초기화 */
80003058:	d9 e5 c4 ff 	lea %a5,[%a14]-60
8000305c:	91 00 00 46 	movh.a %a4,24576
80003060:	d9 44 14 40 	lea %a4,[%a4]276 <60000114 <adcG3Channel>>
80003064:	01 48 03 46 	addsc.a %a4,%a4,%d8,3
80003068:	01 48 02 46 	addsc.a %a4,%a4,%d8,2
8000306c:	6d ff f8 ec 	call 80000a5c <IfxVadc_Adc_initChannel>
}


IFX_INLINE void IfxVadc_Adc_setScan(IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setScan(group->group, channels, mask);
80003070:	02 95       	mov %d5,%d9
80003072:	02 94       	mov %d4,%d9
80003074:	99 c4 04 00 	ld.a %a4,[%a12]4 <60000004 <__TMC_END__>>
80003078:	6d ff be ec 	call 800009f4 <IfxVadc_setScan>

    /* Add the channel to the scan sequence */
    IfxVadc_Adc_setScan(&adcGroup3, ulTemp, ulTemp);                            /* the background scan sequence */
}
8000307c:	00 90       	ret 

8000307e <init_ADC_G3_Channel>:

void init_ADC_G3_Channel(void)
{
8000307e:	40 ae       	mov.aa %a14,%sp
    init_ADC_G3_SingleCh(ADC_G3_CH0);   /* 각 채널 초기화 */
80003080:	82 04       	mov %d4,0
80003082:	6d ff d7 ff 	call 80003030 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH1);   //litekit A0(가변저항)
80003086:	82 14       	mov %d4,1
80003088:	6d ff d4 ff 	call 80003030 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH2);
8000308c:	82 24       	mov %d4,2
8000308e:	6d ff d1 ff 	call 80003030 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH3);
80003092:	82 34       	mov %d4,3
80003094:	6d ff ce ff 	call 80003030 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH4);
80003098:	82 44       	mov %d4,4
8000309a:	6d ff cb ff 	call 80003030 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH5);
8000309e:	82 54       	mov %d4,5
800030a0:	6d ff c8 ff 	call 80003030 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH6);
800030a4:	82 64       	mov %d4,6
800030a6:	6d ff c5 ff 	call 80003030 <init_ADC_G3_SingleCh>
    init_ADC_G3_SingleCh(ADC_G3_CH7);   //가변저항
800030aa:	82 74       	mov %d4,7
800030ac:	6d ff c2 ff 	call 80003030 <init_ADC_G3_SingleCh>
}


IFX_INLINE void IfxVadc_Adc_startScan(IfxVadc_Adc_Group *group)
{
    IfxVadc_startScan(group->group);
800030b0:	91 00 00 26 	movh.a %a2,24576
800030b4:	d9 22 34 50 	lea %a2,[%a2]372 <60000174 <adcGroup3>>
800030b8:	b0 42       	add.a %a2,4
800030ba:	d4 22       	ld.a %a2,[%a2]
    group->ASMR.B.LDEV = 1;     /* set Load event. Channels stored in ASSEL will be copied into pending register and conversion will start */
800030bc:	d9 23 24 20 	lea %a3,[%a2]164
800030c0:	19 22 24 20 	ld.w %d2,[%a2]164
800030c4:	b7 12 81 24 	insert %d2,%d2,1,9,1
800030c8:	74 32       	st.w [%a3],%d2

    IfxVadc_Adc_startScan(&adcGroup3);  //아날로그값이 실제값으로 변환
    }
800030ca:	00 90       	ret 

800030cc <core0_main>:

IfxCpu_syncEvent g_cpuSyncEvent = 0;


void core0_main(void)
{
800030cc:	40 ae       	mov.aa %a14,%sp
800030ce:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
800030d2:	6d ff 51 f6 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
800030d6:	02 24       	mov %d4,%d2
800030d8:	6d ff 32 f5 	call 80001b3c <IfxScuWdt_disableCpuWatchdog>
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
800030dc:	6d ff 5e f6 	call 80001d98 <IfxScuWdt_getSafetyWatchdogPassword>
800030e0:	02 24       	mov %d4,%d2
800030e2:	6d ff 6c f5 	call 80001bba <IfxScuWdt_disableSafetyWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
800030e6:	91 00 00 c6 	movh.a %a12,24576
800030ea:	d9 cc 20 00 	lea %a12,[%a12]32 <60000020 <g_cpuSyncEvent>>
800030ee:	40 c4       	mov.aa %a4,%a12
800030f0:	6d ff 45 fa 	call 8000257a <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
800030f4:	82 14       	mov %d4,1
800030f6:	40 c4       	mov.aa %a4,%a12
800030f8:	6d ff 01 fa 	call 800024fa <IfxCpu_waitEvent>

    init_GPIO();
800030fc:	6d ff 05 ff 	call 80002f06 <init_GPIO>
    init_STM();
80003100:	6d ff 92 ea 	call 80000624 <init_STM>
    init_ADC_Group(); init_ADC_G3_Channel();
80003104:	6d ff 6a ff 	call 80002fd8 <init_ADC_Group>
80003108:	6d ff bb ff 	call 8000307e <init_ADC_G3_Channel>

    while(1)
    {
//        ADC_G3_GetData();
        AppScheduling();
8000310c:	6d ff 65 ea 	call 800005d6 <AppScheduling>
    while(1)
80003110:	1d ff fe ff 	j 8000310c <core0_main+0x40>

80003114 <core1_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core1_main(void)
{
80003114:	40 ae       	mov.aa %a14,%sp
80003116:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG1 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
8000311a:	6d ff 2d f6 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
8000311e:	02 24       	mov %d4,%d2
80003120:	6d ff 0e f5 	call 80001b3c <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80003124:	91 00 00 c6 	movh.a %a12,24576
80003128:	d9 cc 20 00 	lea %a12,[%a12]32 <60000020 <g_cpuSyncEvent>>
8000312c:	40 c4       	mov.aa %a4,%a12
8000312e:	6d ff 26 fa 	call 8000257a <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80003132:	82 14       	mov %d4,1
80003134:	40 c4       	mov.aa %a4,%a12
80003136:	6d ff e2 f9 	call 800024fa <IfxCpu_waitEvent>
    
    while(1)
8000313a:	1d 00 00 00 	j 8000313a <core1_main+0x26>

8000313e <core2_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core2_main(void)
{
8000313e:	40 ae       	mov.aa %a14,%sp
80003140:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG2 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80003144:	6d ff 18 f6 	call 80001d74 <IfxScuWdt_getCpuWatchdogPassword>
80003148:	02 24       	mov %d4,%d2
8000314a:	6d ff f9 f4 	call 80001b3c <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
8000314e:	91 00 00 c6 	movh.a %a12,24576
80003152:	d9 cc 20 00 	lea %a12,[%a12]32 <60000020 <g_cpuSyncEvent>>
80003156:	40 c4       	mov.aa %a4,%a12
80003158:	6d ff 11 fa 	call 8000257a <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
8000315c:	82 14       	mov %d4,1
8000315e:	40 c4       	mov.aa %a4,%a12
80003160:	6d ff cd f9 	call 800024fa <IfxCpu_waitEvent>
    
    while(1)
80003164:	1d 00 00 00 	j 80003164 <core2_main+0x26>

80003168 <memset>:
80003168:	40 42       	mov.aa %a2,%a4
8000316a:	df 05 07 00 	jeq %d5,0,80003178 <memset+0x10>
8000316e:	60 53       	mov.a %a3,%d5
80003170:	b0 f3       	add.a %a3,-1
80003172:	24 44       	st.b [%a4+],%d4
80003174:	fd 30 ff 7f 	loop %a3,80003172 <memset+0xa>
80003178:	00 90       	ret 

8000317a <__divdf3>:
8000317a:	20 38       	sub.a %sp,56
8000317c:	d9 a5 10 00 	lea %a5,[%sp]16
80003180:	40 a4       	mov.aa %a4,%sp
80003182:	89 a4 40 09 	st.d [%sp],%e4
80003186:	89 a6 48 09 	st.d [%sp]8,%e6
8000318a:	6d 00 d5 01 	call 80003534 <__unpack_d>
8000318e:	d9 a5 24 00 	lea %a5,[%sp]36
80003192:	d9 a4 08 00 	lea %a4,[%sp]8
80003196:	6d 00 cf 01 	call 80003534 <__unpack_d>
8000319a:	19 a2 10 00 	ld.w %d2,[%sp]16
8000319e:	ff 22 07 80 	jge.u %d2,2,800031ac <__divdf3+0x32>
800031a2:	d9 a4 10 00 	lea %a4,[%sp]16
800031a6:	6d 00 f8 00 	call 80003396 <__pack_d>
800031aa:	00 90       	ret 
800031ac:	19 a3 24 00 	ld.w %d3,[%sp]36
800031b0:	d9 a4 24 00 	lea %a4,[%sp]36
800031b4:	bf 23 f9 ff 	jlt.u %d3,2,800031a6 <__divdf3+0x2c>
800031b8:	19 a5 14 00 	ld.w %d5,[%sp]20
800031bc:	19 a4 28 00 	ld.w %d4,[%sp]40
800031c0:	c6 54       	xor %d4,%d5
800031c2:	59 a4 14 00 	st.w [%sp]20,%d4
800031c6:	1b e2 ff 4f 	addi %d4,%d2,-2
800031ca:	8f 24 c0 41 	andn %d4,%d4,2
800031ce:	df 04 0a 80 	jne %d4,0,800031e2 <__divdf3+0x68>
800031d2:	91 00 00 48 	movh.a %a4,32768
800031d6:	d9 44 00 80 	lea %a4,[%a4]512 <80000200 <__thenan_df>>
800031da:	5f 32 e4 ff 	jne %d2,%d3,800031a2 <__divdf3+0x28>
800031de:	1d ff e4 ff 	j 800031a6 <__divdf3+0x2c>
800031e2:	df 43 51 00 	jeq %d3,4,80003284 <__divdf3+0x10a>
800031e6:	df 23 5a 00 	jeq %d3,2,8000329a <__divdf3+0x120>
800031ea:	19 a3 18 00 	ld.w %d3,[%sp]24
800031ee:	19 a2 2c 00 	ld.w %d2,[%sp]44
800031f2:	09 a4 70 09 	ld.d %e4,[%sp]48
800031f6:	0b 23 80 00 	sub %d0,%d3,%d2
800031fa:	09 a2 5c 09 	ld.d %e2,[%sp]28
800031fe:	0b 53 00 61 	eq %d6,%d3,%d5
80003202:	02 67       	mov %d7,%d6
80003204:	0b 42 50 72 	and.ge.u %d7,%d2,%d4
80003208:	59 a0 18 00 	st.w [%sp]24,%d0
8000320c:	0b 35 a0 72 	or.lt.u %d7,%d5,%d3
80003210:	df 07 0b 80 	jne %d7,0,80003226 <__divdf3+0xac>
80003214:	1b f0 ff 6f 	addi %d6,%d0,-1
80003218:	77 23 80 30 	dextr %d3,%d3,%d2,1
8000321c:	06 12       	sh %d2,1
8000321e:	59 a6 18 00 	st.w [%sp]24,%d6
80003222:	0b 53 00 61 	eq %d6,%d3,%d5
80003226:	3b d0 03 10 	mov %d1,61
8000322a:	d2 08       	mov %e8,0
8000322c:	82 00       	mov %d0,0
8000322e:	7b 00 00 71 	movh %d7,4096
80003232:	1d 00 04 00 	j 8000323a <__divdf3+0xc0>
80003236:	0b 53 00 61 	eq %d6,%d3,%d5
8000323a:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
8000323e:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
80003242:	df 06 0c 80 	jne %d6,0,8000325a <__divdf3+0xe0>
80003246:	0f 08 a0 a0 	or %d10,%d8,%d0
8000324a:	0f 79 a0 60 	or %d6,%d9,%d7
8000324e:	0b 42 c0 20 	subx %d2,%d2,%d4
80003252:	0b a6 10 88 	mov %e8,%d6,%d10
80003256:	0b 53 d0 30 	subc %d3,%d3,%d5
8000325a:	c2 f1       	add %d1,-1
8000325c:	77 07 80 0f 	dextr %d0,%d7,%d0,31
80003260:	77 23 80 30 	dextr %d3,%d3,%d2,1
80003264:	06 f7       	sh %d7,-1
80003266:	06 12       	sh %d2,1
80003268:	df 01 e7 ff 	jne %d1,0,80003236 <__divdf3+0xbc>
8000326c:	8f f8 0f 41 	and %d4,%d8,255
80003270:	8b 04 28 42 	ne %d4,%d4,128
80003274:	df 04 1a 00 	jeq %d4,0,800032a8 <__divdf3+0x12e>
80003278:	59 a8 1c 00 	st.w [%sp]28,%d8
8000327c:	59 a9 20 00 	st.w [%sp]32,%d9
80003280:	1d ff 91 ff 	j 800031a2 <__divdf3+0x28>
80003284:	82 02       	mov %d2,0
80003286:	a0 02       	mov.a %a2,0
80003288:	a0 03       	mov.a %a3,0
8000328a:	89 a2 dc 09 	st.da [%sp]28,%a2
8000328e:	59 a2 18 00 	st.w [%sp]24,%d2
80003292:	d9 a4 10 00 	lea %a4,[%sp]16
80003296:	1d ff 88 ff 	j 800031a6 <__divdf3+0x2c>
8000329a:	82 42       	mov %d2,4
8000329c:	d9 a4 10 00 	lea %a4,[%sp]16
800032a0:	59 a2 10 00 	st.w [%sp]16,%d2
800032a4:	1d ff 81 ff 	j 800031a6 <__divdf3+0x2c>
800032a8:	a6 32       	or %d2,%d3
800032aa:	77 89 00 4c 	dextr %d4,%d9,%d8,24
800032ae:	8b 02 20 32 	ne %d3,%d2,0
800032b2:	0f 43 e0 20 	andn %d2,%d3,%d4
800032b6:	df 02 e1 7f 	jeq %d2,0,80003278 <__divdf3+0xfe>
800032ba:	8b 08 88 80 	addx %d8,%d8,128
800032be:	8b 09 a0 90 	addc %d9,%d9,0
800032c2:	8f f8 cf 81 	andn %d8,%d8,255
800032c6:	1d ff d9 ff 	j 80003278 <__divdf3+0xfe>

800032ca <__floatsidf>:
800032ca:	82 32       	mov %d2,3
800032cc:	20 18       	sub.a %sp,24
800032ce:	59 a2 04 00 	st.w [%sp]4,%d2
800032d2:	8f 14 1e 20 	sh %d2,%d4,-31
800032d6:	59 a2 08 00 	st.w [%sp]8,%d2
800032da:	df 04 0e 80 	jne %d4,0,800032f6 <__floatsidf+0x2c>
800032de:	82 22       	mov %d2,2
800032e0:	59 a2 04 00 	st.w [%sp]4,%d2
800032e4:	d9 a4 04 00 	lea %a4,[%sp]4
800032e8:	6d 00 57 00 	call 80003396 <__pack_d>
800032ec:	60 25       	mov.a %a5,%d2
800032ee:	60 34       	mov.a %a4,%d3
800032f0:	80 52       	mov.d %d2,%a5
800032f2:	80 43       	mov.d %d3,%a4
800032f4:	00 90       	ret 
800032f6:	ff 04 0a 00 	jge %d4,0,8000330a <__floatsidf+0x40>
800032fa:	7b 00 00 28 	movh %d2,32768
800032fe:	a0 05       	mov.a %a5,0
80003300:	91 00 1e 4c 	movh.a %a4,49632
80003304:	5f 24 f6 7f 	jeq %d4,%d2,800032f0 <__floatsidf+0x26>
80003308:	32 54       	rsub %d4
8000330a:	0f 04 b0 61 	clz %d6,%d4
8000330e:	1b d6 01 60 	addi %d6,%d6,29
80003312:	8f f6 01 21 	and %d2,%d6,31
80003316:	82 05       	mov %d5,0
80003318:	8b 06 82 72 	ge %d7,%d6,32
8000331c:	17 45 80 32 	dextr %d3,%d5,%d4,%d2
80003320:	0f 24 00 20 	sh %d2,%d4,%d2
80003324:	2b 23 50 37 	seln %d3,%d7,%d3,%d2
80003328:	8b c6 03 61 	rsub %d6,%d6,60
8000332c:	ab 02 a0 27 	seln %d2,%d7,%d2,0
80003330:	59 a3 14 00 	st.w [%sp]20,%d3
80003334:	59 a6 0c 00 	st.w [%sp]12,%d6
80003338:	59 a2 10 00 	st.w [%sp]16,%d2
8000333c:	1d ff d4 ff 	j 800032e4 <__floatsidf+0x1a>

80003340 <__truncdfsf2>:
80003340:	20 20       	sub.a %sp,32
80003342:	d9 a5 0c 00 	lea %a5,[%sp]12
80003346:	d9 a4 04 00 	lea %a4,[%sp]4
8000334a:	89 a4 44 09 	st.d [%sp]4,%e4
8000334e:	6d 00 f3 00 	call 80003534 <__unpack_d>
80003352:	19 a3 18 00 	ld.w %d3,[%sp]24
80003356:	19 a2 1c 00 	ld.w %d2,[%sp]28
8000335a:	77 32 00 21 	dextr %d2,%d2,%d3,2
8000335e:	b7 03 02 3f 	insert %d3,%d3,0,30,2
80003362:	02 27       	mov %d7,%d2
80003364:	df 03 04 00 	jeq %d3,0,8000336c <__truncdfsf2+0x2c>
80003368:	8f 12 40 71 	or %d7,%d2,1
8000336c:	19 a6 14 00 	ld.w %d6,[%sp]20
80003370:	19 a5 10 00 	ld.w %d5,[%sp]16
80003374:	19 a4 0c 00 	ld.w %d4,[%sp]12
80003378:	6d 00 03 00 	call 8000337e <__make_fp>
8000337c:	00 90       	ret 

8000337e <__make_fp>:
8000337e:	20 10       	sub.a %sp,16
80003380:	40 a4       	mov.aa %a4,%sp
80003382:	74 a4       	st.w [%sp],%d4
80003384:	59 a5 04 00 	st.w [%sp]4,%d5
80003388:	59 a6 08 00 	st.w [%sp]8,%d6
8000338c:	59 a7 0c 00 	st.w [%sp]12,%d7
80003390:	6d 00 31 01 	call 800035f2 <__pack_f>
80003394:	00 90       	ret 

80003396 <__pack_d>:
80003396:	54 44       	ld.w %d4,[%a4]
80003398:	19 43 0c 00 	ld.w %d3,[%a4]12
8000339c:	19 42 10 00 	ld.w %d2,[%a4]16
800033a0:	19 41 04 00 	ld.w %d1,[%a4]4
800033a4:	bf 24 56 80 	jlt.u %d4,2,80003450 <__pack_d+0xba>
800033a8:	7b 00 ff 57 	movh %d5,32752
800033ac:	d2 06       	mov %e6,0
800033ae:	df 44 0b 00 	jeq %d4,4,800033c4 <__pack_d+0x2e>
800033b2:	0f 23 a0 50 	or %d5,%d3,%d2
800033b6:	8b 05 00 02 	eq %d0,%d5,0
800033ba:	8b 24 e0 04 	or.eq %d0,%d4,2
800033be:	82 05       	mov %d5,0
800033c0:	df 00 0c 00 	jeq %d0,0,800033d8 <__pack_d+0x42>
800033c4:	0b 10 00 28 	mov %e2,%d1
800033c8:	a6 75       	or %d5,%d7
800033ca:	8f f2 01 20 	sh %d2,%d2,31
800033ce:	0f 25 a0 40 	or %d4,%d5,%d2
800033d2:	02 43       	mov %d3,%d4
800033d4:	02 62       	mov %d2,%d6
800033d6:	00 90       	ret 
800033d8:	19 44 08 00 	ld.w %d4,[%a4]8
800033dc:	3b 20 c0 0f 	mov %d0,-1022
800033e0:	3f 04 41 00 	jlt %d4,%d0,80003462 <__pack_d+0xcc>
800033e4:	3b 00 40 00 	mov %d0,1024
800033e8:	7b 00 ff 57 	movh %d5,32752
800033ec:	7f 04 ec 7f 	jge %d4,%d0,800033c4 <__pack_d+0x2e>
800033f0:	8f f3 0f 51 	and %d5,%d3,255
800033f4:	8b 05 28 52 	ne %d5,%d5,128
800033f8:	df 05 1b 00 	jeq %d5,0,8000342e <__pack_d+0x98>
800033fc:	8b f3 87 30 	addx %d3,%d3,127
80003400:	8b 02 a0 20 	addc %d2,%d2,0
80003404:	7b 00 00 52 	movh %d5,8192
80003408:	0b 25 30 61 	lt.u %d6,%d5,%d2
8000340c:	0b 25 70 62 	or.eq %d6,%d5,%d2
80003410:	df 06 19 80 	jne %d6,0,80003442 <__pack_d+0xac>
80003414:	1b f4 3f 40 	addi %d4,%d4,1023
80003418:	0b 40 00 48 	mov %e4,%d4
8000341c:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80003420:	06 82       	sh %d2,-8
80003422:	b7 02 0c 7a 	insert %d7,%d2,0,20,12
80003426:	8f 44 01 50 	sh %d5,%d4,20
8000342a:	1d ff cd ff 	j 800033c4 <__pack_d+0x2e>
8000342e:	8f 03 10 51 	and %d5,%d3,256
80003432:	df 05 e9 7f 	jeq %d5,0,80003404 <__pack_d+0x6e>
80003436:	8b 03 88 30 	addx %d3,%d3,128
8000343a:	8b 02 a0 20 	addc %d2,%d2,0
8000343e:	1d ff e3 ff 	j 80003404 <__pack_d+0x6e>
80003442:	77 32 80 3f 	dextr %d3,%d2,%d3,31
80003446:	1b 04 40 40 	addi %d4,%d4,1024
8000344a:	06 f2       	sh %d2,-1
8000344c:	1d ff e6 ff 	j 80003418 <__pack_d+0x82>
80003450:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80003454:	06 82       	sh %d2,-8
80003456:	b7 12 8d 79 	insert %d7,%d2,1,19,13
8000345a:	7b 00 ff 57 	movh %d5,32752
8000345e:	1d ff b3 ff 	j 800033c4 <__pack_d+0x2e>
80003462:	0b 40 80 40 	sub %d4,%d0,%d4
80003466:	8b 94 83 02 	ge %d0,%d4,57
8000346a:	df 00 ad ff 	jne %d0,0,800033c4 <__pack_d+0x2e>
8000346e:	8b 04 82 52 	ge %d5,%d4,32
80003472:	2b 23 50 05 	seln %d0,%d5,%d3,%d2
80003476:	ab 02 a0 75 	seln %d7,%d5,%d2,0
8000347a:	8f f4 01 51 	and %d5,%d4,31
8000347e:	8b 05 02 61 	rsub %d6,%d5,32
80003482:	17 07 80 66 	dextr %d6,%d7,%d0,%d6
80003486:	2b 06 40 65 	sel %d6,%d5,%d6,%d0
8000348a:	8b 04 82 82 	ge %d8,%d4,32
8000348e:	32 55       	rsub %d5
80003490:	02 60       	mov %d0,%d6
80003492:	8f f4 01 41 	and %d4,%d4,31
80003496:	82 f6       	mov %d6,-1
80003498:	0f 57 00 70 	sh %d7,%d7,%d5
8000349c:	17 66 80 54 	dextr %d5,%d6,%d6,%d4
800034a0:	0f 46 00 40 	sh %d4,%d6,%d4
800034a4:	2b 45 50 58 	seln %d5,%d8,%d5,%d4
800034a8:	ab 04 a0 48 	seln %d4,%d8,%d4,0
800034ac:	0f 43 e0 30 	andn %d3,%d3,%d4
800034b0:	0f 52 e0 20 	andn %d2,%d2,%d5
800034b4:	a6 32       	or %d2,%d3
800034b6:	02 03       	mov %d3,%d0
800034b8:	8b 02 00 35 	or.ne %d3,%d2,0
800034bc:	8f f3 0f 51 	and %d5,%d3,255
800034c0:	82 12       	mov %d2,1
800034c2:	8b 05 08 24 	and.eq %d2,%d5,128
800034c6:	02 74       	mov %d4,%d7
800034c8:	df 02 14 80 	jne %d2,0,800034f0 <__pack_d+0x15a>
800034cc:	8b f3 87 30 	addx %d3,%d3,127
800034d0:	8b 07 a0 20 	addc %d2,%d7,0
800034d4:	77 32 00 6c 	dextr %d6,%d2,%d3,24
800034d8:	7b 00 00 31 	movh %d3,4096
800034dc:	8f 82 1f 70 	sh %d7,%d2,-8
800034e0:	0b 32 50 21 	ge.u %d2,%d2,%d3
800034e4:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
800034e8:	8f 42 01 50 	sh %d5,%d2,20
800034ec:	1d ff 6c ff 	j 800033c4 <__pack_d+0x2e>
800034f0:	8b 03 88 60 	addx %d6,%d3,128
800034f4:	8b 07 a0 20 	addc %d2,%d7,0
800034f8:	7b 00 00 a1 	movh %d10,4096
800034fc:	8f 82 1f 70 	sh %d7,%d2,-8
80003500:	77 62 00 6c 	dextr %d6,%d2,%d6,24
80003504:	0b a2 50 21 	ge.u %d2,%d2,%d10
80003508:	53 12 40 80 	mul.u %e8,%d2,1
8000350c:	8f 03 10 01 	and %d0,%d3,256
80003510:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
80003514:	8f 48 01 50 	sh %d5,%d8,20
80003518:	df 00 56 ff 	jne %d0,0,800033c4 <__pack_d+0x2e>
8000351c:	8f 84 1f 70 	sh %d7,%d4,-8
80003520:	0b a4 50 21 	ge.u %d2,%d4,%d10
80003524:	77 34 00 6c 	dextr %d6,%d4,%d3,24
80003528:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
8000352c:	8f 42 01 50 	sh %d5,%d2,20
80003530:	1d ff 4a ff 	j 800033c4 <__pack_d+0x2e>

80003534 <__unpack_d>:
80003534:	09 48 40 09 	ld.d %e8,[%a4]
80003538:	3b f0 7f 00 	mov %d0,2047
8000353c:	8f 19 1e 70 	sh %d7,%d9,-31
80003540:	37 09 6b 5a 	extr.u %d5,%d9,20,11
80003544:	b7 09 0c 6a 	insert %d6,%d9,0,20,12
80003548:	59 57 04 00 	st.w [%a5]4,%d7
8000354c:	df 05 26 80 	jne %d5,0,80003598 <__unpack_d+0x64>
80003550:	8b 08 20 22 	ne %d2,%d8,0
80003554:	8b 06 00 25 	or.ne %d2,%d6,0
80003558:	df 02 33 00 	jeq %d2,0,800035be <__unpack_d+0x8a>
8000355c:	82 32       	mov %d2,3
8000355e:	77 86 00 34 	dextr %d3,%d6,%d8,8
80003562:	8f 88 00 40 	sh %d4,%d8,8
80003566:	74 52       	st.w [%a5],%d2
80003568:	3b 10 c0 5f 	mov %d5,-1023
8000356c:	7b 00 00 61 	movh %d6,4096
80003570:	77 43 80 30 	dextr %d3,%d3,%d4,1
80003574:	02 57       	mov %d7,%d5
80003576:	0b 63 00 21 	eq %d2,%d3,%d6
8000357a:	b7 02 01 20 	insert %d2,%d2,0,0,1
8000357e:	06 14       	sh %d4,1
80003580:	0b 63 a0 22 	or.lt.u %d2,%d3,%d6
80003584:	c2 f5       	add %d5,-1
80003586:	df 02 f5 ff 	jne %d2,0,80003570 <__unpack_d+0x3c>
8000358a:	59 57 08 00 	st.w [%a5]8,%d7
8000358e:	59 54 0c 00 	st.w [%a5]12,%d4
80003592:	59 53 10 00 	st.w [%a5]16,%d3
80003596:	00 90       	ret 
80003598:	5f 05 16 00 	jeq %d5,%d0,800035c4 <__unpack_d+0x90>
8000359c:	82 32       	mov %d2,3
8000359e:	1b 15 c0 5f 	addi %d5,%d5,-1023
800035a2:	8f 88 00 40 	sh %d4,%d8,8
800035a6:	74 52       	st.w [%a5],%d2
800035a8:	77 86 00 24 	dextr %d2,%d6,%d8,8
800035ac:	59 55 08 00 	st.w [%a5]8,%d5
800035b0:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
800035b4:	59 54 0c 00 	st.w [%a5]12,%d4
800035b8:	59 52 10 00 	st.w [%a5]16,%d2
800035bc:	00 90       	ret 
800035be:	82 22       	mov %d2,2
800035c0:	74 52       	st.w [%a5],%d2
800035c2:	00 90       	ret 
800035c4:	8b 08 20 52 	ne %d5,%d8,0
800035c8:	8b 06 00 55 	or.ne %d5,%d6,0
800035cc:	df 05 05 80 	jne %d5,0,800035d6 <__unpack_d+0xa2>
800035d0:	82 42       	mov %d2,4
800035d2:	74 52       	st.w [%a5],%d2
800035d4:	00 90       	ret 
800035d6:	77 89 00 34 	dextr %d3,%d9,%d8,8
800035da:	37 09 e1 49 	extr.u %d4,%d9,19,1
800035de:	b7 03 85 3d 	insert %d3,%d3,0,27,5
800035e2:	8f 88 00 20 	sh %d2,%d8,8
800035e6:	74 54       	st.w [%a5],%d4
800035e8:	59 52 0c 00 	st.w [%a5]12,%d2
800035ec:	59 53 10 00 	st.w [%a5]16,%d3
800035f0:	00 90       	ret 

800035f2 <__pack_f>:
800035f2:	54 44       	ld.w %d4,[%a4]
800035f4:	19 43 0c 00 	ld.w %d3,[%a4]12
800035f8:	19 47 04 00 	ld.w %d7,[%a4]4
800035fc:	bf 24 3f 80 	jlt.u %d4,2,8000367a <__pack_f+0x88>
80003600:	7b 00 f8 57 	movh %d5,32640
80003604:	82 06       	mov %d6,0
80003606:	df 44 09 00 	jeq %d4,4,80003618 <__pack_f+0x26>
8000360a:	8b 03 00 22 	eq %d2,%d3,0
8000360e:	8b 24 e0 24 	or.eq %d2,%d4,2
80003612:	82 05       	mov %d5,0
80003614:	df 02 08 00 	jeq %d2,0,80003624 <__pack_f+0x32>
80003618:	8f f7 01 70 	sh %d7,%d7,31
8000361c:	0f 56 a0 20 	or %d2,%d6,%d5
80003620:	a6 72       	or %d2,%d7
80003622:	00 90       	ret 
80003624:	19 42 08 00 	ld.w %d2,[%a4]8
80003628:	8b 22 98 42 	ge %d4,%d2,-126
8000362c:	df 04 33 00 	jeq %d4,0,80003692 <__pack_f+0xa0>
80003630:	8b 02 88 42 	ge %d4,%d2,128
80003634:	7b 00 f8 57 	movh %d5,32640
80003638:	df 04 f0 ff 	jne %d4,0,80003618 <__pack_f+0x26>
8000363c:	8f f3 07 51 	and %d5,%d3,127
80003640:	8f 03 08 41 	and %d4,%d3,128
80003644:	8b 05 24 52 	ne %d5,%d5,64
80003648:	ab 03 04 44 	cadd %d4,%d4,%d3,64
8000364c:	1b f3 03 30 	addi %d3,%d3,63
80003650:	2b 43 40 35 	sel %d3,%d5,%d3,%d4
80003654:	1b f2 07 50 	addi %d5,%d2,127
80003658:	bf 03 0c 00 	jlt %d3,0,80003670 <__pack_f+0x7e>
8000365c:	37 03 f7 63 	extr.u %d6,%d3,7,23
80003660:	8f 75 01 50 	sh %d5,%d5,23
80003664:	8f f7 01 70 	sh %d7,%d7,31
80003668:	0f 56 a0 20 	or %d2,%d6,%d5
8000366c:	a6 72       	or %d2,%d7
8000366e:	00 90       	ret 
80003670:	06 f3       	sh %d3,-1
80003672:	1b 02 08 50 	addi %d5,%d2,128
80003676:	1d ff f3 ff 	j 8000365c <__pack_f+0x6a>
8000367a:	37 03 f6 33 	extr.u %d3,%d3,7,22
8000367e:	7b 00 f8 57 	movh %d5,32640
80003682:	b7 f3 01 6b 	insert %d6,%d3,15,22,1
80003686:	8f f7 01 70 	sh %d7,%d7,31
8000368a:	0f 56 a0 20 	or %d2,%d6,%d5
8000368e:	a6 72       	or %d2,%d7
80003690:	00 90       	ret 
80003692:	8b 22 18 21 	rsub %d2,%d2,-126
80003696:	8b a2 81 42 	ge %d4,%d2,26
8000369a:	df 04 bf ff 	jne %d4,0,80003618 <__pack_f+0x26>
8000369e:	82 f5       	mov %d5,-1
800036a0:	8b 02 00 41 	rsub %d4,%d2,0
800036a4:	0f 25 00 20 	sh %d2,%d5,%d2
800036a8:	0f 43 00 40 	sh %d4,%d3,%d4
800036ac:	0f 23 e0 30 	andn %d3,%d3,%d2
800036b0:	8b 03 00 45 	or.ne %d4,%d3,0
800036b4:	8f f4 07 31 	and %d3,%d4,127
800036b8:	8b 03 04 32 	eq %d3,%d3,64
800036bc:	df 03 0e 80 	jne %d3,0,800036d8 <__pack_f+0xe6>
800036c0:	1b f4 03 20 	addi %d2,%d4,63
800036c4:	7b 00 00 34 	movh %d3,16384
800036c8:	37 02 f7 63 	extr.u %d6,%d2,7,23
800036cc:	0b 32 50 21 	ge.u %d2,%d2,%d3
800036d0:	8f 72 01 50 	sh %d5,%d2,23
800036d4:	1d ff a2 ff 	j 80003618 <__pack_f+0x26>
800036d8:	1b 04 04 30 	addi %d3,%d4,64
800036dc:	7b 00 00 24 	movh %d2,16384
800036e0:	37 03 f7 63 	extr.u %d6,%d3,7,23
800036e4:	0b 23 50 31 	ge.u %d3,%d3,%d2
800036e8:	8f 73 01 50 	sh %d5,%d3,23
800036ec:	6f 74 96 ff 	jnz.t %d4,7,80003618 <__pack_f+0x26>
800036f0:	0b 24 50 21 	ge.u %d2,%d4,%d2
800036f4:	37 04 f7 63 	extr.u %d6,%d4,7,23
800036f8:	8f 72 01 50 	sh %d5,%d2,23
800036fc:	1d ff 8e ff 	j 80003618 <__pack_f+0x26>

80003700 <__do_global_ctors_aux>:
80003700:	91 00 00 28 	movh.a %a2,32768
80003704:	d9 22 48 d3 	lea %a2,[%a2]14152 <80003748 <__CTOR_END__>>
80003708:	19 22 fc ff 	ld.w %d2,[%a2]-4 <7ffffffc <__CSA0_END+0xffe43fc>>
8000370c:	d9 23 fc ff 	lea %a3,[%a2]-4 <7ffffffc <__CSA0_END+0xffe43fc>>
80003710:	df f2 0a 00 	jeq %d2,-1,80003724 <__do_global_ctors_aux+0x24>
80003714:	40 3c       	mov.aa %a12,%a3
80003716:	60 22       	mov.a %a2,%d2
80003718:	b0 cc       	add.a %a12,-4
8000371a:	2d 02 00 00 	calli %a2
8000371e:	54 c2       	ld.w %d2,[%a12]
80003720:	df f2 fb ff 	jne %d2,-1,80003716 <__do_global_ctors_aux+0x16>
80003724:	00 90       	ret 
	...

Disassembly of section .init:

80003728 <_init>:
80003728:	6d ff 34 e7 	call 80000590 <frame_dummy>
8000372c:	6d ff ea ff 	call 80003700 <__do_global_ctors_aux>
80003730:	00 90       	ret 
80003732:	00 00       	nop 
80003734:	00 00       	nop 
	...

Disassembly of section .fini:

80003738 <_fini>:
80003738:	6d ff fa e6 	call 8000052c <__do_global_dtors_aux>
8000373c:	00 90       	ret 
	...

Disassembly of section .traptab_tc2:

801f6100 <IfxCpu_Trap_vectorTable2>:
#pragma ghs section text=".traptab_cpu2"
#endif

void IfxCpu_Trap_vectorTable2(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6100:	0d 00 00 02 	svlcx 
801f6104:	02 f4       	mov %d4,%d15
801f6106:	91 00 00 28 	movh.a %a2,32768
801f610a:	d9 22 1e 52 	lea %a2,[%a2]8542 <8000215e <IfxCpu_Trap_memoryManagementError>>
801f610e:	dc 02       	ji %a2
801f6110:	00 80       	rfe 
	...
801f611e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6120:	0d 00 00 02 	svlcx 
801f6124:	02 f4       	mov %d4,%d15
801f6126:	91 00 00 28 	movh.a %a2,32768
801f612a:	d9 22 0c 62 	lea %a2,[%a2]8588 <8000218c <IfxCpu_Trap_internalProtectionError>>
801f612e:	dc 02       	ji %a2
801f6130:	00 80       	rfe 
	...
801f613e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6140:	0d 00 00 02 	svlcx 
801f6144:	02 f4       	mov %d4,%d15
801f6146:	91 00 00 28 	movh.a %a2,32768
801f614a:	d9 22 3a 62 	lea %a2,[%a2]8634 <800021ba <IfxCpu_Trap_instructionError>>
801f614e:	dc 02       	ji %a2
801f6150:	00 80       	rfe 
	...
801f615e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6160:	02 f4       	mov %d4,%d15
801f6162:	91 00 00 28 	movh.a %a2,32768
801f6166:	d9 22 28 72 	lea %a2,[%a2]8680 <800021e8 <IfxCpu_Trap_contextManagementError>>
801f616a:	dc 02       	ji %a2
801f616c:	00 80       	rfe 
	...
801f617e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6180:	0d 00 00 02 	svlcx 
801f6184:	02 f4       	mov %d4,%d15
801f6186:	91 00 00 28 	movh.a %a2,32768
801f618a:	d9 22 16 82 	lea %a2,[%a2]8726 <80002216 <IfxCpu_Trap_busError>>
801f618e:	dc 02       	ji %a2
801f6190:	00 80       	rfe 
	...
801f619e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f61a0:	0d 00 00 02 	svlcx 
801f61a4:	02 f4       	mov %d4,%d15
801f61a6:	91 00 00 28 	movh.a %a2,32768
801f61aa:	d9 22 04 92 	lea %a2,[%a2]8772 <80002244 <IfxCpu_Trap_assertion>>
801f61ae:	dc 02       	ji %a2
801f61b0:	00 80       	rfe 
	...
801f61be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu2);
801f61c0:	0d 00 00 02 	svlcx 
801f61c4:	02 f4       	mov %d4,%d15
801f61c6:	91 00 00 28 	movh.a %a2,32768
801f61ca:	d9 22 10 b2 	lea %a2,[%a2]8912 <800022d0 <IfxCpu_Trap_systemCall_Cpu2>>
801f61ce:	dc 02       	ji %a2
801f61d0:	00 80       	rfe 
	...
801f61de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f61e0:	0d 00 00 02 	svlcx 
801f61e4:	02 f4       	mov %d4,%d15
801f61e6:	91 00 00 28 	movh.a %a2,32768
801f61ea:	d9 22 3c b2 	lea %a2,[%a2]8956 <800022fc <IfxCpu_Trap_nonMaskableInterrupt>>
801f61ee:	dc 02       	ji %a2
801f61f0:	00 80       	rfe 
}
801f61f2:	00 90       	ret 

801f61f4 <IfxCpu_Trap_vectorTable2_end>:
	...

Disassembly of section .traptab_tc1:

801f6200 <IfxCpu_Trap_vectorTable1>:
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6200:	0d 00 00 02 	svlcx 
801f6204:	02 f4       	mov %d4,%d15
801f6206:	91 00 00 28 	movh.a %a2,32768
801f620a:	d9 22 1e 52 	lea %a2,[%a2]8542 <8000215e <IfxCpu_Trap_memoryManagementError>>
801f620e:	dc 02       	ji %a2
801f6210:	00 80       	rfe 
	...
801f621e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6220:	0d 00 00 02 	svlcx 
801f6224:	02 f4       	mov %d4,%d15
801f6226:	91 00 00 28 	movh.a %a2,32768
801f622a:	d9 22 0c 62 	lea %a2,[%a2]8588 <8000218c <IfxCpu_Trap_internalProtectionError>>
801f622e:	dc 02       	ji %a2
801f6230:	00 80       	rfe 
	...
801f623e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6240:	0d 00 00 02 	svlcx 
801f6244:	02 f4       	mov %d4,%d15
801f6246:	91 00 00 28 	movh.a %a2,32768
801f624a:	d9 22 3a 62 	lea %a2,[%a2]8634 <800021ba <IfxCpu_Trap_instructionError>>
801f624e:	dc 02       	ji %a2
801f6250:	00 80       	rfe 
	...
801f625e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6260:	02 f4       	mov %d4,%d15
801f6262:	91 00 00 28 	movh.a %a2,32768
801f6266:	d9 22 28 72 	lea %a2,[%a2]8680 <800021e8 <IfxCpu_Trap_contextManagementError>>
801f626a:	dc 02       	ji %a2
801f626c:	00 80       	rfe 
	...
801f627e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6280:	0d 00 00 02 	svlcx 
801f6284:	02 f4       	mov %d4,%d15
801f6286:	91 00 00 28 	movh.a %a2,32768
801f628a:	d9 22 16 82 	lea %a2,[%a2]8726 <80002216 <IfxCpu_Trap_busError>>
801f628e:	dc 02       	ji %a2
801f6290:	00 80       	rfe 
	...
801f629e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f62a0:	0d 00 00 02 	svlcx 
801f62a4:	02 f4       	mov %d4,%d15
801f62a6:	91 00 00 28 	movh.a %a2,32768
801f62aa:	d9 22 04 92 	lea %a2,[%a2]8772 <80002244 <IfxCpu_Trap_assertion>>
801f62ae:	dc 02       	ji %a2
801f62b0:	00 80       	rfe 
	...
801f62be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu1);
801f62c0:	0d 00 00 02 	svlcx 
801f62c4:	02 f4       	mov %d4,%d15
801f62c6:	91 00 00 28 	movh.a %a2,32768
801f62ca:	d9 22 24 a2 	lea %a2,[%a2]8868 <800022a4 <IfxCpu_Trap_systemCall_Cpu1>>
801f62ce:	dc 02       	ji %a2
801f62d0:	00 80       	rfe 
	...
801f62de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f62e0:	0d 00 00 02 	svlcx 
801f62e4:	02 f4       	mov %d4,%d15
801f62e6:	91 00 00 28 	movh.a %a2,32768
801f62ea:	d9 22 3c b2 	lea %a2,[%a2]8956 <800022fc <IfxCpu_Trap_nonMaskableInterrupt>>
801f62ee:	dc 02       	ji %a2
801f62f0:	00 80       	rfe 
}
801f62f2:	00 90       	ret 

801f62f4 <IfxCpu_Trap_vectorTable1_end>:
	...

Disassembly of section .inttab_tc0_01E:

801f43c0 <__intvec_tc0_30>:
801f43c0:	0d 00 00 02 	svlcx 
801f43c4:	91 00 00 e8 	movh.a %a14,32768
801f43c8:	d9 ee f8 e2 	lea %a14,[%a14]12216 <80002fb8 <ISR_CAN_RX>>
801f43cc:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_064:

801f4c80 <__intvec_tc0_100>:
801f4c80:	0d 00 00 02 	svlcx 
801f4c84:	91 00 00 e8 	movh.a %a14,32768
801f4c88:	d9 ee 78 90 	lea %a14,[%a14]1656 <80000678 <ISR_STM>>
801f4c8c:	dc 0e       	ji %a14
