
Team_Project.elf:     file format elf32-tricore

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bmhd_0       00000020  80000000  80000000  00000314  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .bmhd_1       00000020  80020000  80020000  000085b8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .startup      00000010  80000020  80000020  00000334  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .interface_const 00000000  80000040  80000040  00008e08  2**0
                  CONTENTS
  4 .traptab_tc0  00000100  80000100  80000100  00000360  2**5
                  CONTENTS, ALLOC, LOAD, CODE
  5 .rodata       00000418  80000200  80000200  00000460  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .CPU2.zbss    00000000  50000000  50000000  00008e08  2**0
                  CONTENTS
  7 .CPU2.bss     00000000  50000000  50000000  00008e08  2**0
                  CONTENTS
  8 .CPU1.zbss    00000000  60000000  60000000  00008e08  2**0
                  CONTENTS
  9 .CPU1.bss     00000000  60001df4  60001df4  00008e08  2**0
                  CONTENTS
 10 .CPU0.zbss    00000000  70000000  70000000  00008e08  2**0
                  CONTENTS
 11 .CPU0.bss     00000000  70000000  70000000  00008e08  2**0
                  CONTENTS
 12 .zbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC
 13 .sbss         00000000  60000000  801f6300  00000000  2**0
                  ALLOC, SMALL_DATA
 14 .bss          0000084c  600005a8  801f68a8  00008e08  2**3
                  ALLOC
 15 .CPU2.zdata   00000000  50000000  50000000  00008e08  2**0
                  CONTENTS
 16 .CPU2.data    00000000  50000000  50000000  00008e08  2**0
                  CONTENTS
 17 .CPU1.zdata   00000000  60000000  60000000  00008e08  2**0
                  CONTENTS
 18 .CPU1.data    00000000  60001df4  60001df4  00008e08  2**0
                  CONTENTS
 19 .CPU0.zdata   00000000  70000000  70000000  00008e08  2**0
                  CONTENTS
 20 .CPU0.data    00000000  70000000  70000000  00008e08  2**0
                  CONTENTS
 21 .zdata        00000000  60000000  801f68a8  00008e08  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 22 .sdata        00000000  60000000  801f68a8  00008e08  2**0
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
 23 .data         000005a8  60000000  801f6300  00008860  2**3
                  CONTENTS, ALLOC, LOAD, DATA
 24 .lmu_zdata    00000000  90000000  90000000  00008e08  2**0
                  CONTENTS
 25 .lmu_sdata    00000000  90000000  90000000  00008e08  2**0
                  CONTENTS
 26 .lmu_data     00000000  90000000  90000000  00008e08  2**0
                  CONTENTS
 27 .CPU0.psram_text 00000000  70100000  70100000  00008e08  2**0
                  CONTENTS
 28 .CPU1.psram_text 00000000  60100000  60100000  00008e08  2**0
                  CONTENTS
 29 .CPU2.psram_text 00000000  50100000  50100000  00008e08  2**0
                  CONTENTS
 30 .text         00007d0c  80000618  80000618  00000878  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 31 .init         0000000c  80008324  80008324  00008584  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 32 .fini         00000008  80008330  80008330  00008590  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 33 .eh_frame     00000000  80008338  80008338  00008e08  2**0
                  CONTENTS
 34 .gcc_except_table 00000000  80008338  80008338  00008e08  2**0
                  CONTENTS
 35 .ctors        00000010  80008338  80008338  00008598  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 36 .dtors        00000010  80008348  80008348  000085a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 37 .traptab_tc2  00000100  801f6100  801f6100  00008660  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 38 .traptab_tc1  00000100  801f6200  801f6200  00008760  2**5
                  CONTENTS, ALLOC, LOAD, CODE
 39 .heap         00001000  60000df4  801f68a8  00008e08  2**0
                  ALLOC
 40 .CPU2.ustack  00000800  5001ae00  5001ae00  00000314  2**0
                  ALLOC
 41 .CPU2.istack  00000400  5001b700  5001b700  00000314  2**0
                  ALLOC
 42 .CPU2.csa     00002000  5001bc00  5001bc00  00000314  2**0
                  ALLOC
 43 .CPU1.ustack  00000800  6001ae00  6001ae00  00000314  2**0
                  ALLOC
 44 .CPU1.istack  00000400  6001b700  6001b700  00000314  2**0
                  ALLOC
 45 .CPU1.csa     00002000  6001bc00  6001bc00  00000314  2**0
                  ALLOC
 46 .CPU0.ustack  00000800  70018e00  70018e00  00000314  2**0
                  ALLOC
 47 .CPU0.istack  00000400  70019700  70019700  00000314  2**0
                  ALLOC
 48 .CPU0.csa     00002000  70019c00  70019c00  00000314  2**0
                  ALLOC
 49 .inttab_tc0_000 00000000  801f4000  801f4000  00008e08  2**0
                  CONTENTS
 50 .inttab_tc0_001 00000000  801f4020  801f4020  00008e08  2**0
                  CONTENTS
 51 .inttab_tc0_002 00000000  801f4040  801f4040  00008e08  2**0
                  CONTENTS
 52 .inttab_tc0_003 00000000  801f4060  801f4060  00008e08  2**0
                  CONTENTS
 53 .inttab_tc0_004 0000000e  801f4080  801f4080  000085d8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 54 .inttab_tc0_005 0000000e  801f40a0  801f40a0  000085e6  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 55 .inttab_tc0_006 00000000  801f40c0  801f40c0  00008e08  2**0
                  CONTENTS
 56 .inttab_tc0_007 00000000  801f40e0  801f40e0  00008e08  2**0
                  CONTENTS
 57 .inttab_tc0_008 0000000e  801f4100  801f4100  000085f4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 58 .inttab_tc0_009 0000000e  801f4120  801f4120  00008602  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 59 .inttab_tc0_00A 00000000  801f4140  801f4140  00008e08  2**0
                  CONTENTS
 60 .inttab_tc0_00B 00000000  801f4160  801f4160  00008e08  2**0
                  CONTENTS
 61 .inttab_tc0_00C 0000000e  801f4180  801f4180  00008610  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 62 .inttab_tc0_00D 0000000e  801f41a0  801f41a0  0000861e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
 63 .inttab_tc0_00E 00000000  801f41c0  801f41c0  00008e08  2**0
                  CONTENTS
 64 .inttab_tc0_00F 00000000  801f41e0  801f41e0  00008e08  2**0
                  CONTENTS
 65 .inttab_tc0_010 00000000  801f4200  801f4200  00008e08  2**0
                  CONTENTS
 66 .inttab_tc0_011 00000000  801f4220  801f4220  00008e08  2**0
                  CONTENTS
 67 .inttab_tc0_012 00000000  801f4240  801f4240  00008e08  2**0
                  CONTENTS
 68 .inttab_tc0_013 00000000  801f4260  801f4260  00008e08  2**0
                  CONTENTS
 69 .inttab_tc0_014 00000000  801f4280  801f4280  00008e08  2**0
                  CONTENTS
 70 .inttab_tc0_015 00000000  801f42a0  801f42a0  00008e08  2**0
                  CONTENTS
 71 .inttab_tc0_016 00000000  801f42c0  801f42c0  00008e08  2**0
                  CONTENTS
 72 .inttab_tc0_017 00000000  801f42e0  801f42e0  00008e08  2**0
                  CONTENTS
 73 .inttab_tc0_018 00000000  801f4300  801f4300  00008e08  2**0
                  CONTENTS
 74 .inttab_tc0_019 00000000  801f4320  801f4320  00008e08  2**0
                  CONTENTS
 75 .inttab_tc0_01A 00000000  801f4340  801f4340  00008e08  2**0
                  CONTENTS
 76 .inttab_tc0_01B 00000000  801f4360  801f4360  00008e08  2**0
                  CONTENTS
 77 .inttab_tc0_01C 00000000  801f4380  801f4380  00008e08  2**0
                  CONTENTS
 78 .inttab_tc0_01D 00000000  801f43a0  801f43a0  00008e08  2**0
                  CONTENTS
 79 .inttab_tc0_01E 00000000  801f43c0  801f43c0  00008e08  2**0
                  CONTENTS
 80 .inttab_tc0_01F 00000000  801f43e0  801f43e0  00008e08  2**0
                  CONTENTS
 81 .inttab_tc0_020 00000000  801f4400  801f4400  00008e08  2**0
                  CONTENTS
 82 .inttab_tc0_021 00000000  801f4420  801f4420  00008e08  2**0
                  CONTENTS
 83 .inttab_tc0_022 00000000  801f4440  801f4440  00008e08  2**0
                  CONTENTS
 84 .inttab_tc0_023 00000000  801f4460  801f4460  00008e08  2**0
                  CONTENTS
 85 .inttab_tc0_024 00000000  801f4480  801f4480  00008e08  2**0
                  CONTENTS
 86 .inttab_tc0_025 00000000  801f44a0  801f44a0  00008e08  2**0
                  CONTENTS
 87 .inttab_tc0_026 00000000  801f44c0  801f44c0  00008e08  2**0
                  CONTENTS
 88 .inttab_tc0_027 00000000  801f44e0  801f44e0  00008e08  2**0
                  CONTENTS
 89 .inttab_tc0_028 00000000  801f4500  801f4500  00008e08  2**0
                  CONTENTS
 90 .inttab_tc0_029 00000000  801f4520  801f4520  00008e08  2**0
                  CONTENTS
 91 .inttab_tc0_02A 00000000  801f4540  801f4540  00008e08  2**0
                  CONTENTS
 92 .inttab_tc0_02B 00000000  801f4560  801f4560  00008e08  2**0
                  CONTENTS
 93 .inttab_tc0_02C 00000000  801f4580  801f4580  00008e08  2**0
                  CONTENTS
 94 .inttab_tc0_02D 00000000  801f45a0  801f45a0  00008e08  2**0
                  CONTENTS
 95 .inttab_tc0_02E 00000000  801f45c0  801f45c0  00008e08  2**0
                  CONTENTS
 96 .inttab_tc0_02F 00000000  801f45e0  801f45e0  00008e08  2**0
                  CONTENTS
 97 .inttab_tc0_030 00000000  801f4600  801f4600  00008e08  2**0
                  CONTENTS
 98 .inttab_tc0_031 00000000  801f4620  801f4620  00008e08  2**0
                  CONTENTS
 99 .inttab_tc0_032 00000000  801f4640  801f4640  00008e08  2**0
                  CONTENTS
100 .inttab_tc0_033 00000000  801f4660  801f4660  00008e08  2**0
                  CONTENTS
101 .inttab_tc0_034 00000000  801f4680  801f4680  00008e08  2**0
                  CONTENTS
102 .inttab_tc0_035 00000000  801f46a0  801f46a0  00008e08  2**0
                  CONTENTS
103 .inttab_tc0_036 00000000  801f46c0  801f46c0  00008e08  2**0
                  CONTENTS
104 .inttab_tc0_037 00000000  801f46e0  801f46e0  00008e08  2**0
                  CONTENTS
105 .inttab_tc0_038 00000000  801f4700  801f4700  00008e08  2**0
                  CONTENTS
106 .inttab_tc0_039 00000000  801f4720  801f4720  00008e08  2**0
                  CONTENTS
107 .inttab_tc0_03A 00000000  801f4740  801f4740  00008e08  2**0
                  CONTENTS
108 .inttab_tc0_03B 00000000  801f4760  801f4760  00008e08  2**0
                  CONTENTS
109 .inttab_tc0_03C 00000000  801f4780  801f4780  00008e08  2**0
                  CONTENTS
110 .inttab_tc0_03D 00000000  801f47a0  801f47a0  00008e08  2**0
                  CONTENTS
111 .inttab_tc0_03E 00000000  801f47c0  801f47c0  00008e08  2**0
                  CONTENTS
112 .inttab_tc0_03F 00000000  801f47e0  801f47e0  00008e08  2**0
                  CONTENTS
113 .inttab_tc0_040 00000000  801f4800  801f4800  00008e08  2**0
                  CONTENTS
114 .inttab_tc0_041 00000000  801f4820  801f4820  00008e08  2**0
                  CONTENTS
115 .inttab_tc0_042 00000000  801f4840  801f4840  00008e08  2**0
                  CONTENTS
116 .inttab_tc0_043 00000000  801f4860  801f4860  00008e08  2**0
                  CONTENTS
117 .inttab_tc0_044 00000000  801f4880  801f4880  00008e08  2**0
                  CONTENTS
118 .inttab_tc0_045 00000000  801f48a0  801f48a0  00008e08  2**0
                  CONTENTS
119 .inttab_tc0_046 00000000  801f48c0  801f48c0  00008e08  2**0
                  CONTENTS
120 .inttab_tc0_047 00000000  801f48e0  801f48e0  00008e08  2**0
                  CONTENTS
121 .inttab_tc0_048 00000000  801f4900  801f4900  00008e08  2**0
                  CONTENTS
122 .inttab_tc0_049 00000000  801f4920  801f4920  00008e08  2**0
                  CONTENTS
123 .inttab_tc0_04A 00000000  801f4940  801f4940  00008e08  2**0
                  CONTENTS
124 .inttab_tc0_04B 00000000  801f4960  801f4960  00008e08  2**0
                  CONTENTS
125 .inttab_tc0_04C 00000000  801f4980  801f4980  00008e08  2**0
                  CONTENTS
126 .inttab_tc0_04D 00000000  801f49a0  801f49a0  00008e08  2**0
                  CONTENTS
127 .inttab_tc0_04E 00000000  801f49c0  801f49c0  00008e08  2**0
                  CONTENTS
128 .inttab_tc0_04F 00000000  801f49e0  801f49e0  00008e08  2**0
                  CONTENTS
129 .inttab_tc0_050 00000000  801f4a00  801f4a00  00008e08  2**0
                  CONTENTS
130 .inttab_tc0_051 00000000  801f4a20  801f4a20  00008e08  2**0
                  CONTENTS
131 .inttab_tc0_052 00000000  801f4a40  801f4a40  00008e08  2**0
                  CONTENTS
132 .inttab_tc0_053 00000000  801f4a60  801f4a60  00008e08  2**0
                  CONTENTS
133 .inttab_tc0_054 00000000  801f4a80  801f4a80  00008e08  2**0
                  CONTENTS
134 .inttab_tc0_055 00000000  801f4aa0  801f4aa0  00008e08  2**0
                  CONTENTS
135 .inttab_tc0_056 00000000  801f4ac0  801f4ac0  00008e08  2**0
                  CONTENTS
136 .inttab_tc0_057 00000000  801f4ae0  801f4ae0  00008e08  2**0
                  CONTENTS
137 .inttab_tc0_058 00000000  801f4b00  801f4b00  00008e08  2**0
                  CONTENTS
138 .inttab_tc0_059 00000000  801f4b20  801f4b20  00008e08  2**0
                  CONTENTS
139 .inttab_tc0_05A 00000000  801f4b40  801f4b40  00008e08  2**0
                  CONTENTS
140 .inttab_tc0_05B 00000000  801f4b60  801f4b60  00008e08  2**0
                  CONTENTS
141 .inttab_tc0_05C 00000000  801f4b80  801f4b80  00008e08  2**0
                  CONTENTS
142 .inttab_tc0_05D 00000000  801f4ba0  801f4ba0  00008e08  2**0
                  CONTENTS
143 .inttab_tc0_05E 00000000  801f4bc0  801f4bc0  00008e08  2**0
                  CONTENTS
144 .inttab_tc0_05F 00000000  801f4be0  801f4be0  00008e08  2**0
                  CONTENTS
145 .inttab_tc0_060 00000000  801f4c00  801f4c00  00008e08  2**0
                  CONTENTS
146 .inttab_tc0_061 00000000  801f4c20  801f4c20  00008e08  2**0
                  CONTENTS
147 .inttab_tc0_062 00000000  801f4c40  801f4c40  00008e08  2**0
                  CONTENTS
148 .inttab_tc0_063 00000000  801f4c60  801f4c60  00008e08  2**0
                  CONTENTS
149 .inttab_tc0_064 0000000e  801f4c80  801f4c80  0000862c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
150 .inttab_tc0_065 00000000  801f4ca0  801f4ca0  00008e08  2**0
                  CONTENTS
151 .inttab_tc0_066 00000000  801f4cc0  801f4cc0  00008e08  2**0
                  CONTENTS
152 .inttab_tc0_067 00000000  801f4ce0  801f4ce0  00008e08  2**0
                  CONTENTS
153 .inttab_tc0_068 00000000  801f4d00  801f4d00  00008e08  2**0
                  CONTENTS
154 .inttab_tc0_069 00000000  801f4d20  801f4d20  00008e08  2**0
                  CONTENTS
155 .inttab_tc0_06A 00000000  801f4d40  801f4d40  00008e08  2**0
                  CONTENTS
156 .inttab_tc0_06B 00000000  801f4d60  801f4d60  00008e08  2**0
                  CONTENTS
157 .inttab_tc0_06C 00000000  801f4d80  801f4d80  00008e08  2**0
                  CONTENTS
158 .inttab_tc0_06D 00000000  801f4da0  801f4da0  00008e08  2**0
                  CONTENTS
159 .inttab_tc0_06E 00000000  801f4dc0  801f4dc0  00008e08  2**0
                  CONTENTS
160 .inttab_tc0_06F 00000000  801f4de0  801f4de0  00008e08  2**0
                  CONTENTS
161 .inttab_tc0_070 00000000  801f4e00  801f4e00  00008e08  2**0
                  CONTENTS
162 .inttab_tc0_071 00000000  801f4e20  801f4e20  00008e08  2**0
                  CONTENTS
163 .inttab_tc0_072 00000000  801f4e40  801f4e40  00008e08  2**0
                  CONTENTS
164 .inttab_tc0_073 00000000  801f4e60  801f4e60  00008e08  2**0
                  CONTENTS
165 .inttab_tc0_074 00000000  801f4e80  801f4e80  00008e08  2**0
                  CONTENTS
166 .inttab_tc0_075 00000000  801f4ea0  801f4ea0  00008e08  2**0
                  CONTENTS
167 .inttab_tc0_076 00000000  801f4ec0  801f4ec0  00008e08  2**0
                  CONTENTS
168 .inttab_tc0_077 00000000  801f4ee0  801f4ee0  00008e08  2**0
                  CONTENTS
169 .inttab_tc0_078 00000000  801f4f00  801f4f00  00008e08  2**0
                  CONTENTS
170 .inttab_tc0_079 00000000  801f4f20  801f4f20  00008e08  2**0
                  CONTENTS
171 .inttab_tc0_07A 00000000  801f4f40  801f4f40  00008e08  2**0
                  CONTENTS
172 .inttab_tc0_07B 00000000  801f4f60  801f4f60  00008e08  2**0
                  CONTENTS
173 .inttab_tc0_07C 00000000  801f4f80  801f4f80  00008e08  2**0
                  CONTENTS
174 .inttab_tc0_07D 00000000  801f4fa0  801f4fa0  00008e08  2**0
                  CONTENTS
175 .inttab_tc0_07E 00000000  801f4fc0  801f4fc0  00008e08  2**0
                  CONTENTS
176 .inttab_tc0_07F 00000000  801f4fe0  801f4fe0  00008e08  2**0
                  CONTENTS
177 .inttab_tc0_080 00000000  801f5000  801f5000  00008e08  2**0
                  CONTENTS
178 .inttab_tc0_081 00000000  801f5020  801f5020  00008e08  2**0
                  CONTENTS
179 .inttab_tc0_082 00000000  801f5040  801f5040  00008e08  2**0
                  CONTENTS
180 .inttab_tc0_083 00000000  801f5060  801f5060  00008e08  2**0
                  CONTENTS
181 .inttab_tc0_084 00000000  801f5080  801f5080  00008e08  2**0
                  CONTENTS
182 .inttab_tc0_085 00000000  801f50a0  801f50a0  00008e08  2**0
                  CONTENTS
183 .inttab_tc0_086 00000000  801f50c0  801f50c0  00008e08  2**0
                  CONTENTS
184 .inttab_tc0_087 00000000  801f50e0  801f50e0  00008e08  2**0
                  CONTENTS
185 .inttab_tc0_088 00000000  801f5100  801f5100  00008e08  2**0
                  CONTENTS
186 .inttab_tc0_089 00000000  801f5120  801f5120  00008e08  2**0
                  CONTENTS
187 .inttab_tc0_08A 00000000  801f5140  801f5140  00008e08  2**0
                  CONTENTS
188 .inttab_tc0_08B 00000000  801f5160  801f5160  00008e08  2**0
                  CONTENTS
189 .inttab_tc0_08C 00000000  801f5180  801f5180  00008e08  2**0
                  CONTENTS
190 .inttab_tc0_08D 00000000  801f51a0  801f51a0  00008e08  2**0
                  CONTENTS
191 .inttab_tc0_08E 00000000  801f51c0  801f51c0  00008e08  2**0
                  CONTENTS
192 .inttab_tc0_08F 00000000  801f51e0  801f51e0  00008e08  2**0
                  CONTENTS
193 .inttab_tc0_090 00000000  801f5200  801f5200  00008e08  2**0
                  CONTENTS
194 .inttab_tc0_091 00000000  801f5220  801f5220  00008e08  2**0
                  CONTENTS
195 .inttab_tc0_092 00000000  801f5240  801f5240  00008e08  2**0
                  CONTENTS
196 .inttab_tc0_093 00000000  801f5260  801f5260  00008e08  2**0
                  CONTENTS
197 .inttab_tc0_094 00000000  801f5280  801f5280  00008e08  2**0
                  CONTENTS
198 .inttab_tc0_095 00000000  801f52a0  801f52a0  00008e08  2**0
                  CONTENTS
199 .inttab_tc0_096 00000000  801f52c0  801f52c0  00008e08  2**0
                  CONTENTS
200 .inttab_tc0_097 00000000  801f52e0  801f52e0  00008e08  2**0
                  CONTENTS
201 .inttab_tc0_098 00000000  801f5300  801f5300  00008e08  2**0
                  CONTENTS
202 .inttab_tc0_099 00000000  801f5320  801f5320  00008e08  2**0
                  CONTENTS
203 .inttab_tc0_09A 00000000  801f5340  801f5340  00008e08  2**0
                  CONTENTS
204 .inttab_tc0_09B 00000000  801f5360  801f5360  00008e08  2**0
                  CONTENTS
205 .inttab_tc0_09C 00000000  801f5380  801f5380  00008e08  2**0
                  CONTENTS
206 .inttab_tc0_09D 00000000  801f53a0  801f53a0  00008e08  2**0
                  CONTENTS
207 .inttab_tc0_09E 00000000  801f53c0  801f53c0  00008e08  2**0
                  CONTENTS
208 .inttab_tc0_09F 00000000  801f53e0  801f53e0  00008e08  2**0
                  CONTENTS
209 .inttab_tc0_0A0 00000000  801f5400  801f5400  00008e08  2**0
                  CONTENTS
210 .inttab_tc0_0A1 00000000  801f5420  801f5420  00008e08  2**0
                  CONTENTS
211 .inttab_tc0_0A2 00000000  801f5440  801f5440  00008e08  2**0
                  CONTENTS
212 .inttab_tc0_0A3 00000000  801f5460  801f5460  00008e08  2**0
                  CONTENTS
213 .inttab_tc0_0A4 00000000  801f5480  801f5480  00008e08  2**0
                  CONTENTS
214 .inttab_tc0_0A5 00000000  801f54a0  801f54a0  00008e08  2**0
                  CONTENTS
215 .inttab_tc0_0A6 00000000  801f54c0  801f54c0  00008e08  2**0
                  CONTENTS
216 .inttab_tc0_0A7 00000000  801f54e0  801f54e0  00008e08  2**0
                  CONTENTS
217 .inttab_tc0_0A8 00000000  801f5500  801f5500  00008e08  2**0
                  CONTENTS
218 .inttab_tc0_0A9 00000000  801f5520  801f5520  00008e08  2**0
                  CONTENTS
219 .inttab_tc0_0AA 00000000  801f5540  801f5540  00008e08  2**0
                  CONTENTS
220 .inttab_tc0_0AB 00000000  801f5560  801f5560  00008e08  2**0
                  CONTENTS
221 .inttab_tc0_0AC 00000000  801f5580  801f5580  00008e08  2**0
                  CONTENTS
222 .inttab_tc0_0AD 00000000  801f55a0  801f55a0  00008e08  2**0
                  CONTENTS
223 .inttab_tc0_0AE 00000000  801f55c0  801f55c0  00008e08  2**0
                  CONTENTS
224 .inttab_tc0_0AF 00000000  801f55e0  801f55e0  00008e08  2**0
                  CONTENTS
225 .inttab_tc0_0B0 00000000  801f5600  801f5600  00008e08  2**0
                  CONTENTS
226 .inttab_tc0_0B1 00000000  801f5620  801f5620  00008e08  2**0
                  CONTENTS
227 .inttab_tc0_0B2 00000000  801f5640  801f5640  00008e08  2**0
                  CONTENTS
228 .inttab_tc0_0B3 00000000  801f5660  801f5660  00008e08  2**0
                  CONTENTS
229 .inttab_tc0_0B4 00000000  801f5680  801f5680  00008e08  2**0
                  CONTENTS
230 .inttab_tc0_0B5 00000000  801f56a0  801f56a0  00008e08  2**0
                  CONTENTS
231 .inttab_tc0_0B6 00000000  801f56c0  801f56c0  00008e08  2**0
                  CONTENTS
232 .inttab_tc0_0B7 00000000  801f56e0  801f56e0  00008e08  2**0
                  CONTENTS
233 .inttab_tc0_0B8 00000000  801f5700  801f5700  00008e08  2**0
                  CONTENTS
234 .inttab_tc0_0B9 00000000  801f5720  801f5720  00008e08  2**0
                  CONTENTS
235 .inttab_tc0_0BA 00000000  801f5740  801f5740  00008e08  2**0
                  CONTENTS
236 .inttab_tc0_0BB 00000000  801f5760  801f5760  00008e08  2**0
                  CONTENTS
237 .inttab_tc0_0BC 00000000  801f5780  801f5780  00008e08  2**0
                  CONTENTS
238 .inttab_tc0_0BD 00000000  801f57a0  801f57a0  00008e08  2**0
                  CONTENTS
239 .inttab_tc0_0BE 00000000  801f57c0  801f57c0  00008e08  2**0
                  CONTENTS
240 .inttab_tc0_0BF 00000000  801f57e0  801f57e0  00008e08  2**0
                  CONTENTS
241 .inttab_tc0_0C0 00000000  801f5800  801f5800  00008e08  2**0
                  CONTENTS
242 .inttab_tc0_0C1 00000000  801f5820  801f5820  00008e08  2**0
                  CONTENTS
243 .inttab_tc0_0C2 00000000  801f5840  801f5840  00008e08  2**0
                  CONTENTS
244 .inttab_tc0_0C3 00000000  801f5860  801f5860  00008e08  2**0
                  CONTENTS
245 .inttab_tc0_0C4 00000000  801f5880  801f5880  00008e08  2**0
                  CONTENTS
246 .inttab_tc0_0C5 00000000  801f58a0  801f58a0  00008e08  2**0
                  CONTENTS
247 .inttab_tc0_0C6 00000000  801f58c0  801f58c0  00008e08  2**0
                  CONTENTS
248 .inttab_tc0_0C7 00000000  801f58e0  801f58e0  00008e08  2**0
                  CONTENTS
249 .inttab_tc0_0C8 0000000e  801f5900  801f5900  0000863a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
250 .inttab_tc0_0C9 00000000  801f5920  801f5920  00008e08  2**0
                  CONTENTS
251 .inttab_tc0_0CA 00000000  801f5940  801f5940  00008e08  2**0
                  CONTENTS
252 .inttab_tc0_0CB 00000000  801f5960  801f5960  00008e08  2**0
                  CONTENTS
253 .inttab_tc0_0CC 00000000  801f5980  801f5980  00008e08  2**0
                  CONTENTS
254 .inttab_tc0_0CD 00000000  801f59a0  801f59a0  00008e08  2**0
                  CONTENTS
255 .inttab_tc0_0CE 00000000  801f59c0  801f59c0  00008e08  2**0
                  CONTENTS
256 .inttab_tc0_0CF 00000000  801f59e0  801f59e0  00008e08  2**0
                  CONTENTS
257 .inttab_tc0_0D0 00000000  801f5a00  801f5a00  00008e08  2**0
                  CONTENTS
258 .inttab_tc0_0D1 00000000  801f5a20  801f5a20  00008e08  2**0
                  CONTENTS
259 .inttab_tc0_0D2 00000000  801f5a40  801f5a40  00008e08  2**0
                  CONTENTS
260 .inttab_tc0_0D3 00000000  801f5a60  801f5a60  00008e08  2**0
                  CONTENTS
261 .inttab_tc0_0D4 00000000  801f5a80  801f5a80  00008e08  2**0
                  CONTENTS
262 .inttab_tc0_0D5 00000000  801f5aa0  801f5aa0  00008e08  2**0
                  CONTENTS
263 .inttab_tc0_0D6 00000000  801f5ac0  801f5ac0  00008e08  2**0
                  CONTENTS
264 .inttab_tc0_0D7 00000000  801f5ae0  801f5ae0  00008e08  2**0
                  CONTENTS
265 .inttab_tc0_0D8 00000000  801f5b00  801f5b00  00008e08  2**0
                  CONTENTS
266 .inttab_tc0_0D9 00000000  801f5b20  801f5b20  00008e08  2**0
                  CONTENTS
267 .inttab_tc0_0DA 00000000  801f5b40  801f5b40  00008e08  2**0
                  CONTENTS
268 .inttab_tc0_0DB 00000000  801f5b60  801f5b60  00008e08  2**0
                  CONTENTS
269 .inttab_tc0_0DC 00000000  801f5b80  801f5b80  00008e08  2**0
                  CONTENTS
270 .inttab_tc0_0DD 00000000  801f5ba0  801f5ba0  00008e08  2**0
                  CONTENTS
271 .inttab_tc0_0DE 00000000  801f5bc0  801f5bc0  00008e08  2**0
                  CONTENTS
272 .inttab_tc0_0DF 00000000  801f5be0  801f5be0  00008e08  2**0
                  CONTENTS
273 .inttab_tc0_0E0 00000000  801f5c00  801f5c00  00008e08  2**0
                  CONTENTS
274 .inttab_tc0_0E1 00000000  801f5c20  801f5c20  00008e08  2**0
                  CONTENTS
275 .inttab_tc0_0E2 00000000  801f5c40  801f5c40  00008e08  2**0
                  CONTENTS
276 .inttab_tc0_0E3 00000000  801f5c60  801f5c60  00008e08  2**0
                  CONTENTS
277 .inttab_tc0_0E4 00000000  801f5c80  801f5c80  00008e08  2**0
                  CONTENTS
278 .inttab_tc0_0E5 00000000  801f5ca0  801f5ca0  00008e08  2**0
                  CONTENTS
279 .inttab_tc0_0E6 00000000  801f5cc0  801f5cc0  00008e08  2**0
                  CONTENTS
280 .inttab_tc0_0E7 00000000  801f5ce0  801f5ce0  00008e08  2**0
                  CONTENTS
281 .inttab_tc0_0E8 00000000  801f5d00  801f5d00  00008e08  2**0
                  CONTENTS
282 .inttab_tc0_0E9 00000000  801f5d20  801f5d20  00008e08  2**0
                  CONTENTS
283 .inttab_tc0_0EA 00000000  801f5d40  801f5d40  00008e08  2**0
                  CONTENTS
284 .inttab_tc0_0EB 00000000  801f5d60  801f5d60  00008e08  2**0
                  CONTENTS
285 .inttab_tc0_0EC 00000000  801f5d80  801f5d80  00008e08  2**0
                  CONTENTS
286 .inttab_tc0_0ED 00000000  801f5da0  801f5da0  00008e08  2**0
                  CONTENTS
287 .inttab_tc0_0EE 00000000  801f5dc0  801f5dc0  00008e08  2**0
                  CONTENTS
288 .inttab_tc0_0EF 00000000  801f5de0  801f5de0  00008e08  2**0
                  CONTENTS
289 .inttab_tc0_0F0 00000000  801f5e00  801f5e00  00008e08  2**0
                  CONTENTS
290 .inttab_tc0_0F1 00000000  801f5e20  801f5e20  00008e08  2**0
                  CONTENTS
291 .inttab_tc0_0F2 00000000  801f5e40  801f5e40  00008e08  2**0
                  CONTENTS
292 .inttab_tc0_0F3 00000000  801f5e60  801f5e60  00008e08  2**0
                  CONTENTS
293 .inttab_tc0_0F4 00000000  801f5e80  801f5e80  00008e08  2**0
                  CONTENTS
294 .inttab_tc0_0F5 00000000  801f5ea0  801f5ea0  00008e08  2**0
                  CONTENTS
295 .inttab_tc0_0F6 00000000  801f5ec0  801f5ec0  00008e08  2**0
                  CONTENTS
296 .inttab_tc0_0F7 00000000  801f5ee0  801f5ee0  00008e08  2**0
                  CONTENTS
297 .inttab_tc0_0F8 00000000  801f5f00  801f5f00  00008e08  2**0
                  CONTENTS
298 .inttab_tc0_0F9 00000000  801f5f20  801f5f20  00008e08  2**0
                  CONTENTS
299 .inttab_tc0_0FA 00000000  801f5f40  801f5f40  00008e08  2**0
                  CONTENTS
300 .inttab_tc0_0FB 00000000  801f5f60  801f5f60  00008e08  2**0
                  CONTENTS
301 .inttab_tc0_0FC 00000000  801f5f80  801f5f80  00008e08  2**0
                  CONTENTS
302 .inttab_tc0_0FD 00000000  801f5fa0  801f5fa0  00008e08  2**0
                  CONTENTS
303 .inttab_tc0_0FE 00000000  801f5fc0  801f5fc0  00008e08  2**0
                  CONTENTS
304 .inttab_tc0_0FF 00000000  801f5fe0  801f5fe0  00008e08  2**0
                  CONTENTS
305 .comment      0000001b  00000000  00000000  00008e08  2**0
                  CONTENTS, READONLY
306 .debug_aranges 000012e8  00000000  00000000  00008e28  2**3
                  CONTENTS, READONLY, DEBUGGING
307 .debug_info   001f1c27  00000000  00000000  0000a110  2**0
                  CONTENTS, READONLY, DEBUGGING
308 .debug_abbrev 0000ab9b  00000000  00000000  001fbd37  2**0
                  CONTENTS, READONLY, DEBUGGING
309 .debug_line   00029953  00000000  00000000  002068d2  2**0
                  CONTENTS, READONLY, DEBUGGING
310 .debug_frame  00002700  00000000  00000000  00230228  2**2
                  CONTENTS, READONLY, DEBUGGING
311 .debug_str    00007311  00000000  00000000  00232928  2**0
                  CONTENTS, READONLY, DEBUGGING
312 .debug_loc    000105ce  00000000  00000000  00239c39  2**0
                  CONTENTS, READONLY, DEBUGGING
313 .debug_ranges 00001970  00000000  00000000  0024a208  2**3
                  CONTENTS, READONLY, DEBUGGING
314 .debug_macro  000f51b6  00000000  00000000  0024bb78  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .startup:

80000020 <_START>:
#elif defined(__DCC__)
#pragma section CODE ".start" X
#endif

void _START(void)
{
80000020:	40 ae       	mov.aa %a14,%sp
    __non_return_call(_Core0_start);
80000022:	91 00 00 28 	movh.a %a2,32768
80000026:	d9 22 1e 75 	lea %a2,[%a2]20958 <800051de <_Core0_start>>
8000002a:	dc 02       	ji %a2
}
8000002c:	00 90       	ret 

8000002e <_START_end>:
8000002e:	08 00       	ld.bu %d0,[%a15]0

Disassembly of section .traptab_tc0:

80000100 <IfxCpu_Trap_vectorTable0>:
#pragma ghs section
#pragma ghs section text=".traptab_cpu0"
#endif
void IfxCpu_Trap_vectorTable0(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
80000100:	0d 00 00 02 	svlcx 
80000104:	02 f4       	mov %d4,%d15
80000106:	91 00 00 28 	movh.a %a2,32768
8000010a:	d9 22 e0 64 	lea %a2,[%a2]19872 <80004da0 <IfxCpu_Trap_memoryManagementError>>
8000010e:	dc 02       	ji %a2
80000110:	00 80       	rfe 
	...
8000011e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
80000120:	0d 00 00 02 	svlcx 
80000124:	02 f4       	mov %d4,%d15
80000126:	91 00 00 28 	movh.a %a2,32768
8000012a:	d9 22 ce 74 	lea %a2,[%a2]19918 <80004dce <IfxCpu_Trap_internalProtectionError>>
8000012e:	dc 02       	ji %a2
80000130:	00 80       	rfe 
	...
8000013e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
80000140:	0d 00 00 02 	svlcx 
80000144:	02 f4       	mov %d4,%d15
80000146:	91 00 00 28 	movh.a %a2,32768
8000014a:	d9 22 fc 74 	lea %a2,[%a2]19964 <80004dfc <IfxCpu_Trap_instructionError>>
8000014e:	dc 02       	ji %a2
80000150:	00 80       	rfe 
	...
8000015e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
80000160:	02 f4       	mov %d4,%d15
80000162:	91 00 00 28 	movh.a %a2,32768
80000166:	d9 22 ea 84 	lea %a2,[%a2]20010 <80004e2a <IfxCpu_Trap_contextManagementError>>
8000016a:	dc 02       	ji %a2
8000016c:	00 80       	rfe 
	...
8000017e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
80000180:	0d 00 00 02 	svlcx 
80000184:	02 f4       	mov %d4,%d15
80000186:	91 00 00 28 	movh.a %a2,32768
8000018a:	d9 22 d8 94 	lea %a2,[%a2]20056 <80004e58 <IfxCpu_Trap_busError>>
8000018e:	dc 02       	ji %a2
80000190:	00 80       	rfe 
	...
8000019e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
800001a0:	0d 00 00 02 	svlcx 
800001a4:	02 f4       	mov %d4,%d15
800001a6:	91 00 00 28 	movh.a %a2,32768
800001aa:	d9 22 c6 a4 	lea %a2,[%a2]20102 <80004e86 <IfxCpu_Trap_assertion>>
800001ae:	dc 02       	ji %a2
800001b0:	00 80       	rfe 
	...
800001be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu0);
800001c0:	0d 00 00 02 	svlcx 
800001c4:	02 f4       	mov %d4,%d15
800001c6:	91 00 00 28 	movh.a %a2,32768
800001ca:	d9 22 fa a4 	lea %a2,[%a2]20154 <80004eba <IfxCpu_Trap_systemCall_Cpu0>>
800001ce:	dc 02       	ji %a2
800001d0:	00 80       	rfe 
	...
800001de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
800001e0:	0d 00 00 02 	svlcx 
800001e4:	02 f4       	mov %d4,%d15
800001e6:	91 00 00 28 	movh.a %a2,32768
800001ea:	d9 22 fe c4 	lea %a2,[%a2]20286 <80004f3e <IfxCpu_Trap_nonMaskableInterrupt>>
800001ee:	dc 02       	ji %a2
800001f0:	00 80       	rfe 
}
800001f2:	00 90       	ret 

800001f4 <IfxCpu_Trap_vectorTable0_end>:
	...

Disassembly of section .text:

80000618 <deregister_tm_clones>:
80000618:	7b 00 00 26 	movh %d2,24576
8000061c:	1b 82 5a 20 	addi %d2,%d2,1448
80000620:	91 00 00 46 	movh.a %a4,24576
80000624:	60 22       	mov.a %a2,%d2
80000626:	d9 44 68 60 	lea %a4,[%a4]1448 <600005a8 <__TMC_END__>>
8000062a:	7d 42 0a 00 	jeq.a %a2,%a4,8000063e <deregister_tm_clones+0x26>
8000062e:	91 00 00 20 	movh.a %a2,0
80000632:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
80000636:	bd 02 04 00 	jz.a %a2,8000063e <deregister_tm_clones+0x26>
8000063a:	2d 02 00 00 	calli %a2
8000063e:	00 90       	ret 

80000640 <register_tm_clones>:
80000640:	7b 00 00 26 	movh %d2,24576
80000644:	1b 82 5a 20 	addi %d2,%d2,1448
80000648:	91 00 00 46 	movh.a %a4,24576
8000064c:	60 22       	mov.a %a2,%d2
8000064e:	d9 44 68 60 	lea %a4,[%a4]1448 <600005a8 <__TMC_END__>>
80000652:	01 42 20 20 	sub.a %a2,%a2,%a4
80000656:	80 22       	mov.d %d2,%a2
80000658:	8f e2 3f 30 	sha %d3,%d2,-2
8000065c:	8f 12 1e 20 	sh %d2,%d2,-31
80000660:	42 32       	add %d2,%d3
80000662:	8f f2 3f 40 	sha %d4,%d2,-1
80000666:	df 04 0a 00 	jeq %d4,0,8000067a <register_tm_clones+0x3a>
8000066a:	91 00 00 20 	movh.a %a2,0
8000066e:	d9 22 00 00 	lea %a2,[%a2]0 <0 <__TRICORE_DERIVATE_MEMORY_MAP__-0x270>>
80000672:	bd 02 04 00 	jz.a %a2,8000067a <register_tm_clones+0x3a>
80000676:	2d 02 00 00 	calli %a2
8000067a:	00 90       	ret 

8000067c <__do_global_dtors_aux>:
8000067c:	91 00 00 e6 	movh.a %a14,24576
80000680:	39 e2 68 60 	ld.bu %d2,[%a14]1448 <600005a8 <__TMC_END__>>
80000684:	df 02 2d 80 	jne %d2,0,800006de <__do_global_dtors_aux+0x62>
80000688:	91 10 00 38 	movh.a %a3,32769
8000068c:	91 10 00 28 	movh.a %a2,32769
80000690:	d9 33 18 d8 	lea %a3,[%a3]-31912 <80008358 <__DTOR_END__>>
80000694:	d9 22 0c d8 	lea %a2,[%a2]-31924 <8000834c <__DTOR_LIST__>>
80000698:	01 23 20 20 	sub.a %a2,%a3,%a2
8000069c:	80 22       	mov.d %d2,%a2
8000069e:	86 e2       	sha %d2,-2
800006a0:	1b f2 ff 8f 	addi %d8,%d2,-1
800006a4:	91 00 00 c6 	movh.a %a12,24576
800006a8:	7b 10 00 28 	movh %d2,32769
800006ac:	1b c2 34 28 	addi %d2,%d2,-31924
800006b0:	60 2d       	mov.a %a13,%d2
800006b2:	19 c2 6c 60 	ld.w %d2,[%a12]1452 <600005ac <dtor_idx.0>>
800006b6:	7f 82 0f 80 	jge.u %d2,%d8,800006d4 <__do_global_dtors_aux+0x58>
800006ba:	d9 cc 6c 60 	lea %a12,[%a12]1452 <600005ac <dtor_idx.0>>
800006be:	c2 12       	add %d2,1
800006c0:	74 c2       	st.w [%a12],%d2
800006c2:	06 22       	sh %d2,2
800006c4:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800006c8:	d4 22       	ld.a %a2,[%a2]
800006ca:	2d 02 00 00 	calli %a2
800006ce:	54 c2       	ld.w %d2,[%a12]
800006d0:	3f 82 f7 ff 	jlt.u %d2,%d8,800006be <__do_global_dtors_aux+0x42>
800006d4:	6d ff a2 ff 	call 80000618 <deregister_tm_clones>
800006d8:	82 12       	mov %d2,1
800006da:	e9 e2 68 60 	st.b [%a14]1448 <600005a8 <__TMC_END__>>,%d2
800006de:	00 90       	ret 

800006e0 <frame_dummy>:
800006e0:	6d ff b0 ff 	call 80000640 <register_tm_clones>
800006e4:	00 90       	ret 

800006e6 <init_Trigger>:
    IfxPort_setPinLow(PORT_TRIG_MAIN);
    IfxPort_setPinLow(PORT_TRIG_SUB);
}

void init_Trigger(void)
{
800006e6:	40 ae       	mov.aa %a14,%sp
}


IFX_INLINE void IfxPort_setPinState(Ifx_P *port, uint8 pinIndex, IfxPort_State action)
{
    port->OMR.U = action << pinIndex;
800006e8:	91 40 00 2f 	movh.a %a2,61444
800006ec:	d9 22 40 4b 	lea %a2,[%a2]-19200 <f003b500 <_SMALL_DATA4_+0x60033500>>
800006f0:	3b 00 04 20 	mov %d2,64
800006f4:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
800006f8:	6d 00 fc 12 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
800006fc:	91 30 00 2f 	movh.a %a2,61443
80000700:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80000704:	54 23       	ld.w %d3,[%a2]
80000706:	37 03 64 34 	extr.u %d3,%d3,8,4
8000070a:	4b 03 41 31 	itof %d3,%d3
8000070e:	4b 32 51 20 	div.f %d2,%d2,%d3
    //IfxPort_setPinLow(trigger);     //
    //IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 100000);
    IfxPort_setPinHigh(PORT_TRIG_MAIN);
    IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 100000);
80000712:	7b 30 7c 34 	movh %d3,18371
80000716:	1b 03 00 35 	addi %d3,%d3,20480
8000071a:	4b 32 51 30 	div.f %d3,%d2,%d3
8000071e:	4b 03 71 31 	ftouz %d3,%d3
}


IFX_INLINE uint32 IfxStm_getLower(Ifx_STM *stm)
{
    return stm->TIM0.U;
80000722:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>
80000726:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    beginTime = IfxStm_getLower(stm);

    /*below code will work because of unsigned 32 bit calculation even at timer wrapping condition
     * As an example if beginTime = 0xFFFFFFFE and current time = 2 (after overflow), unsigned calculation
     * 2 - 0xFFFFFFFE will be 4*/
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
8000072a:	a2 42       	sub %d2,%d4
8000072c:	3f 32 fd ff 	jlt.u %d2,%d3,80000726 <init_Trigger+0x40>
80000730:	91 40 00 2f 	movh.a %a2,61444
80000734:	d9 22 40 4b 	lea %a2,[%a2]-19200 <f003b500 <_SMALL_DATA4_+0x60033500>>
80000738:	7b 00 04 20 	movh %d2,64
8000073c:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80000740:	91 40 00 2f 	movh.a %a2,61444
80000744:	d9 22 00 4b 	lea %a2,[%a2]-20224 <f003b100 <_SMALL_DATA4_+0x60033100>>
80000748:	3b 00 04 20 	mov %d2,64
8000074c:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80000750:	6d 00 d0 12 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
80000754:	91 30 00 2f 	movh.a %a2,61443
80000758:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000075c:	54 23       	ld.w %d3,[%a2]
8000075e:	37 03 64 34 	extr.u %d3,%d3,8,4
80000762:	4b 03 41 31 	itof %d3,%d3
80000766:	4b 32 51 20 	div.f %d2,%d2,%d3
    IfxPort_setPinLow(PORT_TRIG_MAIN);

    IfxPort_setPinHigh(PORT_TRIG_SUB);
    IfxStm_waitTicks(STM0, IfxStm_getFrequency(STM0) / 100000);
8000076a:	7b 30 7c 34 	movh %d3,18371
8000076e:	1b 03 00 35 	addi %d3,%d3,20480
80000772:	4b 32 51 30 	div.f %d3,%d2,%d3
80000776:	4b 03 71 31 	ftouz %d3,%d3
    return stm->TIM0.U;
8000077a:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>
8000077e:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    while ((IfxStm_getLower(stm) - beginTime) < ticks)
80000782:	a2 42       	sub %d2,%d4
80000784:	3f 32 fd ff 	jlt.u %d2,%d3,8000077e <init_Trigger+0x98>
80000788:	91 40 00 2f 	movh.a %a2,61444
8000078c:	d9 22 00 4b 	lea %a2,[%a2]-20224 <f003b100 <_SMALL_DATA4_+0x60033100>>
80000790:	7b 00 04 20 	movh %d2,64
80000794:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
    IfxPort_setPinLow(PORT_TRIG_SUB);
}
80000798:	00 90       	ret 

8000079a <measureDistance1>:

void measureDistance1(void)
{
8000079a:	40 ae       	mov.aa %a14,%sp
    init_Trigger();
8000079c:	6d ff a5 ff 	call 800006e6 <init_Trigger>

    float OutNum = 0;
800007a0:	82 04       	mov %d4,0
    return (__getbit(&port->IN.U, pinIndex) != 0) ? TRUE : FALSE;
800007a2:	91 40 00 2f 	movh.a %a2,61444
800007a6:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
800007aa:	19 22 24 00 	ld.w %d2,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
    float errFlag1 = 0;
    while (IfxPort_getPinState(PORT_ECHO_MAIN) == 0)
800007ae:	6f 82 1b 80 	jnz.t %d2,8,800007e4 <measureDistance1+0x4a>
    {
        OutNum += 0.01;
800007b2:	6d 00 24 33 	call 80006dfa <__extendsfdf2>
800007b6:	7b e0 7a 64 	movh %d6,18350
800007ba:	1b b6 47 61 	addi %d6,%d6,5243
800007be:	7b 40 f8 73 	movh %d7,16260
800007c2:	1b 17 ae 77 	addi %d7,%d7,31457
800007c6:	0b 23 10 48 	mov %e4,%d3,%d2
800007ca:	6d 00 5d 34 	call 80007084 <__adddf3>
800007ce:	0b 23 10 48 	mov %e4,%d3,%d2
800007d2:	6d 00 cc 35 	call 8000736a <__truncdfsf2>
800007d6:	02 24       	mov %d4,%d2
        if (OutNum > 10) {OutNum = 0; errFlag1 = 1; break;}
800007d8:	7b 00 12 24 	movh %d2,16672
800007dc:	4b 24 01 20 	cmp.f %d2,%d4,%d2
800007e0:	6f 22 e1 7f 	jz.t %d2,2,800007a2 <measureDistance1+0x8>
    return stm->TIM0.U;
800007e4:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x5fff8010>
    }
    startTime = IfxStm_getLower(STM0);
800007e8:	91 00 00 26 	movh.a %a2,24576
800007ec:	59 23 c8 10 	st.w [%a2]3144 <60000c48 <startTime>>,%d3
800007f0:	91 40 00 2f 	movh.a %a2,61444
800007f4:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
800007f8:	19 22 24 00 	ld.w %d2,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>

    while (IfxPort_getPinState(PORT_ECHO_MAIN) == 1);
800007fc:	6f 82 fa ff 	jnz.t %d2,8,800007f0 <measureDistance1+0x56>
80000800:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    endTime = IfxStm_getLower(STM0);
80000804:	91 00 00 26 	movh.a %a2,24576
80000808:	59 22 c4 10 	st.w [%a2]3140 <60000c44 <endTime>>,%d2

    distance1 = ((endTime - startTime) / (float)IfxStm_getFrequency(STM0)) * 34300 * 0.5;
8000080c:	0b 32 80 80 	sub %d8,%d2,%d3
80000810:	6d 00 70 12 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
80000814:	91 30 00 2f 	movh.a %a2,61443
80000818:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000081c:	54 23       	ld.w %d3,[%a2]
8000081e:	37 03 64 34 	extr.u %d3,%d3,8,4
80000822:	4b 03 41 31 	itof %d3,%d3
80000826:	4b 32 51 20 	div.f %d2,%d2,%d3
8000082a:	4b 08 61 81 	utof %d8,%d8
8000082e:	4b 28 51 20 	div.f %d2,%d8,%d2
80000832:	7b 60 70 34 	movh %d3,18182
80000836:	1b 03 c0 3f 	addi %d3,%d3,-1024
8000083a:	4b 32 41 20 	mul.f %d2,%d2,%d3
8000083e:	7b 00 f0 33 	movh %d3,16128
80000842:	4b 32 41 30 	mul.f %d3,%d2,%d3
80000846:	91 00 00 26 	movh.a %a2,24576
8000084a:	d9 22 d8 10 	lea %a2,[%a2]3160 <60000c58 <distance1>>
8000084e:	74 23       	st.w [%a2],%d3
    filtered_dist1 = alpha_Ultra * distance1 + (1 - alpha_Ultra) * filtered_dist1;
80000850:	91 00 00 26 	movh.a %a2,24576
80000854:	d9 22 58 60 	lea %a2,[%a2]1432 <60000598 <alpha_Ultra>>
80000858:	54 22       	ld.w %d2,[%a2]
8000085a:	4b 32 41 30 	mul.f %d3,%d2,%d3
8000085e:	7b 00 f8 43 	movh %d4,16256
80000862:	6b 02 31 24 	sub.f %d2,%d4,%d2
80000866:	91 00 00 26 	movh.a %a2,24576
8000086a:	d9 23 d0 10 	lea %a3,[%a2]3152 <60000c50 <filtered_dist1>>
8000086e:	54 34       	ld.w %d4,[%a3]
80000870:	4b 42 41 20 	mul.f %d2,%d2,%d4
80000874:	6b 02 21 23 	add.f %d2,%d3,%d2
80000878:	74 32       	st.w [%a3],%d2
}
8000087a:	00 90       	ret 

8000087c <measureDistance2>:


//    distance_prev = distance;

void measureDistance2(void)
{
8000087c:	40 ae       	mov.aa %a14,%sp
    init_Trigger();
8000087e:	6d ff 34 ff 	call 800006e6 <init_Trigger>

    float OutNum = 0;
80000882:	82 04       	mov %d4,0
80000884:	91 40 00 2f 	movh.a %a2,61444
80000888:	d9 22 00 4b 	lea %a2,[%a2]-20224 <f003b100 <_SMALL_DATA4_+0x60033100>>
8000088c:	19 22 24 00 	ld.w %d2,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
    float errFlag2 = 0;
    while (IfxPort_getPinState(PORT_ECHO_SUB) == 0)
80000890:	6f 22 1b 80 	jnz.t %d2,2,800008c6 <measureDistance2+0x4a>
    {
        OutNum += 0.01;
80000894:	6d 00 b3 32 	call 80006dfa <__extendsfdf2>
80000898:	7b e0 7a 64 	movh %d6,18350
8000089c:	1b b6 47 61 	addi %d6,%d6,5243
800008a0:	7b 40 f8 73 	movh %d7,16260
800008a4:	1b 17 ae 77 	addi %d7,%d7,31457
800008a8:	0b 23 10 48 	mov %e4,%d3,%d2
800008ac:	6d 00 ec 33 	call 80007084 <__adddf3>
800008b0:	0b 23 10 48 	mov %e4,%d3,%d2
800008b4:	6d 00 5b 35 	call 8000736a <__truncdfsf2>
800008b8:	02 24       	mov %d4,%d2
        if (OutNum > 10) {OutNum = 0; errFlag2 = 1; break;}
800008ba:	7b 00 12 24 	movh %d2,16672
800008be:	4b 24 01 20 	cmp.f %d2,%d4,%d2
800008c2:	6f 22 e1 7f 	jz.t %d2,2,80000884 <measureDistance2+0x8>
800008c6:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x5fff8010>
    }
    startTime = IfxStm_getLower(STM0);
800008ca:	91 00 00 26 	movh.a %a2,24576
800008ce:	59 23 c8 10 	st.w [%a2]3144 <60000c48 <startTime>>,%d3
800008d2:	91 40 00 2f 	movh.a %a2,61444
800008d6:	d9 22 00 4b 	lea %a2,[%a2]-20224 <f003b100 <_SMALL_DATA4_+0x60033100>>
800008da:	19 22 24 00 	ld.w %d2,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>

    while (IfxPort_getPinState(PORT_ECHO_SUB) == 1);
800008de:	6f 22 fa ff 	jnz.t %d2,2,800008d2 <measureDistance2+0x56>
800008e2:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
    endTime = IfxStm_getLower(STM0);
800008e6:	91 00 00 26 	movh.a %a2,24576
800008ea:	59 22 c4 10 	st.w [%a2]3140 <60000c44 <endTime>>,%d2

    distance2 = ((endTime - startTime) / (float)IfxStm_getFrequency(STM0)) * 34300 * 0.5;
800008ee:	0b 32 80 80 	sub %d8,%d2,%d3
800008f2:	6d 00 ff 11 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
800008f6:	91 30 00 2f 	movh.a %a2,61443
800008fa:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
800008fe:	54 23       	ld.w %d3,[%a2]
80000900:	37 03 64 34 	extr.u %d3,%d3,8,4
80000904:	4b 03 41 31 	itof %d3,%d3
80000908:	4b 32 51 20 	div.f %d2,%d2,%d3
8000090c:	4b 08 61 81 	utof %d8,%d8
80000910:	4b 28 51 20 	div.f %d2,%d8,%d2
80000914:	7b 60 70 34 	movh %d3,18182
80000918:	1b 03 c0 3f 	addi %d3,%d3,-1024
8000091c:	4b 32 41 20 	mul.f %d2,%d2,%d3
80000920:	7b 00 f0 33 	movh %d3,16128
80000924:	4b 32 41 30 	mul.f %d3,%d2,%d3
80000928:	91 00 00 26 	movh.a %a2,24576
8000092c:	d9 22 d4 10 	lea %a2,[%a2]3156 <60000c54 <distance2>>
80000930:	74 23       	st.w [%a2],%d3
    filtered_dist2 = alpha_Ultra * distance2 + (1 - alpha_Ultra) * filtered_dist2;
80000932:	91 00 00 26 	movh.a %a2,24576
80000936:	d9 22 58 60 	lea %a2,[%a2]1432 <60000598 <alpha_Ultra>>
8000093a:	54 22       	ld.w %d2,[%a2]
8000093c:	4b 32 41 30 	mul.f %d3,%d2,%d3
80000940:	7b 00 f8 43 	movh %d4,16256
80000944:	6b 02 31 24 	sub.f %d2,%d4,%d2
80000948:	91 00 00 26 	movh.a %a2,24576
8000094c:	d9 23 cc 10 	lea %a3,[%a2]3148 <60000c4c <filtered_dist2>>
80000950:	54 34       	ld.w %d4,[%a3]
80000952:	4b 42 41 20 	mul.f %d2,%d2,%d4
80000956:	6b 02 21 23 	add.f %d2,%d3,%d2
8000095a:	74 32       	st.w [%a3],%d2
}
8000095c:	00 90       	ret 

8000095e <obstacle_state_decision>:

void obstacle_state_decision(void){
8000095e:	40 ae       	mov.aa %a14,%sp
    if(Sudden_accel_flag == 0){
80000960:	91 00 00 26 	movh.a %a2,24576
80000964:	19 22 d4 20 	ld.w %d2,[%a2]3220 <60000c94 <Sudden_accel_flag>>
80000968:	df 02 a2 80 	jne %d2,0,80000aac <obstacle_state_decision+0x14e>
        if(Ultra_select == 0){
8000096c:	91 00 00 26 	movh.a %a2,24576
80000970:	19 22 fc 00 	ld.w %d2,[%a2]3132 <60000c3c <Ultra_select>>
80000974:	df 02 50 80 	jne %d2,0,80000a14 <obstacle_state_decision+0xb6>
            measureDistance1();     // filtered_dist1
80000978:	6d ff 11 ff 	call 8000079a <measureDistance1>
            if(filtered_dist1 <= 10){
8000097c:	91 00 00 26 	movh.a %a2,24576
80000980:	d9 22 d0 10 	lea %a2,[%a2]3152 <60000c50 <filtered_dist1>>
80000984:	54 23       	ld.w %d3,[%a2]
80000986:	7b 00 12 24 	movh %d2,16672
8000098a:	4b 23 01 20 	cmp.f %d2,%d3,%d2
8000098e:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
80000992:	df 02 08 00 	jeq %d2,0,800009a2 <obstacle_state_decision+0x44>
                Ultra_flag = 1;
80000996:	91 00 00 26 	movh.a %a2,24576
8000099a:	82 12       	mov %d2,1
8000099c:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
800009a0:	00 90       	ret 
            }
            else if(filtered_dist1 > 10 && filtered_dist1 <= 30){
800009a2:	7b 00 12 24 	movh %d2,16672
800009a6:	4b 23 01 20 	cmp.f %d2,%d3,%d2
800009aa:	6f 22 10 00 	jz.t %d2,2,800009ca <obstacle_state_decision+0x6c>
800009ae:	7b 00 1f 24 	movh %d2,16880
800009b2:	4b 23 01 20 	cmp.f %d2,%d3,%d2
800009b6:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
800009ba:	df 02 08 00 	jeq %d2,0,800009ca <obstacle_state_decision+0x6c>
                Ultra_flag = 2;
800009be:	91 00 00 26 	movh.a %a2,24576
800009c2:	82 22       	mov %d2,2
800009c4:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
800009c8:	00 90       	ret 
            }
            else if(filtered_dist1 > 30 && filtered_dist1 <= 70){
800009ca:	7b 00 1f 24 	movh %d2,16880
800009ce:	4b 23 01 20 	cmp.f %d2,%d3,%d2
800009d2:	6f 22 10 00 	jz.t %d2,2,800009f2 <obstacle_state_decision+0x94>
800009d6:	7b c0 28 24 	movh %d2,17036
800009da:	4b 23 01 20 	cmp.f %d2,%d3,%d2
800009de:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
800009e2:	df 02 08 00 	jeq %d2,0,800009f2 <obstacle_state_decision+0x94>
                Ultra_flag = 3;
800009e6:	91 00 00 26 	movh.a %a2,24576
800009ea:	82 32       	mov %d2,3
800009ec:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
800009f0:	00 90       	ret 
            }
            else if(filtered_dist1 > 70){
800009f2:	7b c0 28 24 	movh %d2,17036
800009f6:	4b 23 01 20 	cmp.f %d2,%d3,%d2
800009fa:	6f 22 59 00 	jz.t %d2,2,80000aac <obstacle_state_decision+0x14e>
                Ultra_flag = 0;
800009fe:	91 00 00 26 	movh.a %a2,24576
80000a02:	82 02       	mov %d2,0
80000a04:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
                Ultra_select = 1;
80000a08:	91 00 00 26 	movh.a %a2,24576
80000a0c:	82 12       	mov %d2,1
80000a0e:	59 22 fc 00 	st.w [%a2]3132 <60000c3c <Ultra_select>>,%d2
80000a12:	00 90       	ret 
            }
        }
        else{
            measureDistance2();
80000a14:	6d ff 34 ff 	call 8000087c <measureDistance2>
            if(filtered_dist2 <= 10){
80000a18:	91 00 00 26 	movh.a %a2,24576
80000a1c:	d9 22 cc 10 	lea %a2,[%a2]3148 <60000c4c <filtered_dist2>>
80000a20:	54 23       	ld.w %d3,[%a2]
80000a22:	7b 00 12 24 	movh %d2,16672
80000a26:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000a2a:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
80000a2e:	df 02 08 00 	jeq %d2,0,80000a3e <obstacle_state_decision+0xe0>
                Ultra_flag = 1;
80000a32:	91 00 00 26 	movh.a %a2,24576
80000a36:	82 12       	mov %d2,1
80000a38:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
80000a3c:	00 90       	ret 
            }
            else if(filtered_dist2 > 10 && filtered_dist2 <= 30){
80000a3e:	7b 00 12 24 	movh %d2,16672
80000a42:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000a46:	6f 22 10 00 	jz.t %d2,2,80000a66 <obstacle_state_decision+0x108>
80000a4a:	7b 00 1f 24 	movh %d2,16880
80000a4e:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000a52:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
80000a56:	df 02 08 00 	jeq %d2,0,80000a66 <obstacle_state_decision+0x108>
                Ultra_flag = 2;
80000a5a:	91 00 00 26 	movh.a %a2,24576
80000a5e:	82 22       	mov %d2,2
80000a60:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
80000a64:	00 90       	ret 
            }
            else if(filtered_dist2 > 30 && filtered_dist2 <= 70){
80000a66:	7b 00 1f 24 	movh %d2,16880
80000a6a:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000a6e:	6f 22 10 00 	jz.t %d2,2,80000a8e <obstacle_state_decision+0x130>
80000a72:	7b c0 28 24 	movh %d2,17036
80000a76:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000a7a:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
80000a7e:	df 02 08 00 	jeq %d2,0,80000a8e <obstacle_state_decision+0x130>
                Ultra_flag = 3;
80000a82:	91 00 00 26 	movh.a %a2,24576
80000a86:	82 32       	mov %d2,3
80000a88:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
80000a8c:	00 90       	ret 
            }
            else if(filtered_dist2 > 70){
80000a8e:	7b c0 28 24 	movh %d2,17036
80000a92:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000a96:	6f 22 0b 00 	jz.t %d2,2,80000aac <obstacle_state_decision+0x14e>
                Ultra_flag = 0;
80000a9a:	82 02       	mov %d2,0
80000a9c:	91 00 00 26 	movh.a %a2,24576
80000aa0:	59 22 c0 10 	st.w [%a2]3136 <60000c40 <Ultra_flag>>,%d2
                Ultra_select = 0;
80000aa4:	91 00 00 26 	movh.a %a2,24576
80000aa8:	59 22 fc 00 	st.w [%a2]3132 <60000c3c <Ultra_select>>,%d2
        }
    }
    else{
        // 급발진시 초음파 작동 X
    }
}
80000aac:	00 90       	ret 

80000aae <init_UART_PC>:
uint8 SUB_uartTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 SUB_uartRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];


//----------------- Main <-> PC -----------------//
void init_UART_PC(void){
80000aae:	40 ae       	mov.aa %a14,%sp
80000ab0:	20 98       	sub.a %sp,152
    IfxAsclin_Asc_Config    ascConf;

    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN3);
80000ab2:	c5 f5 80 40 	lea %a5,f0000900 <_SMALL_DATA4_+0x5fff8900>
80000ab6:	d9 e4 cc ef 	lea %a4,[%a14]-116
80000aba:	6d 00 5d 2c 	call 80006374 <IfxAsclin_Asc_initModuleConfig>

    ascConf.baudrate.baudrate   = ASC_BAUDRATE;
80000abe:	7b 10 7e 24 	movh %d2,18401
80000ac2:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    ascConf.baudrate.oversampling   = IfxAsclin_OversamplingFactor_16;
80000ac6:	3b f0 00 20 	mov %d2,15
80000aca:	59 e2 d8 ef 	st.w [%a14]-104,%d2

    ascConf.bitTiming.medianFilter  = IfxAsclin_SamplesPerBit_three;
80000ace:	82 12       	mov %d2,1
80000ad0:	59 e2 dc ef 	st.w [%a14]-100,%d2
    ascConf.bitTiming.samplePointPosition   = IfxAsclin_SamplePointPosition_8;
80000ad4:	3b 80 00 20 	mov %d2,8
80000ad8:	59 e2 e0 ef 	st.w [%a14]-96,%d2

    ascConf.interrupt.txPriority    = ISR_PRIORITY_ASCLIN_TX_PC;
80000adc:	f9 e2 d4 ff 	st.h [%a14]-44,%d2
    ascConf.interrupt.rxPriority    = ISR_PRIORITY_ASCLIN_RX_PC;
80000ae0:	82 42       	mov %d2,4
80000ae2:	f9 e2 d6 ff 	st.h [%a14]-42,%d2
    ascConf.interrupt.erPriority    = ISR_PRIORITY_ASCLIN_ER_PC;
80000ae6:	3b c0 00 20 	mov %d2,12
80000aea:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;
80000aee:	82 02       	mov %d2,0
80000af0:	59 e2 dc ff 	st.w [%a14]-36,%d2

    const IfxAsclin_Asc_Pins pins = {
80000af4:	d9 e3 e8 df 	lea %a3,[%a14]-152
80000af8:	91 00 00 26 	movh.a %a2,24576
80000afc:	d9 22 00 00 	lea %a2,[%a2]0 <60000000 <LCF_DSPR1_START>>
80000b00:	40 34       	mov.aa %a4,%a3
80000b02:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000b06:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000b0a:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000b0e:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000b12:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000b16:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000b1a:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000b1e:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000b22:	44 24       	ld.w %d4,[%a2+]
80000b24:	64 44       	st.w [%a4+],%d4
            .ctsMode    = IfxPort_InputMode_pullUp,
            .rts        = NULL_PTR,
            .rtsMode    = IfxPort_OutputMode_pushPull,
            .pinDriver  =IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;
80000b26:	b5 e3 e0 ff 	st.a [%a14]-32 <60000008 <LCF_DSPR1_START+0x8>>,%a3

    ascConf.txBuffer        = PC_uartTxBuffer;
80000b2a:	91 00 00 26 	movh.a %a2,24576
80000b2e:	d9 22 88 b0 	lea %a2,[%a2]2760 <60000ac8 <PC_uartTxBuffer>>
80000b32:	b5 e2 ec ff 	st.a [%a14]-20 <60000ac8 <PC_uartTxBuffer>>,%a2
    ascConf.txBufferSize    = ASC_TX_BUFFER_SIZE;
80000b36:	3b 00 10 20 	mov %d2,256
80000b3a:	f9 e2 ea ff 	st.h [%a14]-22,%d2
    ascConf.rxBuffer        = PC_uartRxBuffer;
80000b3e:	91 00 00 26 	movh.a %a2,24576
80000b42:	d9 22 a0 60 	lea %a2,[%a2]2464 <600009a0 <PC_uartRxBuffer>>
80000b46:	b5 e2 f4 ff 	st.a [%a14]-12 <600009a0 <PC_uartRxBuffer>>,%a2
    ascConf.rxBufferSize    = ASC_RX_BUFFER_SIZE;
80000b4a:	f9 e2 f0 ff 	st.h [%a14]-16 <600009a0 <PC_uartRxBuffer>>,%d2

    IfxAsclin_Asc_initModule(&PC_ascHandle0, &ascConf);
80000b4e:	d9 e5 cc ef 	lea %a5,[%a14]-116 <600009a0 <PC_uartRxBuffer>>
80000b52:	91 00 00 46 	movh.a %a4,24576
80000b56:	d9 44 b0 f0 	lea %a4,[%a4]3056 <60000bf0 <PC_ascHandle0>>
80000b5a:	6d 00 d3 29 	call 80005f00 <IfxAsclin_Asc_initModule>



    Uart_SUB_Output='X';
80000b5e:	91 00 00 26 	movh.a %a2,24576
80000b62:	3b 80 05 20 	mov %d2,88
80000b66:	e9 22 ed 10 	st.b [%a2]3181 <60000c6d <Uart_SUB_Output>>,%d2
}
80000b6a:	00 90       	ret 

80000b6c <out_UART_PC>:


void out_UART_PC(uint8 data){
80000b6c:	40 ae       	mov.aa %a14,%sp
80000b6e:	20 28       	sub.a %sp,40

    if(Sudden_accel_flag == 0){
80000b70:	91 00 00 26 	movh.a %a2,24576
80000b74:	19 22 d4 20 	ld.w %d2,[%a2]3220 <60000c94 <Sudden_accel_flag>>
80000b78:	df 02 f8 80 	jne %d2,0,80000d68 <out_UART_PC+0x1fc>
        data_ref = target_speed*34000/100;        // 목표 속도 출력
80000b7c:	91 00 00 26 	movh.a %a2,24576
80000b80:	d9 22 c4 50 	lea %a2,[%a2]3396 <60000d44 <target_speed>>
80000b84:	54 22       	ld.w %d2,[%a2]
80000b86:	7b 50 70 34 	movh %d3,18181
80000b8a:	1b 03 00 3d 	addi %d3,%d3,-12288
80000b8e:	4b 23 41 20 	mul.f %d2,%d3,%d2
80000b92:	7b 80 2c 34 	movh %d3,17096
80000b96:	4b 32 51 20 	div.f %d2,%d2,%d3
80000b9a:	91 00 00 26 	movh.a %a2,24576
80000b9e:	d9 22 d4 00 	lea %a2,[%a2]3092 <60000c14 <data_ref>>
80000ba2:	74 22       	st.w [%a2],%d2
    }
    else{
        data_ref = 0;
    }
    int d100 = ((int)data_ref)/100;
80000ba4:	91 00 00 26 	movh.a %a2,24576
80000ba8:	d9 22 d4 00 	lea %a2,[%a2]3092 <60000c14 <data_ref>>
80000bac:	54 26       	ld.w %d6,[%a2]
80000bae:	4b 06 31 81 	ftoiz %d8,%d6
80000bb2:	7b c0 1e 25 	movh %d2,20972
80000bb6:	1b f2 51 28 	addi %d2,%d2,-31457
80000bba:	73 28 6a 20 	mul %e2,%d8,%d2
80000bbe:	8f b3 3f c0 	sha %d12,%d3,-5
80000bc2:	8f 18 3e 20 	sha %d2,%d8,-31
80000bc6:	a2 2c       	sub %d12,%d2
    int d10 = (((int)data_ref)/10)%10;
80000bc8:	7b 60 66 46 	movh %d4,26214
80000bcc:	1b 74 66 46 	addi %d4,%d4,26215
80000bd0:	73 48 6a 40 	mul %e4,%d8,%d4
80000bd4:	8f e5 3f 40 	sha %d4,%d5,-2
80000bd8:	0b 24 80 20 	sub %d2,%d4,%d2
80000bdc:	7b 60 66 46 	movh %d4,26214
80000be0:	1b 74 66 46 	addi %d4,%d4,26215
80000be4:	73 42 6a 40 	mul %e4,%d2,%d4
80000be8:	86 e5       	sha %d5,-2
80000bea:	8f 12 3e a0 	sha %d10,%d2,-31
80000bee:	0b a5 80 a0 	sub %d10,%d5,%d10
80000bf2:	53 aa 20 a0 	mul %d10,%d10,10
80000bf6:	0b a2 80 a0 	sub %d10,%d2,%d10
    int d1 = ((int)data_ref)%10;
80000bfa:	3b a0 00 20 	mov %d2,10
80000bfe:	4b 28 01 82 	div %e8,%d8,%d2
    int d0 = ((int)(data_ref*10))%10;
80000c02:	7b 00 12 d4 	movh %d13,16672
80000c06:	4b d6 41 30 	mul.f %d3,%d6,%d13
80000c0a:	4b 03 31 31 	ftoiz %d3,%d3
80000c0e:	4b 23 01 02 	div %e0,%d3,%d2

    data_rad = velocity_rad/100;           // 현재 속도 출력
80000c12:	91 00 00 26 	movh.a %a2,24576
80000c16:	d9 22 dc 50 	lea %a2,[%a2]3420 <60000d5c <velocity_rad>>
80000c1a:	54 23       	ld.w %d3,[%a2]
80000c1c:	7b 80 2c 44 	movh %d4,17096
80000c20:	4b 43 51 40 	div.f %d4,%d3,%d4
80000c24:	91 00 00 26 	movh.a %a2,24576
80000c28:	d9 22 d0 00 	lea %a2,[%a2]3088 <60000c10 <data_rad>>
80000c2c:	74 24       	st.w [%a2],%d4

    int r100 = ((int)data_rad/100);
80000c2e:	4b 04 31 31 	ftoiz %d3,%d4
80000c32:	7b c0 1e 65 	movh %d6,20972
80000c36:	1b f6 51 68 	addi %d6,%d6,-31457
80000c3a:	73 63 6a 60 	mul %e6,%d3,%d6
80000c3e:	8f b7 3f b0 	sha %d11,%d7,-5
80000c42:	8f 13 3e 50 	sha %d5,%d3,-31
80000c46:	a2 5b       	sub %d11,%d5
    int r10 = (((int)data_rad)/10)%10;
80000c48:	7b 60 66 66 	movh %d6,26214
80000c4c:	1b 76 66 66 	addi %d6,%d6,26215
80000c50:	73 63 6a 60 	mul %e6,%d3,%d6
80000c54:	8f e7 3f 60 	sha %d6,%d7,-2
80000c58:	0b 56 80 50 	sub %d5,%d6,%d5
80000c5c:	7b 60 66 66 	movh %d6,26214
80000c60:	1b 76 66 66 	addi %d6,%d6,26215
80000c64:	73 65 6a 60 	mul %e6,%d5,%d6
80000c68:	86 e7       	sha %d7,-2
80000c6a:	8f 15 3e 60 	sha %d6,%d5,-31
80000c6e:	a2 67       	sub %d7,%d6
80000c70:	73 27 0a 60 	mul %d6,%d7,%d2
80000c74:	0b 65 80 70 	sub %d7,%d5,%d6
    int r1 = ((int)data_rad)%10;
80000c78:	4b 23 01 e2 	div %e14,%d3,%d2
    int r0 = ((int)(data_rad*10))%10;
80000c7c:	4b d4 41 30 	mul.f %d3,%d4,%d13
80000c80:	4b 03 31 31 	ftoiz %d3,%d3
80000c84:	4b 23 01 42 	div %e4,%d3,%d2

    Ifx_SizeT count = 20;
80000c88:	3b 40 01 30 	mov %d3,20
80000c8c:	f9 e3 de ff 	st.h [%a14]-34,%d3

    uint8 dataSet[count];

    dataSet[0] = 'R';
80000c90:	3b 20 05 30 	mov %d3,82
80000c94:	e9 e3 ec ff 	st.b [%a14]-20,%d3
    dataSet[1] = 'e';
80000c98:	3b 50 06 40 	mov %d4,101
80000c9c:	e9 e4 ed ff 	st.b [%a14]-19,%d4
    dataSet[2] = 'f';
80000ca0:	3b 60 06 40 	mov %d4,102
80000ca4:	e9 e4 ee ff 	st.b [%a14]-18,%d4
    dataSet[3] = ',';
80000ca8:	3b c0 02 40 	mov %d4,44
80000cac:	e9 e4 ef ff 	st.b [%a14]-17,%d4
    dataSet[4] = 'R';
80000cb0:	e9 e3 f0 ff 	st.b [%a14]-16,%d3
    dataSet[5] = 'P';
80000cb4:	3b 00 05 30 	mov %d3,80
80000cb8:	e9 e3 f1 ff 	st.b [%a14]-15,%d3
    dataSet[6] = 'M';
80000cbc:	3b d0 04 30 	mov %d3,77
80000cc0:	e9 e3 f2 ff 	st.b [%a14]-14,%d3
    dataSet[7] = '\n';
80000cc4:	e9 e2 f3 ff 	st.b [%a14]-13,%d2

    dataSet[8] = (char)((d100)+'0');
80000cc8:	8f fc 0f 31 	and %d3,%d12,255
80000ccc:	1b 03 03 30 	addi %d3,%d3,48
80000cd0:	e9 e3 f4 ff 	st.b [%a14]-12,%d3
    dataSet[9] = (char)((d10)+'0');
80000cd4:	8f fa 0f 31 	and %d3,%d10,255
80000cd8:	1b 03 03 30 	addi %d3,%d3,48
80000cdc:	e9 e3 f5 ff 	st.b [%a14]-11,%d3
    dataSet[10] = (char)((d1)+'0');
80000ce0:	8f f9 0f 31 	and %d3,%d9,255
80000ce4:	1b 03 03 30 	addi %d3,%d3,48
80000ce8:	e9 e3 f6 ff 	st.b [%a14]-10,%d3
    dataSet[11] = '.';
80000cec:	3b e0 02 30 	mov %d3,46
80000cf0:	e9 e3 f7 ff 	st.b [%a14]-9,%d3
    dataSet[12] = (char)((d0)+'0');
80000cf4:	8f f1 0f 61 	and %d6,%d1,255
80000cf8:	1b 06 03 60 	addi %d6,%d6,48
80000cfc:	e9 e6 f8 ff 	st.b [%a14]-8,%d6
    dataSet[13] = ',';
80000d00:	e9 e4 f9 ff 	st.b [%a14]-7,%d4

    dataSet[14] = (char)((r100)+'0');
80000d04:	8f fb 0f 41 	and %d4,%d11,255
80000d08:	1b 04 03 40 	addi %d4,%d4,48
80000d0c:	e9 e4 fa ff 	st.b [%a14]-6,%d4
    dataSet[15] = (char)((r10)+'0');
80000d10:	8f f7 0f 41 	and %d4,%d7,255
80000d14:	1b 04 03 40 	addi %d4,%d4,48
80000d18:	e9 e4 fb ff 	st.b [%a14]-5,%d4
    dataSet[16] = (char)((r1)+'0');
80000d1c:	8f ff 0f 41 	and %d4,%d15,255
80000d20:	1b 04 03 40 	addi %d4,%d4,48
80000d24:	e9 e4 fc ff 	st.b [%a14]-4,%d4
    dataSet[17] = '.';
80000d28:	e9 e3 fd ff 	st.b [%a14]-3,%d3
    dataSet[18] = (char)((r0)+'0');
80000d2c:	8f f5 0f 31 	and %d3,%d5,255
80000d30:	1b 03 03 30 	addi %d3,%d3,48
80000d34:	e9 e3 fe ff 	st.b [%a14]-2,%d3
    dataSet[19] = '\n';
80000d38:	e9 e2 ff ff 	st.b [%a14]-1,%d2

    IfxAsclin_Asc_write(&PC_ascHandle0, dataSet, &count, TIME_INFINITE);
80000d3c:	82 f4       	mov %d4,-1
80000d3e:	82 f5       	mov %d5,-1
80000d40:	06 f5       	sh %d5,-1
80000d42:	d9 e6 de ff 	lea %a6,[%a14]-34
80000d46:	d9 e5 ec ff 	lea %a5,[%a14]-20
80000d4a:	91 00 00 46 	movh.a %a4,24576
80000d4e:	d9 44 b0 f0 	lea %a4,[%a4]3056 <60000bf0 <PC_ascHandle0>>
80000d52:	6d 00 8a 2b 	call 80006466 <IfxAsclin_Asc_write>

    if(Uart_PC_Output == 'W'){   // 경고
80000d56:	91 00 00 26 	movh.a %a2,24576
80000d5a:	79 22 ec 10 	ld.b %d2,[%a2]3180 <60000c6c <Uart_PC_Output>>
80000d5e:	3b 70 05 30 	mov %d3,87
80000d62:	5f 32 0b 00 	jeq %d2,%d3,80000d78 <out_UART_PC+0x20c>
        dataSet_W[11] = '\n';
        IfxAsclin_Asc_write(&PC_ascHandle0, dataSet_W, &count, TIME_INFINITE);
    }


}
80000d66:	00 90       	ret 
        data_ref = 0;
80000d68:	91 00 00 26 	movh.a %a2,24576
80000d6c:	82 02       	mov %d2,0
80000d6e:	d9 22 d4 00 	lea %a2,[%a2]3092 <60000c14 <data_ref>>
80000d72:	74 22       	st.w [%a2],%d2
80000d74:	1d ff 18 ff 	j 80000ba4 <out_UART_PC+0x38>
        dataSet_W[0] = 'T';
80000d78:	3b 40 05 20 	mov %d2,84
80000d7c:	e9 e2 e0 ff 	st.b [%a14]-32,%d2
        dataSet_W[1] = 'e';
80000d80:	3b 50 06 20 	mov %d2,101
80000d84:	e9 e2 e1 ff 	st.b [%a14]-31,%d2
        dataSet_W[2] = 'm';
80000d88:	3b d0 06 20 	mov %d2,109
80000d8c:	e9 e2 e2 ff 	st.b [%a14]-30,%d2
        dataSet_W[3] = 'p';
80000d90:	3b 00 07 20 	mov %d2,112
80000d94:	e9 e2 e3 ff 	st.b [%a14]-29,%d2
        dataSet_W[4] = 'W';
80000d98:	3b 70 05 20 	mov %d2,87
80000d9c:	e9 e2 e4 ff 	st.b [%a14]-28,%d2
        dataSet_W[5] = 'a';
80000da0:	3b 10 06 20 	mov %d2,97
80000da4:	e9 e2 e5 ff 	st.b [%a14]-27,%d2
        dataSet_W[6] = 'r';
80000da8:	3b 20 07 20 	mov %d2,114
80000dac:	e9 e2 e6 ff 	st.b [%a14]-26,%d2
        dataSet_W[7] = 'n';
80000db0:	3b e0 06 20 	mov %d2,110
80000db4:	e9 e2 e7 ff 	st.b [%a14]-25,%d2
        dataSet_W[8] = 'i';
80000db8:	3b 90 06 30 	mov %d3,105
80000dbc:	e9 e3 e8 ff 	st.b [%a14]-24,%d3
        dataSet_W[9] = 'n';
80000dc0:	e9 e2 e9 ff 	st.b [%a14]-23,%d2
        dataSet_W[10] = 'g';
80000dc4:	3b 70 06 20 	mov %d2,103
80000dc8:	e9 e2 ea ff 	st.b [%a14]-22,%d2
        dataSet_W[11] = '\n';
80000dcc:	3b a0 00 20 	mov %d2,10
80000dd0:	e9 e2 eb ff 	st.b [%a14]-21,%d2
        IfxAsclin_Asc_write(&PC_ascHandle0, dataSet_W, &count, TIME_INFINITE);
80000dd4:	82 f4       	mov %d4,-1
80000dd6:	82 f5       	mov %d5,-1
80000dd8:	06 f5       	sh %d5,-1
80000dda:	d9 e6 de ff 	lea %a6,[%a14]-34
80000dde:	d9 e5 e0 ff 	lea %a5,[%a14]-32
80000de2:	91 00 00 46 	movh.a %a4,24576
80000de6:	d9 44 b0 f0 	lea %a4,[%a4]3056 <60000bf0 <PC_ascHandle0>>
80000dea:	6d 00 3e 2b 	call 80006466 <IfxAsclin_Asc_write>
}
80000dee:	1d ff bc ff 	j 80000d66 <out_UART_PC+0x1fa>

80000df2 <init_UART_SUB>:



//----------------- Main <-> Sub -----------------//
void init_UART_SUB(void){
80000df2:	40 ae       	mov.aa %a14,%sp
80000df4:	20 98       	sub.a %sp,152
    IfxAsclin_Asc_Config    ascConf;

    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN2);
80000df6:	c5 f5 80 00 	lea %a5,f0000800 <_SMALL_DATA4_+0x5fff8800>
80000dfa:	d9 e4 cc ef 	lea %a4,[%a14]-116
80000dfe:	6d 00 bb 2a 	call 80006374 <IfxAsclin_Asc_initModuleConfig>

    ascConf.baudrate.baudrate   = ASC_BAUDRATE;
80000e02:	7b 10 7e 24 	movh %d2,18401
80000e06:	59 e2 d0 ef 	st.w [%a14]-112,%d2
    ascConf.baudrate.oversampling   = IfxAsclin_OversamplingFactor_16;
80000e0a:	3b f0 00 20 	mov %d2,15
80000e0e:	59 e2 d8 ef 	st.w [%a14]-104,%d2

    ascConf.bitTiming.medianFilter  = IfxAsclin_SamplesPerBit_three;
80000e12:	82 12       	mov %d2,1
80000e14:	59 e2 dc ef 	st.w [%a14]-100,%d2
    ascConf.bitTiming.samplePointPosition   = IfxAsclin_SamplePointPosition_8;
80000e18:	3b 80 00 20 	mov %d2,8
80000e1c:	59 e2 e0 ef 	st.w [%a14]-96,%d2

    ascConf.interrupt.txPriority    = ISR_PRIORITY_ASCLIN_TX_SUB;
80000e20:	3b 90 00 20 	mov %d2,9
80000e24:	f9 e2 d4 ff 	st.h [%a14]-44,%d2
    ascConf.interrupt.rxPriority    = ISR_PRIORITY_ASCLIN_RX_SUB;
80000e28:	82 52       	mov %d2,5
80000e2a:	f9 e2 d6 ff 	st.h [%a14]-42,%d2
    ascConf.interrupt.erPriority    = ISR_PRIORITY_ASCLIN_ER_SUB;
80000e2e:	3b d0 00 20 	mov %d2,13
80000e32:	f9 e2 d8 ff 	st.h [%a14]-40,%d2
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;
80000e36:	82 02       	mov %d2,0
80000e38:	59 e2 dc ff 	st.w [%a14]-36,%d2

    const IfxAsclin_Asc_Pins pins = {
80000e3c:	d9 e3 e8 df 	lea %a3,[%a14]-152
80000e40:	91 00 00 26 	movh.a %a2,24576
80000e44:	d9 22 24 00 	lea %a2,[%a2]36 <60000024 <LCF_DSPR1_START+0x24>>
80000e48:	40 34       	mov.aa %a4,%a3
80000e4a:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000e4e:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000e52:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000e56:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000e5a:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000e5e:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000e62:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
80000e66:	89 44 48 01 	st.d [%a4+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
80000e6a:	44 24       	ld.w %d4,[%a2+]
80000e6c:	64 44       	st.w [%a4+],%d4
            .ctsMode    = IfxPort_InputMode_pullUp,
            .rts        = NULL_PTR,
            .rtsMode    = IfxPort_OutputMode_pushPull,
            .pinDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;
80000e6e:	b5 e3 e0 ff 	st.a [%a14]-32 <60000008 <LCF_DSPR1_START+0x8>>,%a3

    ascConf.txBuffer        = SUB_uartTxBuffer;
80000e72:	91 00 00 26 	movh.a %a2,24576
80000e76:	d9 22 98 10 	lea %a2,[%a2]2136 <60000858 <SUB_uartTxBuffer>>
80000e7a:	b5 e2 ec ff 	st.a [%a14]-20 <60000858 <SUB_uartTxBuffer>>,%a2
    ascConf.txBufferSize    = ASC_TX_BUFFER_SIZE;
80000e7e:	3b 00 10 20 	mov %d2,256
80000e82:	f9 e2 ea ff 	st.h [%a14]-22,%d2
    ascConf.rxBuffer        = SUB_uartRxBuffer;
80000e86:	91 00 00 26 	movh.a %a2,24576
80000e8a:	d9 22 70 c0 	lea %a2,[%a2]1840 <60000730 <SUB_uartRxBuffer>>
80000e8e:	b5 e2 f4 ff 	st.a [%a14]-12 <60000730 <SUB_uartRxBuffer>>,%a2
    ascConf.rxBufferSize    = ASC_RX_BUFFER_SIZE;
80000e92:	f9 e2 f0 ff 	st.h [%a14]-16 <60000730 <SUB_uartRxBuffer>>,%d2

    IfxAsclin_Asc_initModule(&SUB_ascHandle0, &ascConf);
80000e96:	d9 e5 cc ef 	lea %a5,[%a14]-116 <60000730 <SUB_uartRxBuffer>>
80000e9a:	91 00 00 46 	movh.a %a4,24576
80000e9e:	d9 44 80 60 	lea %a4,[%a4]2432 <60000980 <SUB_ascHandle0>>
80000ea2:	6d 00 2f 28 	call 80005f00 <IfxAsclin_Asc_initModule>

}
80000ea6:	00 90       	ret 

80000ea8 <out_UART_SUB>:

// 서브 보드로 데이터 전송
void out_UART_SUB(const unsigned char chr){
80000ea8:	40 ae       	mov.aa %a14,%sp
        IfxAsclin_Asc_blockingWrite(&SUB_ascHandle0, chr);
80000eaa:	8f f4 0f 41 	and %d4,%d4,255
80000eae:	91 00 00 46 	movh.a %a4,24576
80000eb2:	d9 44 80 60 	lea %a4,[%a4]2432 <60000980 <SUB_ascHandle0>>
80000eb6:	6d 00 1a 2b 	call 800064ea <IfxAsclin_Asc_blockingWrite>
}
80000eba:	00 90       	ret 

80000ebc <asc0TxISR>:


//----------------- Main <-> PC -----------------//
IFX_INTERRUPT(asc0TxISR, 0, ISR_PRIORITY_ASCLIN_TX_PC);
void asc0TxISR(void){
80000ebc:	40 ae       	mov.aa %a14,%sp
    IfxAsclin_Asc_isrTransmit(&PC_ascHandle0);
80000ebe:	91 00 00 46 	movh.a %a4,24576
80000ec2:	d9 44 b0 f0 	lea %a4,[%a4]3056 <60000bf0 <PC_ascHandle0>>
80000ec6:	6d 00 43 27 	call 80005d4c <IfxAsclin_Asc_isrTransmit>
}
80000eca:	0d 00 40 02 	rslcx 
80000ece:	00 80       	rfe 

80000ed0 <asc0RxISR>:

IFX_INTERRUPT(asc0RxISR, 0, ISR_PRIORITY_ASCLIN_RX_PC);
void asc0RxISR(void){
80000ed0:	40 ae       	mov.aa %a14,%sp
    IfxAsclin_Asc_isrReceive(&PC_ascHandle0);
80000ed2:	91 00 00 46 	movh.a %a4,24576
80000ed6:	d9 44 b0 f0 	lea %a4,[%a4]3056 <60000bf0 <PC_ascHandle0>>
80000eda:	6d 00 9f 27 	call 80005e18 <IfxAsclin_Asc_isrReceive>

    if(RXcnt_PC == byte0){
80000ede:	91 00 00 26 	movh.a %a2,24576
80000ee2:	d9 22 e8 10 	lea %a2,[%a2]3176 <60000c68 <RXcnt_PC>>
80000ee6:	54 23       	ld.w %d3,[%a2]
80000ee8:	82 02       	mov %d2,0
80000eea:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000eee:	8f d2 00 21 	and %d2,%d2,13
80000ef2:	df 02 1b 00 	jeq %d2,0,80000f28 <asc0RxISR+0x58>
        RXcnt_PC = byte1;
        RXDATA_PC[byte0] = IfxAsclin_Asc_blockingRead(&PC_ascHandle0);
    }

    else if(RXcnt_PC == byte1){
80000ef6:	7b 00 f8 23 	movh %d2,16256
80000efa:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000efe:	8f d2 00 21 	and %d2,%d2,13
80000f02:	df 02 26 00 	jeq %d2,0,80000f4e <asc0RxISR+0x7e>
        RXcnt_PC = byte0;
        RXDATA_PC[byte1] = IfxAsclin_Asc_blockingRead(&PC_ascHandle0);
    }
    if(RXDATA_PC[0] == 'C' && RXDATA_PC[1] == '\n'){Uart_SUB_Output = 'O';}
80000f06:	91 00 00 26 	movh.a %a2,24576
80000f0a:	39 22 e4 10 	ld.bu %d2,[%a2]3172 <60000c64 <RXDATA_PC>>
80000f0e:	3b 30 04 30 	mov %d3,67
80000f12:	5f 32 32 00 	jeq %d2,%d3,80000f76 <asc0RxISR+0xa6>
    else{Uart_SUB_Output = 'X';}
80000f16:	91 00 00 26 	movh.a %a2,24576
80000f1a:	3b 80 05 20 	mov %d2,88
80000f1e:	e9 22 ed 10 	st.b [%a2]3181 <60000c6d <Uart_SUB_Output>>,%d2

}
80000f22:	0d 00 40 02 	rslcx 
80000f26:	00 80       	rfe 
        RXcnt_PC = byte1;
80000f28:	91 00 00 26 	movh.a %a2,24576
80000f2c:	7b 00 f8 23 	movh %d2,16256
80000f30:	d9 22 e8 10 	lea %a2,[%a2]3176 <60000c68 <RXcnt_PC>>
80000f34:	74 22       	st.w [%a2],%d2
        RXDATA_PC[byte0] = IfxAsclin_Asc_blockingRead(&PC_ascHandle0);
80000f36:	91 00 00 46 	movh.a %a4,24576
80000f3a:	d9 44 b0 f0 	lea %a4,[%a4]3056 <60000bf0 <PC_ascHandle0>>
80000f3e:	6d 00 cc 27 	call 80005ed6 <IfxAsclin_Asc_blockingRead>
80000f42:	91 00 00 26 	movh.a %a2,24576
80000f46:	e9 22 e4 10 	st.b [%a2]3172 <60000c64 <RXDATA_PC>>,%d2
80000f4a:	1d ff de ff 	j 80000f06 <asc0RxISR+0x36>
        RXcnt_PC = byte0;
80000f4e:	91 00 00 26 	movh.a %a2,24576
80000f52:	82 02       	mov %d2,0
80000f54:	d9 22 e8 10 	lea %a2,[%a2]3176 <60000c68 <RXcnt_PC>>
80000f58:	74 22       	st.w [%a2],%d2
        RXDATA_PC[byte1] = IfxAsclin_Asc_blockingRead(&PC_ascHandle0);
80000f5a:	91 00 00 46 	movh.a %a4,24576
80000f5e:	d9 44 b0 f0 	lea %a4,[%a4]3056 <60000bf0 <PC_ascHandle0>>
80000f62:	6d 00 ba 27 	call 80005ed6 <IfxAsclin_Asc_blockingRead>
80000f66:	91 00 00 26 	movh.a %a2,24576
80000f6a:	d9 22 e4 10 	lea %a2,[%a2]3172 <60000c64 <RXDATA_PC>>
80000f6e:	e9 22 01 00 	st.b [%a2]1 <60000001 <LCF_DSPR1_START+0x1>>,%d2
80000f72:	1d ff ca ff 	j 80000f06 <asc0RxISR+0x36>
    if(RXDATA_PC[0] == 'C' && RXDATA_PC[1] == '\n'){Uart_SUB_Output = 'O';}
80000f76:	d9 22 e4 10 	lea %a2,[%a2]3172 <60000c64 <RXDATA_PC>>
80000f7a:	39 22 01 00 	ld.bu %d2,[%a2]1 <60000001 <LCF_DSPR1_START+0x1>>
80000f7e:	3b a0 00 30 	mov %d3,10
80000f82:	5f 32 ca ff 	jne %d2,%d3,80000f16 <asc0RxISR+0x46>
80000f86:	91 00 00 26 	movh.a %a2,24576
80000f8a:	3b f0 04 20 	mov %d2,79
80000f8e:	e9 22 ed 10 	st.b [%a2]3181 <60000c6d <Uart_SUB_Output>>,%d2
80000f92:	0d 00 40 02 	rslcx 
80000f96:	00 80       	rfe 

80000f98 <asc0ErrISR>:

IFX_INTERRUPT(asc0ErrISR, 0, ISR_PRIORITY_ASCLIN_ER_PC);
void asc0ErrISR(void){
80000f98:	40 ae       	mov.aa %a14,%sp
    while(1);
80000f9a:	1d 00 00 00 	j 80000f9a <asc0ErrISR+0x2>

80000f9e <asc2TxISR>:



//----------------- Main <-> Sub -----------------//
IFX_INTERRUPT(asc2TxISR, 0, ISR_PRIORITY_ASCLIN_TX_SUB);
void asc2TxISR(void){
80000f9e:	40 ae       	mov.aa %a14,%sp
    IfxAsclin_Asc_isrTransmit(&SUB_ascHandle0);
80000fa0:	91 00 00 46 	movh.a %a4,24576
80000fa4:	d9 44 80 60 	lea %a4,[%a4]2432 <60000980 <SUB_ascHandle0>>
80000fa8:	6d 00 d2 26 	call 80005d4c <IfxAsclin_Asc_isrTransmit>
}
80000fac:	0d 00 40 02 	rslcx 
80000fb0:	00 80       	rfe 

80000fb2 <asc2RxISR>:

IFX_INTERRUPT(asc2RxISR, 0, ISR_PRIORITY_ASCLIN_RX_SUB);
void asc2RxISR(void){
80000fb2:	40 ae       	mov.aa %a14,%sp
    IfxAsclin_Asc_isrReceive(&SUB_ascHandle0);
80000fb4:	91 00 00 46 	movh.a %a4,24576
80000fb8:	d9 44 80 60 	lea %a4,[%a4]2432 <60000980 <SUB_ascHandle0>>
80000fbc:	6d 00 2e 27 	call 80005e18 <IfxAsclin_Asc_isrReceive>

    if(RXcnt_SUB == byte0){
80000fc0:	91 00 00 26 	movh.a %a2,24576
80000fc4:	d9 22 e0 10 	lea %a2,[%a2]3168 <60000c60 <RXcnt_SUB>>
80000fc8:	54 23       	ld.w %d3,[%a2]
80000fca:	82 02       	mov %d2,0
80000fcc:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000fd0:	8f d2 00 21 	and %d2,%d2,13
80000fd4:	df 02 26 00 	jeq %d2,0,80001020 <asc2RxISR+0x6e>
        RXcnt_SUB = byte1;
        RXDATA_SUB[byte0] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
    }

    else if(RXcnt_SUB == byte1){
80000fd8:	7b 00 f8 23 	movh %d2,16256
80000fdc:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000fe0:	8f d2 00 21 	and %d2,%d2,13
80000fe4:	df 02 40 00 	jeq %d2,0,80001064 <asc2RxISR+0xb2>
            RXcnt_SUB = byte2;
            RXDATA_SUB[byte1] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
    }
    else if(RXcnt_SUB == byte2){
80000fe8:	7b 00 00 24 	movh %d2,16384
80000fec:	4b 23 01 20 	cmp.f %d2,%d3,%d2
80000ff0:	8f d2 00 21 	and %d2,%d2,13
80000ff4:	df 02 27 80 	jne %d2,0,80001042 <asc2RxISR+0x90>
                RXcnt_SUB = byte0;
80000ff8:	91 00 00 26 	movh.a %a2,24576
80000ffc:	82 02       	mov %d2,0
80000ffe:	d9 22 e0 10 	lea %a2,[%a2]3168 <60000c60 <RXcnt_SUB>>
80001002:	74 22       	st.w [%a2],%d2
                RXDATA_SUB[byte2] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
80001004:	91 00 00 46 	movh.a %a4,24576
80001008:	d9 44 80 60 	lea %a4,[%a4]2432 <60000980 <SUB_ascHandle0>>
8000100c:	6d 00 65 27 	call 80005ed6 <IfxAsclin_Asc_blockingRead>
80001010:	91 00 00 26 	movh.a %a2,24576
80001014:	d9 22 dc 10 	lea %a2,[%a2]3164 <60000c5c <RXDATA_SUB>>
80001018:	e9 22 02 00 	st.b [%a2]2 <60000002 <LCF_DSPR1_START+0x2>>,%d2
8000101c:	1d 00 13 00 	j 80001042 <asc2RxISR+0x90>
        RXcnt_SUB = byte1;
80001020:	91 00 00 26 	movh.a %a2,24576
80001024:	7b 00 f8 23 	movh %d2,16256
80001028:	d9 22 e0 10 	lea %a2,[%a2]3168 <60000c60 <RXcnt_SUB>>
8000102c:	74 22       	st.w [%a2],%d2
        RXDATA_SUB[byte0] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
8000102e:	91 00 00 46 	movh.a %a4,24576
80001032:	d9 44 80 60 	lea %a4,[%a4]2432 <60000980 <SUB_ascHandle0>>
80001036:	6d 00 50 27 	call 80005ed6 <IfxAsclin_Asc_blockingRead>
8000103a:	91 00 00 26 	movh.a %a2,24576
8000103e:	e9 22 dc 10 	st.b [%a2]3164 <60000c5c <RXDATA_SUB>>,%d2
    }
    if(RXDATA_SUB[0] == 'E' && RXDATA_SUB[1] == 'H' && RXDATA_SUB[2] == '\n'){
80001042:	91 00 00 26 	movh.a %a2,24576
80001046:	39 22 dc 10 	ld.bu %d2,[%a2]3164 <60000c5c <RXDATA_SUB>>
8000104a:	3b 50 04 30 	mov %d3,69
8000104e:	5f 32 20 00 	jeq %d2,%d3,8000108e <asc2RxISR+0xdc>
        Uart_PC_Output = 'W';   // 경고
    }
    else{Uart_PC_Output = 'S';} // 안전
80001052:	91 00 00 26 	movh.a %a2,24576
80001056:	3b 30 05 20 	mov %d2,83
8000105a:	e9 22 ec 10 	st.b [%a2]3180 <60000c6c <Uart_PC_Output>>,%d2
}
8000105e:	0d 00 40 02 	rslcx 
80001062:	00 80       	rfe 
            RXcnt_SUB = byte2;
80001064:	91 00 00 26 	movh.a %a2,24576
80001068:	7b 00 00 24 	movh %d2,16384
8000106c:	d9 22 e0 10 	lea %a2,[%a2]3168 <60000c60 <RXcnt_SUB>>
80001070:	74 22       	st.w [%a2],%d2
            RXDATA_SUB[byte1] = IfxAsclin_Asc_blockingRead(&SUB_ascHandle0);
80001072:	91 00 00 46 	movh.a %a4,24576
80001076:	d9 44 80 60 	lea %a4,[%a4]2432 <60000980 <SUB_ascHandle0>>
8000107a:	6d 00 2e 27 	call 80005ed6 <IfxAsclin_Asc_blockingRead>
8000107e:	91 00 00 26 	movh.a %a2,24576
80001082:	d9 22 dc 10 	lea %a2,[%a2]3164 <60000c5c <RXDATA_SUB>>
80001086:	e9 22 01 00 	st.b [%a2]1 <60000001 <LCF_DSPR1_START+0x1>>,%d2
8000108a:	1d ff dc ff 	j 80001042 <asc2RxISR+0x90>
    if(RXDATA_SUB[0] == 'E' && RXDATA_SUB[1] == 'H' && RXDATA_SUB[2] == '\n'){
8000108e:	d9 22 dc 10 	lea %a2,[%a2]3164 <60000c5c <RXDATA_SUB>>
80001092:	39 22 01 00 	ld.bu %d2,[%a2]1 <60000001 <LCF_DSPR1_START+0x1>>
80001096:	3b 80 04 30 	mov %d3,72
8000109a:	5f 32 dc ff 	jne %d2,%d3,80001052 <asc2RxISR+0xa0>
8000109e:	91 00 00 26 	movh.a %a2,24576
800010a2:	d9 22 dc 10 	lea %a2,[%a2]3164 <60000c5c <RXDATA_SUB>>
800010a6:	39 22 02 00 	ld.bu %d2,[%a2]2 <60000002 <LCF_DSPR1_START+0x2>>
800010aa:	3b a0 00 30 	mov %d3,10
800010ae:	5f 32 d2 ff 	jne %d2,%d3,80001052 <asc2RxISR+0xa0>
        Uart_PC_Output = 'W';   // 경고
800010b2:	91 00 00 26 	movh.a %a2,24576
800010b6:	3b 70 05 20 	mov %d2,87
800010ba:	e9 22 ec 10 	st.b [%a2]3180 <60000c6c <Uart_PC_Output>>,%d2
800010be:	0d 00 40 02 	rslcx 
800010c2:	00 80       	rfe 

800010c4 <asc2ErrISR>:

IFX_INTERRUPT(asc2ErrISR, 0, ISR_PRIORITY_ASCLIN_ER_SUB);
void asc2ErrISR(void){
800010c4:	40 ae       	mov.aa %a14,%sp
    while(1);
800010c6:	1d 00 00 00 	j 800010c6 <asc2ErrISR+0x2>

800010ca <Task1ms>:
        }

    }
}

void Task1ms(void){
800010ca:	40 ae       	mov.aa %a14,%sp
    //cnt1ms++;
    radiantospeed();        // 엔코더 값 변환 및 필터링
800010cc:	6d 00 62 2d 	call 80006b90 <radiantospeed>
    target_speed_decision();    // 목표 속도 판단
800010d0:	6d 00 19 02 	call 80001502 <target_speed_decision>
    PID_motor_control();    // PID 제어
800010d4:	6d 00 d0 02 	call 80001674 <PID_motor_control>
    PWM_dutyUpdate();       // PWM 업데이트
800010d8:	6d 00 17 01 	call 80001306 <PWM_dutyUpdate>
}
800010dc:	00 90       	ret 

800010de <Task10ms>:

void Task10ms(void){
800010de:	40 ae       	mov.aa %a14,%sp
    //cnt10ms++;
    Mode_flag = GetState_SWITCH();
800010e0:	6d 00 5b 00 	call 80001196 <GetState_SWITCH>
800010e4:	91 00 00 26 	movh.a %a2,24576
800010e8:	59 22 f0 10 	st.w [%a2]3184 <60000c70 <Mode_flag>>,%d2
    ADC_G4_GetData();
800010ec:	6d 00 ea 2d 	call 80006cc0 <ADC_G4_GetData>
}
800010f0:	00 90       	ret 

800010f2 <Task100ms>:

void Task100ms(void){
800010f2:	40 ae       	mov.aa %a14,%sp
    //cnt100ms++;
    obstacle_state_decision();  // 장애물 상태 판단
800010f4:	6d ff 35 fc 	call 8000095e <obstacle_state_decision>

    out_UART_PC('c');   //  목표 값, 현재 모터 속도 값 전송
800010f8:	3b 30 06 40 	mov %d4,99
800010fc:	6d ff 38 fd 	call 80000b6c <out_UART_PC>
    out_UART_SUB(Uart_SUB_Output);  // 쿨러 작동 신호 전송
80001100:	91 00 00 26 	movh.a %a2,24576
80001104:	39 24 ed 10 	ld.bu %d4,[%a2]3181 <60000c6d <Uart_SUB_Output>>
80001108:	6d ff d0 fe 	call 80000ea8 <out_UART_SUB>

    redled_buzzer_cycle();
8000110c:	6d 00 d8 2a 	call 800066bc <redled_buzzer_cycle>
    rgb_led_color();
80001110:	6d 00 7b 2b 	call 80006806 <rgb_led_color>
    blue_led_onoff();
80001114:	6d 00 1c 2c 	call 8000694c <blue_led_onoff>

}
80001118:	00 90       	ret 

8000111a <Task1000ms>:

void Task1000ms(void){
8000111a:	40 ae       	mov.aa %a14,%sp
    cnt1000ms++;
8000111c:	91 00 00 26 	movh.a %a2,24576
80001120:	d9 23 d0 20 	lea %a3,[%a2]3216 <60000c90 <cnt1000ms>>
80001124:	54 32       	ld.w %d2,[%a3]
80001126:	c2 12       	add %d2,1
80001128:	59 22 d0 20 	st.w [%a2]3216 <60000c90 <cnt1000ms>>,%d2

}
8000112c:	00 90       	ret 

8000112e <AppScheduling>:
void AppScheduling(void){
8000112e:	40 ae       	mov.aa %a14,%sp
    if(Scheduler1msFlag == 1){
80001130:	91 00 00 26 	movh.a %a2,24576
80001134:	19 22 e8 00 	ld.w %d2,[%a2]3112 <60000c28 <Scheduler1msFlag>>
80001138:	df 12 03 00 	jeq %d2,1,8000113e <AppScheduling+0x10>
}
8000113c:	00 90       	ret 
        Scheduler1msFlag = 0;
8000113e:	82 02       	mov %d2,0
80001140:	59 22 e8 00 	st.w [%a2]3112,%d2
        Task1ms();
80001144:	6d ff c3 ff 	call 800010ca <Task1ms>
        if(Scheduler10msFlag == 1){
80001148:	91 00 00 26 	movh.a %a2,24576
8000114c:	19 22 e4 00 	ld.w %d2,[%a2]3108 <60000c24 <Scheduler10msFlag>>
80001150:	df 12 15 00 	jeq %d2,1,8000117a <AppScheduling+0x4c>
        if(Scheduler100msFlag == 1){
80001154:	91 00 00 26 	movh.a %a2,24576
80001158:	19 22 e0 00 	ld.w %d2,[%a2]3104 <60000c20 <Scheduler100msFlag>>
8000115c:	df 12 16 00 	jeq %d2,1,80001188 <AppScheduling+0x5a>
        if(Scheduler1000msFlag == 1){
80001160:	91 00 00 26 	movh.a %a2,24576
80001164:	19 22 dc 00 	ld.w %d2,[%a2]3100 <60000c1c <Scheduler1000msFlag>>
80001168:	df 12 ea ff 	jne %d2,1,8000113c <AppScheduling+0xe>
            Scheduler1000msFlag = 0;
8000116c:	82 02       	mov %d2,0
8000116e:	59 22 dc 00 	st.w [%a2]3100 <60000c1c <Scheduler1000msFlag>>,%d2
            Task1000ms();
80001172:	6d ff d4 ff 	call 8000111a <Task1000ms>
}
80001176:	1d ff e3 ff 	j 8000113c <AppScheduling+0xe>
            Scheduler10msFlag = 0;
8000117a:	82 02       	mov %d2,0
8000117c:	59 22 e4 00 	st.w [%a2]3108,%d2
            Task10ms();
80001180:	6d ff af ff 	call 800010de <Task10ms>
80001184:	1d ff e8 ff 	j 80001154 <AppScheduling+0x26>
            Scheduler100msFlag = 0;
80001188:	82 02       	mov %d2,0
8000118a:	59 22 e0 00 	st.w [%a2]3104,%d2
            Task100ms();
8000118e:	6d ff b2 ff 	call 800010f2 <Task100ms>
80001192:	1d ff e7 ff 	j 80001160 <AppScheduling+0x32>

80001196 <GetState_SWITCH>:
//{
//    IfxPort_setPinModeInput(PORT_002, IfxPort_InputMode_pullUp); // SW1 핀을 입력으로 설정
//} // 초기화 함수

int GetState_SWITCH(void)
{
80001196:	40 ae       	mov.aa %a14,%sp
80001198:	91 40 00 2f 	movh.a %a2,61444
8000119c:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800011a0:	19 22 24 00 	ld.w %d2,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
800011a4:	8f 12 00 31 	and %d3,%d2,1
    static int state = 0;  // 현재 반환할 상태 (0 또는 1)
    static int lastSwitchState = 1;  // 이전 스위치 상태를 추적
    int currentSwitchState = IfxPort_getPinState(PORT_SW1);

    // SW1을 눌렀다 떼는 동작이 발생할 때 상태를 변경
    if (currentSwitchState == 1 && lastSwitchState == 0)  // 눌렀다 떼면
800011a8:	6f 02 0b 80 	jnz.t %d2,0,800011be <GetState_SWITCH+0x28>
    {
        state = !state;  // 상태를 반전
    }

    // 현재 스위치 상태를 기록
    lastSwitchState = currentSwitchState;
800011ac:	91 00 00 26 	movh.a %a2,24576
800011b0:	59 23 5c 60 	st.w [%a2]1436 <6000059c <lastSwitchState.1>>,%d3


    // 현재 상태 반환
    return state;
} // SW1을 눌렀다 떼면 1과 0을 번갈아 반환하는 함수
800011b4:	91 00 00 26 	movh.a %a2,24576
800011b8:	19 22 d8 00 	ld.w %d2,[%a2]3096 <60000c18 <state.0>>
800011bc:	00 90       	ret 
    if (currentSwitchState == 1 && lastSwitchState == 0)  // 눌렀다 떼면
800011be:	91 00 00 26 	movh.a %a2,24576
800011c2:	19 22 5c 60 	ld.w %d2,[%a2]1436 <6000059c <lastSwitchState.1>>
800011c6:	df 02 f3 ff 	jne %d2,0,800011ac <GetState_SWITCH+0x16>
        state = !state;  // 상태를 반전
800011ca:	91 00 00 26 	movh.a %a2,24576
800011ce:	19 22 d8 00 	ld.w %d2,[%a2]3096 <60000c18 <state.0>>
800011d2:	8b 02 00 22 	eq %d2,%d2,0
800011d6:	59 22 d8 00 	st.w [%a2]3096 <60000c18 <state.0>>,%d2
800011da:	1d ff e9 ff 	j 800011ac <GetState_SWITCH+0x16>

800011de <init_STM>:
uint32 Scheduler1msFlag = 0;
uint32 Scheduler10msFlag = 0;
uint32 Scheduler100msFlag = 0;
uint32 Scheduler1000msFlag = 0;

void init_STM(void){
800011de:	40 ae       	mov.aa %a14,%sp
/******************************************************************************/

IFX_INLINE boolean IfxCpu_areInterruptsEnabled(void)
{
    Ifx_CPU_ICR reg;
    reg.U = __mfcr(CPU_ICR);
800011e0:	4d c0 e2 8f 	mfcr %d8,$icr
    return reg.B.IE != 0;
800011e4:	37 08 e1 87 	extr.u %d8,%d8,15,1

IFX_INLINE boolean IfxCpu_disableInterrupts(void)
{
    boolean enabled;
    enabled = IfxCpu_areInterruptsEnabled();
    __disable();
800011e8:	0d 00 40 03 	disable 

/** Insert NOP instruction
 */
IFX_INLINE void Ifx__nop(void)
{
    __asm__ volatile ("nop" : : : "memory");
800011ec:	00 00       	nop 

    boolean ISR_State = IfxCpu_disableInterrupts();

    IfxStm_enableOcdsSuspend(STM0);
800011ee:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
800011f2:	6d 00 72 0b 	call 800028d6 <IfxStm_enableOcdsSuspend>
    IfxStm_initCompareConfig(&stmConfig);
800011f6:	91 00 00 c6 	movh.a %a12,24576
800011fa:	d9 cc f4 10 	lea %a12,[%a12]3188 <60000c74 <stmConfig>>
800011fe:	40 c4       	mov.aa %a4,%a12
80001200:	6d 00 48 0c 	call 80002a90 <IfxStm_initCompareConfig>

    stmConfig.ticks             = 100000u;
80001204:	7b 20 00 20 	movh %d2,2
80001208:	1b 02 6a 28 	addi %d2,%d2,-31072
8000120c:	59 c2 10 00 	st.w [%a12]16 <60000010 <LCF_DSPR1_START+0x10>>,%d2
    stmConfig.triggerPriority   = 100u;
80001210:	3b 40 06 20 	mov %d2,100
80001214:	f9 c2 14 00 	st.h [%a12]20 <60000014 <LCF_DSPR1_START+0x14>>,%d2
    stmConfig.typeOfService     = IfxSrc_Tos_cpu0;
80001218:	82 02       	mov %d2,0
8000121a:	59 c2 18 00 	st.w [%a12]24 <60000018 <LCF_DSPR1_START+0x18>>,%d2

    IfxStm_initCompare(STM0, &stmConfig);
8000121e:	40 c5       	mov.aa %a5,%a12
80001220:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001224:	6d 00 8d 0b 	call 8000293e <IfxStm_initCompare>
}


IFX_INLINE void IfxCpu_restoreInterrupts(boolean enabled)
{
    if (enabled != FALSE)
80001228:	df 08 04 00 	jeq %d8,0,80001230 <init_STM+0x52>
    {
        __enable();
8000122c:	0d 00 00 03 	enable 

    IfxCpu_restoreInterrupts(ISR_State);

}
80001230:	00 90       	ret 

80001232 <ISR_STM>:

IFX_INTERRUPT(ISR_STM,0,100);
void ISR_STM(void){
80001232:	40 ae       	mov.aa %a14,%sp
    __enable();
80001234:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    IfxStm_clearCompareFlag(STM0, stmConfig.comparator);
80001238:	91 00 00 c6 	movh.a %a12,24576
8000123c:	19 c4 f4 10 	ld.w %d4,[%a12]3188 <60000c74 <stmConfig>>
80001240:	c5 f4 00 00 	lea %a4,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001244:	6d 00 1b 0b 	call 8000287a <IfxStm_clearCompareFlag>
    IfxStm_increaseCompare(STM0, stmConfig.comparator,100000u);
80001248:	19 c2 f4 10 	ld.w %d2,[%a12]3188 <60000c74 <stmConfig>>
    stm->CMP[comparator].B.CMPVAL = stm->CMP[comparator].B.CMPVAL + ticks;
8000124c:	1b c2 00 20 	addi %d2,%d2,12
80001250:	06 22       	sh %d2,2
80001252:	60 22       	mov.a %a2,%d2
80001254:	11 02 00 2f 	addih.a %a2,%a2,61440
80001258:	54 22       	ld.w %d2,[%a2]
8000125a:	7b 20 00 30 	movh %d3,2
8000125e:	1b 03 6a 38 	addi %d3,%d3,-31072
80001262:	42 32       	add %d2,%d3
80001264:	74 22       	st.w [%a2],%d2
    //IfxStm_increaseCompare(STM0, stmConfig.comparator,count_STM); // Debug Mode

    counter1ms++;
80001266:	91 00 00 26 	movh.a %a2,24576
8000126a:	d9 23 ec 00 	lea %a3,[%a2]3116 <60000c2c <counter1ms>>
8000126e:	54 32       	ld.w %d2,[%a3]
80001270:	c2 12       	add %d2,1
80001272:	59 22 ec 00 	st.w [%a2]3116 <60000c2c <counter1ms>>,%d2

    if((counter1ms % 1)==0) Scheduler1msFlag = 1;
80001276:	91 00 00 26 	movh.a %a2,24576
8000127a:	82 13       	mov %d3,1
8000127c:	59 23 e8 00 	st.w [%a2]3112 <60000c28 <Scheduler1msFlag>>,%d3
    if((counter1ms % 10)==0) Scheduler10msFlag = 1;
80001280:	7b d0 cc 4c 	movh %d4,52429
80001284:	1b d4 cc 4c 	addi %d4,%d4,-13107
80001288:	73 42 68 40 	mul.u %e4,%d2,%d4
8000128c:	8f d5 1f 30 	sh %d3,%d5,-3
80001290:	53 a3 20 30 	mul %d3,%d3,10
80001294:	5f 32 07 80 	jne %d2,%d3,800012a2 <ISR_STM+0x70>
80001298:	91 00 00 26 	movh.a %a2,24576
8000129c:	82 13       	mov %d3,1
8000129e:	59 23 e4 00 	st.w [%a2]3108 <60000c24 <Scheduler10msFlag>>,%d3
    if((counter1ms % 100)==0) Scheduler100msFlag = 1;
800012a2:	7b c0 1e 45 	movh %d4,20972
800012a6:	1b f4 51 48 	addi %d4,%d4,-31457
800012aa:	73 42 68 40 	mul.u %e4,%d2,%d4
800012ae:	8f b5 1f 30 	sh %d3,%d5,-5
800012b2:	53 43 26 30 	mul %d3,%d3,100
800012b6:	5f 32 07 80 	jne %d2,%d3,800012c4 <ISR_STM+0x92>
800012ba:	91 00 00 26 	movh.a %a2,24576
800012be:	82 13       	mov %d3,1
800012c0:	59 23 e0 00 	st.w [%a2]3104 <60000c20 <Scheduler100msFlag>>,%d3
    if((counter1ms % 1000)==0) Scheduler1000msFlag = 1;
800012c4:	7b 20 06 41 	movh %d4,4194
800012c8:	1b 34 dd 44 	addi %d4,%d4,19923
800012cc:	73 42 68 40 	mul.u %e4,%d2,%d4
800012d0:	8f a5 1f 30 	sh %d3,%d5,-6
800012d4:	3b 80 3e 40 	mov %d4,1000
800012d8:	e2 43       	mul %d3,%d4
800012da:	5f 32 07 80 	jne %d2,%d3,800012e8 <ISR_STM+0xb6>
800012de:	91 00 00 26 	movh.a %a2,24576
800012e2:	82 12       	mov %d2,1
800012e4:	59 22 dc 00 	st.w [%a2]3100 <60000c1c <Scheduler1000msFlag>>,%d2
    //if((counter1ms % ((int)ADC_G4_RAWDATA[6]/4))==0) SchedulerFlag = 1;

    //IfxPort_togglePin(PORT_102);
}
800012e8:	0d 00 40 02 	rslcx 
800012ec:	00 80       	rfe 

800012ee <ISR_PWM_GTM>:
    init_PWM(&timerConfig);

}

IFX_INTERRUPT(ISR_PWM_GTM, 0, PRIORITY_GTM);
void ISR_PWM_GTM(void){
800012ee:	40 ae       	mov.aa %a14,%sp
800012f0:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    IfxGtm_Tom_Timer_acknowledgeTimerIrq(&GtmPwmHl.timer);
800012f4:	91 00 00 46 	movh.a %a4,24576
800012f8:	d9 44 d8 20 	lea %a4,[%a4]3224 <60000c98 <GtmPwmHl>>
800012fc:	6d 00 ba 11 	call 80003670 <IfxGtm_Tom_Timer_acknowledgeTimerIrq>
}
80001300:	0d 00 40 02 	rslcx 
80001304:	00 80       	rfe 

80001306 <PWM_dutyUpdate>:

   IfxGtm_Tom_Timer_run(&GtmPwmHl.timer);
}


void PWM_dutyUpdate(){
80001306:	40 ae       	mov.aa %a14,%sp
80001308:	20 08       	sub.a %sp,8
    IfxGtm_Tom_PwmHl    *pwmHl  = &GtmPwmHl.pwm;
    IfxGtm_Tom_Timer    *timer  = &GtmPwmHl.timer;

    Ifx_TimerValue timerPeriod = IfxGtm_Tom_Timer_getPeriod(timer);
8000130a:	91 00 00 c6 	movh.a %a12,24576
8000130e:	d9 cc d8 20 	lea %a12,[%a12]3224 <60000c98 <GtmPwmHl>>
80001312:	40 c4       	mov.aa %a4,%a12
80001314:	6d 00 e1 11 	call 800036d6 <IfxGtm_Tom_Timer_getPeriod>
    Ifx_TimerValue Duty2Tic[2];

    Duty2Tic[0] = (uint32)(GtmPwmHl.duty[0]*timerPeriod);
80001318:	19 c3 1c 20 	ld.w %d3,[%a12]156 <6000009c <_impure_data+0x38>>
8000131c:	4b 02 61 21 	utof %d2,%d2
80001320:	4b 23 41 30 	mul.f %d3,%d3,%d2
80001324:	4b 03 71 31 	ftouz %d3,%d3
80001328:	59 e3 f8 ff 	st.w [%a14]-8,%d3
    Duty2Tic[1] = (uint32)(GtmPwmHl.duty[1]*timerPeriod);
8000132c:	19 c3 20 20 	ld.w %d3,[%a12]160 <600000a0 <_impure_data+0x3c>>
80001330:	4b 32 41 20 	mul.f %d2,%d2,%d3
80001334:	4b 02 71 21 	ftouz %d2,%d2
80001338:	59 e2 fc ff 	st.w [%a14]-4,%d2

    IfxGtm_Tom_Timer_disableUpdate(timer);
8000133c:	40 c4       	mov.aa %a4,%a12
8000133e:	6d 00 be 11 	call 800036ba <IfxGtm_Tom_Timer_disableUpdate>
    IfxGtm_Tom_PwmHl_setOnTime(pwmHl, Duty2Tic);
80001342:	d9 e5 f8 ff 	lea %a5,[%a14]-8
80001346:	d9 c4 04 10 	lea %a4,[%a12]68 <60000044 <LCF_DSPR1_START+0x44>>
8000134a:	6d 00 dc 15 	call 80003f02 <IfxGtm_Tom_PwmHl_setOnTime>
    IfxGtm_Tom_Timer_applyUpdate(timer);
8000134e:	40 c4       	mov.aa %a4,%a12
80001350:	6d 00 a7 11 	call 8000369e <IfxGtm_Tom_Timer_applyUpdate>
}
80001354:	00 90       	ret 

80001356 <init_PWM>:
void init_PWM(IfxGtm_Tom_Timer_Config *timerConfig){
80001356:	40 ae       	mov.aa %a14,%sp
80001358:	20 48       	sub.a %sp,72
8000135a:	40 4d       	mov.aa %a13,%a4
   IfxGtm_Tom_PwmHl_initConfig(&pwmHlConfig);
8000135c:	d9 e4 c8 ff 	lea %a4,[%a14]-56
80001360:	6d 00 3e 1b 	call 800049dc <IfxGtm_Tom_PwmHl_initConfig>
   coutx[0]     = &IfxGtm_TOM0_4_TOUT22_P33_0_OUT;
80001364:	91 00 00 28 	movh.a %a2,32768
80001368:	d9 22 30 90 	lea %a2,[%a2]624 <80000270 <IfxGtm_TOM0_4_TOUT22_P33_0_OUT>>
8000136c:	b5 e2 f8 ef 	st.a [%a14]-72 <80000270 <IfxGtm_TOM0_4_TOUT22_P33_0_OUT>>,%a2
   ccx[0]   = &IfxGtm_TOM0_3_TOUT105_P10_3_OUT;
80001370:	91 00 00 28 	movh.a %a2,32768
80001374:	d9 22 0c a0 	lea %a2,[%a2]652 <8000028c <IfxGtm_TOM0_3_TOUT105_P10_3_OUT>>
80001378:	b5 e2 c0 ff 	st.a [%a14]-64 <8000028c <IfxGtm_TOM0_3_TOUT105_P10_3_OUT>>,%a2
   ccx[1]     = &IfxGtm_TOM0_5_TOUT23_P33_1_OUT;
8000137c:	91 00 00 28 	movh.a %a2,32768
80001380:	d9 22 14 90 	lea %a2,[%a2]596 <80000254 <IfxGtm_TOM0_5_TOUT23_P33_1_OUT>>
80001384:	b5 e2 c4 ff 	st.a [%a14]-60 <80000254 <IfxGtm_TOM0_5_TOUT23_P33_1_OUT>>,%a2
   coutx[1]   = &IfxGtm_TOM0_2_TOUT107_P10_5_OUT;
80001388:	91 00 00 28 	movh.a %a2,32768
8000138c:	d9 22 28 a0 	lea %a2,[%a2]680 <800002a8 <IfxGtm_TOM0_2_TOUT107_P10_5_OUT>>
80001390:	b5 e2 fc ef 	st.a [%a14]-68 <800002a8 <IfxGtm_TOM0_2_TOUT107_P10_5_OUT>>,%a2
   pwmHlConfig.timer                    = &GtmPwmHl.timer;
80001394:	91 00 00 c6 	movh.a %a12,24576
80001398:	d9 cc d8 20 	lea %a12,[%a12]3224 <60000c98 <GtmPwmHl>>
8000139c:	b5 ec ec ff 	st.a [%a14]-20 <60000c98 <GtmPwmHl>>,%a12
   pwmHlConfig.tom                      = timerConfig->tom;
800013a0:	19 d2 38 00 	ld.w %d2,[%a13]56 <60000c98 <GtmPwmHl>>
800013a4:	59 e2 f0 ff 	st.w [%a14]-16 <60000c98 <GtmPwmHl>>,%d2
   pwmHlConfig.base.deadtime            = 2e-6;
800013a8:	7b 60 60 23 	movh %d2,13830
800013ac:	1b d2 7b 23 	addi %d2,%d2,14269
800013b0:	59 e2 c8 ff 	st.w [%a14]-56,%d2
   pwmHlConfig.base.minPulse            = 1e-6;
800013b4:	7b 60 58 23 	movh %d2,13702
800013b8:	1b d2 7b 23 	addi %d2,%d2,14269
800013bc:	59 e2 cc ff 	st.w [%a14]-52,%d2
   pwmHlConfig.base.channelCount        = 2;
800013c0:	82 22       	mov %d2,2
800013c2:	e9 e2 d0 ff 	st.b [%a14]-48,%d2
   pwmHlConfig.base.emergencyEnabled    = FALSE;
800013c6:	82 02       	mov %d2,0
800013c8:	e9 e2 d1 ff 	st.b [%a14]-47,%d2
   pwmHlConfig.base.outputMode          = IfxPort_OutputMode_none;
800013cc:	82 02       	mov %d2,0
800013ce:	59 e2 d4 ff 	st.w [%a14]-44,%d2
   pwmHlConfig.base.outputDriver        = IfxPort_PadDriver_cmosAutomotiveSpeed1;
800013d2:	59 e2 d8 ff 	st.w [%a14]-40,%d2
   pwmHlConfig.base.ccxActiveState      = Ifx_ActiveState_high;
800013d6:	82 12       	mov %d2,1
800013d8:	59 e2 e4 ff 	st.w [%a14]-28,%d2
   pwmHlConfig.base.coutxActiveState    = Ifx_ActiveState_high;
800013dc:	59 e2 e8 ff 	st.w [%a14]-24,%d2
   pwmHlConfig.ccx                      = ccx;
800013e0:	d9 e2 c0 ff 	lea %a2,[%a14]-64
800013e4:	b5 e2 f4 ff 	st.a [%a14]-12,%a2
   pwmHlConfig.coutx                    = coutx;
800013e8:	d9 e2 f8 ef 	lea %a2,[%a14]-72
800013ec:	b5 e2 f8 ff 	st.a [%a14]-8,%a2
   IfxGtm_Tom_PwmHl_init(&GtmPwmHl.pwm, &pwmHlConfig);
800013f0:	80 c2       	mov.d %d2,%a12
800013f2:	1b 42 04 80 	addi %d8,%d2,68
800013f6:	d9 e5 c8 ff 	lea %a5,[%a14]-56
800013fa:	60 84       	mov.a %a4,%d8
800013fc:	6d 00 f5 18 	call 800045e6 <IfxGtm_Tom_PwmHl_init>
   IfxGtm_Tom_PwmHl_setMode(&GtmPwmHl.pwm, Ifx_Pwm_Mode_centerAligned);
80001400:	82 04       	mov %d4,0
80001402:	60 84       	mov.a %a4,%d8
80001404:	6d 00 d6 14 	call 80003db0 <IfxGtm_Tom_PwmHl_setMode>
   GtmPwmHl.duty[0] = 0.0;
80001408:	82 02       	mov %d2,0
8000140a:	59 c2 1c 20 	st.w [%a12]156 <6000009c <_impure_data+0x38>>,%d2
   GtmPwmHl.duty[1] = 0.9;
8000140e:	7b 60 f6 23 	movh %d2,16230
80001412:	1b 62 66 26 	addi %d2,%d2,26214
80001416:	59 c2 20 20 	st.w [%a12]160 <600000a0 <_impure_data+0x3c>>,%d2
   PWM_dutyUpdate();
8000141a:	6d ff 76 ff 	call 80001306 <PWM_dutyUpdate>
   IfxGtm_Tom_Timer_run(&GtmPwmHl.timer);
8000141e:	40 c4       	mov.aa %a4,%a12
80001420:	6d 00 a1 11 	call 80003762 <IfxGtm_Tom_Timer_run>
}
80001424:	00 90       	ret 

80001426 <init_Tom>:
void init_Tom(void){
80001426:	40 ae       	mov.aa %a14,%sp
80001428:	20 58       	sub.a %sp,88
    IfxGtm_Tom_Timer_initConfig(&timerConfig, &MODULE_GTM);
8000142a:	91 00 01 5f 	movh.a %a5,61456
8000142e:	d9 e4 ec ef 	lea %a4,[%a14]-84
80001432:	6d 00 85 14 	call 80003d3c <IfxGtm_Tom_Timer_initConfig>
    timerConfig.base.frequency          = 2000;
80001436:	7b a0 4f 24 	movh %d2,17658
8000143a:	59 e2 ec ef 	st.w [%a14]-84,%d2
    timerConfig.base.isrPriority        = PRIORITY_GTM;
8000143e:	3b 80 0c 20 	mov %d2,200
80001442:	f9 e2 f0 ef 	st.h [%a14]-80,%d2
    timerConfig.base.isrPriority        = IfxSrc_Tos_cpu0;
80001446:	82 02       	mov %d2,0
80001448:	f9 e2 f0 ef 	st.h [%a14]-80,%d2
    timerConfig.base.minResolution      = (1.0/timerConfig.base.frequency)/1000;
8000144c:	7b 60 50 23 	movh %d2,13574
80001450:	1b d2 7b 23 	addi %d2,%d2,14269
80001454:	59 e2 f8 ef 	st.w [%a14]-72,%d2
    timerConfig.clock                   = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0;
80001458:	82 03       	mov %d3,0
8000145a:	59 e3 f0 ff 	st.w [%a14]-16,%d3
    timerConfig.base.countDir           = IfxStdIf_Timer_CountDir_upAndDown;
8000145e:	82 12       	mov %d2,1
80001460:	59 e2 d8 ff 	st.w [%a14]-40,%d2
    timerConfig.tom                     = IfxGtm_Tom_0;
80001464:	59 e3 e4 ff 	st.w [%a14]-28,%d3
    timerConfig.timerChannel            = IfxGtm_Tom_Ch_0;
80001468:	59 e3 e8 ff 	st.w [%a14]-24,%d3
    timerConfig.triggerOut              = &IfxGtm_TOM0_0_TOUT77_P15_6_OUT;
8000146c:	91 00 00 28 	movh.a %a2,32768
80001470:	d9 22 04 b0 	lea %a2,[%a2]708 <800002c4 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>
80001474:	b5 e2 ec ff 	st.a [%a14]-20 <800002c4 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>,%a2
    timerConfig.base.trigger.enabled                = TRUE;
80001478:	e9 e2 fc ef 	st.b [%a14]-68 <800002c4 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>,%d2
    timerConfig.base.trigger.outputEnabled          = TRUE;
8000147c:	e9 e2 d5 ff 	st.b [%a14]-43 <800002c4 <IfxGtm_TOM0_0_TOUT77_P15_6_OUT>>,%d2
    timerConfig.base.trigger.triggerPoint           = 500;
80001480:	3b 40 1f 30 	mov %d3,500
80001484:	59 e3 c0 ff 	st.w [%a14]-64,%d3
    timerConfig.base.trigger.risingEdgeAtPeriod     = TRUE;
80001488:	e9 e2 d4 ff 	st.b [%a14]-44,%d2
    IfxGtm_Tom_Timer_init(&GtmPwmHl.timer, &timerConfig);
8000148c:	d9 e5 ec ef 	lea %a5,[%a14]-84
80001490:	91 00 00 46 	movh.a %a4,24576
80001494:	d9 44 d8 20 	lea %a4,[%a4]3224 <60000c98 <GtmPwmHl>>
80001498:	6d 00 0e 12 	call 800038b4 <IfxGtm_Tom_Timer_init>
    init_PWM(&timerConfig);
8000149c:	d9 e4 ec ef 	lea %a4,[%a14]-84
800014a0:	6d ff 5b ff 	call 80001356 <init_PWM>
}
800014a4:	00 90       	ret 

800014a6 <init_GTM>:

void init_GTM(void){
800014a6:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_ICR);
800014a8:	4d c0 e2 8f 	mfcr %d8,$icr
    return reg.B.IE != 0;
800014ac:	37 08 e1 87 	extr.u %d8,%d8,15,1
    __disable();
800014b0:	0d 00 40 03 	disable 
800014b4:	00 00       	nop 

    boolean interruptState   = IfxCpu_disableInterrupts();

    Ifx_GTM  *gtm = &MODULE_GTM;
    float32 gtmFreq = IfxGtm_Cmu_getModuleFrequency(gtm);
800014b6:	91 00 01 4f 	movh.a %a4,61456
800014ba:	6d 00 cc 1a 	call 80004a52 <IfxGtm_Cmu_getModuleFrequency>
800014be:	02 29       	mov %d9,%d2
    IfxGtm_enable(gtm);
800014c0:	91 00 01 4f 	movh.a %a4,61456
800014c4:	6d 00 9d 1a 	call 800049fe <IfxGtm_enable>


    IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, gtmFreq);
800014c8:	02 94       	mov %d4,%d9
800014ca:	91 00 01 4f 	movh.a %a4,61456
800014ce:	6d 00 ed 1b 	call 80004ca8 <IfxGtm_Cmu_setGclkFrequency>

    float32 gtmGclkFreq = IfxGtm_Cmu_getGclkFrequency(gtm);
800014d2:	91 00 01 4f 	movh.a %a4,61456
800014d6:	6d 00 c2 1a 	call 80004a5a <IfxGtm_Cmu_getGclkFrequency>
    IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, gtmGclkFreq);
800014da:	02 25       	mov %d5,%d2
800014dc:	82 04       	mov %d4,0
800014de:	91 00 01 4f 	movh.a %a4,61456
800014e2:	6d 00 9d 1b 	call 80004c1c <IfxGtm_Cmu_setClkFrequency>

    init_Tom();
800014e6:	6d ff a0 ff 	call 80001426 <init_Tom>
    if (enabled != FALSE)
800014ea:	df 08 04 00 	jeq %d8,0,800014f2 <init_GTM+0x4c>
        __enable();
800014ee:	0d 00 00 03 	enable 

    IfxCpu_restoreInterrupts(interruptState);

    IfxGtm_Cmu_enableClocks(gtm, IFXGTM_CMU_CLKEN_FXCLK | IFXGTM_CMU_CLKEN_CLK0);
800014f2:	7b 00 08 40 	movh %d4,128
800014f6:	c2 24       	add %d4,2
800014f8:	91 00 01 4f 	movh.a %a4,61456
800014fc:	6d 00 a7 1a 	call 80004a4a <IfxGtm_Cmu_enableClocks>
}
80001500:	00 90       	ret 

80001502 <target_speed_decision>:


void target_speed_decision(void){
80001502:	40 ae       	mov.aa %a14,%sp
    if(ADC_G4_RAWDATA[5] == 4095){
80001504:	91 00 00 26 	movh.a %a2,24576
80001508:	d9 22 f4 50 	lea %a2,[%a2]3444 <60000d74 <ADC_G4_RAWDATA>>
8000150c:	b9 22 0a 00 	ld.hu %d2,[%a2]10 <6000000a <LCF_DSPR1_START+0xa>>
80001510:	3b f0 ff 30 	mov %d3,4095
80001514:	5f 32 1c 00 	jeq %d2,%d3,8000154c <target_speed_decision+0x4a>
        Sudden_accel_flag = 1;
        Mode_flag = 0;
    }

    if(Sudden_accel_flag == 1){
80001518:	91 00 00 26 	movh.a %a2,24576
8000151c:	19 23 d4 20 	ld.w %d3,[%a2]3220 <60000c94 <Sudden_accel_flag>>
80001520:	df 13 22 00 	jeq %d3,1,80001564 <target_speed_decision+0x62>
        target_speed = target_speed - 0.01;
    }
    else{
        if(Mode_flag == 0){         // 속도 변환만 가능
80001524:	91 00 00 26 	movh.a %a2,24576
80001528:	19 23 f0 10 	ld.w %d3,[%a2]3184 <60000c70 <Mode_flag>>
8000152c:	df 03 37 80 	jne %d3,0,8000159a <target_speed_decision+0x98>
            target_speed = (float32)ADC_G4_RAWDATA[5]/4095;
80001530:	4b 02 61 21 	utof %d2,%d2
80001534:	7b 00 58 34 	movh %d3,17792
80001538:	1b 03 00 3f 	addi %d3,%d3,-4096
8000153c:	4b 32 51 20 	div.f %d2,%d2,%d3
80001540:	91 00 00 26 	movh.a %a2,24576
80001544:	d9 22 c4 50 	lea %a2,[%a2]3396 <60000d44 <target_speed>>
80001548:	74 22       	st.w [%a2],%d2
8000154a:	00 90       	ret 
        Sudden_accel_flag = 1;
8000154c:	91 00 00 26 	movh.a %a2,24576
80001550:	82 13       	mov %d3,1
80001552:	59 23 d4 20 	st.w [%a2]3220 <60000c94 <Sudden_accel_flag>>,%d3
        Mode_flag = 0;
80001556:	91 00 00 26 	movh.a %a2,24576
8000155a:	82 03       	mov %d3,0
8000155c:	59 23 f0 10 	st.w [%a2]3184 <60000c70 <Mode_flag>>,%d3
80001560:	1d ff dc ff 	j 80001518 <target_speed_decision+0x16>
        target_speed = target_speed - 0.01;
80001564:	91 00 00 c6 	movh.a %a12,24576
80001568:	d9 c2 c4 50 	lea %a2,[%a12]3396 <60000d44 <target_speed>>
8000156c:	54 24       	ld.w %d4,[%a2]
8000156e:	6d 00 46 2c 	call 80006dfa <__extendsfdf2>
80001572:	7b e0 7a 64 	movh %d6,18350
80001576:	1b b6 47 61 	addi %d6,%d6,5243
8000157a:	7b 40 f8 73 	movh %d7,16260
8000157e:	1b 17 ae 77 	addi %d7,%d7,31457
80001582:	0b 23 10 48 	mov %e4,%d3,%d2
80001586:	6d 00 9c 2d 	call 800070be <__subdf3>
8000158a:	0b 23 10 48 	mov %e4,%d3,%d2
8000158e:	6d 00 ee 2e 	call 8000736a <__truncdfsf2>
80001592:	d9 c2 c4 50 	lea %a2,[%a12]3396 <60000d44 <target_speed>>
80001596:	74 22       	st.w [%a2],%d2
80001598:	00 90       	ret 
        }
        else if(Mode_flag == 1 && Ultra_flag == 1){     // 정지
8000159a:	df 13 07 00 	jeq %d3,1,800015a8 <target_speed_decision+0xa6>
            target_speed = 0;
        }
        else if(Mode_flag == 1 && Ultra_flag == 2){     // 감속
8000159e:	df 13 12 00 	jeq %d3,1,800015c2 <target_speed_decision+0xc0>
            target_speed = ((float32)ADC_G4_RAWDATA[5]/4095)/2;
        }
        else if(Mode_flag == 1 && Ultra_flag == 3){     // 유지
800015a2:	df 13 28 00 	jeq %d3,1,800015f2 <target_speed_decision+0xf0>
            target_speed = (float32)ADC_G4_RAWDATA[5]/4095;
        }
    }

}
800015a6:	00 90       	ret 
        else if(Mode_flag == 1 && Ultra_flag == 1){     // 정지
800015a8:	91 00 00 26 	movh.a %a2,24576
800015ac:	19 24 c0 10 	ld.w %d4,[%a2]3136 <60000c40 <Ultra_flag>>
800015b0:	df 14 f7 ff 	jne %d4,1,8000159e <target_speed_decision+0x9c>
            target_speed = 0;
800015b4:	91 00 00 26 	movh.a %a2,24576
800015b8:	82 02       	mov %d2,0
800015ba:	d9 22 c4 50 	lea %a2,[%a2]3396 <60000d44 <target_speed>>
800015be:	74 22       	st.w [%a2],%d2
800015c0:	00 90       	ret 
        else if(Mode_flag == 1 && Ultra_flag == 2){     // 감속
800015c2:	91 00 00 26 	movh.a %a2,24576
800015c6:	19 24 c0 10 	ld.w %d4,[%a2]3136 <60000c40 <Ultra_flag>>
800015ca:	df 24 ec ff 	jne %d4,2,800015a2 <target_speed_decision+0xa0>
            target_speed = ((float32)ADC_G4_RAWDATA[5]/4095)/2;
800015ce:	4b 02 61 21 	utof %d2,%d2
800015d2:	7b 00 58 34 	movh %d3,17792
800015d6:	1b 03 00 3f 	addi %d3,%d3,-4096
800015da:	4b 32 51 20 	div.f %d2,%d2,%d3
800015de:	7b 00 f0 33 	movh %d3,16128
800015e2:	4b 32 41 20 	mul.f %d2,%d2,%d3
800015e6:	91 00 00 26 	movh.a %a2,24576
800015ea:	d9 22 c4 50 	lea %a2,[%a2]3396 <60000d44 <target_speed>>
800015ee:	74 22       	st.w [%a2],%d2
800015f0:	00 90       	ret 
        else if(Mode_flag == 1 && Ultra_flag == 3){     // 유지
800015f2:	91 00 00 26 	movh.a %a2,24576
800015f6:	19 23 c0 10 	ld.w %d3,[%a2]3136 <60000c40 <Ultra_flag>>
800015fa:	df 33 d6 ff 	jne %d3,3,800015a6 <target_speed_decision+0xa4>
            target_speed = (float32)ADC_G4_RAWDATA[5]/4095;
800015fe:	4b 02 61 21 	utof %d2,%d2
80001602:	7b 00 58 34 	movh %d3,17792
80001606:	1b 03 00 3f 	addi %d3,%d3,-4096
8000160a:	4b 32 51 20 	div.f %d2,%d2,%d3
8000160e:	91 00 00 26 	movh.a %a2,24576
80001612:	d9 22 c4 50 	lea %a2,[%a2]3396 <60000d44 <target_speed>>
80001616:	74 22       	st.w [%a2],%d2
}
80001618:	1d ff c7 ff 	j 800015a6 <target_speed_decision+0xa4>

8000161c <init_PID>:
#include "Encoder.h"
#include "PID.h"

float alpha_PID = 0.01;

void init_PID(void){
8000161c:	40 ae       	mov.aa %a14,%sp
    Kp = 5;
8000161e:	91 00 00 26 	movh.a %a2,24576
80001622:	7b 00 0a 24 	movh %d2,16544
80001626:	d9 22 d8 50 	lea %a2,[%a2]3416 <60000d58 <Kp>>
8000162a:	74 22       	st.w [%a2],%d2
    Ki = 0.007;
8000162c:	91 00 00 26 	movh.a %a2,24576
80001630:	7b 50 be 23 	movh %d2,15333
80001634:	1b 22 04 26 	addi %d2,%d2,24642
80001638:	d9 22 d4 50 	lea %a2,[%a2]3412 <60000d54 <Ki>>
8000163c:	74 22       	st.w [%a2],%d2
    //Kd = 0.015;

    current_speed = 0.0;
8000163e:	82 02       	mov %d2,0
80001640:	91 00 00 26 	movh.a %a2,24576
80001644:	d9 22 c0 50 	lea %a2,[%a2]3392 <60000d40 <current_speed>>
80001648:	74 22       	st.w [%a2],%d2

    previous_error = 0.0;    // 이전 에러
8000164a:	91 00 00 26 	movh.a %a2,24576
8000164e:	d9 22 cc 50 	lea %a2,[%a2]3404 <60000d4c <previous_error>>
80001652:	74 22       	st.w [%a2],%d2
    integral = 0.0;      // 적분
80001654:	91 00 00 26 	movh.a %a2,24576
80001658:	d9 22 c8 50 	lea %a2,[%a2]3400 <60000d48 <integral>>
8000165c:	74 22       	st.w [%a2],%d2
    control = 0.0;      // 제어 신호
8000165e:	91 00 00 26 	movh.a %a2,24576
80001662:	d9 22 fc 40 	lea %a2,[%a2]3388 <60000d3c <control>>
80001666:	74 22       	st.w [%a2],%d2
    cur_angle = 0.0;
80001668:	91 00 00 26 	movh.a %a2,24576
8000166c:	d9 22 e0 50 	lea %a2,[%a2]3424 <60000d60 <cur_angle>>
80001670:	74 22       	st.w [%a2],%d2

}
80001672:	00 90       	ret 

80001674 <PID_motor_control>:

void PID_motor_control(void){
80001674:	40 ae       	mov.aa %a14,%sp
    float32 error, derivative;

    // PID 제어 계산
    current_speed = velocity_rad;
80001676:	91 00 00 26 	movh.a %a2,24576
8000167a:	d9 22 dc 50 	lea %a2,[%a2]3420 <60000d5c <velocity_rad>>
8000167e:	54 22       	ld.w %d2,[%a2]
80001680:	91 00 00 26 	movh.a %a2,24576
80001684:	d9 22 c0 50 	lea %a2,[%a2]3392 <60000d40 <current_speed>>
80001688:	74 22       	st.w [%a2],%d2
    //target_speed = (float)((int)(target_speed*100))/100;
    //target_speed = low_pass_filter(target_speed,alpha_PID);
    error = target_speed*34000 - current_speed;  // 현재 속도는 센서나 피드백 값에서 얻어옴
8000168a:	91 00 00 26 	movh.a %a2,24576
8000168e:	d9 22 c4 50 	lea %a2,[%a2]3396 <60000d44 <target_speed>>
80001692:	54 23       	ld.w %d3,[%a2]
80001694:	7b 50 70 44 	movh %d4,18181
80001698:	1b 04 00 4d 	addi %d4,%d4,-12288
8000169c:	4b 34 41 30 	mul.f %d3,%d4,%d3
800016a0:	6b 02 31 23 	sub.f %d2,%d3,%d2
    integral += error;                     // 누적 오차
800016a4:	91 00 00 26 	movh.a %a2,24576
800016a8:	d9 23 c8 50 	lea %a3,[%a2]3400 <60000d48 <integral>>
800016ac:	54 33       	ld.w %d3,[%a3]
800016ae:	6b 03 21 32 	add.f %d3,%d2,%d3
800016b2:	74 33       	st.w [%a3],%d3
    derivative = error - previous_error;   // 오차 변화율
800016b4:	91 00 00 26 	movh.a %a2,24576
800016b8:	d9 23 cc 50 	lea %a3,[%a2]3404 <60000d4c <previous_error>>
800016bc:	54 34       	ld.w %d4,[%a3]
800016be:	6b 04 31 52 	sub.f %d5,%d2,%d4

    control = (Kp * error) + (Ki * integral) + (Kd * derivative);
800016c2:	91 00 00 36 	movh.a %a3,24576
800016c6:	d9 33 d8 50 	lea %a3,[%a3]3416 <60000d58 <Kp>>
800016ca:	54 34       	ld.w %d4,[%a3]
800016cc:	4b 42 41 40 	mul.f %d4,%d2,%d4
800016d0:	91 00 00 36 	movh.a %a3,24576
800016d4:	d9 33 d4 50 	lea %a3,[%a3]3412 <60000d54 <Ki>>
800016d8:	54 36       	ld.w %d6,[%a3]
800016da:	4b 63 41 30 	mul.f %d3,%d3,%d6
800016de:	6b 03 21 44 	add.f %d4,%d4,%d3
800016e2:	91 00 00 36 	movh.a %a3,24576
800016e6:	d9 33 d0 50 	lea %a3,[%a3]3408 <60000d50 <Kd>>
800016ea:	54 33       	ld.w %d3,[%a3]
800016ec:	4b 35 41 30 	mul.f %d3,%d5,%d3
800016f0:	6b 03 21 34 	add.f %d3,%d4,%d3
800016f4:	91 00 00 36 	movh.a %a3,24576
800016f8:	d9 33 fc 40 	lea %a3,[%a3]3388 <60000d3c <control>>
800016fc:	74 33       	st.w [%a3],%d3

    previous_error = error;
800016fe:	d9 22 cc 50 	lea %a2,[%a2]3404 <60000d4c <previous_error>>
80001702:	74 22       	st.w [%a2],%d2



    if (GtmPwmHl.duty[0] > 1) {
80001704:	91 00 00 26 	movh.a %a2,24576
80001708:	d9 22 d8 20 	lea %a2,[%a2]3224 <60000c98 <GtmPwmHl>>
8000170c:	19 22 1c 20 	ld.w %d2,[%a2]156 <6000009c <_impure_data+0x38>>
80001710:	7b 00 f8 43 	movh %d4,16256
80001714:	4b 42 01 40 	cmp.f %d4,%d2,%d4
80001718:	6f 24 0b 00 	jz.t %d4,2,8000172e <PID_motor_control+0xba>
        GtmPwmHl.duty[0] = 1;
8000171c:	91 00 00 26 	movh.a %a2,24576
80001720:	d9 22 d8 20 	lea %a2,[%a2]3224 <60000c98 <GtmPwmHl>>
80001724:	7b 00 f8 23 	movh %d2,16256
80001728:	59 22 1c 20 	st.w [%a2]156 <6000009c <_impure_data+0x38>>,%d2
8000172c:	00 90       	ret 
    }
    else if (GtmPwmHl.duty[0] < 0) {
8000172e:	82 04       	mov %d4,0
80001730:	4b 42 01 20 	cmp.f %d2,%d2,%d4
80001734:	6f 02 0f 80 	jnz.t %d2,0,80001752 <PID_motor_control+0xde>
        GtmPwmHl.duty[0] = 0;
    }
    else{
        GtmPwmHl.duty[0] = control/34000;
80001738:	7b 50 70 24 	movh %d2,18181
8000173c:	1b 02 00 2d 	addi %d2,%d2,-12288
80001740:	4b 23 51 20 	div.f %d2,%d3,%d2
80001744:	91 00 00 26 	movh.a %a2,24576
80001748:	d9 22 d8 20 	lea %a2,[%a2]3224 <60000c98 <GtmPwmHl>>
8000174c:	59 22 1c 20 	st.w [%a2]156 <6000009c <_impure_data+0x38>>,%d2
    }

}
80001750:	00 90       	ret 
        GtmPwmHl.duty[0] = 0;
80001752:	91 00 00 26 	movh.a %a2,24576
80001756:	d9 22 d8 20 	lea %a2,[%a2]3224 <60000c98 <GtmPwmHl>>
8000175a:	59 24 1c 20 	st.w [%a2]156 <6000009c <_impure_data+0x38>>,%d4
8000175e:	00 90       	ret 

80001760 <IfxGtm_PinMap_setTomTout>:
    IfxPort_setPinModeOutput(config->pin.port, config->pin.pinIndex, outputMode, config->select);
    IfxPort_setPinPadDriver(config->pin.port, config->pin.pinIndex, padDriver);
}

void IfxGtm_PinMap_setTomTout(IfxGtm_Tom_ToutMap *config, IfxPort_OutputMode outputMode, IfxPort_PadDriver padDriver)
{
80001760:	40 ae       	mov.aa %a14,%sp
80001762:	40 4c       	mov.aa %a12,%a4
80001764:	02 58       	mov %d8,%d5
    uint32 outselReg = (config->toutn >> 4);
80001766:	19 42 0c 00 	ld.w %d2,[%a4]12
8000176a:	8f c2 1f 70 	sh %d7,%d2,-4
    uint32 shift = (config->toutn & 0xFU) * 2;
8000176e:	8f f2 00 21 	and %d2,%d2,15
80001772:	06 12       	sh %d2,1
    uint32 outsel = (uint32)config->toutSel << shift;
80001774:	19 43 08 00 	ld.w %d3,[%a4]8
80001778:	0f 23 00 60 	sh %d6,%d3,%d2
    uint32 mask = 0x3U << shift;
8000177c:	82 33       	mov %d3,3
8000177e:	0f 23 00 30 	sh %d3,%d3,%d2

    __ldmst_c(&(MODULE_GTM.INOUTSEL.T.OUTSEL[outselReg].U), mask, outsel);
80001782:	8f 27 00 20 	sh %d2,%d7,2
80001786:	7b a0 01 5f 	movh %d5,61466
8000178a:	1b 05 d3 5f 	addi %d5,%d5,-720
8000178e:	60 52       	mov.a %a2,%d5
80001790:	01 22 00 26 	addsc.a %a2,%a2,%d2,0


/******************************************************************************/
IFX_INLINE void __ldmst_c(volatile void *address, unsigned mask, unsigned value)
{
    *(volatile uint32 *)address = (*(volatile uint32 *)address & ~(mask)) | (mask & value);
80001794:	54 22       	ld.w %d2,[%a2]
80001796:	c6 26       	xor %d6,%d2
80001798:	26 63       	and %d3,%d6
8000179a:	c6 32       	xor %d2,%d3
8000179c:	74 22       	st.w [%a2],%d2
    IfxPort_setPinModeOutput(config->pin.port, config->pin.pinIndex, outputMode, config->select);
8000179e:	19 45 18 00 	ld.w %d5,[%a4]24
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
800017a2:	a6 45       	or %d5,%d4
800017a4:	39 44 14 00 	ld.bu %d4,[%a4]20
800017a8:	99 44 10 00 	ld.a %a4,[%a4]16
800017ac:	6d 00 06 0f 	call 800035b8 <IfxPort_setPinMode>
    IfxPort_setPinPadDriver(config->pin.port, config->pin.pinIndex, padDriver);
800017b0:	02 85       	mov %d5,%d8
800017b2:	39 c4 14 00 	ld.bu %d4,[%a12]20
800017b6:	99 c4 10 00 	ld.a %a4,[%a12]16
800017ba:	6d 00 36 0f 	call 80003626 <IfxPort_setPinPadDriver>
}
800017be:	00 90       	ret 

800017c0 <Ifx_CircularBuffer_read8>:
    }
}


void *Ifx_CircularBuffer_read8(Ifx_CircularBuffer *buffer, void *data, Ifx_SizeT count)
{
800017c0:	40 ae       	mov.aa %a14,%sp
800017c2:	40 52       	mov.aa %a2,%a5
    uint8 *Dest = (uint8 *)data;
800017c4:	1d 00 07 00 	j 800017d2 <Ifx_CircularBuffer_read8+0x12>
        Dest  = &Dest[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
800017c8:	82 02       	mov %d2,0
800017ca:	f9 42 04 00 	st.h [%a4]4,%d2
        }
    } while (count > 0);
800017ce:	bf 14 19 00 	jlt %d4,1,80001800 <Ifx_CircularBuffer_read8+0x40>
        count--;
800017d2:	c2 f4       	add %d4,-1
800017d4:	37 04 50 40 	extr %d4,%d4,0,16
        *Dest = ((uint8 *)buffer->base)[buffer->index];
800017d8:	b9 42 04 00 	ld.hu %d2,[%a4]4
800017dc:	d4 43       	ld.a %a3,[%a4]
800017de:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
800017e2:	14 32       	ld.bu %d2,[%a3]
800017e4:	24 22       	st.b [%a2+],%d2
        buffer->index++;
800017e6:	b9 42 04 00 	ld.hu %d2,[%a4]4
800017ea:	c2 12       	add %d2,1
800017ec:	37 02 70 20 	extr.u %d2,%d2,0,16
800017f0:	f9 42 04 00 	st.h [%a4]4,%d2
        if (buffer->index >= buffer->length)
800017f4:	b9 43 06 00 	ld.hu %d3,[%a4]6
800017f8:	3f 32 eb ff 	jlt.u %d2,%d3,800017ce <Ifx_CircularBuffer_read8+0xe>
800017fc:	1d ff e6 ff 	j 800017c8 <Ifx_CircularBuffer_read8+0x8>

    return Dest;
}
80001800:	00 90       	ret 

80001802 <Ifx_CircularBuffer_write8>:
    return Dest;
}


const void *Ifx_CircularBuffer_write8(Ifx_CircularBuffer *buffer, const void *data, Ifx_SizeT count)
{
80001802:	40 ae       	mov.aa %a14,%sp
80001804:	40 52       	mov.aa %a2,%a5
    const uint8 *source = (const uint8 *)data;
80001806:	1d 00 07 00 	j 80001814 <Ifx_CircularBuffer_write8+0x12>
        source                                 = &source[1];
        buffer->index++;

        if (buffer->index >= buffer->length)
        {
            buffer->index = 0;
8000180a:	82 02       	mov %d2,0
8000180c:	f9 42 04 00 	st.h [%a4]4,%d2
        }
    } while (count > 0);
80001810:	bf 14 19 00 	jlt %d4,1,80001842 <Ifx_CircularBuffer_write8+0x40>
        count--;
80001814:	c2 f4       	add %d4,-1
80001816:	37 04 50 40 	extr %d4,%d4,0,16
        ((uint8 *)buffer->base)[buffer->index] = *source;
8000181a:	b9 42 04 00 	ld.hu %d2,[%a4]4
8000181e:	d4 43       	ld.a %a3,[%a4]
80001820:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
80001824:	04 22       	ld.bu %d2,[%a2+]
80001826:	34 32       	st.b [%a3],%d2
        buffer->index++;
80001828:	b9 42 04 00 	ld.hu %d2,[%a4]4
8000182c:	c2 12       	add %d2,1
8000182e:	37 02 70 20 	extr.u %d2,%d2,0,16
80001832:	f9 42 04 00 	st.h [%a4]4,%d2
        if (buffer->index >= buffer->length)
80001836:	b9 43 06 00 	ld.hu %d3,[%a4]6
8000183a:	3f 32 eb ff 	jlt.u %d2,%d3,80001810 <Ifx_CircularBuffer_write8+0xe>
8000183e:	1d ff e6 ff 	j 8000180a <Ifx_CircularBuffer_write8+0x8>

    return source;
}
80001842:	00 90       	ret 

80001844 <Ifx_Fifo_beginRead>:

/**
 * param: count in bytes
 */
static Ifx_SizeT Ifx_Fifo_beginRead(Ifx_Fifo *fifo, Ifx_SizeT count)
{
80001844:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_ICR);
80001846:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
8000184a:	37 03 e1 37 	extr.u %d3,%d3,15,1
    __disable();
8000184e:	0d 00 40 03 	disable 
80001852:	00 00       	nop 
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80001854:	c9 40 04 00 	ld.h %d0,[%a4]4
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80001858:	0b 04 80 01 	min %d0,%d4,%d0
    boolean   interruptState;
    Ifx_SizeT blockSize;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, Ifx_Fifo_readCount(fifo));
8000185c:	37 00 50 50 	extr %d5,%d0,0,16
    blockSize               -= blockSize % fifo->elementSize;
80001860:	c9 46 1a 00 	ld.h %d6,[%a4]26
80001864:	4b 65 01 62 	div %e6,%d5,%d6
80001868:	0b 70 80 20 	sub %d2,%d0,%d7
8000186c:	37 02 50 20 	extr %d2,%d2,0,16
    fifo->eventReader        = FALSE;
80001870:	82 05       	mov %d5,0
80001872:	e9 45 1c 00 	st.b [%a4]28,%d5
    fifo->shared.readerWaitx = __min(count - blockSize, fifo->size);
80001876:	a2 24       	sub %d4,%d2
80001878:	c9 45 18 00 	ld.h %d5,[%a4]24
8000187c:	0b 54 80 41 	min %d4,%d4,%d5
80001880:	59 44 08 00 	st.w [%a4]8,%d4
    if (enabled != FALSE)
80001884:	df 03 04 00 	jeq %d3,0,8000188c <Ifx_Fifo_beginRead+0x48>
        __enable();
80001888:	0d 00 00 03 	enable 
    IfxCpu_restoreInterrupts(interruptState);

    return blockSize;
}
8000188c:	00 90       	ret 

8000188e <Ifx_Fifo_readEnd>:

/**
 * param: count in bytes
 */
static Ifx_SizeT Ifx_Fifo_readEnd(Ifx_Fifo *fifo, Ifx_SizeT count, Ifx_SizeT blockSize)
{
8000188e:	40 ae       	mov.aa %a14,%sp
80001890:	02 47       	mov %d7,%d4
    reg.U = __mfcr(CPU_ICR);
80001892:	4d c0 e2 3f 	mfcr %d3,$icr
    return reg.B.IE != 0;
80001896:	37 03 e1 37 	extr.u %d3,%d3,15,1
    __disable();
8000189a:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
8000189e:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState      = IfxCpu_disableInterrupts();

    fifo->shared.count -= blockSize;
800018a0:	37 05 70 20 	extr.u %d2,%d5,0,16
800018a4:	c9 46 04 00 	ld.h %d6,[%a4]4
800018a8:	a2 26       	sub %d6,%d2
800018aa:	f9 46 04 00 	st.h [%a4]4,%d6

    if (fifo->shared.writerWaitx != 0)
800018ae:	d9 42 0c 00 	lea %a2,[%a4]12
800018b2:	19 46 0c 00 	ld.w %d6,[%a4]12
800018b6:	df 06 07 00 	jeq %d6,0,800018c4 <Ifx_Fifo_readEnd+0x36>
    {
        fifo->shared.writerWaitx -= blockSize;
800018ba:	0b 56 80 40 	sub %d4,%d6,%d5
800018be:	74 24       	st.w [%a2],%d4

        if (fifo->shared.writerWaitx <= 0)
800018c0:	bf 14 0b 00 	jlt %d4,1,800018d6 <Ifx_Fifo_readEnd+0x48>
    if (enabled != FALSE)
800018c4:	df 03 04 00 	jeq %d3,0,800018cc <Ifx_Fifo_readEnd+0x3e>
        __enable();
800018c8:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
800018cc:	0b 27 80 20 	sub %d2,%d7,%d2
}
800018d0:	37 02 50 20 	extr %d2,%d2,0,16
800018d4:	00 90       	ret 
            fifo->shared.writerWaitx = 0;
800018d6:	82 04       	mov %d4,0
800018d8:	74 24       	st.w [%a2],%d4
            fifo->eventWriter        = TRUE; /* Signal the writer */
800018da:	82 14       	mov %d4,1
800018dc:	e9 44 1d 00 	st.b [%a4]29,%d4
800018e0:	1d ff f2 ff 	j 800018c4 <Ifx_Fifo_readEnd+0x36>

800018e4 <Ifx_Fifo_beginWrite>:
    IfxCpu_restoreInterrupts(interruptState);
}


static Ifx_SizeT Ifx_Fifo_beginWrite(Ifx_Fifo *fifo, Ifx_SizeT count)
{
800018e4:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_ICR);
800018e6:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
800018ea:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
800018ee:	0d 00 40 03 	disable 
800018f2:	00 00       	nop 
    Ifx_SizeT blockSize;
    boolean   interruptState;

    interruptState           = IfxCpu_disableInterrupts();
    blockSize                = __min(count, fifo->size - Ifx_Fifo_readCount(fifo));
800018f4:	c9 43 18 00 	ld.h %d3,[%a4]24
800018f8:	c9 42 04 00 	ld.h %d2,[%a4]4
800018fc:	0b 23 80 20 	sub %d2,%d3,%d2
    __asm__ volatile ("min %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80001900:	0b 24 80 01 	min %d0,%d4,%d2
80001904:	37 00 50 60 	extr %d6,%d0,0,16
    blockSize               -= blockSize % fifo->elementSize;
80001908:	c9 42 1a 00 	ld.h %d2,[%a4]26
8000190c:	4b 26 01 62 	div %e6,%d6,%d2
80001910:	0b 70 80 20 	sub %d2,%d0,%d7
80001914:	37 02 50 20 	extr %d2,%d2,0,16
    fifo->eventWriter        = FALSE;
80001918:	82 06       	mov %d6,0
8000191a:	e9 46 1d 00 	st.b [%a4]29,%d6
    fifo->shared.writerWaitx = __min(count - blockSize, fifo->size);
8000191e:	a2 24       	sub %d4,%d2
80001920:	0b 34 80 41 	min %d4,%d4,%d3
80001924:	59 44 0c 00 	st.w [%a4]12,%d4
    if (enabled != FALSE)
80001928:	df 05 04 00 	jeq %d5,0,80001930 <Ifx_Fifo_beginWrite+0x4c>
        __enable();
8000192c:	0d 00 00 03 	enable 
    IfxCpu_restoreInterrupts(interruptState);

    return blockSize;
}
80001930:	00 90       	ret 

80001932 <Ifx_Fifo_endWrite>:

    return result;
}

static Ifx_SizeT Ifx_Fifo_endWrite(Ifx_Fifo *fifo, Ifx_SizeT count, Ifx_SizeT blockSize)
{
80001932:	40 ae       	mov.aa %a14,%sp
80001934:	02 40       	mov %d0,%d4
    reg.U = __mfcr(CPU_ICR);
80001936:	4d c0 e2 6f 	mfcr %d6,$icr
    return reg.B.IE != 0;
8000193a:	37 06 e1 67 	extr.u %d6,%d6,15,1
    __disable();
8000193e:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
80001942:	00 00       	nop 
    boolean interruptState;

    /* Set the shared values */
    interruptState        = IfxCpu_disableInterrupts();

    fifo->shared.count   += blockSize;
80001944:	37 05 70 20 	extr.u %d2,%d5,0,16
80001948:	c9 43 04 00 	ld.h %d3,[%a4]4
8000194c:	42 23       	add %d3,%d2
8000194e:	37 03 50 30 	extr %d3,%d3,0,16
80001952:	f9 43 04 00 	st.h [%a4]4,%d3
    fifo->shared.maxcount = __max(fifo->shared.maxcount, fifo->shared.count);   /* Update maximum value */
80001956:	c9 47 10 00 	ld.h %d7,[%a4]16
    __asm__ volatile ("max %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
8000195a:	0b 37 a0 31 	max %d3,%d7,%d3
8000195e:	f9 43 10 00 	st.h [%a4]16,%d3

    if (fifo->shared.readerWaitx != 0)
80001962:	d9 42 08 00 	lea %a2,[%a4]8
80001966:	19 43 08 00 	ld.w %d3,[%a4]8
8000196a:	df 03 06 00 	jeq %d3,0,80001976 <Ifx_Fifo_endWrite+0x44>
    {
        fifo->shared.readerWaitx -= blockSize;
8000196e:	a2 53       	sub %d3,%d5
80001970:	74 23       	st.w [%a2],%d3

        if (fifo->shared.readerWaitx <= 0)
80001972:	bf 13 0b 00 	jlt %d3,1,80001988 <Ifx_Fifo_endWrite+0x56>
    if (enabled != FALSE)
80001976:	df 06 04 00 	jeq %d6,0,8000197e <Ifx_Fifo_endWrite+0x4c>
        __enable();
8000197a:	0d 00 00 03 	enable 
        }
    }

    IfxCpu_restoreInterrupts(interruptState);

    return count - blockSize;
8000197e:	0b 20 80 20 	sub %d2,%d0,%d2
}
80001982:	37 02 50 20 	extr %d2,%d2,0,16
80001986:	00 90       	ret 
            fifo->shared.readerWaitx = 0;
80001988:	82 03       	mov %d3,0
8000198a:	74 23       	st.w [%a2],%d3
            fifo->eventReader        = TRUE; /* Signal the reader - a re-scheduling may occur at this point! */
8000198c:	82 13       	mov %d3,1
8000198e:	e9 43 1c 00 	st.b [%a4]28,%d3
80001992:	1d ff f2 ff 	j 80001976 <Ifx_Fifo_endWrite+0x44>

80001996 <Ifx_Fifo_init>:
{
80001996:	40 ae       	mov.aa %a14,%sp
80001998:	40 42       	mov.aa %a2,%a4
    size = Ifx_AlignOn32(size);     /* data transfer is optimised for 32 bit access */
8000199a:	c2 34       	add %d4,3
8000199c:	37 04 50 40 	extr %d4,%d4,0,16
800019a0:	8f 34 c0 41 	andn %d4,%d4,3
        fifo->eventReader        = FALSE;
800019a4:	82 02       	mov %d2,0
800019a6:	e9 42 1c 00 	st.b [%a4]28,%d2
        fifo->eventWriter        = TRUE;
800019aa:	82 12       	mov %d2,1
800019ac:	e9 42 1d 00 	st.b [%a4]29,%d2
        fifo->buffer             = (uint8 *)Ifx_AlignOn64(((uint32)fifo) + sizeof(Ifx_Fifo));
800019b0:	80 42       	mov.d %d2,%a4
800019b2:	1b 72 02 20 	addi %d2,%d2,39
800019b6:	8f 72 c0 21 	andn %d2,%d2,7
800019ba:	74 42       	st.w [%a4],%d2
        fifo->shared.count       = 0;
800019bc:	82 02       	mov %d2,0
800019be:	f9 42 04 00 	st.h [%a4]4,%d2
        fifo->shared.maxcount    = 0;
800019c2:	f9 42 10 00 	st.h [%a4]16,%d2
        fifo->shared.readerWaitx = fifo->shared.writerWaitx = 0;
800019c6:	82 02       	mov %d2,0
800019c8:	59 42 0c 00 	st.w [%a4]12,%d2
800019cc:	59 42 08 00 	st.w [%a4]8,%d2
        fifo->startIndex         = fifo->endIndex = 0;
800019d0:	f9 42 16 00 	st.h [%a4]22,%d2
800019d4:	f9 42 14 00 	st.h [%a4]20,%d2
        fifo->size               = size;
800019d8:	f9 44 18 00 	st.h [%a4]24,%d4
        fifo->elementSize        = elementSize;
800019dc:	f9 45 1a 00 	st.h [%a4]26,%d5
}
800019e0:	00 90       	ret 

800019e2 <Ifx_Fifo_create>:
{
800019e2:	40 ae       	mov.aa %a14,%sp
800019e4:	37 05 50 90 	extr %d9,%d5,0,16
    size = Ifx_AlignOn32(size);                 /* data transfer is optimised for 32 bit access */
800019e8:	1b 34 00 20 	addi %d2,%d4,3
800019ec:	37 02 50 20 	extr %d2,%d2,0,16
800019f0:	8f 32 c0 81 	andn %d8,%d2,3
    fifo = malloc(size + sizeof(Ifx_Fifo) + 8); /* +8 because of padding in case the pointer is not aligned on 64 */
800019f4:	1b 88 02 40 	addi %d4,%d8,40
800019f8:	6d 00 3f 2f 	call 80007876 <malloc>
    if (IFX_VALIDATE(IFX_VERBOSE_LEVEL_ERROR, (fifo != NULL_PTR)))
800019fc:	bd 02 07 00 	jz.a %a2,80001a0a <Ifx_Fifo_create+0x28>
        fifo = Ifx_Fifo_init(fifo, size, elementSize);
80001a00:	02 95       	mov %d5,%d9
80001a02:	02 84       	mov %d4,%d8
80001a04:	40 24       	mov.aa %a4,%a2
80001a06:	6d ff c8 ff 	call 80001996 <Ifx_Fifo_init>
}
80001a0a:	00 90       	ret 

80001a0c <Ifx_Fifo_read>:
{
80001a0c:	40 ae       	mov.aa %a14,%sp
80001a0e:	20 08       	sub.a %sp,8
80001a10:	40 4c       	mov.aa %a12,%a4
80001a12:	80 5d       	mov.d %d13,%a5
80001a14:	02 69       	mov %d9,%d6
80001a16:	02 78       	mov %d8,%d7
80001a18:	37 04 50 a0 	extr %d10,%d4,0,16
    if (count != 0)
80001a1c:	df 0a 7c 00 	jeq %d10,0,80001b14 <Ifx_Fifo_read+0x108>
        buffer.base   = fifo->buffer;
80001a20:	54 42       	ld.w %d2,[%a4]
80001a22:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        buffer.length = (uint16)fifo->size;         /* size always fit into 16 bit */
80001a26:	b9 42 18 00 	ld.hu %d2,[%a4]24
80001a2a:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        buffer.index  = (uint16)fifo->startIndex;   /* startIndex always fit into size */
80001a2e:	b9 42 14 00 	ld.hu %d2,[%a4]20
80001a32:	f9 e2 fc ff 	st.h [%a14]-4,%d2

IFX_INLINE sint64 IfxStm_getDeadLine(sint64 timeout)
{
    sint64 deadLine;

    if (timeout == TIME_INFINITE)
80001a36:	82 f2       	mov %d2,-1
80001a38:	06 f2       	sh %d2,-1
80001a3a:	0b 27 00 21 	eq %d2,%d7,%d2
80001a3e:	8b f6 1f 24 	and.eq %d2,%d6,-1
80001a42:	df 02 1a 80 	jne %d2,0,80001a76 <Ifx_Fifo_read+0x6a>
    reg.U = __mfcr(CPU_ICR);
80001a46:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80001a4a:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80001a4e:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
80001a52:	00 00       	nop 
    result  = stm->TIM0.U;
80001a54:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001a58:	19 26 10 00 	ld.w %d6,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80001a5c:	19 22 2c 00 	ld.w %d2,[%a2]44
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80001a60:	02 63       	mov %d3,%d6
80001a62:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80001a66:	df 04 04 00 	jeq %d4,0,80001a6e <Ifx_Fifo_read+0x62>
        __enable();
80001a6a:	0d 00 00 03 	enable 
    {
        deadLine = TIME_INFINITE;
    }
    else
    {
        deadLine = IfxStm_now() + timeout;
80001a6e:	0b 39 40 90 	addx %d9,%d9,%d3
80001a72:	0b 28 50 80 	addc %d8,%d8,%d2
    boolean            Stop = FALSE;
80001a76:	82 0c       	mov %d12,0
80001a78:	1d 00 1f 00 	j 80001ab6 <Ifx_Fifo_read+0xaa>
                data  = Ifx_CircularBuffer_read8(&buffer, data, blockSize);
80001a7c:	02 24       	mov %d4,%d2
80001a7e:	60 d5       	mov.a %a5,%d13
80001a80:	d9 e4 f8 ff 	lea %a4,[%a14]-8
80001a84:	6d ff 9e fe 	call 800017c0 <Ifx_CircularBuffer_read8>
80001a88:	80 2d       	mov.d %d13,%a2
                count = Ifx_Fifo_readEnd(fifo, count, blockSize);
80001a8a:	02 b5       	mov %d5,%d11
80001a8c:	02 a4       	mov %d4,%d10
80001a8e:	40 c4       	mov.aa %a4,%a12
80001a90:	6d ff ff fe 	call 8000188e <Ifx_Fifo_readEnd>
80001a94:	02 2a       	mov %d10,%d2
80001a96:	1d 00 17 00 	j 80001ac4 <Ifx_Fifo_read+0xb8>
    {
        result = FALSE;
    }
    else
    {
        result = IfxStm_now() >= deadLine;
80001a9a:	0b 38 00 21 	eq %d2,%d8,%d3
80001a9e:	0b 94 50 22 	and.ge.u %d2,%d4,%d9
80001aa2:	0b 38 90 22 	or.lt %d2,%d8,%d3
80001aa6:	8f f2 0f 21 	and %d2,%d2,255
            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80001aaa:	df 02 2e 80 	jne %d2,0,80001b06 <Ifx_Fifo_read+0xfa>
            if (count != 0)
80001aae:	df 0a 3f 80 	jne %d10,0,80001b2c <Ifx_Fifo_read+0x120>
        } while (count != 0);
80001ab2:	df 0a 2d 00 	jeq %d10,0,80001b0c <Ifx_Fifo_read+0x100>
            blockSize = Ifx_Fifo_beginRead(fifo, count);
80001ab6:	02 a4       	mov %d4,%d10
80001ab8:	40 c4       	mov.aa %a4,%a12
80001aba:	6d ff c5 fe 	call 80001844 <Ifx_Fifo_beginRead>
80001abe:	02 2b       	mov %d11,%d2
            if (blockSize != 0)
80001ac0:	df 02 de ff 	jne %d2,0,80001a7c <Ifx_Fifo_read+0x70>
            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80001ac4:	df 0c 21 80 	jne %d12,0,80001b06 <Ifx_Fifo_read+0xfa>
    if (deadLine == TIME_INFINITE)
80001ac8:	82 f2       	mov %d2,-1
80001aca:	06 f2       	sh %d2,-1
80001acc:	0b 28 00 21 	eq %d2,%d8,%d2
80001ad0:	8b f9 1f 24 	and.eq %d2,%d9,-1
80001ad4:	df 02 ed ff 	jne %d2,0,80001aae <Ifx_Fifo_read+0xa2>
    reg.U = __mfcr(CPU_ICR);
80001ad8:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80001adc:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80001ae0:	0d 00 40 03 	disable 
80001ae4:	00 00       	nop 
    result  = stm->TIM0.U;
80001ae6:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001aea:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80001aee:	19 32 2c 00 	ld.w %d2,[%a3]44
80001af2:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80001af6:	b7 02 81 3f 	insert %d3,%d2,0,31,1
    if (enabled != FALSE)
80001afa:	df 05 d0 7f 	jeq %d5,0,80001a9a <Ifx_Fifo_read+0x8e>
        __enable();
80001afe:	0d 00 00 03 	enable 
80001b02:	1d ff cc ff 	j 80001a9a <Ifx_Fifo_read+0x8e>
                fifo->shared.readerWaitx = 0;
80001b06:	82 02       	mov %d2,0
80001b08:	59 c2 08 00 	st.w [%a12]8,%d2
        fifo->startIndex = buffer.index;
80001b0c:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80001b10:	f9 c2 14 00 	st.h [%a12]20,%d2
}
80001b14:	02 a2       	mov %d2,%d10
80001b16:	00 90       	ret 
        result = IfxStm_now() >= deadLine;
80001b18:	0b 28 00 31 	eq %d3,%d8,%d2
80001b1c:	0b 94 50 32 	and.ge.u %d3,%d4,%d9
80001b20:	0b 28 90 32 	or.lt %d3,%d8,%d2
80001b24:	8f f3 0f 31 	and %d3,%d3,255
                while ((fifo->eventReader == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80001b28:	df 03 25 80 	jne %d3,0,80001b72 <Ifx_Fifo_read+0x166>
80001b2c:	39 c2 1c 00 	ld.bu %d2,[%a12]28
80001b30:	df 02 21 80 	jne %d2,0,80001b72 <Ifx_Fifo_read+0x166>
    if (deadLine == TIME_INFINITE)
80001b34:	82 f2       	mov %d2,-1
80001b36:	06 f2       	sh %d2,-1
80001b38:	0b 28 00 21 	eq %d2,%d8,%d2
80001b3c:	8b f9 1f 24 	and.eq %d2,%d9,-1
80001b40:	df 02 f6 ff 	jne %d2,0,80001b2c <Ifx_Fifo_read+0x120>
    reg.U = __mfcr(CPU_ICR);
80001b44:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80001b48:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80001b4c:	0d 00 40 03 	disable 
80001b50:	00 00       	nop 
    result  = stm->TIM0.U;
80001b52:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001b56:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80001b5a:	19 32 2c 00 	ld.w %d2,[%a3]44
80001b5e:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80001b62:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80001b66:	df 05 d9 7f 	jeq %d5,0,80001b18 <Ifx_Fifo_read+0x10c>
        __enable();
80001b6a:	0d 00 00 03 	enable 
80001b6e:	1d ff d5 ff 	j 80001b18 <Ifx_Fifo_read+0x10c>
                Stop = (fifo->eventReader == FALSE);    /* If the function timeout, the maximum number of characters are read before returning */
80001b72:	39 cc 1c 00 	ld.bu %d12,[%a12]28
80001b76:	8b 0c 00 c2 	eq %d12,%d12,0
80001b7a:	1d ff 9c ff 	j 80001ab2 <Ifx_Fifo_read+0xa6>

80001b7e <Ifx_Fifo_write>:



Ifx_SizeT Ifx_Fifo_write(Ifx_Fifo *fifo, const void *data, Ifx_SizeT count, Ifx_TickTime timeout)
{
80001b7e:	40 ae       	mov.aa %a14,%sp
80001b80:	20 08       	sub.a %sp,8
80001b82:	40 4c       	mov.aa %a12,%a4
80001b84:	80 5d       	mov.d %d13,%a5
80001b86:	02 69       	mov %d9,%d6
80001b88:	02 78       	mov %d8,%d7
80001b8a:	37 04 50 a0 	extr %d10,%d4,0,16
    boolean            Stop = FALSE;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, fifo != NULL_PTR);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, data != NULL_PTR);

    if (count != 0)
80001b8e:	df 0a 7c 00 	jeq %d10,0,80001c86 <Ifx_Fifo_write+0x108>
    {
        buffer.base   = fifo->buffer;
80001b92:	54 42       	ld.w %d2,[%a4]
80001b94:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        buffer.length = (uint16)fifo->size;     /* size always fit into 16 bit */
80001b98:	b9 42 18 00 	ld.hu %d2,[%a4]24
80001b9c:	f9 e2 fe ff 	st.h [%a14]-2,%d2
        buffer.index  = (uint16)fifo->endIndex; /* startIndex always fit into size */
80001ba0:	b9 42 16 00 	ld.hu %d2,[%a4]22
80001ba4:	f9 e2 fc ff 	st.h [%a14]-4,%d2
    if (timeout == TIME_INFINITE)
80001ba8:	82 f2       	mov %d2,-1
80001baa:	06 f2       	sh %d2,-1
80001bac:	0b 27 00 21 	eq %d2,%d7,%d2
80001bb0:	8b f6 1f 24 	and.eq %d2,%d6,-1
80001bb4:	df 02 1a 80 	jne %d2,0,80001be8 <Ifx_Fifo_write+0x6a>
    reg.U = __mfcr(CPU_ICR);
80001bb8:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80001bbc:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80001bc0:	0d 00 40 03 	disable 
80001bc4:	00 00       	nop 
    result  = stm->TIM0.U;
80001bc6:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001bca:	19 26 10 00 	ld.w %d6,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80001bce:	19 22 2c 00 	ld.w %d2,[%a2]44
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80001bd2:	02 63       	mov %d3,%d6
80001bd4:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80001bd8:	df 04 04 00 	jeq %d4,0,80001be0 <Ifx_Fifo_write+0x62>
        __enable();
80001bdc:	0d 00 00 03 	enable 
        deadLine = IfxStm_now() + timeout;
80001be0:	0b 39 40 90 	addx %d9,%d9,%d3
80001be4:	0b 28 50 80 	addc %d8,%d8,%d2
    boolean            Stop = FALSE;
80001be8:	82 0c       	mov %d12,0
80001bea:	1d 00 1f 00 	j 80001c28 <Ifx_Fifo_write+0xaa>
            blockSize = Ifx_Fifo_beginWrite(fifo, count);

            if (blockSize != 0)
            {
                /* write element to the buffer */
                data  = Ifx_CircularBuffer_write8(&buffer, data, blockSize);
80001bee:	02 24       	mov %d4,%d2
80001bf0:	60 d5       	mov.a %a5,%d13
80001bf2:	d9 e4 f8 ff 	lea %a4,[%a14]-8
80001bf6:	6d ff 06 fe 	call 80001802 <Ifx_CircularBuffer_write8>
80001bfa:	80 2d       	mov.d %d13,%a2
                count = Ifx_Fifo_endWrite(fifo, count, blockSize);
80001bfc:	02 b5       	mov %d5,%d11
80001bfe:	02 a4       	mov %d4,%d10
80001c00:	40 c4       	mov.aa %a4,%a12
80001c02:	6d ff 98 fe 	call 80001932 <Ifx_Fifo_endWrite>
80001c06:	02 2a       	mov %d10,%d2
80001c08:	1d 00 17 00 	j 80001c36 <Ifx_Fifo_write+0xb8>
        result = IfxStm_now() >= deadLine;
80001c0c:	0b 38 00 21 	eq %d2,%d8,%d3
80001c10:	0b 94 50 22 	and.ge.u %d2,%d4,%d9
80001c14:	0b 38 90 22 	or.lt %d2,%d8,%d3
80001c18:	8f f2 0f 21 	and %d2,%d2,255
            }

            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80001c1c:	df 02 2e 80 	jne %d2,0,80001c78 <Ifx_Fifo_write+0xfa>
                /*When exiting, the writer is not waiting for any space */
                fifo->shared.writerWaitx = 0;
                break;
            }

            if (count != 0)
80001c20:	df 0a 3f 80 	jne %d10,0,80001c9e <Ifx_Fifo_write+0x120>
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
                {}

                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
            }
        } while (count != 0);
80001c24:	df 0a 2d 00 	jeq %d10,0,80001c7e <Ifx_Fifo_write+0x100>
            blockSize = Ifx_Fifo_beginWrite(fifo, count);
80001c28:	02 a4       	mov %d4,%d10
80001c2a:	40 c4       	mov.aa %a4,%a12
80001c2c:	6d ff 5c fe 	call 800018e4 <Ifx_Fifo_beginWrite>
80001c30:	02 2b       	mov %d11,%d2
            if (blockSize != 0)
80001c32:	df 02 de ff 	jne %d2,0,80001bee <Ifx_Fifo_write+0x70>
            if ((Stop != FALSE) || (IfxStm_isDeadLine(DeadLine) != FALSE))
80001c36:	df 0c 21 80 	jne %d12,0,80001c78 <Ifx_Fifo_write+0xfa>
    if (deadLine == TIME_INFINITE)
80001c3a:	82 f2       	mov %d2,-1
80001c3c:	06 f2       	sh %d2,-1
80001c3e:	0b 28 00 21 	eq %d2,%d8,%d2
80001c42:	8b f9 1f 24 	and.eq %d2,%d9,-1
80001c46:	df 02 ed ff 	jne %d2,0,80001c20 <Ifx_Fifo_write+0xa2>
    reg.U = __mfcr(CPU_ICR);
80001c4a:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80001c4e:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80001c52:	0d 00 40 03 	disable 
80001c56:	00 00       	nop 
    result  = stm->TIM0.U;
80001c58:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001c5c:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80001c60:	19 32 2c 00 	ld.w %d2,[%a3]44
80001c64:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80001c68:	b7 02 81 3f 	insert %d3,%d2,0,31,1
    if (enabled != FALSE)
80001c6c:	df 05 d0 7f 	jeq %d5,0,80001c0c <Ifx_Fifo_write+0x8e>
        __enable();
80001c70:	0d 00 00 03 	enable 
80001c74:	1d ff cc ff 	j 80001c0c <Ifx_Fifo_write+0x8e>
                fifo->shared.writerWaitx = 0;
80001c78:	82 02       	mov %d2,0
80001c7a:	59 c2 0c 00 	st.w [%a12]12,%d2

        fifo->endIndex = buffer.index;
80001c7e:	c9 e2 fc ff 	ld.h %d2,[%a14]-4
80001c82:	f9 c2 16 00 	st.h [%a12]22,%d2
    }

    return count;
}
80001c86:	02 a2       	mov %d2,%d10
80001c88:	00 90       	ret 
        result = IfxStm_now() >= deadLine;
80001c8a:	0b 28 00 31 	eq %d3,%d8,%d2
80001c8e:	0b 94 50 32 	and.ge.u %d3,%d4,%d9
80001c92:	0b 28 90 32 	or.lt %d3,%d8,%d2
80001c96:	8f f3 0f 31 	and %d3,%d3,255
                while ((fifo->eventWriter == FALSE) && (IfxStm_isDeadLine(DeadLine) == FALSE))
80001c9a:	df 03 25 80 	jne %d3,0,80001ce4 <Ifx_Fifo_write+0x166>
80001c9e:	39 c2 1d 00 	ld.bu %d2,[%a12]29
80001ca2:	df 02 21 80 	jne %d2,0,80001ce4 <Ifx_Fifo_write+0x166>
    if (deadLine == TIME_INFINITE)
80001ca6:	82 f2       	mov %d2,-1
80001ca8:	06 f2       	sh %d2,-1
80001caa:	0b 28 00 21 	eq %d2,%d8,%d2
80001cae:	8b f9 1f 24 	and.eq %d2,%d9,-1
80001cb2:	df 02 f6 ff 	jne %d2,0,80001c9e <Ifx_Fifo_write+0x120>
    reg.U = __mfcr(CPU_ICR);
80001cb6:	4d c0 e2 5f 	mfcr %d5,$icr
    return reg.B.IE != 0;
80001cba:	37 05 e1 57 	extr.u %d5,%d5,15,1
    __disable();
80001cbe:	0d 00 40 03 	disable 
80001cc2:	00 00       	nop 
    result  = stm->TIM0.U;
80001cc4:	c5 f3 00 00 	lea %a3,f0000000 <_SMALL_DATA4_+0x5fff8000>
80001cc8:	19 34 10 00 	ld.w %d4,[%a3]16
    result |= ((uint64)stm->CAP.U) << 32;
80001ccc:	19 32 2c 00 	ld.w %d2,[%a3]44
80001cd0:	8f 04 40 41 	or %d4,%d4,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80001cd4:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80001cd8:	df 05 d9 7f 	jeq %d5,0,80001c8a <Ifx_Fifo_write+0x10c>
        __enable();
80001cdc:	0d 00 00 03 	enable 
80001ce0:	1d ff d5 ff 	j 80001c8a <Ifx_Fifo_write+0x10c>
                Stop = fifo->eventWriter == FALSE;  /* If the function timeout, the maximum number of characters are written before returning */
80001ce4:	39 cc 1d 00 	ld.bu %d12,[%a12]29
80001ce8:	8b 0c 00 c2 	eq %d12,%d12,0
80001cec:	1d ff 9c ff 	j 80001c24 <Ifx_Fifo_write+0xa6>

80001cf0 <IfxVadc_disableAccess>:
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_externalMultiplexer);
}


void IfxVadc_disableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80001cf0:	40 ae       	mov.aa %a14,%sp
80001cf2:	40 4c       	mov.aa %a12,%a4
80001cf4:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80001cf6:	6d 00 09 0c 	call 80003508 <IfxScuWdt_getSafetyWatchdogPassword>
80001cfa:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80001cfc:	02 24       	mov %d4,%d2
80001cfe:	6d 00 af 0a 	call 8000325c <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80001d02:	8b 08 a2 32 	ge.u %d3,%d8,32
80001d06:	df 03 0d 80 	jne %d3,0,80001d20 <IfxVadc_disableAccess+0x30>
    {
        vadc->ACCPROT0.U |= (0x00000001 << protectionSet);
80001d0a:	d9 c2 08 20 	lea %a2,[%a12]136
80001d0e:	19 c2 08 20 	ld.w %d2,[%a12]136
80001d12:	d7 12 01 28 	insert %d2,%d2,1,%d8,1
80001d16:	74 22       	st.w [%a2],%d2
    else
    {
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80001d18:	02 94       	mov %d4,%d9
80001d1a:	6d 00 27 0c 	call 80003568 <IfxScuWdt_setSafetyEndinit>
}
80001d1e:	00 90       	ret 
        vadc->ACCPROT1.U |= (0x00000001 << (protectionSet & 0x1F));
80001d20:	d9 c2 0c 20 	lea %a2,[%a12]140
80001d24:	19 c3 0c 20 	ld.w %d3,[%a12]140
80001d28:	8f f8 01 21 	and %d2,%d8,31
80001d2c:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80001d30:	74 22       	st.w [%a2],%d2
80001d32:	1d ff f3 ff 	j 80001d18 <IfxVadc_disableAccess+0x28>

80001d36 <IfxVadc_enableAccess>:
    }
}


void IfxVadc_enableAccess(Ifx_VADC *vadc, IfxVadc_Protection protectionSet)
{
80001d36:	40 ae       	mov.aa %a14,%sp
80001d38:	40 4c       	mov.aa %a12,%a4
80001d3a:	02 48       	mov %d8,%d4
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();
80001d3c:	6d 00 e6 0b 	call 80003508 <IfxScuWdt_getSafetyWatchdogPassword>
80001d40:	02 29       	mov %d9,%d2
    IfxScuWdt_clearSafetyEndinit(passwd);
80001d42:	02 24       	mov %d4,%d2
80001d44:	6d 00 8c 0a 	call 8000325c <IfxScuWdt_clearSafetyEndinit>

    if (protectionSet < IFXVADC_MAXIMUM_BITFIELDS_IN_ACCPROT0_REGISTER)
80001d48:	8b 08 a2 32 	ge.u %d3,%d8,32
80001d4c:	df 03 0d 80 	jne %d3,0,80001d66 <IfxVadc_enableAccess+0x30>
    {
        vadc->ACCPROT0.U &= ~(0x00000001 << protectionSet);
80001d50:	d9 c2 08 20 	lea %a2,[%a12]136
80001d54:	19 c2 08 20 	ld.w %d2,[%a12]136
80001d58:	d7 02 01 28 	insert %d2,%d2,0,%d8,1
80001d5c:	74 22       	st.w [%a2],%d2
    else
    {
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
    }

    IfxScuWdt_setSafetyEndinit(passwd);
80001d5e:	02 94       	mov %d4,%d9
80001d60:	6d 00 04 0c 	call 80003568 <IfxScuWdt_setSafetyEndinit>
}
80001d64:	00 90       	ret 
        vadc->ACCPROT1.U &= ~(0x00000001 << (protectionSet & 0x1F));
80001d66:	d9 c2 0c 20 	lea %a2,[%a12]140
80001d6a:	19 c3 0c 20 	ld.w %d3,[%a12]140
80001d6e:	8f f8 01 21 	and %d2,%d8,31
80001d72:	d7 03 01 22 	insert %d2,%d3,0,%d2,1
80001d76:	74 22       	st.w [%a2],%d2
80001d78:	1d ff f3 ff 	j 80001d5e <IfxVadc_enableAccess+0x28>

80001d7c <IfxVadc_disablePostCalibration>:
{
80001d7c:	40 ae       	mov.aa %a14,%sp
80001d7e:	40 4c       	mov.aa %a12,%a4
80001d80:	02 48       	mov %d8,%d4
80001d82:	8f f5 0f 91 	and %d9,%d5,255
    if (group < IFXVADC_NUM_ADC_CAL_GROUPS)
80001d86:	bf 84 03 80 	jlt.u %d4,8,80001d8c <IfxVadc_disablePostCalibration+0x10>
}
80001d8a:	00 90       	ret 
        IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80001d8c:	3b f0 01 40 	mov %d4,31
80001d90:	6d ff d3 ff 	call 80001d36 <IfxVadc_enableAccess>
        uint32 mask = 1 << (IFX_VADC_GLOBCFG_DPCAL0_OFF + group);
80001d94:	1b 08 01 80 	addi %d8,%d8,16
80001d98:	82 12       	mov %d2,1
80001d9a:	0f 82 00 20 	sh %d2,%d2,%d8
        if (disable == TRUE)
80001d9e:	df 19 10 00 	jeq %d9,1,80001dbe <IfxVadc_disablePostCalibration+0x42>
            vadc->GLOBCFG.U &= ~mask;
80001da2:	d9 c2 00 20 	lea %a2,[%a12]128
80001da6:	19 c3 00 20 	ld.w %d3,[%a12]128
80001daa:	0f 23 e0 20 	andn %d2,%d3,%d2
80001dae:	74 22       	st.w [%a2],%d2
        IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80001db0:	3b f0 01 40 	mov %d4,31
80001db4:	40 c4       	mov.aa %a4,%a12
80001db6:	6d ff 9d ff 	call 80001cf0 <IfxVadc_disableAccess>
}
80001dba:	1d ff e8 ff 	j 80001d8a <IfxVadc_disablePostCalibration+0xe>
            vadc->GLOBCFG.U |= mask;
80001dbe:	d9 c2 00 20 	lea %a2,[%a12]128
80001dc2:	19 c3 00 20 	ld.w %d3,[%a12]128
80001dc6:	a6 32       	or %d2,%d3
80001dc8:	74 22       	st.w [%a2],%d2
80001dca:	1d ff f3 ff 	j 80001db0 <IfxVadc_disablePostCalibration+0x34>

80001dce <IfxVadc_getAdcAnalogFrequency>:
    IfxScuWdt_setCpuEndinit(passwd);
}


float32 IfxVadc_getAdcAnalogFrequency(Ifx_VADC *vadc)
{
80001dce:	40 ae       	mov.aa %a14,%sp
80001dd0:	40 4c       	mov.aa %a12,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVA);
80001dd2:	6d 00 37 08 	call 80002e40 <IfxScuCcu_getSpbFrequency>
80001dd6:	19 c3 00 20 	ld.w %d3,[%a12]128
80001dda:	8f f3 01 31 	and %d3,%d3,31
80001dde:	c2 13       	add %d3,1
80001de0:	4b 03 61 31 	utof %d3,%d3
}
80001de4:	4b 32 51 20 	div.f %d2,%d2,%d3
80001de8:	00 90       	ret 

80001dea <IfxVadc_getAdcDigitalFrequency>:


float32 IfxVadc_getAdcDigitalFrequency(Ifx_VADC *vadc)
{
80001dea:	40 ae       	mov.aa %a14,%sp
80001dec:	40 4c       	mov.aa %a12,%a4
    return IfxScuCcu_getSpbFrequency() / (1U + vadc->GLOBCFG.B.DIVD);
80001dee:	6d 00 29 08 	call 80002e40 <IfxScuCcu_getSpbFrequency>
80001df2:	19 c3 00 20 	ld.w %d3,[%a12]128
80001df6:	37 03 62 34 	extr.u %d3,%d3,8,2
80001dfa:	c2 13       	add %d3,1
80001dfc:	4b 03 61 31 	utof %d3,%d3
}
80001e00:	4b 32 51 20 	div.f %d2,%d2,%d3
80001e04:	00 90       	ret 

80001e06 <IfxVadc_getSrcAddress>:
    }
}


volatile Ifx_SRC_SRCR *IfxVadc_getSrcAddress(IfxVadc_GroupId group, IfxVadc_SrcNr index)
{
80001e06:	40 ae       	mov.aa %a14,%sp
    Ifx_SRC_SRCR *base;

    if (IfxVadc_SrcNr_shared0 <= index)
80001e08:	bf 45 07 80 	jlt.u %d5,4,80001e16 <IfxVadc_getSrcAddress+0x10>
    {
        index -= 4;
80001e0c:	c2 c5       	add %d5,-4

        if ((group & 0x1) != 0)
80001e0e:	6f 04 10 00 	jz.t %d4,0,80001e2e <IfxVadc_getSrcAddress+0x28>
        {
            group = IfxVadc_GroupId_global1;    /* Shared interrupt common 1 is used */
80001e12:	3b 90 00 40 	mov %d4,9
    else
    {
        /* do nothing */
    }

    base = (Ifx_SRC_SRCR *)IfxVadc_cfg_srcAddresses[(group * 4) + index];
80001e16:	8f 24 00 20 	sh %d2,%d4,2
80001e1a:	42 52       	add %d2,%d5
80001e1c:	06 22       	sh %d2,2
80001e1e:	91 00 00 28 	movh.a %a2,32768
80001e22:	d9 22 30 c0 	lea %a2,[%a2]816 <80000330 <IfxVadc_cfg_srcAddresses>>
80001e26:	01 22 00 26 	addsc.a %a2,%a2,%d2,0

    return &(base[0]);
}
80001e2a:	d4 22       	ld.a %a2,[%a2]
80001e2c:	00 90       	ret 
            group = IfxVadc_GroupId_global0;    /* Shared interrupt common 0 is used */
80001e2e:	3b 80 00 40 	mov %d4,8
80001e32:	1d ff f2 ff 	j 80001e16 <IfxVadc_getSrcAddress+0x10>

80001e36 <IfxVadc_initialiseAdcArbiterClock>:


void IfxVadc_initialiseAdcArbiterClock(Ifx_VADC *vadc, uint32 arbiterClockDivider)
{
80001e36:	40 ae       	mov.aa %a14,%sp
80001e38:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80001e3a:	19 42 00 20 	ld.w %d2,[%a4]128
80001e3e:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.DIVD  = arbiterClockDivider;
80001e40:	37 48 02 84 	insert %d8,%d8,%d4,8,2
    tempGLOBCFG.B.DIVWC = 1;
80001e44:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80001e48:	3b f0 01 40 	mov %d4,31
80001e4c:	6d ff 75 ff 	call 80001d36 <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80001e50:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80001e54:	3b f0 01 40 	mov %d4,31
80001e58:	40 c4       	mov.aa %a4,%a12
80001e5a:	6d ff 4b ff 	call 80001cf0 <IfxVadc_disableAccess>
}
80001e5e:	00 90       	ret 

80001e60 <IfxVadc_initialiseAdcConverterClock>:


void IfxVadc_initialiseAdcConverterClock(Ifx_VADC *vadc, uint32 converterClockDivider)
{
80001e60:	40 ae       	mov.aa %a14,%sp
80001e62:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80001e64:	19 42 00 20 	ld.w %d2,[%a4]128
80001e68:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.DIVA  = converterClockDivider;
80001e6a:	37 48 05 80 	insert %d8,%d8,%d4,0,5
    tempGLOBCFG.B.DIVWC = 1;
80001e6e:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80001e72:	3b f0 01 40 	mov %d4,31
80001e76:	6d ff 60 ff 	call 80001d36 <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80001e7a:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80001e7e:	3b f0 01 40 	mov %d4,31
80001e82:	40 c4       	mov.aa %a4,%a12
80001e84:	6d ff 36 ff 	call 80001cf0 <IfxVadc_disableAccess>
}
80001e88:	00 90       	ret 

80001e8a <IfxVadc_initializeFAdcD>:


uint32 IfxVadc_initializeFAdcD(Ifx_VADC *vadc, uint32 fAdcD)
{
80001e8a:	40 ae       	mov.aa %a14,%sp
80001e8c:	80 4a       	mov.d %d10,%a4
80001e8e:	02 48       	mov %d8,%d4
    uint32 divD;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80001e90:	6d 00 d8 07 	call 80002e40 <IfxScuCcu_getSpbFrequency>
80001e94:	4b 02 71 21 	ftouz %d2,%d2

    divD   = (fadc / fAdcD - 1);
80001e98:	4b 82 11 82 	div.u %e8,%d2,%d8
80001e9c:	1b f8 ff 3f 	addi %d3,%d8,-1
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80001ea0:	82 34       	mov %d4,3
80001ea2:	0b 43 90 41 	min.u %d4,%d3,%d4

    divD   = __minu(divD, 0x3u);

    result = fadc / (divD + 1);
80001ea6:	1b 14 00 80 	addi %d8,%d4,1
80001eaa:	4b 82 11 82 	div.u %e8,%d2,%d8
    IfxVadc_initialiseAdcArbiterClock(vadc, divD);
80001eae:	60 a4       	mov.a %a4,%d10
80001eb0:	6d ff c3 ff 	call 80001e36 <IfxVadc_initialiseAdcArbiterClock>
    return result;
}
80001eb4:	02 82       	mov %d2,%d8
80001eb6:	00 90       	ret 

80001eb8 <IfxVadc_initializeFAdcI>:


uint32 IfxVadc_initializeFAdcI(Ifx_VADC *vadc, uint32 fAdcI)
{
80001eb8:	40 ae       	mov.aa %a14,%sp
80001eba:	80 49       	mov.d %d9,%a4
80001ebc:	02 48       	mov %d8,%d4
    uint32 divA;
    uint32 result;
    uint32 fadc = IfxScuCcu_getSpbFrequency();
80001ebe:	6d 00 c1 07 	call 80002e40 <IfxScuCcu_getSpbFrequency>
80001ec2:	4b 02 71 31 	ftouz %d3,%d2

    /*    DivA = min(max(0, Fadc / FAdcI - 1), 0x3F); */
    divA   = (fadc << 2) / fAdcI;
80001ec6:	8f 23 00 40 	sh %d4,%d3,2
80001eca:	4b 84 11 42 	div.u %e4,%d4,%d8

    divA   = (divA + 2) >> 2; /* Round to nearest integer */
80001ece:	1b 24 00 20 	addi %d2,%d4,2
80001ed2:	06 e2       	sh %d2,-2
    divA   = __minu(divA - 1, 0x1Fu);
80001ed4:	c2 f2       	add %d2,-1
80001ed6:	3b f0 01 40 	mov %d4,31
80001eda:	0b 42 90 41 	min.u %d4,%d2,%d4
    result = fadc / (divA + 1);
80001ede:	1b 14 00 20 	addi %d2,%d4,1
80001ee2:	4b 23 11 62 	div.u %e6,%d3,%d2
80001ee6:	02 68       	mov %d8,%d6

    if (result > IFXVADC_ANALOG_FREQUENCY_MAX)
80001ee8:	7b 10 13 50 	movh %d5,305
80001eec:	1b 05 d0 52 	addi %d5,%d5,11520
80001ef0:	7f 65 0b 80 	jge.u %d5,%d6,80001f06 <IfxVadc_initializeFAdcI+0x4e>
80001ef4:	3b f0 01 40 	mov %d4,31
80001ef8:	0b 42 90 41 	min.u %d4,%d2,%d4
    {
        divA   = __minu(divA + 1, 0x1Fu);

        result = fadc / (divA + 1);
80001efc:	1b 14 00 20 	addi %d2,%d4,1
80001f00:	4b 23 11 22 	div.u %e2,%d3,%d2
80001f04:	02 28       	mov %d8,%d2
    else
    {
        /* do nothing */
    }

    if (!((result >= IFXVADC_ANALOG_FREQUENCY_MIN) && (result <= IFXVADC_ANALOG_FREQUENCY_MAX)))
80001f06:	7b 80 ff 2f 	movh %d2,65528
80001f0a:	1b 02 ee 25 	addi %d2,%d2,24288
80001f0e:	42 82       	add %d2,%d8
80001f10:	7b a0 12 30 	movh %d3,298
80001f14:	1b 03 be 38 	addi %d3,%d3,-29728
80001f18:	7f 23 05 80 	jge.u %d3,%d2,80001f22 <IfxVadc_initializeFAdcI+0x6a>
    {
        result = 0;             /* Min / Max FAdcI frequency */
80001f1c:	82 08       	mov %d8,0
    {
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
    }

    return result;
}
80001f1e:	02 82       	mov %d2,%d8
80001f20:	00 90       	ret 
        IfxVadc_initialiseAdcConverterClock(vadc, divA);
80001f22:	60 94       	mov.a %a4,%d9
80001f24:	6d ff 9e ff 	call 80001e60 <IfxVadc_initialiseAdcConverterClock>
80001f28:	1d ff fb ff 	j 80001f1e <IfxVadc_initializeFAdcI+0x66>

80001f2c <IfxVadc_selectPowerSupplyVoltage>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxVadc_selectPowerSupplyVoltage(Ifx_VADC *vadc, IfxVadc_LowSupplyVoltageSelect supplyVoltage)
{
80001f2c:	40 ae       	mov.aa %a14,%sp
80001f2e:	40 4c       	mov.aa %a12,%a4
    Ifx_VADC_GLOBCFG tempGLOBCFG;
    tempGLOBCFG.U       = vadc->GLOBCFG.U;
80001f30:	19 42 00 20 	ld.w %d2,[%a4]128
80001f34:	02 28       	mov %d8,%d2
    tempGLOBCFG.B.LOSUP = supplyVoltage;
80001f36:	67 48 0e 80 	ins.t %d8,%d8,14,%d4,0
    tempGLOBCFG.B.DIVWC = 1;
80001f3a:	b7 18 81 87 	insert %d8,%d8,1,15,1
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80001f3e:	3b f0 01 40 	mov %d4,31
80001f42:	6d ff fa fe 	call 80001d36 <IfxVadc_enableAccess>
    vadc->GLOBCFG.U     = tempGLOBCFG.U;
80001f46:	59 c8 00 20 	st.w [%a12]128,%d8
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80001f4a:	3b f0 01 40 	mov %d4,31
80001f4e:	40 c4       	mov.aa %a4,%a12
80001f50:	6d ff d0 fe 	call 80001cf0 <IfxVadc_disableAccess>
}
80001f54:	00 90       	ret 

80001f56 <IfxVadc_setArbiterPriority>:


void IfxVadc_setArbiterPriority(Ifx_VADC_G *vadcG, boolean slotEnable, IfxVadc_RequestSlotPriority prio, IfxVadc_RequestSlotStartMode mode, IfxVadc_RequestSource slot)
{
80001f56:	40 ae       	mov.aa %a14,%sp
80001f58:	02 50       	mov %d0,%d5
    if (slotEnable != FALSE)
80001f5a:	df 04 2a 00 	jeq %d4,0,80001fae <IfxVadc_setArbiterPriority+0x58>
    {
        vadcG->ARBPR.U |= slotEnable << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot); /* enable Slot */
80001f5e:	d9 42 04 00 	lea %a2,[%a4]4
80001f62:	19 43 04 00 	ld.w %d3,[%a4]4
80001f66:	1b 87 01 20 	addi %d2,%d7,24
80001f6a:	0f 24 00 20 	sh %d2,%d4,%d2
80001f6e:	a6 32       	or %d2,%d3
80001f70:	74 22       	st.w [%a2],%d2
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_PRIO0_MSK << (slot * 4u));      /* clear Priority */
80001f72:	54 23       	ld.w %d3,[%a2]
80001f74:	06 27       	sh %d7,2
80001f76:	82 32       	mov %d2,3
80001f78:	0f 72 00 20 	sh %d2,%d2,%d7
80001f7c:	0f 23 e0 20 	andn %d2,%d3,%d2
80001f80:	74 22       	st.w [%a2],%d2
        vadcG->ARBPR.U |= (prio << (slot * 4u));                             /* Set Priority */
80001f82:	54 23       	ld.w %d3,[%a2]
80001f84:	0f 70 00 20 	sh %d2,%d0,%d7
80001f88:	a6 32       	or %d2,%d3
80001f8a:	74 22       	st.w [%a2],%d2

        if (mode != IfxVadc_RequestSlotStartMode_waitForStart)
80001f8c:	df 06 08 00 	jeq %d6,0,80001f9c <IfxVadc_setArbiterPriority+0x46>
        {
            vadcG->ARBPR.U |= 0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)); /* Set cancel inject mode */
80001f90:	54 22       	ld.w %d2,[%a2]
80001f92:	c2 37       	add %d7,3
80001f94:	d7 12 01 27 	insert %d2,%d2,1,%d7,1
80001f98:	74 22       	st.w [%a2],%d2
80001f9a:	00 90       	ret 
        }
        else
        {
            vadcG->ARBPR.U &= ~(0x1u << (IFX_VADC_G_ARBPR_CSM0_OFF + (slot * 4u)));  /* Set Wait for Start mode */
80001f9c:	d9 42 04 00 	lea %a2,[%a4]4
80001fa0:	19 42 04 00 	ld.w %d2,[%a4]4
80001fa4:	c2 37       	add %d7,3
80001fa6:	d7 02 01 27 	insert %d2,%d2,0,%d7,1
80001faa:	74 22       	st.w [%a2],%d2
80001fac:	00 90       	ret 
        }
    }
    else
    {
        vadcG->ARBPR.U &= ~(IFX_VADC_G_ARBPR_ASEN0_MSK << (IFX_VADC_G_ARBPR_ASEN0_OFF + slot));  /* disable Slot */
80001fae:	d9 42 04 00 	lea %a2,[%a4]4
80001fb2:	19 43 04 00 	ld.w %d3,[%a4]4
80001fb6:	1b 87 01 20 	addi %d2,%d7,24
80001fba:	d7 03 01 22 	insert %d2,%d3,0,%d2,1
80001fbe:	74 22       	st.w [%a2],%d2
    }
}
80001fc0:	00 90       	ret 

80001fc2 <IfxVadc_setScan>:


void IfxVadc_setScan(Ifx_VADC_G *group, uint32 channels, uint32 mask)
{
80001fc2:	40 ae       	mov.aa %a14,%sp
    /* select channels which should take part in the scan sequence */
    /* the mask allows to specify the channels which should be enabled/disabled */
    group->ASSEL.U = (group->ASSEL.U & ~mask) | (channels & mask);
80001fc4:	d9 42 28 20 	lea %a2,[%a4]168
80001fc8:	19 42 28 20 	ld.w %d2,[%a4]168
80001fcc:	0f 42 c0 30 	xor %d3,%d2,%d4
80001fd0:	26 53       	and %d3,%d5
80001fd2:	c6 32       	xor %d2,%d3
80001fd4:	74 22       	st.w [%a2],%d2
}
80001fd6:	00 90       	ret 

80001fd8 <IfxVadc_startupCalibration>:


void IfxVadc_startupCalibration(Ifx_VADC *vadc)
{
80001fd8:	40 ae       	mov.aa %a14,%sp
80001fda:	40 4c       	mov.aa %a12,%a4
    boolean calibrationRunning;
    uint8   adcCalGroupNum;

    /* Start calibration */
    IfxVadc_enableAccess(vadc, IfxVadc_Protection_globalConfig);
80001fdc:	3b f0 01 40 	mov %d4,31
80001fe0:	6d ff ab fe 	call 80001d36 <IfxVadc_enableAccess>
}


IFX_INLINE void IfxVadc_initiateStartupCalibration(Ifx_VADC *vadc)
{
    vadc->GLOBCFG.B.SUCAL = 1;
80001fe4:	d9 c2 00 20 	lea %a2,[%a12]128
80001fe8:	19 c2 00 20 	ld.w %d2,[%a12]128
80001fec:	b7 12 81 2f 	insert %d2,%d2,1,31,1
80001ff0:	74 22       	st.w [%a2],%d2
    /* Set SUCAL bit */
    IfxVadc_initiateStartupCalibration(vadc);
    IfxVadc_disableAccess(vadc, IfxVadc_Protection_globalConfig);
80001ff2:	3b f0 01 40 	mov %d4,31
80001ff6:	40 c4       	mov.aa %a4,%a12
80001ff8:	6d ff 7c fe 	call 80001cf0 <IfxVadc_disableAccess>
    /* Wait until Calibration is done */
    do
    {
        calibrationRunning = FALSE;

        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80001ffc:	82 02       	mov %d2,0
        calibrationRunning = FALSE;
80001ffe:	82 04       	mov %d4,0
        for (adcCalGroupNum = 0; adcCalGroupNum < IFXVADC_NUM_ADC_CAL_GROUPS; adcCalGroupNum++)
80002000:	1d 00 05 00 	j 8000200a <IfxVadc_startupCalibration+0x32>
80002004:	c2 12       	add %d2,1
80002006:	8f f2 0f 21 	and %d2,%d2,255
8000200a:	ff 82 0d 80 	jge.u %d2,8,80002024 <IfxVadc_startupCalibration+0x4c>
    status = vadc->G[adcCalGroupNum].ARBCFG.B.CAL;
8000200e:	8f a2 00 30 	sh %d3,%d2,10
80002012:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80002016:	19 23 40 20 	ld.w %d3,[%a2]1152
        {
            if (IfxVadc_getAdcCalibrationActiveState(vadc, adcCalGroupNum) != 0)     /* Check ADC Calibration Flag CAL */
8000201a:	ef c3 f5 7f 	jz.t %d3,28,80002004 <IfxVadc_startupCalibration+0x2c>
            {
                calibrationRunning = TRUE;
8000201e:	82 14       	mov %d4,1
80002020:	1d ff f2 ff 	j 80002004 <IfxVadc_startupCalibration+0x2c>
            else
            {
                /* do nothing */
            }
        }
    } while (calibrationRunning == TRUE); /* wait until calibration of all calibrated kernels are done */
80002024:	df 04 ec ff 	jne %d4,0,80001ffc <IfxVadc_startupCalibration+0x24>
}
80002028:	00 90       	ret 

8000202a <IfxVadc_Adc_initChannel>:
    config->disablePostCalibration = ((IfxVadc_getGlobalConfigValue(vadc)).U >> (IFX_VADC_GLOBCFG_DPCAL0_OFF + group->groupId)) & 0x1;
}


IfxVadc_Status IfxVadc_Adc_initChannel(IfxVadc_Adc_Channel *channel, const IfxVadc_Adc_ChannelConfig *config)
{
8000202a:	40 ae       	mov.aa %a14,%sp
8000202c:	40 4f       	mov.aa %a15,%a4
8000202e:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status    Status = IfxVadc_Status_noError;
    Ifx_VADC         *vadc   = IfxVadc_Adc_getVadcFromGroup(config->group);
80002030:	99 52 38 00 	ld.a %a2,[%a5]56
}


IFX_INLINE Ifx_VADC *IfxVadc_Adc_getVadcFromGroup(const IfxVadc_Adc_Group *group)
{
    return group->module.vadc;
80002034:	54 28       	ld.w %d8,[%a2]
    return group->group;
80002036:	99 2d 04 00 	ld.a %a13,[%a2]4
    Ifx_VADC_G       *vadcG  = IfxVadc_Adc_getGroupRegsFromGroup(config->group);

    channel->group = config->group;
8000203a:	b5 42 08 00 	st.a [%a4]8,%a2
    IfxVadc_GroupId   groupIndex   = channel->group->groupId;
8000203e:	19 29 08 00 	ld.w %d9,[%a2]8
    IfxVadc_ChannelId channelIndex = config->channelId;
80002042:	19 5a 18 00 	ld.w %d10,[%a5]24

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
80002046:	02 94       	mov %d4,%d9
80002048:	60 84       	mov.a %a4,%d8
8000204a:	6d ff 76 fe 	call 80001d36 <IfxVadc_enableAccess>

    /* Configure Channel */
    {
        IfxVadc_setReferenceInput(vadcG, channelIndex, config->reference);
8000204e:	19 c3 20 00 	ld.w %d3,[%a12]32
}


IFX_INLINE void IfxVadc_setReferenceInput(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelReference reference)
{
    vadcG->CHCTR[channelIndex].B.REFSEL = reference;
80002052:	1b 0a 06 20 	addi %d2,%d10,96
80002056:	06 22       	sh %d2,2
80002058:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
8000205c:	54 22       	ld.w %d2,[%a2]
8000205e:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
80002062:	74 22       	st.w [%a2],%d2
        IfxVadc_storeGroupResult(vadcG, channelIndex, config->resultRegister);
80002064:	19 c3 24 00 	ld.w %d3,[%a12]36
}


IFX_INLINE void IfxVadc_storeGroupResult(Ifx_VADC_G *vadcG, IfxVadc_ChannelId channelIndex, IfxVadc_ChannelResult resultRegister)
{
    vadcG->CHCTR[channelIndex].B.RESREG = resultRegister;
80002068:	54 22       	ld.w %d2,[%a2]
8000206a:	37 32 04 28 	insert %d2,%d2,%d3,16,4
8000206e:	74 22       	st.w [%a2],%d2
        IfxVadc_setLowerBoundary(vadcG, channelIndex, config->lowerBoundary);
80002070:	19 c3 28 00 	ld.w %d3,[%a12]40
    vadcG->CHCTR[channelIndex].B.BNDSELL = lowerBoundary;
80002074:	54 22       	ld.w %d2,[%a2]
80002076:	37 32 02 22 	insert %d2,%d2,%d3,4,2
8000207a:	74 22       	st.w [%a2],%d2
        IfxVadc_setUpperBoundary(vadcG, channelIndex, config->upperBoundary);
8000207c:	19 c3 2c 00 	ld.w %d3,[%a12]44
    vadcG->CHCTR[channelIndex].B.BNDSELU = upperBoundary;
80002080:	54 22       	ld.w %d2,[%a2]
80002082:	37 32 02 23 	insert %d2,%d2,%d3,6,2
80002086:	74 22       	st.w [%a2],%d2
        IfxVadc_setSyncRequest(vadcG, channelIndex, config->synchonize);
80002088:	39 c3 01 00 	ld.bu %d3,[%a12]1
    vadcG->CHCTR[channelIndex].B.SYNC = synchonize;
8000208c:	54 22       	ld.w %d2,[%a2]
8000208e:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
80002092:	74 22       	st.w [%a2],%d2
        IfxVadc_setChannelInputClass(vadcG, channelIndex, config->inputClass);
80002094:	19 c3 1c 00 	ld.w %d3,[%a12]28
    vadcG->CHCTR[channelIndex].B.ICLSEL = inputClass;
80002098:	54 22       	ld.w %d2,[%a2]
8000209a:	37 32 02 20 	insert %d2,%d2,%d3,0,2
8000209e:	74 22       	st.w [%a2],%d2
        IfxVadc_setChannelLimitCheckMode(vadcG, channelIndex, config->limitCheck);
800020a0:	19 c3 34 00 	ld.w %d3,[%a12]52
    vadcG->CHCTR[channelIndex].B.CHEVMODE = limitCheck;
800020a4:	54 22       	ld.w %d2,[%a2]
800020a6:	37 32 02 24 	insert %d2,%d2,%d3,8,2
800020aa:	74 22       	st.w [%a2],%d2
        IfxVadc_setResultPosition(vadcG, channelIndex, config->rightAlignedStorage);
800020ac:	39 c3 03 00 	ld.bu %d3,[%a12]3
    vadcG->CHCTR[channelIndex].B.RESPOS = rightAlignedStorage;
800020b0:	54 22       	ld.w %d2,[%a2]
800020b2:	67 32 15 20 	ins.t %d2,%d2,21,%d3,0
800020b6:	74 22       	st.w [%a2],%d2
        IfxVadc_setBackgroundResultTarget(vadcG, channelIndex, config->globalResultUsage);
800020b8:	14 c3       	ld.bu %d3,[%a12]
    vadcG->CHCTR[channelIndex].B.RESTBS = globalResultUsage;
800020ba:	54 22       	ld.w %d2,[%a2]
800020bc:	67 32 14 20 	ins.t %d2,%d2,20,%d3,0
800020c0:	74 22       	st.w [%a2],%d2
        IfxVadc_setBoundaryMode(vadcG, channelIndex, config->boundaryMode);
800020c2:	19 c3 30 00 	ld.w %d3,[%a12]48
    vadcG->CHCTR[channelIndex].B.BNDSELX = boundaryMode;
800020c6:	54 22       	ld.w %d2,[%a2]
800020c8:	37 32 04 26 	insert %d2,%d2,%d3,12,4
800020cc:	74 22       	st.w [%a2],%d2
    }

    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800020ce:	1b 09 01 b0 	addi %d11,%d9,16
800020d2:	02 b4       	mov %d4,%d11
800020d4:	60 84       	mov.a %a4,%d8
800020d6:	6d ff 30 fe 	call 80001d36 <IfxVadc_enableAccess>

    if (config->backgroundChannel == FALSE)
800020da:	39 c2 02 00 	ld.bu %d2,[%a12]2
800020de:	df 02 4c 80 	jne %d2,0,80002176 <IfxVadc_Adc_initChannel+0x14c>
    vadcG->CHASS.U |= (1 << channelIndex);
800020e2:	d9 d2 08 00 	lea %a2,[%a13]8
800020e6:	19 d2 08 00 	ld.w %d2,[%a13]8
800020ea:	d7 12 01 2a 	insert %d2,%d2,1,%d10,1
800020ee:	74 22       	st.w [%a2],%d2
    else
    {
        IfxVadc_setBackgroundPriorityChannel(vadcG, channelIndex);
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800020f0:	02 b4       	mov %d4,%d11
800020f2:	60 84       	mov.a %a4,%d8
800020f4:	6d ff fe fd 	call 80001cf0 <IfxVadc_disableAccess>

    IfxVadc_setChannelEventNodePointer0(vadcG, config->channelSrcNr, channel->channel);
800020f8:	19 c4 14 00 	ld.w %d4,[%a12]20
800020fc:	48 02       	ld.w %d2,[%a15]0
    vadcG->CEVNP0.U &= ~(IFX_VADC_G_CEVNP0_CEV0NP_MSK << (channel * 4));
800020fe:	d9 d2 20 40 	lea %a2,[%a13]288
80002102:	19 d5 20 40 	ld.w %d5,[%a13]288
80002106:	06 22       	sh %d2,2
80002108:	3b f0 00 30 	mov %d3,15
8000210c:	0f 23 00 30 	sh %d3,%d3,%d2
80002110:	0f 35 e0 30 	andn %d3,%d5,%d3
80002114:	74 23       	st.w [%a2],%d3
    vadcG->CEVNP0.U |= (channelSrcNr << (channel * 4));
80002116:	54 23       	ld.w %d3,[%a2]
80002118:	0f 24 00 20 	sh %d2,%d4,%d2
8000211c:	a6 32       	or %d2,%d3
8000211e:	74 22       	st.w [%a2],%d2

    if (config->channelPriority > 0)
80002120:	b9 c2 06 00 	ld.hu %d2,[%a12]6
80002124:	df 02 32 80 	jne %d2,0,80002188 <IfxVadc_Adc_initChannel+0x15e>
    else
    {
        /* do nothing */
    }

    if (config->resultRegister < IfxVadc_ChannelResult_8)
80002128:	19 c2 24 00 	ld.w %d2,[%a12]36
8000212c:	ff 82 51 80 	jge.u %d2,8,800021ce <IfxVadc_Adc_initChannel+0x1a4>
    {
        IfxVadc_setResultNodeEventPointer0(vadcG, config->resultSrcNr, config->resultRegister);
80002130:	19 c4 10 00 	ld.w %d4,[%a12]16
    vadcG->REVNP0.U &= ~(IFX_VADC_G_REVNP0_REV0NP_MSK << (resultRegister * 4));
80002134:	d9 d2 30 40 	lea %a2,[%a13]304
80002138:	19 d5 30 40 	ld.w %d5,[%a13]304
8000213c:	06 22       	sh %d2,2
8000213e:	3b f0 00 30 	mov %d3,15
80002142:	0f 23 00 30 	sh %d3,%d3,%d2
80002146:	0f 35 e0 30 	andn %d3,%d5,%d3
8000214a:	74 23       	st.w [%a2],%d3
    vadcG->REVNP0.U |= (resultSrcNr << (resultRegister * 4));
8000214c:	54 23       	ld.w %d3,[%a2]
8000214e:	0f 24 00 20 	sh %d2,%d4,%d2
80002152:	a6 32       	or %d2,%d3
80002154:	74 22       	st.w [%a2],%d2
    else
    {
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
    }

    if (config->resultPriority > 0)
80002156:	b9 c2 04 00 	ld.hu %d2,[%a12]4
8000215a:	df 02 50 80 	jne %d2,0,800021fa <IfxVadc_Adc_initChannel+0x1d0>
    else
    {
        /* do nothing */
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_channelControl0 + groupIndex));
8000215e:	02 94       	mov %d4,%d9
80002160:	60 84       	mov.a %a4,%d8
80002162:	6d ff c7 fd 	call 80001cf0 <IfxVadc_disableAccess>
    /* Software initialization */
    channel->resultreg = config->resultRegister;
80002166:	19 c2 24 00 	ld.w %d2,[%a12]36
8000216a:	68 12       	st.w [%a15]4,%d2
    channel->channel   = config->channelId;
8000216c:	19 c2 18 00 	ld.w %d2,[%a12]24
80002170:	68 02       	st.w [%a15]0,%d2

    return Status;
}
80002172:	82 02       	mov %d2,0
80002174:	00 90       	ret 
    vadcG->CHASS.U &= ~(1 << channelIndex);
80002176:	d9 d2 08 00 	lea %a2,[%a13]8
8000217a:	19 d2 08 00 	ld.w %d2,[%a13]8
8000217e:	d7 02 01 2a 	insert %d2,%d2,0,%d10,1
80002182:	74 22       	st.w [%a2],%d2
}
80002184:	1d ff b6 ff 	j 800020f0 <IfxVadc_Adc_initChannel+0xc6>
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->channelSrcNr);
80002188:	19 c5 14 00 	ld.w %d5,[%a12]20
8000218c:	02 94       	mov %d4,%d9
8000218e:	6d ff 3c fe 	call 80001e06 <IfxVadc_getSrcAddress>
        IfxVadc_clearChannelRequest(vadcG, config->channelId);
80002192:	19 c4 18 00 	ld.w %d4,[%a12]24
    vadcG->CEFCLR.U = 1 << channelId;
80002196:	82 13       	mov %d3,1
80002198:	82 12       	mov %d2,1
8000219a:	0f 42 00 20 	sh %d2,%d2,%d4
8000219e:	59 d2 10 40 	st.w [%a13]272,%d2
        IfxSrc_init(src, config->channelServProvider, config->channelPriority);
800021a2:	19 c5 0c 00 	ld.w %d5,[%a12]12
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority)
{
    src->B.SRPN = priority;
800021a6:	39 c4 06 00 	ld.bu %d4,[%a12]6
800021aa:	54 22       	ld.w %d2,[%a2]
800021ac:	37 42 08 20 	insert %d2,%d2,%d4,0,8
800021b0:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800021b2:	54 22       	ld.w %d2,[%a2]
800021b4:	37 52 82 25 	insert %d2,%d2,%d5,11,2
800021b8:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
800021ba:	54 22       	ld.w %d2,[%a2]
800021bc:	67 32 19 20 	ins.t %d2,%d2,25,%d3,0
800021c0:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
800021c2:	54 22       	ld.w %d2,[%a2]
800021c4:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
800021c8:	74 22       	st.w [%a2],%d2
}
800021ca:	1d ff af ff 	j 80002128 <IfxVadc_Adc_initChannel+0xfe>
        IfxVadc_setResultNodeEventPointer1(vadcG, config->resultSrcNr, config->resultRegister);
800021ce:	19 c4 10 00 	ld.w %d4,[%a12]16
    vadcG->REVNP1.U &= ~(IFX_VADC_G_REVNP1_REV8NP_MSK << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
800021d2:	d9 d2 34 40 	lea %a2,[%a13]308
800021d6:	19 d5 34 40 	ld.w %d5,[%a13]308
800021da:	c2 82       	add %d2,-8
800021dc:	06 22       	sh %d2,2
800021de:	3b f0 00 30 	mov %d3,15
800021e2:	0f 23 00 30 	sh %d3,%d3,%d2
800021e6:	0f 35 e0 30 	andn %d3,%d5,%d3
800021ea:	74 23       	st.w [%a2],%d3
    vadcG->REVNP1.U |= (resultSrcNr << ((resultRegister - IfxVadc_ChannelResult_8) * 4));
800021ec:	54 23       	ld.w %d3,[%a2]
800021ee:	0f 24 00 20 	sh %d2,%d4,%d2
800021f2:	a6 32       	or %d2,%d3
800021f4:	74 22       	st.w [%a2],%d2
}
800021f6:	1d ff b0 ff 	j 80002156 <IfxVadc_Adc_initChannel+0x12c>
        volatile Ifx_SRC_SRCR *src = IfxVadc_getSrcAddress(groupIndex, config->resultSrcNr);
800021fa:	19 c5 10 00 	ld.w %d5,[%a12]16
800021fe:	02 94       	mov %d4,%d9
80002200:	6d ff 03 fe 	call 80001e06 <IfxVadc_getSrcAddress>
    vadcG->RCR[resultRegister].B.SRGEN = 1;
80002204:	19 c2 24 00 	ld.w %d2,[%a12]36
80002208:	1b 02 08 20 	addi %d2,%d2,128
8000220c:	06 22       	sh %d2,2
8000220e:	01 d2 00 36 	addsc.a %a3,%a13,%d2,0
80002212:	54 32       	ld.w %d2,[%a3]
80002214:	b7 12 81 2f 	insert %d2,%d2,1,31,1
80002218:	74 32       	st.w [%a3],%d2
    vadcG->REFCLR.U = 0x0000FFFFu;
8000221a:	bb f0 ff 2f 	mov.u %d2,65535
8000221e:	59 d2 14 40 	st.w [%a13]276,%d2
        IfxSrc_init(src, config->resultServProvider, config->resultPriority);
80002222:	19 c4 08 00 	ld.w %d4,[%a12]8
    src->B.SRPN = priority;
80002226:	39 c3 04 00 	ld.bu %d3,[%a12]4
8000222a:	54 22       	ld.w %d2,[%a2]
8000222c:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80002230:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80002232:	54 22       	ld.w %d2,[%a2]
80002234:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80002238:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
8000223a:	54 22       	ld.w %d2,[%a2]
8000223c:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80002240:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80002242:	54 22       	ld.w %d2,[%a2]
80002244:	b7 12 01 25 	insert %d2,%d2,1,10,1
80002248:	74 22       	st.w [%a2],%d2
}
8000224a:	1d ff 8a ff 	j 8000215e <IfxVadc_Adc_initChannel+0x134>

8000224e <IfxVadc_Adc_initChannelConfig>:


void IfxVadc_Adc_initChannelConfig(IfxVadc_Adc_ChannelConfig *config, const IfxVadc_Adc_Group *group)
{
8000224e:	40 ae       	mov.aa %a14,%sp
80002250:	40 4c       	mov.aa %a12,%a4
80002252:	80 58       	mov.d %d8,%a5
        .resultServProvider  = IfxSrc_Tos_cpu0,
        .channelPriority     = 0,
        .channelSrcNr        = IfxVadc_SrcNr_group0,
        .channelServProvider = IfxSrc_Tos_cpu0
    };
    *config       = IfxVadc_Adc_defaultChannelConfig;
80002254:	3b c0 03 50 	mov %d5,60
80002258:	82 04       	mov %d4,0
8000225a:	6d 00 c7 25 	call 80006de8 <memset>
    config->group = group;
8000225e:	59 c8 38 00 	st.w [%a12]56,%d8
}
80002262:	00 90       	ret 

80002264 <IfxVadc_Adc_initGroup>:


IfxVadc_Status IfxVadc_Adc_initGroup(IfxVadc_Adc_Group *group, const IfxVadc_Adc_GroupConfig *config)
{
80002264:	40 ae       	mov.aa %a14,%sp
80002266:	40 5c       	mov.aa %a12,%a5
    IfxVadc_Status status = IfxVadc_Status_noError;
    Ifx_VADC      *vadc   = config->module->vadc;
80002268:	d4 52       	ld.a %a2,[%a5]
8000226a:	d4 2d       	ld.a %a13,[%a2]
    Ifx_VADC_G    *vadcG  = &vadc->G[config->groupId];
8000226c:	19 58 04 00 	ld.w %d8,[%a5]4
80002270:	8f a8 00 20 	sh %d2,%d8,10
80002274:	1b 02 48 20 	addi %d2,%d2,1152
80002278:	80 d3       	mov.d %d3,%a13
8000227a:	0b 23 00 90 	add %d9,%d3,%d2

    /* check for write access */
    group->group   = vadcG;
8000227e:	59 49 04 00 	st.w [%a4]4,%d9
    group->module  = *config->module;
80002282:	d4 52       	ld.a %a2,[%a5]
80002284:	54 22       	ld.w %d2,[%a2]
80002286:	74 42       	st.w [%a4],%d2
    IfxVadc_GroupId groupIndex      = config->groupId;
80002288:	19 5a 04 00 	ld.w %d10,[%a5]4
    group->groupId = groupIndex;
8000228c:	59 4a 08 00 	st.w [%a4]8,%d10
    float32         analogFrequency = IfxVadc_getAdcAnalogFrequency(vadc);
80002290:	40 d4       	mov.aa %a4,%a13
80002292:	6d ff 9e fd 	call 80001dce <IfxVadc_getAdcAnalogFrequency>
80002296:	02 2c       	mov %d12,%d2

    uint8           inputClassNum;

    /* Request Access to configuration registers */
    IfxVadc_enableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
80002298:	1b 0a 01 b0 	addi %d11,%d10,16
8000229c:	02 b4       	mov %d4,%d11
8000229e:	40 d4       	mov.aa %a4,%a13
800022a0:	6d ff 4b fd 	call 80001d36 <IfxVadc_enableAccess>

    if (config->arbiter.requestSlotQueueEnabled == TRUE)
800022a4:	39 c4 38 10 	ld.bu %d4,[%a12]120
800022a8:	df 14 7c 00 	jeq %d4,1,800023a0 <IfxVadc_Adc_initGroup+0x13c>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_queue);
800022ac:	82 07       	mov %d7,0
800022ae:	82 06       	mov %d6,0
800022b0:	82 05       	mov %d5,0
800022b2:	82 04       	mov %d4,0
800022b4:	60 94       	mov.a %a4,%d9
800022b6:	6d ff 50 fe 	call 80001f56 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotScanEnabled == TRUE)
800022ba:	39 c4 39 10 	ld.bu %d4,[%a12]121
800022be:	df 14 7b 00 	jeq %d4,1,800023b4 <IfxVadc_Adc_initGroup+0x150>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_scan);
800022c2:	82 17       	mov %d7,1
800022c4:	82 06       	mov %d6,0
800022c6:	82 05       	mov %d5,0
800022c8:	82 04       	mov %d4,0
800022ca:	60 94       	mov.a %a4,%d9
800022cc:	6d ff 45 fe 	call 80001f56 <IfxVadc_setArbiterPriority>
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
800022d0:	39 c4 3a 10 	ld.bu %d4,[%a12]122
800022d4:	df 14 7a 00 	jeq %d4,1,800023c8 <IfxVadc_Adc_initGroup+0x164>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
    }
    else
    {
        /* Disable the slot */
        IfxVadc_setArbiterPriority(vadcG, FALSE, IfxVadc_RequestSlotPriority_lowest, IfxVadc_RequestSlotStartMode_waitForStart, IfxVadc_RequestSource_background);
800022d8:	82 27       	mov %d7,2
800022da:	82 06       	mov %d6,0
800022dc:	82 05       	mov %d5,0
800022de:	82 04       	mov %d4,0
800022e0:	60 94       	mov.a %a4,%d9
800022e2:	6d ff 3a fe 	call 80001f56 <IfxVadc_setArbiterPriority>
    }

    /* master slave configuration */
    if (config->master != groupIndex)
800022e6:	19 c2 08 00 	ld.w %d2,[%a12]8
800022ea:	5f a2 22 00 	jeq %d2,%d10,8000232e <IfxVadc_Adc_initGroup+0xca>
    return IfxVadc_Adc_masterIndex[slave][master];
800022ee:	8f 3a 00 30 	sh %d3,%d10,3
800022f2:	91 00 00 28 	movh.a %a2,32768
800022f6:	d9 22 10 f0 	lea %a2,[%a2]976 <800003d0 <IfxVadc_Adc_masterIndex>>
800022fa:	80 24       	mov.d %d4,%a2
800022fc:	42 34       	add %d4,%d3
800022fe:	60 42       	mov.a %a2,%d4
80002300:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80002304:	14 22       	ld.bu %d2,[%a2]
    vadcG->SYNCTR.B.STSEL = (masterIndex % 4);
80002306:	8f a8 00 30 	sh %d3,%d8,10
8000230a:	01 d3 00 26 	addsc.a %a2,%a13,%d3,0
8000230e:	d9 23 40 30 	lea %a3,[%a2]1216
80002312:	19 23 40 30 	ld.w %d3,[%a2]1216
80002316:	37 23 02 30 	insert %d3,%d3,%d2,0,2
8000231a:	74 33       	st.w [%a3],%d3
    vadcG->SYNCTR.U      |= (0x00000008U << (masterIndex % 4));
8000231c:	54 33       	ld.w %d3,[%a3]
8000231e:	8f 32 00 21 	and %d2,%d2,3
80002322:	3b 80 00 40 	mov %d4,8
80002326:	0f 24 00 20 	sh %d2,%d4,%d2
8000232a:	a6 32       	or %d2,%d3
8000232c:	74 32       	st.w [%a3],%d2
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
8000232e:	8f a8 00 20 	sh %d2,%d8,10
80002332:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002336:	d9 23 40 20 	lea %a3,[%a2]1152
8000233a:	19 23 40 20 	ld.w %d3,[%a2]1152
8000233e:	8f 33 c0 31 	andn %d3,%d3,3
80002342:	74 33       	st.w [%a3],%d3

    /* Setup arbiter */
    /* turn off the group during initialization, see UM for sync mode */
    IfxVadc_setAnalogConvertControl(vadcG, IfxVadc_AnalogConverterMode_off);

    IfxVadc_setArbitrationRoundLength(vadcG, config->arbiter.arbiterRoundLength);
80002344:	19 c2 34 10 	ld.w %d2,[%a12]116
    vadcG->ARBCFG.B.ARBRND = arbiterRoundLength;
80002348:	d9 23 40 20 	lea %a3,[%a2]1152
8000234c:	19 23 40 20 	ld.w %d3,[%a2]1152
80002350:	37 23 02 32 	insert %d3,%d3,%d2,4,2
80002354:	74 33       	st.w [%a3],%d3

    /* Setup queue request if enabled */
    if (config->arbiter.requestSlotQueueEnabled == TRUE)
80002356:	39 c2 38 10 	ld.bu %d2,[%a12]120
8000235a:	df 12 41 00 	jeq %d2,1,800023dc <IfxVadc_Adc_initGroup+0x178>
    {
        /* do nothing */
    }

    /* Setup scan request if enabled */
    if (config->arbiter.requestSlotScanEnabled == TRUE)
8000235e:	39 c2 39 10 	ld.bu %d2,[%a12]121
80002362:	df 12 b0 00 	jeq %d2,1,800024c2 <IfxVadc_Adc_initGroup+0x25e>
    else
    {
        /* do nothing */
    }

    if (config->arbiter.requestSlotBackgroundScanEnabled == TRUE)
80002366:	39 c2 3a 10 	ld.bu %d2,[%a12]122
8000236a:	df 12 1f 01 	jeq %d2,1,800025a8 <IfxVadc_Adc_initGroup+0x344>
    {
        /* do nothing */
    }

    /* turn on group after initialisation, only in master mode */
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
8000236e:	19 c2 08 00 	ld.w %d2,[%a12]8
80002372:	5f a2 76 01 	jeq %d2,%d10,8000265e <IfxVadc_Adc_initGroup+0x3fa>
80002376:	82 04       	mov %d4,0
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
80002378:	8f a8 00 20 	sh %d2,%d8,10
8000237c:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002380:	d9 23 40 20 	lea %a3,[%a2]1152
80002384:	19 23 40 20 	ld.w %d3,[%a2]1152
80002388:	37 43 02 30 	insert %d3,%d3,%d4,0,2
8000238c:	74 33       	st.w [%a3],%d3
    IfxVadc_setAnalogConvertControl(vadcG, convertMode);

    /*  Post Calibration */
    IfxVadc_disablePostCalibration(vadc, groupIndex, config->disablePostCalibration);
8000238e:	39 c5 30 10 	ld.bu %d5,[%a12]112
80002392:	02 a4       	mov %d4,%d10
80002394:	40 d4       	mov.aa %a4,%a13
80002396:	6d ff f3 fc 	call 80001d7c <IfxVadc_disablePostCalibration>

    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
8000239a:	82 03       	mov %d3,0
8000239c:	1d 00 77 01 	j 8000268a <IfxVadc_Adc_initGroup+0x426>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotQueueEnabled, config->queueRequest.requestSlotPrio, config->queueRequest.requestSlotStartMode, IfxVadc_RequestSource_queue);
800023a0:	82 07       	mov %d7,0
800023a2:	19 c6 10 10 	ld.w %d6,[%a12]80
800023a6:	19 c5 0c 10 	ld.w %d5,[%a12]76
800023aa:	60 94       	mov.a %a4,%d9
800023ac:	6d ff d5 fd 	call 80001f56 <IfxVadc_setArbiterPriority>
800023b0:	1d ff 85 ff 	j 800022ba <IfxVadc_Adc_initGroup+0x56>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotScanEnabled, config->scanRequest.requestSlotPrio, config->scanRequest.requestSlotStartMode, IfxVadc_RequestSource_scan);
800023b4:	82 17       	mov %d7,1
800023b6:	19 c6 34 00 	ld.w %d6,[%a12]52
800023ba:	19 c5 30 00 	ld.w %d5,[%a12]48
800023be:	60 94       	mov.a %a4,%d9
800023c0:	6d ff cb fd 	call 80001f56 <IfxVadc_setArbiterPriority>
800023c4:	1d ff 86 ff 	j 800022d0 <IfxVadc_Adc_initGroup+0x6c>
        IfxVadc_setArbiterPriority(vadcG, config->arbiter.requestSlotBackgroundScanEnabled, config->backgroundScanRequest.requestSlotPrio, config->backgroundScanRequest.requestSlotStartMode, IfxVadc_RequestSource_background);
800023c8:	82 27       	mov %d7,2
800023ca:	19 c6 2c 10 	ld.w %d6,[%a12]108
800023ce:	19 c5 28 10 	ld.w %d5,[%a12]104
800023d2:	60 94       	mov.a %a4,%d9
800023d4:	6d ff c1 fd 	call 80001f56 <IfxVadc_setArbiterPriority>
800023d8:	1d ff 87 ff 	j 800022e6 <IfxVadc_Adc_initGroup+0x82>
        if (queueSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800023dc:	19 c2 08 10 	ld.w %d2,[%a12]72
800023e0:	df 02 37 00 	jeq %d2,0,8000244e <IfxVadc_Adc_initGroup+0x1ea>
    vadcG->QMR0.B.ENTR = 1;     /* enable external trigger */
800023e4:	8f a8 00 20 	sh %d2,%d8,10
800023e8:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800023ec:	d9 23 44 40 	lea %a3,[%a2]1284
800023f0:	19 22 44 40 	ld.w %d2,[%a2]1284
800023f4:	b7 12 01 21 	insert %d2,%d2,1,2,1
800023f8:	74 32       	st.w [%a3],%d2
            IfxVadc_setQueueSlotTriggerOperatingConfig(vadcG, queueSlot->triggerConfig.triggerMode, queueSlot->triggerConfig.triggerSource);
800023fa:	19 c5 08 10 	ld.w %d5,[%a12]72
800023fe:	19 c4 00 10 	ld.w %d4,[%a12]64
    qctrl0.U        = vadcG->QCTRL0.U;
80002402:	d9 23 40 40 	lea %a3,[%a2]1280
80002406:	19 22 40 40 	ld.w %d2,[%a2]1280
    qctrl0.B.XTWC   = 1;
8000240a:	b7 12 81 27 	insert %d2,%d2,1,15,1
    qctrl0.B.XTMODE = triggerMode;
8000240e:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    qctrl0.B.XTSEL  = triggerSource;
80002412:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadcG->QCTRL0.U = qctrl0.U;
80002416:	74 32       	st.w [%a3],%d2
            if (queueSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)
80002418:	19 c2 00 10 	ld.w %d2,[%a12]64
8000241c:	8b f2 20 22 	ne %d2,%d2,15
80002420:	df 02 22 80 	jne %d2,0,80002464 <IfxVadc_Adc_initGroup+0x200>
                IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80002424:	19 c3 3c 00 	ld.w %d3,[%a12]60
    qctrl0.U           = vadcG->QCTRL0.U;
80002428:	8f a8 00 20 	sh %d2,%d8,10
8000242c:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002430:	54 32       	ld.w %d2,[%a3]
    qctrl0.B.GTWC      = 1;
80002432:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
80002436:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
8000243a:	74 32       	st.w [%a3],%d2
    vadcG->QMR0.B.ENGT = gatingMode;
8000243c:	d9 23 44 40 	lea %a3,[%a2]1284
80002440:	19 22 44 40 	ld.w %d2,[%a2]1284
80002444:	b7 12 02 20 	insert %d2,%d2,1,0,2
80002448:	74 32       	st.w [%a3],%d2
}
8000244a:	1d 00 0d 00 	j 80002464 <IfxVadc_Adc_initGroup+0x200>
    vadcG->QMR0.B.ENTR = 0; /* disable external trigger */
8000244e:	8f a8 00 20 	sh %d2,%d8,10
80002452:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002456:	d9 23 44 40 	lea %a3,[%a2]1284
8000245a:	19 22 44 40 	ld.w %d2,[%a2]1284
8000245e:	8f 42 c0 21 	andn %d2,%d2,4
80002462:	74 32       	st.w [%a3],%d2
        if ((queueSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
80002464:	19 c2 00 10 	ld.w %d2,[%a12]64
80002468:	8b f2 00 22 	eq %d2,%d2,15
8000246c:	df 02 1a 80 	jne %d2,0,800024a0 <IfxVadc_Adc_initGroup+0x23c>
            IfxVadc_setQueueSlotGatingConfig(vadcG, queueSlot->triggerConfig.gatingSource, queueSlot->triggerConfig.gatingMode);
80002470:	19 c5 3c 00 	ld.w %d5,[%a12]60
80002474:	19 c4 04 10 	ld.w %d4,[%a12]68
    qctrl0.U           = vadcG->QCTRL0.U;
80002478:	8f a8 00 20 	sh %d2,%d8,10
8000247c:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002480:	d9 23 40 40 	lea %a3,[%a2]1280
80002484:	19 22 40 40 	ld.w %d2,[%a2]1280
    qctrl0.B.GTWC      = 1;
80002488:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    qctrl0.B.GTSEL     = gatingSource;
8000248c:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadcG->QCTRL0.U    = qctrl0.U;
80002490:	74 32       	st.w [%a3],%d2
    vadcG->QMR0.B.ENGT = gatingMode;
80002492:	d9 23 44 40 	lea %a3,[%a2]1284
80002496:	19 22 44 40 	ld.w %d2,[%a2]1284
8000249a:	37 42 02 20 	insert %d2,%d2,%d4,0,2
8000249e:	74 32       	st.w [%a3],%d2
        IfxVadc_clearQueue(vadcG, (queueSlot->flushQueueAfterInit) ? 1 : 0);
800024a0:	39 c3 38 00 	ld.bu %d3,[%a12]56
800024a4:	8b 03 20 32 	ne %d3,%d3,0
    vadcG->QMR0.B.FLUSH = flushQueue;
800024a8:	8f a8 00 20 	sh %d2,%d8,10
800024ac:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800024b0:	d9 23 44 40 	lea %a3,[%a2]1284
800024b4:	19 22 44 40 	ld.w %d2,[%a2]1284
800024b8:	67 32 0a 20 	ins.t %d2,%d2,10,%d3,0
800024bc:	74 32       	st.w [%a3],%d2
}
800024be:	1d ff 50 ff 	j 8000235e <IfxVadc_Adc_initGroup+0xfa>
        if (scanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800024c2:	19 c2 2c 00 	ld.w %d2,[%a12]44
800024c6:	df 02 37 00 	jeq %d2,0,80002534 <IfxVadc_Adc_initGroup+0x2d0>
    vadcG->ASMR.B.ENTR = 1; /* enable external trigger */
800024ca:	8f a8 00 20 	sh %d2,%d8,10
800024ce:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800024d2:	d9 23 64 40 	lea %a3,[%a2]1316
800024d6:	19 22 64 40 	ld.w %d2,[%a2]1316
800024da:	b7 12 01 21 	insert %d2,%d2,1,2,1
800024de:	74 32       	st.w [%a3],%d2
            IfxVadc_setScanSlotTriggerConfig(vadcG, scanSlot->triggerConfig.triggerMode, scanSlot->triggerConfig.triggerSource);
800024e0:	19 c5 2c 00 	ld.w %d5,[%a12]44
800024e4:	19 c4 24 00 	ld.w %d4,[%a12]36
    asctrl.U        = vadcG->ASCTRL.U;
800024e8:	d9 23 60 40 	lea %a3,[%a2]1312
800024ec:	19 22 60 40 	ld.w %d2,[%a2]1312
    asctrl.B.XTWC   = 1;
800024f0:	b7 12 81 27 	insert %d2,%d2,1,15,1
    asctrl.B.XTMODE = triggerMode;
800024f4:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    asctrl.B.XTSEL  = triggerSource;
800024f8:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadcG->ASCTRL.U = asctrl.U;
800024fc:	74 32       	st.w [%a3],%d2
            if (scanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
800024fe:	19 c2 24 00 	ld.w %d2,[%a12]36
80002502:	8b f2 20 22 	ne %d2,%d2,15
80002506:	df 02 22 80 	jne %d2,0,8000254a <IfxVadc_Adc_initGroup+0x2e6>
                IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
8000250a:	19 c3 20 00 	ld.w %d3,[%a12]32
    asctrl.U           = vadcG->ASCTRL.U;
8000250e:	8f a8 00 20 	sh %d2,%d8,10
80002512:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002516:	54 32       	ld.w %d2,[%a3]
    asctrl.B.GTWC      = 1;
80002518:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    asctrl.B.GTSEL     = gatingSource;
8000251c:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80002520:	74 32       	st.w [%a3],%d2
    vadcG->ASMR.B.ENGT = gatingMode;
80002522:	d9 23 64 40 	lea %a3,[%a2]1316
80002526:	19 22 64 40 	ld.w %d2,[%a2]1316
8000252a:	b7 12 02 20 	insert %d2,%d2,1,0,2
8000252e:	74 32       	st.w [%a3],%d2
}
80002530:	1d 00 0d 00 	j 8000254a <IfxVadc_Adc_initGroup+0x2e6>
    vadcG->ASMR.B.ENTR = 0; /* disable external trigger */
80002534:	8f a8 00 20 	sh %d2,%d8,10
80002538:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
8000253c:	d9 23 64 40 	lea %a3,[%a2]1316
80002540:	19 22 64 40 	ld.w %d2,[%a2]1316
80002544:	8f 42 c0 21 	andn %d2,%d2,4
80002548:	74 32       	st.w [%a3],%d2
        if ((scanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
8000254a:	19 c2 24 00 	ld.w %d2,[%a12]36
8000254e:	8b f2 00 22 	eq %d2,%d2,15
80002552:	df 02 1a 80 	jne %d2,0,80002586 <IfxVadc_Adc_initGroup+0x322>
            IfxVadc_setScanSlotGatingConfig(vadcG, scanSlot->triggerConfig.gatingSource, scanSlot->triggerConfig.gatingMode);
80002556:	19 c5 20 00 	ld.w %d5,[%a12]32
8000255a:	19 c4 28 00 	ld.w %d4,[%a12]40
    asctrl.U           = vadcG->ASCTRL.U;
8000255e:	8f a8 00 20 	sh %d2,%d8,10
80002562:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002566:	d9 23 60 40 	lea %a3,[%a2]1312
8000256a:	19 22 60 40 	ld.w %d2,[%a2]1312
    asctrl.B.GTWC      = 1;
8000256e:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    asctrl.B.GTSEL     = gatingSource;
80002572:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadcG->ASCTRL.U    = asctrl.U;
80002576:	74 32       	st.w [%a3],%d2
    vadcG->ASMR.B.ENGT = gatingMode;
80002578:	d9 23 64 40 	lea %a3,[%a2]1316
8000257c:	19 22 64 40 	ld.w %d2,[%a2]1316
80002580:	37 42 02 20 	insert %d2,%d2,%d4,0,2
80002584:	74 32       	st.w [%a3],%d2
        IfxVadc_setAutoScan(vadcG, scanSlot->autoscanEnabled ? 1 : 0);
80002586:	39 c3 1c 00 	ld.bu %d3,[%a12]28
8000258a:	8b 03 20 32 	ne %d3,%d3,0
    vadcG->ASMR.B.SCAN = autoscanEnable;
8000258e:	8f a8 00 20 	sh %d2,%d8,10
80002592:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
80002596:	d9 23 64 40 	lea %a3,[%a2]1316
8000259a:	19 22 64 40 	ld.w %d2,[%a2]1316
8000259e:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
800025a2:	74 32       	st.w [%a3],%d2
}
800025a4:	1d ff e1 fe 	j 80002366 <IfxVadc_Adc_initGroup+0x102>
        if (backgroundScanSlot->triggerConfig.triggerMode != IfxVadc_TriggerMode_noExternalTrigger)
800025a8:	19 c2 24 10 	ld.w %d2,[%a12]100
800025ac:	df 02 1e 00 	jeq %d2,0,800025e8 <IfxVadc_Adc_initGroup+0x384>
    vadc->BRSMR.B.ENTR = 1; /* enable external trigger */
800025b0:	d9 d2 04 80 	lea %a2,[%a13]516
800025b4:	19 d2 04 80 	ld.w %d2,[%a13]516
800025b8:	b7 12 01 21 	insert %d2,%d2,1,2,1
800025bc:	74 22       	st.w [%a2],%d2
            IfxVadc_setBackgroundScanSlotTriggerConfig(vadc, backgroundScanSlot->triggerConfig.triggerMode, backgroundScanSlot->triggerConfig.triggerSource);
800025be:	19 c5 24 10 	ld.w %d5,[%a12]100
800025c2:	19 c4 1c 10 	ld.w %d4,[%a12]92
    brsctrl.U        = vadc->BRSCTRL.U;
800025c6:	d9 d2 00 80 	lea %a2,[%a13]512
800025ca:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.XTWC   = 1;
800025ce:	b7 12 81 27 	insert %d2,%d2,1,15,1
    brsctrl.B.XTMODE = triggerMode;
800025d2:	37 52 82 26 	insert %d2,%d2,%d5,13,2
    brsctrl.B.XTSEL  = triggerSource;
800025d6:	37 42 04 24 	insert %d2,%d2,%d4,8,4
    vadc->BRSCTRL.U  = brsctrl.U;
800025da:	74 22       	st.w [%a2],%d2
            if (backgroundScanSlot->triggerConfig.triggerSource == IfxVadc_TriggerSource_15)    /* if last input is used the trigger input selection is extend by Gating inputs */
800025dc:	19 c2 1c 10 	ld.w %d2,[%a12]92
800025e0:	8b f2 20 22 	ne %d2,%d2,15
800025e4:	df 02 29 00 	jeq %d2,0,80002636 <IfxVadc_Adc_initGroup+0x3d2>
        if ((backgroundScanSlot->triggerConfig.triggerSource != IfxVadc_TriggerSource_15))
800025e8:	19 c2 1c 10 	ld.w %d2,[%a12]92
800025ec:	8b f2 00 22 	eq %d2,%d2,15
800025f0:	df 02 16 80 	jne %d2,0,8000261c <IfxVadc_Adc_initGroup+0x3b8>
            IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, backgroundScanSlot->triggerConfig.gatingMode);
800025f4:	19 c5 18 10 	ld.w %d5,[%a12]88
800025f8:	19 c4 20 10 	ld.w %d4,[%a12]96
    brsctrl.U          = vadc->BRSCTRL.U;
800025fc:	d9 d2 00 80 	lea %a2,[%a13]512
80002600:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.GTWC     = 1;
80002604:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80002608:	37 52 04 28 	insert %d2,%d2,%d5,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
8000260c:	74 22       	st.w [%a2],%d2
    vadc->BRSMR.B.ENGT = gatingMode;
8000260e:	d9 d2 04 80 	lea %a2,[%a13]516
80002612:	19 d2 04 80 	ld.w %d2,[%a13]516
80002616:	37 42 02 20 	insert %d2,%d2,%d4,0,2
8000261a:	74 22       	st.w [%a2],%d2
        IfxVadc_setAutoBackgroundScan(vadc, backgroundScanSlot->autoBackgroundScanEnabled ? 1 : 0);
8000261c:	39 c3 14 10 	ld.bu %d3,[%a12]84
80002620:	8b 03 20 32 	ne %d3,%d3,0
    vadc->BRSMR.B.SCAN = autoBackgroundScanEnable;
80002624:	d9 d2 04 80 	lea %a2,[%a13]516
80002628:	19 d2 04 80 	ld.w %d2,[%a13]516
8000262c:	67 32 04 20 	ins.t %d2,%d2,4,%d3,0
80002630:	74 22       	st.w [%a2],%d2
}
80002632:	1d ff 9e fe 	j 8000236e <IfxVadc_Adc_initGroup+0x10a>
                IfxVadc_setBackgroundScanSlotGatingConfig(vadc, backgroundScanSlot->triggerConfig.gatingSource, IfxVadc_GatingMode_always);
80002636:	19 c3 18 10 	ld.w %d3,[%a12]88
    brsctrl.U          = vadc->BRSCTRL.U;
8000263a:	d9 d2 00 80 	lea %a2,[%a13]512
8000263e:	19 d2 00 80 	ld.w %d2,[%a13]512
    brsctrl.B.GTWC     = 1;
80002642:	b7 12 81 2b 	insert %d2,%d2,1,23,1
    brsctrl.B.GTSEL    = gatingSource;
80002646:	37 32 04 28 	insert %d2,%d2,%d3,16,4
    vadc->BRSCTRL.U    = brsctrl.U;
8000264a:	74 22       	st.w [%a2],%d2
    vadc->BRSMR.B.ENGT = gatingMode;
8000264c:	d9 d2 04 80 	lea %a2,[%a13]516
80002650:	19 d2 04 80 	ld.w %d2,[%a13]516
80002654:	b7 12 02 20 	insert %d2,%d2,1,0,2
80002658:	74 22       	st.w [%a2],%d2
}
8000265a:	1d ff c7 ff 	j 800025e8 <IfxVadc_Adc_initGroup+0x384>
    IfxVadc_AnalogConverterMode convertMode = (config->master == groupIndex) ? IfxVadc_AnalogConverterMode_normalOperation : IfxVadc_AnalogConverterMode_off;
8000265e:	82 34       	mov %d4,3
80002660:	1d ff 8c fe 	j 80002378 <IfxVadc_Adc_initGroup+0x114>
80002664:	3b f0 0f 50 	mov %d5,255
80002668:	0b 54 90 51 	min.u %d5,%d4,%d5
    vadcG->ICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
8000266c:	8f 88 00 20 	sh %d2,%d8,8
80002670:	42 62       	add %d2,%d6
80002672:	1b 82 12 40 	addi %d4,%d2,296
80002676:	06 24       	sh %d4,2
80002678:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
8000267c:	54 24       	ld.w %d4,[%a2]
8000267e:	37 54 05 40 	insert %d4,%d4,%d5,0,5
80002682:	74 24       	st.w [%a2],%d4
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_INPUTCLASSES; inputClassNum++)
80002684:	c2 13       	add %d3,1
80002686:	8f f3 0f 31 	and %d3,%d3,255
8000268a:	ff 23 29 80 	jge.u %d3,2,800026dc <IfxVadc_Adc_initGroup+0x478>
    {
        /* configure Group input class registers */
        IfxVadc_setGroupResolution(vadcG, inputClassNum, config->inputClass[inputClassNum].resolution);
8000268e:	02 36       	mov %d6,%d3
80002690:	1b 23 00 40 	addi %d4,%d3,2
80002694:	06 34       	sh %d4,3
80002696:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
8000269a:	54 25       	ld.w %d5,[%a2]
    vadcG->ICLASS[inputClassNum].B.CMS = resolution;
8000269c:	8f 88 00 20 	sh %d2,%d8,8
800026a0:	42 32       	add %d2,%d3
800026a2:	1b 82 12 40 	addi %d4,%d2,296
800026a6:	06 24       	sh %d4,2
800026a8:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800026ac:	54 24       	ld.w %d4,[%a2]
800026ae:	37 54 03 44 	insert %d4,%d4,%d5,8,3
800026b2:	74 24       	st.w [%a2],%d4
        /* Calculate Sample time ticks */
        IfxVadc_setGroupSampleTime(vadcG, inputClassNum, analogFrequency, config->inputClass[inputClassNum].sampleTime);
800026b4:	8f 33 00 40 	sh %d4,%d3,3
800026b8:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
800026bc:	19 24 0c 00 	ld.w %d4,[%a2]12
    ticks = (uint32)(sampleTime * analogFrequency) - 2;
800026c0:	4b c4 41 40 	mul.f %d4,%d4,%d12
800026c4:	4b 04 71 41 	ftouz %d4,%d4
800026c8:	c2 e4       	add %d4,-2
    if (ticks > 31)
800026ca:	8b 04 62 52 	lt.u %d5,%d4,32
800026ce:	df 05 cb ff 	jne %d5,0,80002664 <IfxVadc_Adc_initGroup+0x400>
        ticks = (ticks / 16) + 15;
800026d2:	06 c4       	sh %d4,-4
800026d4:	1b f4 00 40 	addi %d4,%d4,15
800026d8:	1d ff c6 ff 	j 80002664 <IfxVadc_Adc_initGroup+0x400>
    }

    IfxVadc_disableAccess(vadc, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupIndex));
800026dc:	02 b4       	mov %d4,%d11
800026de:	40 d4       	mov.aa %a4,%a13
800026e0:	6d ff 08 fb 	call 80001cf0 <IfxVadc_disableAccess>

    return status;
}
800026e4:	82 02       	mov %d2,0
800026e6:	00 90       	ret 

800026e8 <IfxVadc_Adc_initGroupConfig>:


void IfxVadc_Adc_initGroupConfig(IfxVadc_Adc_GroupConfig *config, IfxVadc_Adc *vadc)
{
800026e8:	40 ae       	mov.aa %a14,%sp
800026ea:	40 4c       	mov.aa %a12,%a4
800026ec:	80 58       	mov.d %d8,%a5
        .inputClass[0].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
        .inputClass[1].resolution = IfxVadc_ChannelResolution_12bit,
        .inputClass[1].sampleTime = 1.0e-6,                           /* Set sample time to 1us */
    };

    *config                        = IfxVadc_Adc_defaultGroupConfig;
800026ee:	3b c0 07 50 	mov %d5,124
800026f2:	82 04       	mov %d4,0
800026f4:	6d 00 7a 23 	call 80006de8 <memset>
800026f8:	7b 60 58 23 	movh %d2,13702
800026fc:	1b d2 7b 23 	addi %d2,%d2,14269
80002700:	59 c2 0c 00 	st.w [%a12]12,%d2
80002704:	59 c2 14 00 	st.w [%a12]20,%d2
80002708:	82 12       	mov %d2,1
8000270a:	59 c2 30 00 	st.w [%a12]48,%d2
8000270e:	e9 c2 38 00 	st.b [%a12]56,%d2
80002712:	59 c2 0c 10 	st.w [%a12]76,%d2
80002716:	59 c2 28 10 	st.w [%a12]104,%d2
    config->groupId                = IfxVadc_GroupId_0;
    config->module                 = vadc;
8000271a:	74 c8       	st.w [%a12],%d8
    config->master                 = config->groupId;
    config->disablePostCalibration = FALSE;
}
8000271c:	00 90       	ret 

8000271e <IfxVadc_Adc_initModule>:


IfxVadc_Status IfxVadc_Adc_initModule(IfxVadc_Adc *vadc, const IfxVadc_Adc_Config *config)
{
8000271e:	40 ae       	mov.aa %a14,%sp
80002720:	40 5d       	mov.aa %a13,%a5
    IfxVadc_Status status  = IfxVadc_Status_noError;
    Ifx_VADC      *vadcSFR = config->vadc;
80002722:	d4 5c       	ld.a %a12,[%a5]
    vadc->vadc = vadcSFR;
80002724:	f4 4c       	st.a [%a4],%a12
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80002726:	6d 00 df 06 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
8000272a:	02 28       	mov %d8,%d2
    IfxScuWdt_clearCpuEndinit(passwd);
8000272c:	02 24       	mov %d4,%d2
8000272e:	6d 00 72 05 	call 80003212 <IfxScuWdt_clearCpuEndinit>
    vadc->CLC.U = 0x00000000;
80002732:	82 02       	mov %d2,0
80002734:	74 c2       	st.w [%a12],%d2
    IfxScuWdt_setCpuEndinit(passwd);
80002736:	02 84       	mov %d4,%d8
80002738:	6d 00 f3 06 	call 8000351e <IfxScuWdt_setCpuEndinit>
    float32        analogFrequency;
    uint8          inputClassNum, groupNum;

    /* Enable VADC kernel clock */
    IfxVadc_enableModule(vadcSFR);
    IfxVadc_selectPowerSupplyVoltage(vadcSFR, config->supplyVoltage);
8000273c:	19 d4 24 00 	ld.w %d4,[%a13]36
80002740:	40 c4       	mov.aa %a4,%a12
80002742:	6d ff f5 fb 	call 80001f2c <IfxVadc_selectPowerSupplyVoltage>

    /* Set Analog Frequency */
    if (IfxVadc_initializeFAdcI(vadcSFR, config->analogFrequency) == 0)
80002746:	19 d4 18 00 	ld.w %d4,[%a13]24
8000274a:	4b 04 71 41 	ftouz %d4,%d4
8000274e:	40 c4       	mov.aa %a4,%a12
80002750:	6d ff b4 fb 	call 80001eb8 <IfxVadc_initializeFAdcI>
80002754:	df 02 04 80 	jne %d2,0,8000275c <IfxVadc_Adc_initModule+0x3e>
    {
        return IfxVadc_Status_notInitialised;
80002758:	82 12       	mov %d2,1
        // execute calibration
        IfxVadc_startupCalibration(vadcSFR);
    }

    return status;
}
8000275a:	00 90       	ret 
    IfxVadc_initializeFAdcD(vadcSFR, config->digitalFrequency);
8000275c:	19 d4 14 00 	ld.w %d4,[%a13]20
80002760:	4b 04 71 41 	ftouz %d4,%d4
80002764:	40 c4       	mov.aa %a4,%a12
80002766:	6d ff 92 fb 	call 80001e8a <IfxVadc_initializeFAdcD>
    analogFrequency = IfxVadc_getAdcAnalogFrequency(vadcSFR);
8000276a:	40 c4       	mov.aa %a4,%a12
8000276c:	6d ff 31 fb 	call 80001dce <IfxVadc_getAdcAnalogFrequency>
    for (inputClassNum = 0; inputClassNum < IFXVADC_NUM_GLOBAL_INPUTCLASSES; inputClassNum++)
80002770:	82 03       	mov %d3,0
80002772:	1d 00 12 00 	j 80002796 <IfxVadc_Adc_initModule+0x78>
80002776:	3b f0 0f 50 	mov %d5,255
8000277a:	0b 54 90 51 	min.u %d5,%d4,%d5
    vadc->GLOBICLASS[inputClassNum].B.STCS = IfxVadc_calculateSampleTime(analogFrequency, sampleTime);
8000277e:	1b 86 02 40 	addi %d4,%d6,40
80002782:	06 24       	sh %d4,2
80002784:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80002788:	54 24       	ld.w %d4,[%a2]
8000278a:	37 54 05 40 	insert %d4,%d4,%d5,0,5
8000278e:	74 24       	st.w [%a2],%d4
80002790:	c2 13       	add %d3,1
80002792:	8f f3 0f 31 	and %d3,%d3,255
80002796:	ff 23 26 80 	jge.u %d3,2,800027e2 <IfxVadc_Adc_initModule+0xc4>
        IfxVadc_setGlobalResolution(vadcSFR, inputClassNum, config->globalInputClass[inputClassNum].resolution);
8000279a:	02 36       	mov %d6,%d3
8000279c:	1b 13 00 40 	addi %d4,%d3,1
800027a0:	06 34       	sh %d4,3
800027a2:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800027a6:	54 25       	ld.w %d5,[%a2]
    vadc->GLOBICLASS[inputClassNum].B.CMS = resolution;
800027a8:	1b 83 02 40 	addi %d4,%d3,40
800027ac:	06 24       	sh %d4,2
800027ae:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
800027b2:	54 24       	ld.w %d4,[%a2]
800027b4:	37 54 03 44 	insert %d4,%d4,%d5,8,3
800027b8:	74 24       	st.w [%a2],%d4
        IfxVadc_setGlobalSampleTime(vadcSFR, inputClassNum, analogFrequency, config->globalInputClass[inputClassNum].sampleTime);
800027ba:	8f 33 00 40 	sh %d4,%d3,3
800027be:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
800027c2:	19 24 04 00 	ld.w %d4,[%a2]4
    ticks = (uint32)(sampleTime * analogFrequency) - 2;
800027c6:	4b 24 41 40 	mul.f %d4,%d4,%d2
800027ca:	4b 04 71 41 	ftouz %d4,%d4
800027ce:	c2 e4       	add %d4,-2
    if (ticks > 31)
800027d0:	8b 04 62 52 	lt.u %d5,%d4,32
800027d4:	df 05 d1 ff 	jne %d5,0,80002776 <IfxVadc_Adc_initModule+0x58>
        ticks = (ticks / 16) + 15;
800027d8:	06 c4       	sh %d4,-4
800027da:	1b f4 00 40 	addi %d4,%d4,15
800027de:	1d ff cc ff 	j 80002776 <IfxVadc_Adc_initModule+0x58>
    if (config->startupCalibration == TRUE)
800027e2:	39 d2 20 00 	ld.bu %d2,[%a13]32
800027e6:	df 12 23 00 	jeq %d2,1,8000282c <IfxVadc_Adc_initModule+0x10e>
    return status;
800027ea:	82 02       	mov %d2,0
800027ec:	00 90       	ret 
            IfxVadc_enableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
800027ee:	1b 08 01 90 	addi %d9,%d8,16
800027f2:	02 94       	mov %d4,%d9
800027f4:	40 c4       	mov.aa %a4,%a12
800027f6:	6d ff a0 fa 	call 80001d36 <IfxVadc_enableAccess>
    vadcG->ARBCFG.B.ANONC = analogConverterMode;
800027fa:	8f a8 00 20 	sh %d2,%d8,10
800027fe:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80002802:	d9 23 40 20 	lea %a3,[%a2]1152
80002806:	19 22 40 20 	ld.w %d2,[%a2]1152
8000280a:	b7 32 02 20 	insert %d2,%d2,3,0,2
8000280e:	74 32       	st.w [%a3],%d2
            IfxVadc_disableAccess(vadcSFR, (IfxVadc_Protection)(IfxVadc_Protection_initGroup0 + groupNum));
80002810:	02 94       	mov %d4,%d9
80002812:	40 c4       	mov.aa %a4,%a12
80002814:	6d ff 6e fa 	call 80001cf0 <IfxVadc_disableAccess>
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
80002818:	c2 18       	add %d8,1
8000281a:	8f f8 0f 81 	and %d8,%d8,255
8000281e:	bf 88 e8 ff 	jlt.u %d8,8,800027ee <IfxVadc_Adc_initModule+0xd0>
        IfxVadc_startupCalibration(vadcSFR);
80002822:	40 c4       	mov.aa %a4,%a12
80002824:	6d ff da fb 	call 80001fd8 <IfxVadc_startupCalibration>
    return status;
80002828:	82 02       	mov %d2,0
8000282a:	00 90       	ret 
        for (groupNum = 0; groupNum < IFXVADC_NUM_ADC_GROUPS; groupNum++)
8000282c:	82 08       	mov %d8,0
8000282e:	1d ff f8 ff 	j 8000281e <IfxVadc_Adc_initModule+0x100>

80002832 <IfxVadc_Adc_initModuleConfig>:


void IfxVadc_Adc_initModuleConfig(IfxVadc_Adc_Config *config, Ifx_VADC *vadc)
{
80002832:	40 ae       	mov.aa %a14,%sp
80002834:	40 4c       	mov.aa %a12,%a4
80002836:	40 54       	mov.aa %a4,%a5
    config->vadc                           = vadc;
80002838:	f4 c5       	st.a [%a12],%a5
    config->analogFrequency                = IFXVADC_DEFAULT_ANALOG_FREQ;
8000283a:	7b 90 b9 24 	movh %d2,19353
8000283e:	1b 02 68 29 	addi %d2,%d2,-27008
80002842:	59 c2 18 00 	st.w [%a12]24,%d2

    config->digitalFrequency               = IfxVadc_getAdcDigitalFrequency(vadc);
80002846:	6d ff d2 fa 	call 80001dea <IfxVadc_getAdcDigitalFrequency>
8000284a:	59 c2 14 00 	st.w [%a12]20,%d2
    config->moduleFrequency                = IfxScuCcu_getSpbFrequency();
8000284e:	6d 00 f9 02 	call 80002e40 <IfxScuCcu_getSpbFrequency>
80002852:	59 c2 1c 00 	st.w [%a12]28,%d2
    config->globalInputClass[0].resolution = IfxVadc_ChannelResolution_12bit;
80002856:	82 02       	mov %d2,0
80002858:	59 c2 08 00 	st.w [%a12]8,%d2
    config->globalInputClass[0].sampleTime = 1.0e-6;
8000285c:	7b 60 58 33 	movh %d3,13702
80002860:	1b d3 7b 33 	addi %d3,%d3,14269
80002864:	59 c3 04 00 	st.w [%a12]4,%d3
    config->globalInputClass[1].resolution = IfxVadc_ChannelResolution_12bit;
80002868:	59 c2 10 00 	st.w [%a12]16,%d2
    config->globalInputClass[1].sampleTime = 1.0e-6;
8000286c:	59 c3 0c 00 	st.w [%a12]12,%d3
    config->startupCalibration             = FALSE;
80002870:	e9 c2 20 00 	st.b [%a12]32,%d2
    config->supplyVoltage                  = IfxVadc_LowSupplyVoltageSelect_5V;
80002874:	59 c2 24 00 	st.w [%a12]36,%d2
}
80002878:	00 90       	ret 

8000287a <IfxStm_clearCompareFlag>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxStm_clearCompareFlag(Ifx_STM *stm, IfxStm_Comparator comparator)
{
8000287a:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
8000287c:	df 04 0a 80 	jne %d4,0,80002890 <IfxStm_clearCompareFlag+0x16>
    {
        stm->ISCR.B.CMP0IRR = 1U;
80002880:	d9 42 00 10 	lea %a2,[%a4]64
80002884:	19 42 00 10 	ld.w %d2,[%a4]64
80002888:	b7 12 01 20 	insert %d2,%d2,1,0,1
8000288c:	74 22       	st.w [%a2],%d2
8000288e:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
80002890:	df 14 03 00 	jeq %d4,1,80002896 <IfxStm_clearCompareFlag+0x1c>
    {
        stm->ISCR.B.CMP1IRR = 1U;
    }
}
80002894:	00 90       	ret 
        stm->ISCR.B.CMP1IRR = 1U;
80002896:	d9 42 00 10 	lea %a2,[%a4]64
8000289a:	19 42 00 10 	ld.w %d2,[%a4]64
8000289e:	b7 12 01 21 	insert %d2,%d2,1,2,1
800028a2:	74 22       	st.w [%a2],%d2
}
800028a4:	1d ff f8 ff 	j 80002894 <IfxStm_clearCompareFlag+0x1a>

800028a8 <IfxStm_enableComparatorInterrupt>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxStm_enableComparatorInterrupt(Ifx_STM *stm, IfxStm_Comparator comparator)
{
800028a8:	40 ae       	mov.aa %a14,%sp
    if (comparator == IfxStm_Comparator_0)
800028aa:	df 04 0a 80 	jne %d4,0,800028be <IfxStm_enableComparatorInterrupt+0x16>
    {
        stm->ICR.B.CMP0EN = 1U;
800028ae:	d9 42 3c 00 	lea %a2,[%a4]60
800028b2:	19 42 3c 00 	ld.w %d2,[%a4]60
800028b6:	b7 12 01 20 	insert %d2,%d2,1,0,1
800028ba:	74 22       	st.w [%a2],%d2
800028bc:	00 90       	ret 
    }
    else if (comparator == IfxStm_Comparator_1)
800028be:	df 14 03 00 	jeq %d4,1,800028c4 <IfxStm_enableComparatorInterrupt+0x1c>
    {
        stm->ICR.B.CMP1EN = 1U;
    }
}
800028c2:	00 90       	ret 
        stm->ICR.B.CMP1EN = 1U;
800028c4:	d9 42 3c 00 	lea %a2,[%a4]60
800028c8:	19 42 3c 00 	ld.w %d2,[%a4]60
800028cc:	b7 12 01 22 	insert %d2,%d2,1,4,1
800028d0:	74 22       	st.w [%a2],%d2
}
800028d2:	1d ff f8 ff 	j 800028c2 <IfxStm_enableComparatorInterrupt+0x1a>

800028d6 <IfxStm_enableOcdsSuspend>:


void IfxStm_enableOcdsSuspend(Ifx_STM *stm)
{
800028d6:	40 ae       	mov.aa %a14,%sp
    Ifx_STM_OCS ocs = stm->OCS;
800028d8:	d9 42 28 30 	lea %a2,[%a4]232
800028dc:	19 42 28 30 	ld.w %d2,[%a4]232

    /* Only if OCDS is enabled write into the OCS register */
    if (MODULE_CBS.OSTATE.B.OEN == 1U)
800028e0:	85 f3 40 20 	ld.w %d3,f0000480 <_SMALL_DATA4_+0x5fff8480>
800028e4:	6f 03 03 80 	jnz.t %d3,0,800028ea <IfxStm_enableOcdsSuspend+0x14>
        ocs.B.SUS_P      = 1;
        ocs.B.SUS        = 2;
        stm->OCS         = ocs;
        stm->OCS.B.SUS_P = 0;
    }
}
800028e8:	00 90       	ret 
        ocs.B.SUS_P      = 1;
800028ea:	b7 12 01 2e 	insert %d2,%d2,1,28,1
        ocs.B.SUS        = 2;
800028ee:	b7 22 04 2c 	insert %d2,%d2,2,24,4
        stm->OCS         = ocs;
800028f2:	74 22       	st.w [%a2],%d2
        stm->OCS.B.SUS_P = 0;
800028f4:	54 22       	ld.w %d2,[%a2]
800028f6:	b7 02 01 2e 	insert %d2,%d2,0,28,1
800028fa:	74 22       	st.w [%a2],%d2
}
800028fc:	1d ff f6 ff 	j 800028e8 <IfxStm_enableOcdsSuspend+0x12>

80002900 <IfxStm_getIndex>:
    return module;
}


IfxStm_Index IfxStm_getIndex(Ifx_STM *stm)
{
80002900:	40 ae       	mov.aa %a14,%sp
    uint32       index;
    IfxStm_Index result;

    result = IfxStm_Index_none;

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
80002902:	82 02       	mov %d2,0
80002904:	1d 00 03 00 	j 8000290a <IfxStm_getIndex+0xa>
80002908:	c2 12       	add %d2,1
8000290a:	ff 32 18 80 	jge.u %d2,3,8000293a <IfxStm_getIndex+0x3a>
    {
        if (IfxStm_cfg_indexMap[index].module == stm)
8000290e:	8f 32 00 30 	sh %d3,%d2,3
80002912:	91 00 00 28 	movh.a %a2,32768
80002916:	d9 22 18 c0 	lea %a2,[%a2]792 <80000318 <IfxStm_cfg_indexMap>>
8000291a:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
8000291e:	54 23       	ld.w %d3,[%a2]
80002920:	80 44       	mov.d %d4,%a4
80002922:	5f 43 f3 ff 	jne %d3,%d4,80002908 <IfxStm_getIndex+0x8>
        {
            result = (IfxStm_Index)IfxStm_cfg_indexMap[index].index;
80002926:	06 32       	sh %d2,3
80002928:	91 00 00 28 	movh.a %a2,32768
8000292c:	d9 22 18 c0 	lea %a2,[%a2]792 <80000318 <IfxStm_cfg_indexMap>>
80002930:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80002934:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80002938:	00 90       	ret 
    result = IfxStm_Index_none;
8000293a:	82 f2       	mov %d2,-1
        }
    }

    return result;
}
8000293c:	00 90       	ret 

8000293e <IfxStm_initCompare>:
    return comparator == IfxStm_Comparator_0 ? &MODULE_SRC.STM.STM[index].SR0 : &MODULE_SRC.STM.STM[index].SR1;
}


boolean IfxStm_initCompare(Ifx_STM *stm, const IfxStm_CompareConfig *config)
{
8000293e:	40 ae       	mov.aa %a14,%sp
80002940:	40 4d       	mov.aa %a13,%a4
80002942:	40 5c       	mov.aa %a12,%a5
    sint32        index;
    boolean       result;
    Ifx_STM_CMCON comcon = stm->CMCON;
80002944:	19 42 38 00 	ld.w %d2,[%a4]56
    Ifx_STM_ICR   icr    = stm->ICR;
80002948:	19 43 3c 00 	ld.w %d3,[%a4]60

    if (config->comparator == 0)
8000294c:	54 54       	ld.w %d4,[%a5]
8000294e:	df 04 82 80 	jne %d4,0,80002a52 <IfxStm_initCompare+0x114>
    {
        comcon.B.MSIZE0  = config->compareSize;
80002952:	19 54 0c 00 	ld.w %d4,[%a5]12
80002956:	37 42 05 20 	insert %d2,%d2,%d4,0,5
        comcon.B.MSTART0 = config->compareOffset;
8000295a:	19 54 08 00 	ld.w %d4,[%a5]8
8000295e:	37 42 05 24 	insert %d2,%d2,%d4,8,5
        icr.B.CMP0OS     = config->comparatorInterrupt;
80002962:	19 54 04 00 	ld.w %d4,[%a5]4
80002966:	67 43 02 30 	ins.t %d3,%d3,2,%d4,0
        result           = TRUE;
8000296a:	82 18       	mov %d8,1
    {
        /*Invalid value */
        result = FALSE;
    }

    stm->ICR.U   = icr.U;
8000296c:	59 d3 3c 00 	st.w [%a13]60,%d3
    stm->CMCON.U = comcon.U;
80002970:	59 d2 38 00 	st.w [%a13]56,%d2

    /* configure interrupt */
    index = IfxStm_getIndex(stm);
80002974:	40 d4       	mov.aa %a4,%a13
80002976:	6d ff c5 ff 	call 80002900 <IfxStm_getIndex>

    if (config->triggerPriority > 0)
8000297a:	b9 c3 14 00 	ld.hu %d3,[%a12]20
8000297e:	df 03 20 00 	jeq %d3,0,800029be <IfxStm_initCompare+0x80>
    {
        volatile Ifx_SRC_SRCR *srcr;

        if (config->comparatorInterrupt == IfxStm_ComparatorInterrupt_ir0)
80002982:	19 c4 04 00 	ld.w %d4,[%a12]4
80002986:	df 04 7a 80 	jne %d4,0,80002a7a <IfxStm_initCompare+0x13c>
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR0);
8000298a:	06 32       	sh %d2,3
8000298c:	7b 40 00 4f 	movh %d4,61444
80002990:	1b 04 49 48 	addi %d4,%d4,-31600
80002994:	60 42       	mov.a %a2,%d4
80002996:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
        else
        {
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
        }

        IfxSrc_init(srcr, config->typeOfService, config->triggerPriority);
8000299a:	19 c4 18 00 	ld.w %d4,[%a12]24
    src->B.SRPN = priority;
8000299e:	54 22       	ld.w %d2,[%a2]
800029a0:	37 32 08 20 	insert %d2,%d2,%d3,0,8
800029a4:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
800029a6:	54 22       	ld.w %d2,[%a2]
800029a8:	37 42 82 25 	insert %d2,%d2,%d4,11,2
800029ac:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
800029ae:	54 22       	ld.w %d2,[%a2]
800029b0:	b7 12 81 2c 	insert %d2,%d2,1,25,1
800029b4:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
800029b6:	54 22       	ld.w %d2,[%a2]
800029b8:	b7 12 01 25 	insert %d2,%d2,1,10,1
800029bc:	74 22       	st.w [%a2],%d2
        IfxSrc_enable(srcr);
    }

    /*Configure the comparator ticks to current value to avoid any wrong triggering*/
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset);
800029be:	39 c5 08 00 	ld.bu %d5,[%a12]8

IFX_INLINE uint64 IfxStm_get(Ifx_STM *stm)
{
    uint64 result;

    result  = stm->TIM0.U;
800029c2:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
800029c6:	19 d2 2c 00 	ld.w %d2,[%a13]44
800029ca:	8f 06 40 41 	or %d4,%d6,0
800029ce:	02 23       	mov %d3,%d2
{
    uint64 now;

    now = IfxStm_get(stm);

    return (uint32)(now >> offset);
800029d0:	8b 05 82 22 	ge %d2,%d5,32
800029d4:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
800029d8:	ab 03 a0 32 	seln %d3,%d2,%d3,0
800029dc:	8f f5 01 21 	and %d2,%d5,31
800029e0:	8b 02 02 51 	rsub %d5,%d2,32
800029e4:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
800029e8:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
800029ec:	54 c2       	ld.w %d2,[%a12]
800029ee:	1b c2 00 20 	addi %d2,%d2,12
800029f2:	06 22       	sh %d2,2
800029f4:	01 d2 00 26 	addsc.a %a2,%a13,%d2,0
800029f8:	74 23       	st.w [%a2],%d3

    /* clear the interrupt flag of the selected comparator before enabling the interrupt */
    /* this is to avaoid the unneccesary interrupt for the compare match of reset values of the registers */
    IfxStm_clearCompareFlag(stm, config->comparator);
800029fa:	54 c4       	ld.w %d4,[%a12]
800029fc:	40 d4       	mov.aa %a4,%a13
800029fe:	6d ff 3e ff 	call 8000287a <IfxStm_clearCompareFlag>
    /* enable the interrupt for the selected comparator */
    IfxStm_enableComparatorInterrupt(stm, config->comparator);
80002a02:	54 c4       	ld.w %d4,[%a12]
80002a04:	40 d4       	mov.aa %a4,%a13
80002a06:	6d ff 51 ff 	call 800028a8 <IfxStm_enableComparatorInterrupt>

    /*Configure the comparator ticks */
    stm->CMP[config->comparator].U = IfxStm_getOffsetTimer(stm, (uint8)config->compareOffset) + config->ticks;
80002a0a:	39 c5 08 00 	ld.bu %d5,[%a12]8
    result  = stm->TIM0.U;
80002a0e:	19 d6 10 00 	ld.w %d6,[%a13]16
    result |= ((uint64)stm->CAP.U) << 32;
80002a12:	19 d2 2c 00 	ld.w %d2,[%a13]44
80002a16:	8f 06 40 41 	or %d4,%d6,0
80002a1a:	02 23       	mov %d3,%d2
    return (uint32)(now >> offset);
80002a1c:	8b 05 82 22 	ge %d2,%d5,32
80002a20:	2b 34 50 42 	seln %d4,%d2,%d4,%d3
80002a24:	ab 03 a0 32 	seln %d3,%d2,%d3,0
80002a28:	8f f5 01 21 	and %d2,%d5,31
80002a2c:	8b 02 02 51 	rsub %d5,%d2,32
80002a30:	17 43 80 35 	dextr %d3,%d3,%d4,%d5
80002a34:	2b 43 40 32 	sel %d3,%d2,%d3,%d4
80002a38:	02 34       	mov %d4,%d3
80002a3a:	19 c3 10 00 	ld.w %d3,[%a12]16
80002a3e:	54 c2       	ld.w %d2,[%a12]
80002a40:	42 43       	add %d3,%d4
80002a42:	1b c2 00 20 	addi %d2,%d2,12
80002a46:	06 22       	sh %d2,2
80002a48:	01 d2 00 d6 	addsc.a %a13,%a13,%d2,0
80002a4c:	74 d3       	st.w [%a13],%d3

    return result;
}
80002a4e:	02 82       	mov %d2,%d8
80002a50:	00 90       	ret 
    else if (config->comparator == 1)
80002a52:	df 14 05 00 	jeq %d4,1,80002a5c <IfxStm_initCompare+0x11e>
        result = FALSE;
80002a56:	82 08       	mov %d8,0
80002a58:	1d ff 8a ff 	j 8000296c <IfxStm_initCompare+0x2e>
        comcon.B.MSIZE1  = config->compareSize;
80002a5c:	19 54 0c 00 	ld.w %d4,[%a5]12
80002a60:	37 42 05 28 	insert %d2,%d2,%d4,16,5
        comcon.B.MSTART1 = config->compareOffset;
80002a64:	19 54 08 00 	ld.w %d4,[%a5]8
80002a68:	37 42 05 2c 	insert %d2,%d2,%d4,24,5
        icr.B.CMP1OS     = config->comparatorInterrupt;
80002a6c:	19 54 04 00 	ld.w %d4,[%a5]4
80002a70:	67 43 06 30 	ins.t %d3,%d3,6,%d4,0
        result           = TRUE;
80002a74:	82 18       	mov %d8,1
80002a76:	1d ff 7b ff 	j 8000296c <IfxStm_initCompare+0x2e>
            srcr = &(MODULE_SRC.STM.STM[index].SR1);
80002a7a:	06 32       	sh %d2,3
80002a7c:	c2 42       	add %d2,4
80002a7e:	7b 40 00 4f 	movh %d4,61444
80002a82:	1b 04 49 48 	addi %d4,%d4,-31600
80002a86:	60 42       	mov.a %a2,%d4
80002a88:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80002a8c:	1d ff 87 ff 	j 8000299a <IfxStm_initCompare+0x5c>

80002a90 <IfxStm_initCompareConfig>:


void IfxStm_initCompareConfig(IfxStm_CompareConfig *config)
{
80002a90:	40 ae       	mov.aa %a14,%sp
    config->comparator          = IfxStm_Comparator_0;
80002a92:	82 02       	mov %d2,0
80002a94:	74 42       	st.w [%a4],%d2
    config->compareOffset       = IfxStm_ComparatorOffset_0;
80002a96:	59 42 08 00 	st.w [%a4]8,%d2
    config->compareSize         = IfxStm_ComparatorSize_32Bits;
80002a9a:	3b f0 01 30 	mov %d3,31
80002a9e:	59 43 0c 00 	st.w [%a4]12,%d3
    config->comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;     /*User must select the interrupt output */
80002aa2:	59 42 04 00 	st.w [%a4]4,%d2
    config->ticks               = 0xFFFFFFFF;
80002aa6:	82 f3       	mov %d3,-1
80002aa8:	59 43 10 00 	st.w [%a4]16,%d3
    config->triggerPriority     = 0;
80002aac:	f9 42 14 00 	st.h [%a4]20,%d2
    config->typeOfService       = IfxSrc_Tos_cpu0;
80002ab0:	59 42 18 00 	st.w [%a4]24,%d2
}
80002ab4:	00 90       	ret 

80002ab6 <IfxScuCcu_isOscillatorStable>:
    *cfg = IfxScuCcu_defaultErayPllConfig;
}


IFX_STATIC boolean IfxScuCcu_isOscillatorStable(void)
{
80002ab6:	40 ae       	mov.aa %a14,%sp
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
    boolean status     = 0;

    uint16  endinitPw  = IfxScuWdt_getCpuWatchdogPassword();
80002ab8:	6d 00 16 05 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80002abc:	02 28       	mov %d8,%d2

    /* Mode External Crystal / Ceramic Resonator Mode and External Input Clock.
     * The oscillator Power-Saving Mode is not entered
     */
    SCU_OSCCON.B.MODE = 0U;
80002abe:	91 30 00 2f 	movh.a %a2,61443
80002ac2:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
80002ac6:	54 23       	ld.w %d3,[%a2]
80002ac8:	8f 03 c6 31 	andn %d3,%d3,96
80002acc:	74 23       	st.w [%a2],%d3

    /* OSCVAL  defines the divider value that generates  the reference clock
     *  that is supervised by the oscillator watchdog.
     *  fOSC / (OSCVAL + 1) ~ 2.5Mhz  => OSCVAL = (fOSC / 2.5Mhz) - 1 */

    SCU_OSCCON.B.OSCVAL = ((uint32)IfxScuCcu_xtalFrequency / 2500000) - 1;
80002ace:	91 00 00 36 	movh.a %a3,24576
80002ad2:	19 33 60 60 	ld.w %d3,[%a3]1440 <600005a0 <IfxScuCcu_xtalFrequency>>
80002ad6:	7b 00 b6 26 	movh %d2,27488
80002ada:	1b b2 a6 2c 	addi %d2,%d2,-13717
80002ade:	73 23 68 20 	mul.u %e2,%d3,%d2
80002ae2:	8f c3 1e 20 	sh %d2,%d3,-20
80002ae6:	c2 f2       	add %d2,-1
80002ae8:	54 23       	ld.w %d3,[%a2]
80002aea:	37 23 05 38 	insert %d3,%d3,%d2,16,5
80002aee:	74 23       	st.w [%a2],%d3

    /* The Oscillator Watchdog of the PLL is cleared and restarted */
    SCU_OSCCON.B.OSCRES = 1U;
80002af0:	54 23       	ld.w %d3,[%a2]
80002af2:	b7 13 01 31 	insert %d3,%d3,1,2,1
80002af6:	74 23       	st.w [%a2],%d3
    sint32  TimeoutCtr = IFXSCUCCU_OSC_STABLECHK_TIME;
80002af8:	3b 00 28 30 	mov %d3,640

    /* wait until PLLLV and PLLHV flags are set */
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80002afc:	1d 00 05 00 	j 80002b06 <IfxScuCcu_isOscillatorStable+0x50>
    {
        TimeoutCtr--;
80002b00:	c2 f3       	add %d3,-1

        if (TimeoutCtr == 0)
80002b02:	df 03 25 00 	jeq %d3,0,80002b4c <IfxScuCcu_isOscillatorStable+0x96>
    while ((SCU_OSCCON.B.PLLLV == 0) || (SCU_OSCCON.B.PLLHV == 0))
80002b06:	91 30 00 2f 	movh.a %a2,61443
80002b0a:	d9 22 10 06 	lea %a2,[%a2]24592 <f0036010 <_SMALL_DATA4_+0x6002e010>>
80002b0e:	54 25       	ld.w %d5,[%a2]
80002b10:	6f 15 f8 7f 	jz.t %d5,1,80002b00 <IfxScuCcu_isOscillatorStable+0x4a>
80002b14:	54 25       	ld.w %d5,[%a2]
80002b16:	6f 85 f5 7f 	jz.t %d5,8,80002b00 <IfxScuCcu_isOscillatorStable+0x4a>
    boolean status     = 0;
80002b1a:	82 09       	mov %d9,0
        }
    }

    {
        /* clear and then set SMU trap (oscillator watchdog and unlock detection) */
        IfxScuWdt_clearCpuEndinit(endinitPw);
80002b1c:	02 84       	mov %d4,%d8
80002b1e:	6d 00 7a 03 	call 80003212 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;    /* TODO Can this be removed? */
80002b22:	91 30 00 2f 	movh.a %a2,61443
80002b26:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
80002b2a:	54 23       	ld.w %d3,[%a2]
80002b2c:	b7 13 81 31 	insert %d3,%d3,1,3,1
80002b30:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = 1U;    /* TODO Can this be removed? */
80002b32:	91 30 00 2f 	movh.a %a2,61443
80002b36:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
80002b3a:	54 23       	ld.w %d3,[%a2]
80002b3c:	b7 13 81 31 	insert %d3,%d3,1,3,1
80002b40:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinitPw);
80002b42:	02 84       	mov %d4,%d8
80002b44:	6d 00 ed 04 	call 8000351e <IfxScuWdt_setCpuEndinit>
    }

    return status;
}
80002b48:	02 92       	mov %d2,%d9
80002b4a:	00 90       	ret 
            status = 1;
80002b4c:	82 19       	mov %d9,1
80002b4e:	1d ff e7 ff 	j 80002b1c <IfxScuCcu_isOscillatorStable+0x66>

80002b52 <IfxScuCcu_getOsc0Frequency>:
{
80002b52:	40 ae       	mov.aa %a14,%sp
    return (float32)IfxScuCcu_xtalFrequency;
80002b54:	91 00 00 26 	movh.a %a2,24576
80002b58:	19 22 60 60 	ld.w %d2,[%a2]1440 <600005a0 <IfxScuCcu_xtalFrequency>>
}
80002b5c:	4b 02 61 21 	utof %d2,%d2
80002b60:	00 90       	ret 

80002b62 <IfxScuCcu_getOscFrequency>:
{
80002b62:	40 ae       	mov.aa %a14,%sp
    if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc1)
80002b64:	91 30 00 2f 	movh.a %a2,61443
80002b68:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80002b6c:	54 22       	ld.w %d2,[%a2]
80002b6e:	37 02 62 2e 	extr.u %d2,%d2,28,2
80002b72:	df 02 10 00 	jeq %d2,0,80002b92 <IfxScuCcu_getOscFrequency+0x30>
    else if (SCU_CCUCON1.B.INSEL == IfxScu_CCUCON1_INSEL_fOsc0)
80002b76:	54 22       	ld.w %d2,[%a2]
80002b78:	37 02 62 2e 	extr.u %d2,%d2,28,2
80002b7c:	df 12 04 00 	jeq %d2,1,80002b84 <IfxScuCcu_getOscFrequency+0x22>
        freq = 0.0f;
80002b80:	82 02       	mov %d2,0
}
80002b82:	00 90       	ret 
        freq = (float32)IfxScuCcu_xtalFrequency;
80002b84:	91 00 00 26 	movh.a %a2,24576
80002b88:	19 22 60 60 	ld.w %d2,[%a2]1440 <600005a0 <IfxScuCcu_xtalFrequency>>
80002b8c:	4b 02 61 21 	utof %d2,%d2
80002b90:	00 90       	ret 
        freq = IFXSCU_EVR_OSC_FREQUENCY;
80002b92:	7b f0 cb 24 	movh %d2,19647
80002b96:	1b 02 c2 2b 	addi %d2,%d2,-17376
80002b9a:	00 90       	ret 

80002b9c <IfxScuCcu_getPllErayFrequency>:
{
80002b9c:	40 ae       	mov.aa %a14,%sp
    oscFreq = IfxScuCcu_getOscFrequency();
80002b9e:	6d ff e2 ff 	call 80002b62 <IfxScuCcu_getOscFrequency>
80002ba2:	02 24       	mov %d4,%d2
    if (scu->PLLERAYSTAT.B.VCOBYST == 1)
80002ba4:	91 30 00 2f 	movh.a %a2,61443
80002ba8:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002bac:	19 23 24 00 	ld.w %d3,[%a2]36 <f0030024 <_SMALL_DATA4_+0x60028024>>
80002bb0:	6f 03 21 80 	jnz.t %d3,0,80002bf2 <IfxScuCcu_getPllErayFrequency+0x56>
    else if (scu->PLLERAYSTAT.B.FINDIS == 1)
80002bb4:	91 30 00 2f 	movh.a %a2,61443
80002bb8:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002bbc:	19 22 24 00 	ld.w %d2,[%a2]36 <f0030024 <_SMALL_DATA4_+0x60028024>>
80002bc0:	6f 32 27 80 	jnz.t %d2,3,80002c0e <IfxScuCcu_getPllErayFrequency+0x72>
        freq = (oscFreq * (scu->PLLERAYCON0.B.NDIV + 1)) / (scu->PLLERAYCON1.B.K2DIV + 1);
80002bc4:	91 30 00 2f 	movh.a %a2,61443
80002bc8:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002bcc:	19 22 28 00 	ld.w %d2,[%a2]40 <f0030028 <_SMALL_DATA4_+0x60028028>>
80002bd0:	37 02 e5 24 	extr.u %d2,%d2,9,5
80002bd4:	c2 12       	add %d2,1
80002bd6:	4b 02 41 21 	itof %d2,%d2
80002bda:	4b 42 41 40 	mul.f %d4,%d2,%d4
80002bde:	19 22 2c 00 	ld.w %d2,[%a2]44 <f003002c <_SMALL_DATA4_+0x6002802c>>
80002be2:	8f f2 07 21 	and %d2,%d2,127
80002be6:	c2 12       	add %d2,1
80002be8:	4b 02 41 21 	itof %d2,%d2
80002bec:	4b 24 51 20 	div.f %d2,%d4,%d2
}
80002bf0:	00 90       	ret 
        freq = oscFreq / (scu->PLLERAYCON1.B.K1DIV + 1);
80002bf2:	91 30 00 2f 	movh.a %a2,61443
80002bf6:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002bfa:	19 22 2c 00 	ld.w %d2,[%a2]44 <f003002c <_SMALL_DATA4_+0x6002802c>>
80002bfe:	37 02 67 28 	extr.u %d2,%d2,16,7
80002c02:	c2 12       	add %d2,1
80002c04:	4b 02 41 21 	itof %d2,%d2
80002c08:	4b 24 51 20 	div.f %d2,%d4,%d2
80002c0c:	00 90       	ret 
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLERAYCON1.B.K2DIV + 1);
80002c0e:	91 30 00 2f 	movh.a %a2,61443
80002c12:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002c16:	19 24 2c 00 	ld.w %d4,[%a2]44 <f003002c <_SMALL_DATA4_+0x6002802c>>
80002c1a:	8f f4 07 41 	and %d4,%d4,127
80002c1e:	c2 14       	add %d4,1
80002c20:	6d 00 5a 23 	call 800072d4 <__floatsidf>
80002c24:	0b 23 10 68 	mov %e6,%d3,%d2
80002c28:	82 04       	mov %d4,0
80002c2a:	7b 80 19 54 	movh %d5,16792
80002c2e:	1b 45 78 5d 	addi %d5,%d5,-10364
80002c32:	6d 00 69 22 	call 80007104 <__divdf3>
80002c36:	0b 23 10 48 	mov %e4,%d3,%d2
80002c3a:	6d 00 98 23 	call 8000736a <__truncdfsf2>
80002c3e:	00 90       	ret 

80002c40 <IfxScuCcu_getPllFrequency>:
{
80002c40:	40 ae       	mov.aa %a14,%sp
    oscFreq = IfxScuCcu_getOscFrequency();
80002c42:	6d ff 90 ff 	call 80002b62 <IfxScuCcu_getOscFrequency>
80002c46:	02 24       	mov %d4,%d2
    if (scu->PLLSTAT.B.VCOBYST == 1)
80002c48:	91 30 00 2f 	movh.a %a2,61443
80002c4c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002c50:	19 23 14 00 	ld.w %d3,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
80002c54:	6f 03 27 80 	jnz.t %d3,0,80002ca2 <IfxScuCcu_getPllFrequency+0x62>
    else if (scu->PLLSTAT.B.FINDIS == 1)
80002c58:	91 30 00 2f 	movh.a %a2,61443
80002c5c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002c60:	19 22 14 00 	ld.w %d2,[%a2]20 <f0030014 <_SMALL_DATA4_+0x60028014>>
80002c64:	6f 32 2d 80 	jnz.t %d2,3,80002cbe <IfxScuCcu_getPllFrequency+0x7e>
        freq = (oscFreq * (scu->PLLCON0.B.NDIV + 1)) / ((scu->PLLCON1.B.K2DIV + 1) * (scu->PLLCON0.B.PDIV + 1));
80002c68:	91 30 00 2f 	movh.a %a2,61443
80002c6c:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002c70:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
80002c74:	37 02 e7 24 	extr.u %d2,%d2,9,7
80002c78:	c2 12       	add %d2,1
80002c7a:	4b 02 41 21 	itof %d2,%d2
80002c7e:	4b 42 41 30 	mul.f %d3,%d2,%d4
80002c82:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80002c86:	8f f4 07 41 	and %d4,%d4,127
80002c8a:	19 22 18 00 	ld.w %d2,[%a2]24 <f0030018 <_SMALL_DATA4_+0x60028018>>
80002c8e:	37 02 64 2c 	extr.u %d2,%d2,24,4
80002c92:	c2 12       	add %d2,1
80002c94:	03 24 0a 22 	madd %d2,%d2,%d4,%d2
80002c98:	4b 02 41 21 	itof %d2,%d2
80002c9c:	4b 23 51 20 	div.f %d2,%d3,%d2
}
80002ca0:	00 90       	ret 
        freq = oscFreq / (scu->PLLCON1.B.K1DIV + 1);
80002ca2:	91 30 00 2f 	movh.a %a2,61443
80002ca6:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002caa:	19 22 1c 00 	ld.w %d2,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80002cae:	37 02 67 28 	extr.u %d2,%d2,16,7
80002cb2:	c2 12       	add %d2,1
80002cb4:	4b 02 41 21 	itof %d2,%d2
80002cb8:	4b 24 51 20 	div.f %d2,%d4,%d2
80002cbc:	00 90       	ret 
        freq = IFXSCU_VCO_BASE_FREQUENCY / (scu->PLLCON1.B.K2DIV + 1);
80002cbe:	91 30 00 2f 	movh.a %a2,61443
80002cc2:	d9 22 00 06 	lea %a2,[%a2]24576 <f0036000 <_SMALL_DATA4_+0x6002e000>>
80002cc6:	19 24 1c 00 	ld.w %d4,[%a2]28 <f003001c <_SMALL_DATA4_+0x6002801c>>
80002cca:	8f f4 07 41 	and %d4,%d4,127
80002cce:	c2 14       	add %d4,1
80002cd0:	6d 00 02 23 	call 800072d4 <__floatsidf>
80002cd4:	0b 23 10 68 	mov %e6,%d3,%d2
80002cd8:	82 04       	mov %d4,0
80002cda:	7b 80 19 54 	movh %d5,16792
80002cde:	1b 45 78 5d 	addi %d5,%d5,-10364
80002ce2:	6d 00 11 22 	call 80007104 <__divdf3>
80002ce6:	0b 23 10 48 	mov %e4,%d3,%d2
80002cea:	6d 00 40 23 	call 8000736a <__truncdfsf2>
80002cee:	00 90       	ret 

80002cf0 <IfxScuCcu_getSourceFrequency>:
{
80002cf0:	40 ae       	mov.aa %a14,%sp
    switch (SCU_CCUCON0.B.CLKSEL)
80002cf2:	91 30 00 2f 	movh.a %a2,61443
80002cf6:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80002cfa:	54 22       	ld.w %d2,[%a2]
80002cfc:	37 02 62 2e 	extr.u %d2,%d2,28,2
80002d00:	df 02 07 00 	jeq %d2,0,80002d0e <IfxScuCcu_getSourceFrequency+0x1e>
80002d04:	df 12 0a 80 	jne %d2,1,80002d18 <IfxScuCcu_getSourceFrequency+0x28>
        sourcefreq = IfxScuCcu_getPllFrequency();
80002d08:	6d ff 9c ff 	call 80002c40 <IfxScuCcu_getPllFrequency>
        break;
80002d0c:	00 90       	ret 
    switch (SCU_CCUCON0.B.CLKSEL)
80002d0e:	7b f0 cb 24 	movh %d2,19647
80002d12:	1b 02 c2 2b 	addi %d2,%d2,-17376
80002d16:	00 90       	ret 
        sourcefreq = 0;
80002d18:	82 02       	mov %d2,0
}
80002d1a:	00 90       	ret 

80002d1c <IfxScuCcu_wait>:
    }
}


IFX_STATIC void IfxScuCcu_wait(float32 timeSec)
{
80002d1c:	40 ae       	mov.aa %a14,%sp
80002d1e:	02 48       	mov %d8,%d4
}


IFX_INLINE float32 IfxScuCcu_getStmFrequency(void)
{
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80002d20:	6d ff e8 ff 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
80002d24:	91 30 00 2f 	movh.a %a2,61443
80002d28:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80002d2c:	54 23       	ld.w %d3,[%a2]
80002d2e:	37 03 64 34 	extr.u %d3,%d3,8,4
80002d32:	4b 03 41 31 	itof %d3,%d3
80002d36:	4b 32 51 20 	div.f %d2,%d2,%d3
    uint32 stmCount      = (uint32)(IfxScuCcu_getStmFrequency() * timeSec);
80002d3a:	4b 28 41 40 	mul.f %d4,%d8,%d2
80002d3e:	4b 04 71 41 	ftouz %d4,%d4
    uint32 stmCountBegin = STM0_TIM0.U;
80002d42:	85 f3 10 00 	ld.w %d3,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((uint32)(STM0_TIM0.U - stmCountBegin) < stmCount)
80002d46:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
80002d4a:	a2 32       	sub %d2,%d3
80002d4c:	3f 42 fd ff 	jlt.u %d2,%d4,80002d46 <IfxScuCcu_wait+0x2a>
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}
80002d50:	00 90       	ret 
	...

80002d54 <IfxScuCcu_getMaxFrequency>:
{
80002d54:	40 ae       	mov.aa %a14,%sp
    sourceFrequency = IfxScuCcu_getSourceFrequency();
80002d56:	6d ff cd ff 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
    switch (SCU_CCUCON0.B.LPDIV)
80002d5a:	91 30 00 2f 	movh.a %a2,61443
80002d5e:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80002d62:	54 23       	ld.w %d3,[%a2]
80002d64:	37 03 64 36 	extr.u %d3,%d3,12,4
80002d68:	ff 53 39 80 	jge.u %d3,5,80002dda <IfxScuCcu_getMaxFrequency+0x86>
80002d6c:	91 00 00 28 	movh.a %a2,32768
80002d70:	d9 22 fc 52 	lea %a2,[%a2]11644 <80002d7c <IfxScuCcu_getMaxFrequency+0x28>>
80002d74:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
80002d78:	dc 02       	ji %a2
80002d7a:	00 00       	nop 
80002d7c:	1d 00 0a 00 	j 80002d90 <IfxScuCcu_getMaxFrequency+0x3c>
80002d80:	1d 00 19 00 	j 80002db2 <IfxScuCcu_getMaxFrequency+0x5e>
80002d84:	1d 00 1c 00 	j 80002dbc <IfxScuCcu_getMaxFrequency+0x68>
80002d88:	1d 00 1f 00 	j 80002dc6 <IfxScuCcu_getMaxFrequency+0x72>
80002d8c:	1d 00 22 00 	j 80002dd0 <IfxScuCcu_getMaxFrequency+0x7c>
        if (SCU_CCUCON5.B.MAXDIV == 0)
80002d90:	91 30 00 2f 	movh.a %a2,61443
80002d94:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x6002e04c>>
80002d98:	54 23       	ld.w %d3,[%a2]
80002d9a:	8f f3 00 31 	and %d3,%d3,15
80002d9e:	df 03 1f 00 	jeq %d3,0,80002ddc <IfxScuCcu_getMaxFrequency+0x88>
            maxFrequency = sourceFrequency / SCU_CCUCON5.B.MAXDIV;
80002da2:	54 23       	ld.w %d3,[%a2]
80002da4:	8f f3 00 31 	and %d3,%d3,15
80002da8:	4b 03 41 31 	itof %d3,%d3
80002dac:	4b 32 51 20 	div.f %d2,%d2,%d3
80002db0:	00 90       	ret 
        maxFrequency = sourceFrequency / 15;
80002db2:	7b 00 17 34 	movh %d3,16752
80002db6:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002dba:	00 90       	ret 
        maxFrequency = sourceFrequency / 30;
80002dbc:	7b 00 1f 34 	movh %d3,16880
80002dc0:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002dc4:	00 90       	ret 
        maxFrequency = sourceFrequency / 60;
80002dc6:	7b 00 27 34 	movh %d3,17008
80002dca:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002dce:	00 90       	ret 
        maxFrequency = sourceFrequency / 120;
80002dd0:	7b 00 2f 34 	movh %d3,17136
80002dd4:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002dd8:	00 90       	ret 
    switch (SCU_CCUCON0.B.LPDIV)
80002dda:	82 02       	mov %d2,0
}
80002ddc:	00 90       	ret 

80002dde <IfxScuCcu_getMaxFrequency_end>:
	...

80002de0 <IfxScuCcu_getBaud1Frequency>:
{
80002de0:	40 ae       	mov.aa %a14,%sp
80002de2:	20 08       	sub.a %sp,8
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80002de4:	91 30 00 2f 	movh.a %a2,61443
80002de8:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80002dec:	54 28       	ld.w %d8,[%a2]
    if (ccucon0.B.BAUD1DIV == 0)
80002dee:	59 e8 fc ff 	st.w [%a14]-4 <f0036030 <_SMALL_DATA4_+0x6002e030>>,%d8
80002df2:	8f f8 00 21 	and %d2,%d8,15
80002df6:	df 02 04 80 	jne %d2,0,80002dfe <IfxScuCcu_getBaud1Frequency+0x1e>
        frequency = 0;
80002dfa:	82 02       	mov %d2,0
}
80002dfc:	00 90       	ret 
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD1DIV;
80002dfe:	6d ff ab ff 	call 80002d54 <IfxScuCcu_getMaxFrequency>
80002e02:	8f f8 00 31 	and %d3,%d8,15
80002e06:	4b 03 41 31 	itof %d3,%d3
80002e0a:	4b 32 51 20 	div.f %d2,%d2,%d3
80002e0e:	00 90       	ret 

80002e10 <IfxScuCcu_getBaud2Frequency>:
{
80002e10:	40 ae       	mov.aa %a14,%sp
80002e12:	20 08       	sub.a %sp,8
    Ifx_SCU_CCUCON0 ccucon0 = SCU_CCUCON0;
80002e14:	91 30 00 2f 	movh.a %a2,61443
80002e18:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80002e1c:	54 28       	ld.w %d8,[%a2]
    if (ccucon0.B.BAUD2DIV == 0)
80002e1e:	59 e8 fc ff 	st.w [%a14]-4 <f0036030 <_SMALL_DATA4_+0x6002e030>>,%d8
80002e22:	8f 08 0f 21 	and %d2,%d8,240
80002e26:	df 02 04 80 	jne %d2,0,80002e2e <IfxScuCcu_getBaud2Frequency+0x1e>
        frequency = 0;
80002e2a:	82 02       	mov %d2,0
}
80002e2c:	00 90       	ret 
        frequency = IfxScuCcu_getMaxFrequency() / ccucon0.B.BAUD2DIV;
80002e2e:	6d ff 93 ff 	call 80002d54 <IfxScuCcu_getMaxFrequency>
80002e32:	37 08 64 32 	extr.u %d3,%d8,4,4
80002e36:	4b 03 41 31 	itof %d3,%d3
80002e3a:	4b 32 51 20 	div.f %d2,%d2,%d3
80002e3e:	00 90       	ret 

80002e40 <IfxScuCcu_getSpbFrequency>:
{
80002e40:	40 ae       	mov.aa %a14,%sp
    sourceFrequency = IfxScuCcu_getSourceFrequency();
80002e42:	6d ff 57 ff 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
    switch (SCU_CCUCON0.B.LPDIV)
80002e46:	91 30 00 2f 	movh.a %a2,61443
80002e4a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80002e4e:	54 23       	ld.w %d3,[%a2]
80002e50:	37 03 64 36 	extr.u %d3,%d3,12,4
80002e54:	ff 53 39 80 	jge.u %d3,5,80002ec6 <IfxScuCcu_getSpbFrequency+0x86>
80002e58:	91 00 00 28 	movh.a %a2,32768
80002e5c:	d9 22 e8 92 	lea %a2,[%a2]11880 <80002e68 <IfxScuCcu_getSpbFrequency+0x28>>
80002e60:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
80002e64:	dc 02       	ji %a2
80002e66:	00 00       	nop 
80002e68:	1d 00 0a 00 	j 80002e7c <IfxScuCcu_getSpbFrequency+0x3c>
80002e6c:	1d 00 19 00 	j 80002e9e <IfxScuCcu_getSpbFrequency+0x5e>
80002e70:	1d 00 1c 00 	j 80002ea8 <IfxScuCcu_getSpbFrequency+0x68>
80002e74:	1d 00 1f 00 	j 80002eb2 <IfxScuCcu_getSpbFrequency+0x72>
80002e78:	1d 00 22 00 	j 80002ebc <IfxScuCcu_getSpbFrequency+0x7c>
        if (SCU_CCUCON0.B.SPBDIV == 0)
80002e7c:	91 30 00 2f 	movh.a %a2,61443
80002e80:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80002e84:	54 23       	ld.w %d3,[%a2]
80002e86:	37 03 64 38 	extr.u %d3,%d3,16,4
80002e8a:	df 03 20 00 	jeq %d3,0,80002eca <IfxScuCcu_getSpbFrequency+0x8a>
            spbFrequency = sourceFrequency / SCU_CCUCON0.B.SPBDIV;
80002e8e:	54 23       	ld.w %d3,[%a2]
80002e90:	37 03 64 38 	extr.u %d3,%d3,16,4
80002e94:	4b 03 41 31 	itof %d3,%d3
80002e98:	4b 32 51 20 	div.f %d2,%d2,%d3
80002e9c:	00 90       	ret 
        spbFrequency = sourceFrequency / 30;
80002e9e:	7b 00 1f 34 	movh %d3,16880
80002ea2:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002ea6:	00 90       	ret 
        spbFrequency = sourceFrequency / 60;
80002ea8:	7b 00 27 34 	movh %d3,17008
80002eac:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002eb0:	00 90       	ret 
        spbFrequency = sourceFrequency / 120;
80002eb2:	7b 00 2f 34 	movh %d3,17136
80002eb6:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002eba:	00 90       	ret 
        spbFrequency = sourceFrequency / 240;
80002ebc:	7b 00 37 34 	movh %d3,17264
80002ec0:	4b 32 51 20 	div.f %d2,%d2,%d3
        break;
80002ec4:	00 90       	ret 
    switch (SCU_CCUCON0.B.LPDIV)
80002ec6:	82 02       	mov %d2,0
80002ec8:	00 90       	ret 
            spbFrequency = 0.0f;
80002eca:	82 02       	mov %d2,0
}
80002ecc:	00 90       	ret 

80002ece <IfxScuCcu_getSpbFrequency_end>:
	...

80002ed0 <IfxScuCcu_init>:
{
80002ed0:	40 ae       	mov.aa %a14,%sp
80002ed2:	40 4c       	mov.aa %a12,%a4
    IfxScuCcu_xtalFrequency = cfg->xtalFrequency;
80002ed4:	19 42 10 10 	ld.w %d2,[%a4]80
80002ed8:	91 00 00 26 	movh.a %a2,24576
80002edc:	59 22 60 60 	st.w [%a2]1440 <600005a0 <IfxScuCcu_xtalFrequency>>,%d2
    endinit_pw              = IfxScuWdt_getCpuWatchdogPassword();
80002ee0:	6d 00 02 03 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80002ee4:	02 2a       	mov %d10,%d2
    endinitSfty_pw          = IfxScuWdt_getSafetyWatchdogPassword();
80002ee6:	6d 00 11 03 	call 80003508 <IfxScuWdt_getSafetyWatchdogPassword>
80002eea:	02 28       	mov %d8,%d2
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80002eec:	02 a4       	mov %d4,%d10
80002eee:	6d 00 92 01 	call 80003212 <IfxScuWdt_clearCpuEndinit>
        smuTrapEnable      = SCU_TRAPDIS.B.SMUT;
80002ef2:	91 30 00 2f 	movh.a %a2,61443
80002ef6:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
80002efa:	54 2d       	ld.w %d13,[%a2]
80002efc:	37 0d e1 d1 	extr.u %d13,%d13,3,1
        SCU_TRAPDIS.B.SMUT = 1U;
80002f00:	54 22       	ld.w %d2,[%a2]
80002f02:	b7 12 81 21 	insert %d2,%d2,1,3,1
80002f06:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(endinit_pw);
80002f08:	02 a4       	mov %d4,%d10
80002f0a:	6d 00 0a 03 	call 8000351e <IfxScuWdt_setCpuEndinit>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80002f0e:	02 84       	mov %d4,%d8
80002f10:	6d 00 a6 01 	call 8000325c <IfxScuWdt_clearSafetyEndinit>
        while (SCU_CCUCON0.B.LCK != 0U)
80002f14:	91 30 00 2f 	movh.a %a2,61443
80002f18:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80002f1c:	54 23       	ld.w %d3,[%a2]
80002f1e:	bf 03 fb 7f 	jlt %d3,0,80002f14 <IfxScuCcu_init+0x44>
        SCU_CCUCON0.B.CLKSEL = 0; /*Select the EVR as fOSC for the clock distribution */
80002f22:	54 22       	ld.w %d2,[%a2]
80002f24:	b7 02 02 2e 	insert %d2,%d2,0,28,2
80002f28:	74 22       	st.w [%a2],%d2
        SCU_CCUCON0.B.UP     = 1; /*Update the ccucon0 register */
80002f2a:	54 22       	ld.w %d2,[%a2]
80002f2c:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80002f30:	74 22       	st.w [%a2],%d2
        SCU_PLLCON0.B.SETFINDIS = 1;
80002f32:	91 30 00 2f 	movh.a %a2,61443
80002f36:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80002f3a:	54 22       	ld.w %d2,[%a2]
80002f3c:	b7 12 01 22 	insert %d2,%d2,1,4,1
80002f40:	74 22       	st.w [%a2],%d2
        while (SCU_CCUCON1.B.LCK != 0U)
80002f42:	91 30 00 2f 	movh.a %a2,61443
80002f46:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80002f4a:	54 23       	ld.w %d3,[%a2]
80002f4c:	bf 03 fb 7f 	jlt %d3,0,80002f42 <IfxScuCcu_init+0x72>
        SCU_CCUCON1.B.INSEL = 1; /*Select oscillator OSC0 as clock to PLL */
80002f50:	54 22       	ld.w %d2,[%a2]
80002f52:	b7 12 02 2e 	insert %d2,%d2,1,28,2
80002f56:	74 22       	st.w [%a2],%d2
        SCU_CCUCON1.B.UP    = 1; /*Update the ccucon0 register */
80002f58:	54 22       	ld.w %d2,[%a2]
80002f5a:	b7 12 01 2f 	insert %d2,%d2,1,30,1
80002f5e:	74 22       	st.w [%a2],%d2
        status             |= IfxScuCcu_isOscillatorStable();
80002f60:	6d ff ab fd 	call 80002ab6 <IfxScuCcu_isOscillatorStable>
80002f64:	02 2c       	mov %d12,%d2
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80002f66:	02 84       	mov %d4,%d8
80002f68:	6d 00 00 03 	call 80003568 <IfxScuWdt_setSafetyEndinit>
    if (status == 0)
80002f6c:	df 0c 28 00 	jeq %d12,0,80002fbc <IfxScuCcu_init+0xec>
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80002f70:	02 84       	mov %d4,%d8
80002f72:	6d 00 75 01 	call 8000325c <IfxScuWdt_clearSafetyEndinit>
        SCU_PLLCON0.B.OSCDISCDIS = 0U;
80002f76:	91 30 00 2f 	movh.a %a2,61443
80002f7a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80002f7e:	54 23       	ld.w %d3,[%a2]
80002f80:	8f 03 c4 31 	andn %d3,%d3,64
80002f84:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80002f86:	02 84       	mov %d4,%d8
80002f88:	6d 00 f0 02 	call 80003568 <IfxScuWdt_setSafetyEndinit>
        IfxScuWdt_clearCpuEndinit(endinit_pw);
80002f8c:	02 a4       	mov %d4,%d10
80002f8e:	6d 00 42 01 	call 80003212 <IfxScuWdt_clearCpuEndinit>
        SCU_TRAPCLR.B.SMUT = 1U;
80002f92:	91 30 00 2f 	movh.a %a2,61443
80002f96:	d9 22 2c 46 	lea %a2,[%a2]24876 <f003612c <_SMALL_DATA4_+0x6002e12c>>
80002f9a:	54 23       	ld.w %d3,[%a2]
80002f9c:	b7 13 81 31 	insert %d3,%d3,1,3,1
80002fa0:	74 23       	st.w [%a2],%d3
        SCU_TRAPDIS.B.SMUT = smuTrapEnable;
80002fa2:	91 30 00 2f 	movh.a %a2,61443
80002fa6:	d9 22 30 46 	lea %a2,[%a2]24880 <f0036130 <_SMALL_DATA4_+0x6002e130>>
80002faa:	54 23       	ld.w %d3,[%a2]
80002fac:	67 d3 03 30 	ins.t %d3,%d3,3,%d13,0
80002fb0:	74 23       	st.w [%a2],%d3
        IfxScuWdt_setCpuEndinit(endinit_pw);
80002fb2:	02 a4       	mov %d4,%d10
80002fb4:	6d 00 b5 02 	call 8000351e <IfxScuWdt_setCpuEndinit>
}
80002fb8:	02 c2       	mov %d2,%d12
80002fba:	00 90       	ret 
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
80002fbc:	02 84       	mov %d4,%d8
80002fbe:	6d 00 4f 01 	call 8000325c <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
80002fc2:	91 30 00 2f 	movh.a %a2,61443
80002fc6:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
80002fca:	54 23       	ld.w %d3,[%a2]
80002fcc:	6f 53 fb 7f 	jz.t %d3,5,80002fc2 <IfxScuCcu_init+0xf2>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllInitialStep.k2Initial;
80002fd0:	39 c3 0a 00 	ld.bu %d3,[%a12]10
80002fd4:	91 30 00 2f 	movh.a %a2,61443
80002fd8:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
80002fdc:	54 22       	ld.w %d2,[%a2]
80002fde:	37 32 07 20 	insert %d2,%d2,%d3,0,7
80002fe2:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PDIV = cfg->sysPll.pllInitialStep.pDivider;
80002fe4:	39 c3 08 00 	ld.bu %d3,[%a12]8
80002fe8:	91 30 00 2f 	movh.a %a2,61443
80002fec:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
80002ff0:	54 22       	ld.w %d2,[%a2]
80002ff2:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
80002ff6:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.NDIV = cfg->sysPll.pllInitialStep.nDivider;
80002ff8:	39 c3 09 00 	ld.bu %d3,[%a12]9
80002ffc:	54 22       	ld.w %d2,[%a2]
80002ffe:	37 32 87 24 	insert %d2,%d2,%d3,9,7
80003002:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.OSCDISCDIS = 1;
80003004:	54 22       	ld.w %d2,[%a2]
80003006:	b7 12 01 23 	insert %d2,%d2,1,6,1
8000300a:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 0; // set PLL to power down
8000300c:	54 22       	ld.w %d2,[%a2]
8000300e:	b7 02 01 28 	insert %d2,%d2,0,16,1
80003012:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.CLRFINDIS  = 1;
80003014:	54 22       	ld.w %d2,[%a2]
80003016:	b7 12 81 22 	insert %d2,%d2,1,5,1
8000301a:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.PLLPWD     = 1; // set PLL to normal
8000301c:	54 22       	ld.w %d2,[%a2]
8000301e:	b7 12 01 28 	insert %d2,%d2,1,16,1
80003022:	74 22       	st.w [%a2],%d2
                    SCU_PLLCON0.B.RESLD = 1;
80003024:	54 22       	ld.w %d2,[%a2]
80003026:	b7 12 01 29 	insert %d2,%d2,1,18,1
8000302a:	74 22       	st.w [%a2],%d2
                    IfxScuCcu_wait(0.000050F);  /*Wait for 50us */
8000302c:	7b 20 85 43 	movh %d4,14418
80003030:	1b 74 71 4b 	addi %d4,%d4,-18665
80003034:	6d ff 74 fe 	call 80002d1c <IfxScuCcu_wait>
                    while (SCU_PLLSTAT.B.VCOLOCK == 0U)
80003038:	91 30 00 2f 	movh.a %a2,61443
8000303c:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
80003040:	54 23       	ld.w %d3,[%a2]
80003042:	6f 23 fb 7f 	jz.t %d3,2,80003038 <IfxScuCcu_init+0x168>
                    SCU_PLLCON0.B.VCOBYP = 0; /*VCO bypass disabled */
80003046:	91 30 00 2f 	movh.a %a2,61443
8000304a:	d9 22 18 06 	lea %a2,[%a2]24600 <f0036018 <_SMALL_DATA4_+0x6002e018>>
8000304e:	54 22       	ld.w %d2,[%a2]
80003050:	8f 12 c0 21 	andn %d2,%d2,1
80003054:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
80003056:	91 30 00 2f 	movh.a %a2,61443
8000305a:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
8000305e:	54 23       	ld.w %d3,[%a2]
80003060:	bf 03 fb 7f 	jlt %d3,0,80003056 <IfxScuCcu_init+0x186>
                    SCU_CCUCON0.B.CLKSEL = 0x01;
80003064:	54 22       	ld.w %d2,[%a2]
80003066:	b7 12 02 2e 	insert %d2,%d2,1,28,2
8000306a:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON0.B.LCK != 0U)
8000306c:	91 30 00 2f 	movh.a %a2,61443
80003070:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80003074:	54 23       	ld.w %d3,[%a2]
80003076:	bf 03 fb 7f 	jlt %d3,0,8000306c <IfxScuCcu_init+0x19c>
                    IfxScuCcu_wait(cfg->sysPll.pllInitialStep.waitTime); /*Wait for configured initial time */
8000307a:	19 c4 0c 00 	ld.w %d4,[%a12]12
8000307e:	6d ff 4f fe 	call 80002d1c <IfxScuCcu_wait>
                        ccucon0.U        = SCU_CCUCON0.U & ~cfg->clockDistribution.ccucon0.mask;
80003082:	91 30 00 2f 	movh.a %a2,61443
80003086:	d9 22 30 06 	lea %a2,[%a2]24624 <f0036030 <_SMALL_DATA4_+0x6002e030>>
8000308a:	54 23       	ld.w %d3,[%a2]
8000308c:	19 c4 14 00 	ld.w %d4,[%a12]20 <f0036030 <_SMALL_DATA4_+0x6002e030>>
80003090:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon0.U       |= (cfg->clockDistribution.ccucon0.mask & cfg->clockDistribution.ccucon0.value);
80003094:	19 c2 10 00 	ld.w %d2,[%a12]16
80003098:	26 42       	and %d2,%d4
8000309a:	a6 23       	or %d3,%d2
                        ccucon0.B.CLKSEL = 0x01;    /*  Select fpll as CCU input clock, even if this was not selected by configuration */
8000309c:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon0.B.UP     = 1;
800030a0:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON0      = ccucon0; /*Set update bit explicitly to make above configurations effective */
800030a4:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON1.B.LCK != 0U)
800030a6:	91 30 00 2f 	movh.a %a2,61443
800030aa:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
800030ae:	54 23       	ld.w %d3,[%a2]
800030b0:	bf 03 fb 7f 	jlt %d3,0,800030a6 <IfxScuCcu_init+0x1d6>
                        ccucon1.U       = SCU_CCUCON1.U & ~cfg->clockDistribution.ccucon1.mask;
800030b4:	54 23       	ld.w %d3,[%a2]
800030b6:	19 c4 1c 00 	ld.w %d4,[%a12]28
800030ba:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon1.U      |= (cfg->clockDistribution.ccucon1.mask & cfg->clockDistribution.ccucon1.value);
800030be:	19 c2 18 00 	ld.w %d2,[%a12]24
800030c2:	26 42       	and %d2,%d4
800030c4:	a6 23       	or %d3,%d2
                        ccucon1.B.INSEL = 1;
800030c6:	b7 13 02 3e 	insert %d3,%d3,1,28,2
                        ccucon1.B.UP    = 1;
800030ca:	b7 13 01 3f 	insert %d3,%d3,1,30,1
                        SCU_CCUCON1     = ccucon1;
800030ce:	74 23       	st.w [%a2],%d3
                    while (SCU_CCUCON2.B.LCK != 0U)
800030d0:	91 30 00 2f 	movh.a %a2,61443
800030d4:	d9 22 00 16 	lea %a2,[%a2]24640 <f0036040 <_SMALL_DATA4_+0x6002e040>>
800030d8:	54 23       	ld.w %d3,[%a2]
800030da:	bf 03 fb 7f 	jlt %d3,0,800030d0 <IfxScuCcu_init+0x200>
                        ccucon2.U    = SCU_CCUCON2.U & ~cfg->clockDistribution.ccucon2.mask;
800030de:	54 23       	ld.w %d3,[%a2]
800030e0:	19 c4 24 00 	ld.w %d4,[%a12]36
800030e4:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon2.U   |= (cfg->clockDistribution.ccucon2.mask & cfg->clockDistribution.ccucon2.value);
800030e8:	19 c2 20 00 	ld.w %d2,[%a12]32
800030ec:	26 42       	and %d2,%d4
800030ee:	a6 32       	or %d2,%d3
                        ccucon2.B.UP = 1;
800030f0:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON2  = ccucon2;
800030f4:	74 22       	st.w [%a2],%d2
                    while (SCU_CCUCON5.B.LCK != 0U)
800030f6:	91 30 00 2f 	movh.a %a2,61443
800030fa:	d9 22 0c 16 	lea %a2,[%a2]24652 <f003604c <_SMALL_DATA4_+0x6002e04c>>
800030fe:	54 23       	ld.w %d3,[%a2]
80003100:	bf 03 fb 7f 	jlt %d3,0,800030f6 <IfxScuCcu_init+0x226>
                        ccucon5.U    = SCU_CCUCON5.U & ~cfg->clockDistribution.ccucon5.mask;
80003104:	54 23       	ld.w %d3,[%a2]
80003106:	19 c4 2c 00 	ld.w %d4,[%a12]44
8000310a:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon5.U   |= (cfg->clockDistribution.ccucon5.mask & cfg->clockDistribution.ccucon5.value);
8000310e:	19 c2 28 00 	ld.w %d2,[%a12]40
80003112:	26 42       	and %d2,%d4
80003114:	a6 32       	or %d2,%d3
                        ccucon5.B.UP = 1;
80003116:	b7 12 01 2f 	insert %d2,%d2,1,30,1
                        SCU_CCUCON5  = ccucon5;
8000311a:	74 22       	st.w [%a2],%d2
                        ccucon6.U   = SCU_CCUCON6.U & ~cfg->clockDistribution.ccucon6.mask;
8000311c:	91 30 00 2f 	movh.a %a2,61443
80003120:	d9 22 00 26 	lea %a2,[%a2]24704 <f0036080 <_SMALL_DATA4_+0x6002e080>>
80003124:	54 23       	ld.w %d3,[%a2]
80003126:	19 c4 34 00 	ld.w %d4,[%a12]52 <f0036080 <_SMALL_DATA4_+0x6002e080>>
8000312a:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon6.U  |= (cfg->clockDistribution.ccucon6.mask & cfg->clockDistribution.ccucon6.value);
8000312e:	19 c2 30 00 	ld.w %d2,[%a12]48
80003132:	26 42       	and %d2,%d4
80003134:	a6 32       	or %d2,%d3
                        SCU_CCUCON6 = ccucon6;
80003136:	74 22       	st.w [%a2],%d2
                        ccucon7.U   = SCU_CCUCON7.U & ~cfg->clockDistribution.ccucon7.mask;
80003138:	91 30 00 2f 	movh.a %a2,61443
8000313c:	d9 22 04 26 	lea %a2,[%a2]24708 <f0036084 <_SMALL_DATA4_+0x6002e084>>
80003140:	54 23       	ld.w %d3,[%a2]
80003142:	19 c4 3c 00 	ld.w %d4,[%a12]60 <f0036084 <_SMALL_DATA4_+0x6002e084>>
80003146:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon7.U  |= (cfg->clockDistribution.ccucon7.mask & cfg->clockDistribution.ccucon7.value);
8000314a:	19 c2 38 00 	ld.w %d2,[%a12]56
8000314e:	26 42       	and %d2,%d4
80003150:	a6 32       	or %d2,%d3
                        SCU_CCUCON7 = ccucon7;
80003152:	74 22       	st.w [%a2],%d2
                        ccucon8.U   = SCU_CCUCON8.U & ~cfg->clockDistribution.ccucon8.mask;
80003154:	91 30 00 2f 	movh.a %a2,61443
80003158:	d9 22 08 26 	lea %a2,[%a2]24712 <f0036088 <_SMALL_DATA4_+0x6002e088>>
8000315c:	54 23       	ld.w %d3,[%a2]
8000315e:	19 c4 04 10 	ld.w %d4,[%a12]68 <f0036088 <_SMALL_DATA4_+0x6002e088>>
80003162:	0f 43 e0 30 	andn %d3,%d3,%d4
                        ccucon8.U  |= (cfg->clockDistribution.ccucon8.mask & cfg->clockDistribution.ccucon8.value);
80003166:	19 c2 00 10 	ld.w %d2,[%a12]64
8000316a:	26 42       	and %d2,%d4
8000316c:	a6 32       	or %d2,%d3
                        SCU_CCUCON8 = ccucon8;
8000316e:	74 22       	st.w [%a2],%d2
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
80003170:	02 84       	mov %d4,%d8
80003172:	6d 00 fb 01 	call 80003568 <IfxScuWdt_setSafetyEndinit>
            fcon.U = FLASH0_FCON.U & ~cfg->flashFconWaitStateConfig.mask;
80003176:	91 00 80 df 	movh.a %a13,63488
8000317a:	d9 dd 14 02 	lea %a13,[%a13]8212 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
8000317e:	54 d9       	ld.w %d9,[%a13]
80003180:	19 c4 0c 10 	ld.w %d4,[%a12]76 <f8002014 <_SMALL_DATA4_+0x67ffa014>>
80003184:	0f 49 e0 90 	andn %d9,%d9,%d4
            fcon.U |= (cfg->flashFconWaitStateConfig.mask & cfg->flashFconWaitStateConfig.value);
80003188:	19 c2 08 10 	ld.w %d2,[%a12]72
8000318c:	26 42       	and %d2,%d4
8000318e:	a6 29       	or %d9,%d2
                IfxScuWdt_clearCpuEndinit(endinit_pw);
80003190:	02 a4       	mov %d4,%d10
80003192:	6d 00 40 00 	call 80003212 <IfxScuWdt_clearCpuEndinit>
                FLASH0_FCON = fcon;
80003196:	74 d9       	st.w [%a13],%d9
                IfxScuWdt_setCpuEndinit(endinit_pw);
80003198:	02 a4       	mov %d4,%d10
8000319a:	6d 00 c2 01 	call 8000351e <IfxScuWdt_setCpuEndinit>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
8000319e:	02 c9       	mov %d9,%d12
800031a0:	1d 00 0d 00 	j 800031ba <IfxScuCcu_init+0x2ea>
            IfxScuCcu_wait(cfg->sysPll.pllDividerStep[pllStepsCount].waitTime);
800031a4:	99 c2 04 00 	ld.a %a2,[%a12]4
800031a8:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
800031ac:	19 24 04 00 	ld.w %d4,[%a2]4
800031b0:	6d ff b6 fd 	call 80002d1c <IfxScuCcu_wait>
        for (pllStepsCount = 0; pllStepsCount < cfg->sysPll.numOfPllDividerSteps; pllStepsCount++)
800031b4:	c2 19       	add %d9,1
800031b6:	8f f9 0f 91 	and %d9,%d9,255
800031ba:	14 c3       	ld.bu %d3,[%a12]
800031bc:	7f 39 da fe 	jge.u %d9,%d3,80002f70 <IfxScuCcu_init+0xa0>
                IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
800031c0:	02 84       	mov %d4,%d8
800031c2:	6d 00 4d 00 	call 8000325c <IfxScuWdt_clearSafetyEndinit>
                while (SCU_PLLSTAT.B.K2RDY == 0U)
800031c6:	91 30 00 2f 	movh.a %a2,61443
800031ca:	d9 22 14 06 	lea %a2,[%a2]24596 <f0036014 <_SMALL_DATA4_+0x6002e014>>
800031ce:	54 23       	ld.w %d3,[%a2]
800031d0:	6f 53 fb 7f 	jz.t %d3,5,800031c6 <IfxScuCcu_init+0x2f6>
                SCU_PLLCON1.B.K2DIV = cfg->sysPll.pllDividerStep[pllStepsCount].k2Step;
800031d4:	53 c9 20 b0 	mul %d11,%d9,12
800031d8:	99 c2 04 00 	ld.a %a2,[%a12]4
800031dc:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
800031e0:	14 24       	ld.bu %d4,[%a2]
800031e2:	91 30 00 2f 	movh.a %a2,61443
800031e6:	d9 22 1c 06 	lea %a2,[%a2]24604 <f003601c <_SMALL_DATA4_+0x6002e01c>>
800031ea:	54 23       	ld.w %d3,[%a2]
800031ec:	37 43 07 30 	insert %d3,%d3,%d4,0,7
800031f0:	74 23       	st.w [%a2],%d3
                IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
800031f2:	02 84       	mov %d4,%d8
800031f4:	6d 00 ba 01 	call 80003568 <IfxScuWdt_setSafetyEndinit>
            if (cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction != (IfxScuCcu_PllStepsFunctionHook)0)
800031f8:	99 c2 04 00 	ld.a %a2,[%a12]4
800031fc:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
80003200:	d9 22 08 00 	lea %a2,[%a2]8
80003204:	d4 22       	ld.a %a2,[%a2]
80003206:	bd 02 cf 7f 	jz.a %a2,800031a4 <IfxScuCcu_init+0x2d4>
                cfg->sysPll.pllDividerStep[pllStepsCount].hookFunction();
8000320a:	2d 02 00 00 	calli %a2
8000320e:	1d ff cb ff 	j 800031a4 <IfxScuCcu_init+0x2d4>

80003212 <IfxScuWdt_clearCpuEndinit>:
    {}
}


void IfxScuWdt_clearCpuEndinit(uint16 password)
{
80003212:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80003214:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80003218:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
8000321c:	7b 30 00 3f 	movh %d3,61443
80003220:	1b 03 10 36 	addi %d3,%d3,24832
80003224:	13 c2 20 23 	madd %d2,%d3,%d2,12
80003228:	60 22       	mov.a %a2,%d2
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScuWdt_clearCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000322a:	54 22       	ld.w %d2,[%a2]
8000322c:	6f 12 0b 00 	jz.t %d2,1,80003242 <IfxScuWdt_clearCpuEndinit+0x30>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003230:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003234:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003238:	54 22       	ld.w %d2,[%a2]
8000323a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000323e:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003240:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003242:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003246:	8f 23 40 31 	or %d3,%d3,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000324a:	54 22       	ld.w %d2,[%a2]
8000324c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003250:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003252:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (watchdog->CON0.B.ENDINIT == 1)
80003254:	54 22       	ld.w %d2,[%a2]
80003256:	6f 02 ff ff 	jnz.t %d2,0,80003254 <IfxScuWdt_clearCpuEndinit+0x42>
}
8000325a:	00 90       	ret 

8000325c <IfxScuWdt_clearSafetyEndinit>:


void IfxScuWdt_clearSafetyEndinit(uint16 password)
{
8000325c:	40 ae       	mov.aa %a14,%sp
8000325e:	37 04 70 40 	extr.u %d4,%d4,0,16
}


IFX_INLINE void IfxScuWdt_clearSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80003262:	91 30 00 2f 	movh.a %a2,61443
80003266:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000326a:	54 22       	ld.w %d2,[%a2]
8000326c:	6f 12 0b 00 	jz.t %d2,1,80003282 <IfxScuWdt_clearSafetyEndinit+0x26>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80003270:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80003274:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003278:	54 22       	ld.w %d2,[%a2]
8000327a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000327e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80003280:	74 22       	st.w [%a2],%d2
    }

    /* Clear ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80003282:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80003286:	8f 23 40 31 	or %d3,%d3,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
8000328a:	91 30 00 2f 	movh.a %a2,61443
8000328e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80003292:	54 22       	ld.w %d2,[%a2]
80003294:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80003298:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000329a:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
8000329c:	91 30 00 2f 	movh.a %a2,61443
800032a0:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800032a4:	54 22       	ld.w %d2,[%a2]
800032a6:	6f 02 fb ff 	jnz.t %d2,0,8000329c <IfxScuWdt_clearSafetyEndinit+0x40>
    IfxScuWdt_clearSafetyEndinitInline(password);
}
800032aa:	00 90       	ret 

800032ac <IfxScuWdt_disableCpuWatchdog>:


void IfxScuWdt_disableCpuWatchdog(uint16 password)
{
800032ac:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800032ae:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800032b2:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800032b6:	7b 30 00 3f 	movh %d3,61443
800032ba:	1b 03 10 36 	addi %d3,%d3,24832
800032be:	13 c2 20 23 	madd %d2,%d3,%d2,12
800032c2:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
800032c4:	54 22       	ld.w %d2,[%a2]
800032c6:	6f 12 0b 00 	jz.t %d2,1,800032dc <IfxScuWdt_disableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800032ca:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800032ce:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800032d2:	54 22       	ld.w %d2,[%a2]
800032d4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800032d8:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800032da:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800032dc:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800032de:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800032e2:	54 22       	ld.w %d2,[%a2]
800032e4:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800032e8:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800032ea:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800032ec:	54 22       	ld.w %d2,[%a2]
800032ee:	6f 02 ff ff 	jnz.t %d2,0,800032ec <IfxScuWdt_disableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 1;         //Set DR bit in Config_1 register
800032f2:	d9 23 04 00 	lea %a3,[%a2]4
800032f6:	19 22 04 00 	ld.w %d2,[%a2]4
800032fa:	b7 12 81 21 	insert %d2,%d2,1,3,1
800032fe:	74 32       	st.w [%a3],%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
80003300:	54 22       	ld.w %d2,[%a2]
80003302:	6f 12 09 00 	jz.t %d2,1,80003314 <IfxScuWdt_disableCpuWatchdog+0x68>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003306:	8f 14 40 31 	or %d3,%d4,1
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000330a:	54 22       	ld.w %d2,[%a2]
8000330c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003310:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003312:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003314:	8f 34 40 41 	or %d4,%d4,3
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003318:	54 22       	ld.w %d2,[%a2]
8000331a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000331e:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003320:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
80003322:	54 22       	ld.w %d2,[%a2]
80003324:	6f 02 ff 7f 	jz.t %d2,0,80003322 <IfxScuWdt_disableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80003328:	00 90       	ret 

8000332a <IfxScuWdt_disableSafetyWatchdog>:


void IfxScuWdt_disableSafetyWatchdog(uint16 password)
{
8000332a:	40 ae       	mov.aa %a14,%sp
8000332c:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
80003330:	91 30 00 2f 	movh.a %a2,61443
80003334:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80003338:	54 22       	ld.w %d2,[%a2]
8000333a:	6f 12 0b 00 	jz.t %d2,1,80003350 <IfxScuWdt_disableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000333e:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80003342:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003346:	54 22       	ld.w %d2,[%a2]
80003348:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000334c:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000334e:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80003350:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80003352:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003356:	91 30 00 2f 	movh.a %a2,61443
8000335a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000335e:	54 22       	ld.w %d2,[%a2]
80003360:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80003364:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80003366:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80003368:	91 30 00 2f 	movh.a %a2,61443
8000336c:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80003370:	54 22       	ld.w %d2,[%a2]
80003372:	6f 02 fb ff 	jnz.t %d2,0,80003368 <IfxScuWdt_disableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 1;     //Set DR bit in Config_1 register
80003376:	91 30 00 2f 	movh.a %a2,61443
8000337a:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
8000337e:	54 22       	ld.w %d2,[%a2]
80003380:	b7 12 81 21 	insert %d2,%d2,1,3,1
80003384:	74 22       	st.w [%a2],%d2
}


IFX_INLINE void IfxScuWdt_setSafetyEndinitInline(uint16 password)
{
    if (SCU_WDTS_CON0.B.LCK)
80003386:	91 30 00 2f 	movh.a %a2,61443
8000338a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000338e:	54 22       	ld.w %d2,[%a2]
80003390:	6f 12 09 00 	jz.t %d2,1,800033a2 <IfxScuWdt_disableSafetyWatchdog+0x78>
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80003394:	8f 14 40 31 	or %d3,%d4,1
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003398:	54 22       	ld.w %d2,[%a2]
8000339a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000339e:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800033a0:	74 22       	st.w [%a2],%d2
    }

    /* Set ENDINT and set LCK bit in Config_0 register */
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800033a2:	8f 34 40 41 	or %d4,%d4,3
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800033a6:	91 30 00 2f 	movh.a %a2,61443
800033aa:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800033ae:	54 22       	ld.w %d2,[%a2]
800033b0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800033b4:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800033b6:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been cleared */
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800033b8:	91 30 00 2f 	movh.a %a2,61443
800033bc:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800033c0:	54 22       	ld.w %d2,[%a2]
800033c2:	6f 02 fb 7f 	jz.t %d2,0,800033b8 <IfxScuWdt_disableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800033c6:	00 90       	ret 

800033c8 <IfxScuWdt_enableCpuWatchdog>:


void IfxScuWdt_enableCpuWatchdog(uint16 password)
{
800033c8:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800033ca:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800033ce:	8f 72 00 21 	and %d2,%d2,7
    /* Select CPU Watchdog based on Core Id */
    uint32          coreId = (uint32)IfxCpu_getCoreIndex();
    Ifx_SCU_WDTCPU *wdt    = &MODULE_SCU.WDTCPU[coreId];
800033d2:	7b 30 00 3f 	movh %d3,61443
800033d6:	1b 03 10 36 	addi %d3,%d3,24832
800033da:	13 c2 20 23 	madd %d2,%d3,%d2,12
800033de:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
800033e0:	54 22       	ld.w %d2,[%a2]
800033e2:	6f 12 0b 00 	jz.t %d2,1,800033f8 <IfxScuWdt_enableCpuWatchdog+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800033e6:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800033ea:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800033ee:	54 22       	ld.w %d2,[%a2]
800033f0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800033f4:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800033f6:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800033f8:	06 24       	sh %d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
800033fa:	8f 24 40 31 	or %d3,%d4,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800033fe:	54 22       	ld.w %d2,[%a2]
80003400:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80003404:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80003406:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80003408:	54 22       	ld.w %d2,[%a2]
8000340a:	6f 02 ff ff 	jnz.t %d2,0,80003408 <IfxScuWdt_enableCpuWatchdog+0x40>

    IfxScuWdt_clearCpuEndinitInline(wdt, password);
    wdt->CON1.B.DR = 0;         //Clear DR bit in Config_1 register
8000340e:	d9 23 04 00 	lea %a3,[%a2]4
80003412:	19 22 04 00 	ld.w %d2,[%a2]4
80003416:	8f 82 c0 21 	andn %d2,%d2,8
8000341a:	74 32       	st.w [%a3],%d2
    if (watchdog->CON0.B.LCK)
8000341c:	54 22       	ld.w %d2,[%a2]
8000341e:	6f 12 09 00 	jz.t %d2,1,80003430 <IfxScuWdt_enableCpuWatchdog+0x68>
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003422:	8f 14 40 31 	or %d3,%d4,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003426:	54 22       	ld.w %d2,[%a2]
80003428:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000342c:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000342e:	74 22       	st.w [%a2],%d2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003430:	8f 34 40 41 	or %d4,%d4,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003434:	54 22       	ld.w %d2,[%a2]
80003436:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000343a:	a6 42       	or %d2,%d4
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000343c:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
8000343e:	54 22       	ld.w %d2,[%a2]
80003440:	6f 02 ff 7f 	jz.t %d2,0,8000343e <IfxScuWdt_enableCpuWatchdog+0x76>
    IfxScuWdt_setCpuEndinitInline(wdt, password);
}
80003444:	00 90       	ret 

80003446 <IfxScuWdt_enableSafetyWatchdog>:


void IfxScuWdt_enableSafetyWatchdog(uint16 password)
{
80003446:	40 ae       	mov.aa %a14,%sp
80003448:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
8000344c:	91 30 00 2f 	movh.a %a2,61443
80003450:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80003454:	54 22       	ld.w %d2,[%a2]
80003456:	6f 12 0b 00 	jz.t %d2,1,8000346c <IfxScuWdt_enableSafetyWatchdog+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000345a:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000345e:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003462:	54 22       	ld.w %d2,[%a2]
80003464:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80003468:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000346a:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000346c:	06 24       	sh %d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
8000346e:	8f 24 40 31 	or %d3,%d4,2
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003472:	91 30 00 2f 	movh.a %a2,61443
80003476:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000347a:	54 22       	ld.w %d2,[%a2]
8000347c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
80003480:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (0 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
80003482:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 1)
80003484:	91 30 00 2f 	movh.a %a2,61443
80003488:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000348c:	54 22       	ld.w %d2,[%a2]
8000348e:	6f 02 fb ff 	jnz.t %d2,0,80003484 <IfxScuWdt_enableSafetyWatchdog+0x3e>
    IfxScuWdt_clearSafetyEndinitInline(password);
    SCU_WDTS_CON1.B.DR = 0;     //Clear DR bit in Config_1 register
80003492:	91 30 00 2f 	movh.a %a2,61443
80003496:	d9 22 34 36 	lea %a2,[%a2]24820 <f00360f4 <_SMALL_DATA4_+0x6002e0f4>>
8000349a:	54 22       	ld.w %d2,[%a2]
8000349c:	8f 82 c0 21 	andn %d2,%d2,8
800034a0:	74 22       	st.w [%a2],%d2
    if (SCU_WDTS_CON0.B.LCK)
800034a2:	91 30 00 2f 	movh.a %a2,61443
800034a6:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800034aa:	54 22       	ld.w %d2,[%a2]
800034ac:	6f 12 09 00 	jz.t %d2,1,800034be <IfxScuWdt_enableSafetyWatchdog+0x78>
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800034b0:	8f 14 40 31 	or %d3,%d4,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800034b4:	54 22       	ld.w %d2,[%a2]
800034b6:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800034ba:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800034bc:	74 22       	st.w [%a2],%d2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
800034be:	8f 34 40 41 	or %d4,%d4,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
800034c2:	91 30 00 2f 	movh.a %a2,61443
800034c6:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800034ca:	54 22       	ld.w %d2,[%a2]
800034cc:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800034d0:	a6 42       	or %d2,%d4
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800034d2:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800034d4:	91 30 00 2f 	movh.a %a2,61443
800034d8:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800034dc:	54 22       	ld.w %d2,[%a2]
800034de:	6f 02 fb 7f 	jz.t %d2,0,800034d4 <IfxScuWdt_enableSafetyWatchdog+0x8e>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800034e2:	00 90       	ret 

800034e4 <IfxScuWdt_getCpuWatchdogPassword>:


uint16 IfxScuWdt_getCpuWatchdogPassword(void)
{
800034e4:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800034e6:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800034ea:	8f 72 00 21 	and %d2,%d2,7
    return IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
800034ee:	7b 30 00 3f 	movh %d3,61443
800034f2:	1b 03 10 36 	addi %d3,%d3,24832
800034f6:	13 c2 20 23 	madd %d2,%d3,%d2,12
    password  = watchdog->CON0.B.PW;
800034fa:	60 22       	mov.a %a2,%d2
800034fc:	54 22       	ld.w %d2,[%a2]
800034fe:	37 02 6e 21 	extr.u %d2,%d2,2,14
}
80003502:	8f f2 83 21 	xor %d2,%d2,63
80003506:	00 90       	ret 

80003508 <IfxScuWdt_getSafetyWatchdogPassword>:
    return (boolean)IfxScuWdt_getCpuWatchdogEndInitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()]);
}


uint16 IfxScuWdt_getSafetyWatchdogPassword(void)
{
80003508:	40 ae       	mov.aa %a14,%sp
    password  = watchdog->CON0.B.PW;
8000350a:	91 30 00 2f 	movh.a %a2,61443
8000350e:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80003512:	54 22       	ld.w %d2,[%a2]
80003514:	37 02 6e 21 	extr.u %d2,%d2,2,14
    return IfxScuWdt_getSafetyWatchdogPasswordInline();
}
80003518:	8f f2 83 21 	xor %d2,%d2,63
8000351c:	00 90       	ret 

8000351e <IfxScuWdt_setCpuEndinit>:
    IfxScuWdt_setSafetyEndinit(password);
}


void IfxScuWdt_setCpuEndinit(uint16 password)
{
8000351e:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
80003520:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80003524:	8f 72 00 21 	and %d2,%d2,7
    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[IfxCpu_getCoreIndex()], password);
80003528:	7b 30 00 3f 	movh %d3,61443
8000352c:	1b 03 10 36 	addi %d3,%d3,24832
80003530:	13 c2 20 23 	madd %d2,%d3,%d2,12
80003534:	60 22       	mov.a %a2,%d2
    if (watchdog->CON0.B.LCK)
80003536:	54 22       	ld.w %d2,[%a2]
80003538:	6f 12 0b 00 	jz.t %d2,1,8000354e <IfxScuWdt_setCpuEndinit+0x30>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000353c:	8f 24 00 30 	sh %d3,%d4,2
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003540:	8f 13 40 31 	or %d3,%d3,1
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003544:	54 22       	ld.w %d2,[%a2]
80003546:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000354a:	a6 32       	or %d2,%d3
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000354c:	74 22       	st.w [%a2],%d2
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000354e:	8f 24 00 30 	sh %d3,%d4,2
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
80003552:	8f 33 40 31 	or %d3,%d3,3
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80003556:	54 22       	ld.w %d2,[%a2]
80003558:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000355c:	a6 32       	or %d2,%d3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000355e:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80003560:	54 22       	ld.w %d2,[%a2]
80003562:	6f 02 ff 7f 	jz.t %d2,0,80003560 <IfxScuWdt_setCpuEndinit+0x42>
}
80003566:	00 90       	ret 

80003568 <IfxScuWdt_setSafetyEndinit>:


void IfxScuWdt_setSafetyEndinit(uint16 password)
{
80003568:	40 ae       	mov.aa %a14,%sp
8000356a:	37 04 70 40 	extr.u %d4,%d4,0,16
    if (SCU_WDTS_CON0.B.LCK)
8000356e:	91 30 00 2f 	movh.a %a2,61443
80003572:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
80003576:	54 22       	ld.w %d2,[%a2]
80003578:	6f 12 0b 00 	jz.t %d2,1,8000358e <IfxScuWdt_setSafetyEndinit+0x26>
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000357c:	8f 24 00 30 	sh %d3,%d4,2
                          (0 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80003580:	8f 13 40 31 	or %d3,%d3,1
                          (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003584:	54 22       	ld.w %d2,[%a2]
80003586:	b7 02 10 20 	insert %d2,%d2,0,0,16
                          (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000358a:	a6 32       	or %d2,%d3
        SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
8000358c:	74 22       	st.w [%a2],%d2
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
8000358e:	8f 24 00 30 	sh %d3,%d4,2
                      (1 << IFX_SCU_WDTS_CON0_LCK_OFF) |
80003592:	8f 33 40 31 	or %d3,%d3,3
                      (SCU_WDTS_CON0.B.REL << IFX_SCU_WDTS_CON0_REL_OFF);
80003596:	91 30 00 2f 	movh.a %a2,61443
8000359a:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
8000359e:	54 22       	ld.w %d2,[%a2]
800035a0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                      (password << IFX_SCU_WDTS_CON0_PW_OFF) |
800035a4:	a6 32       	or %d2,%d3
    SCU_WDTS_CON0.U = (1 << IFX_SCU_WDTS_CON0_ENDINIT_OFF) |
800035a6:	74 22       	st.w [%a2],%d2
    while (SCU_WDTS_CON0.B.ENDINIT == 0)
800035a8:	91 30 00 2f 	movh.a %a2,61443
800035ac:	d9 22 30 36 	lea %a2,[%a2]24816 <f00360f0 <_SMALL_DATA4_+0x6002e0f0>>
800035b0:	54 22       	ld.w %d2,[%a2]
800035b2:	6f 02 fb 7f 	jz.t %d2,0,800035a8 <IfxScuWdt_setSafetyEndinit+0x40>
    IfxScuWdt_setSafetyEndinitInline(password);
}
800035b6:	00 90       	ret 

800035b8 <IfxPort_setPinMode>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
800035b8:	40 ae       	mov.aa %a14,%sp
800035ba:	40 4c       	mov.aa %a12,%a4
800035bc:	02 5a       	mov %d10,%d5
800035be:	8f f4 0f c1 	and %d12,%d4,255
    volatile Ifx_P_IOCR0 *iocr      = &(port->IOCR0);
800035c2:	80 42       	mov.d %d2,%a4
800035c4:	1b 02 01 b0 	addi %d11,%d2,16
    uint8                 iocrIndex = (pinIndex / 4);
800035c8:	37 04 66 91 	extr.u %d9,%d4,2,6
    uint8                 shift     = (pinIndex & 0x3U) * 8;
800035cc:	8f 34 00 41 	and %d4,%d4,3
800035d0:	8f 34 00 80 	sh %d8,%d4,3

    if (port == &MODULE_P40)
800035d4:	7b 40 00 2f 	movh %d2,61444
800035d8:	1b 02 00 2e 	addi %d2,%d2,-8192
800035dc:	80 43       	mov.d %d3,%a4
800035de:	5f 23 12 00 	jeq %d3,%d2,80003602 <IfxPort_setPinMode+0x4a>
        IfxScuWdt_clearCpuEndinit(passwd);
        port->PDISC.U &= ~(1 << pinIndex);
        IfxScuWdt_setCpuEndinit(passwd);
    }

    __ldmst(&iocr[iocrIndex].U, (0xFFUL << shift), (mode << shift));
800035e2:	8f 29 00 20 	sh %d2,%d9,2
800035e6:	60 b2       	mov.a %a2,%d11
800035e8:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800035ec:	3b f0 0f 40 	mov %d4,255
800035f0:	0f 84 00 40 	sh %d4,%d4,%d8
800035f4:	0f 8a 00 20 	sh %d2,%d10,%d8
                     ::"a"(address), "d"(mask), "d"((long long)value));
800035f8:	82 03       	mov %d3,0
    __asm__ volatile("mov %H2,%1 \n\
800035fa:	02 43       	mov %d3,%d4
800035fc:	49 22 40 08 	ldmst [%a2]0,%e2
}
80003600:	00 90       	ret 
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80003602:	6d ff 71 ff 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80003606:	02 2d       	mov %d13,%d2
        IfxScuWdt_clearCpuEndinit(passwd);
80003608:	02 24       	mov %d4,%d2
8000360a:	6d ff 04 fe 	call 80003212 <IfxScuWdt_clearCpuEndinit>
        port->PDISC.U &= ~(1 << pinIndex);
8000360e:	d9 c2 20 10 	lea %a2,[%a12]96
80003612:	19 c2 20 10 	ld.w %d2,[%a12]96
80003616:	d7 02 01 2c 	insert %d2,%d2,0,%d12,1
8000361a:	74 22       	st.w [%a2],%d2
        IfxScuWdt_setCpuEndinit(passwd);
8000361c:	02 d4       	mov %d4,%d13
8000361e:	6d ff 80 ff 	call 8000351e <IfxScuWdt_setCpuEndinit>
80003622:	1d ff e0 ff 	j 800035e2 <IfxPort_setPinMode+0x2a>

80003626 <IfxPort_setPinPadDriver>:
    IfxScuWdt_setCpuEndinit(passwd);
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
80003626:	40 ae       	mov.aa %a14,%sp
80003628:	80 4b       	mov.d %d11,%a4
8000362a:	02 5a       	mov %d10,%d5
8000362c:	8f f4 0f 81 	and %d8,%d4,255
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
80003630:	6d ff 5a ff 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80003634:	02 29       	mov %d9,%d2

    IfxScuWdt_clearCpuEndinit(passwd);
80003636:	02 24       	mov %d4,%d2
80003638:	6d ff ed fd 	call 80003212 <IfxScuWdt_clearCpuEndinit>
    {
        volatile uint32 *pdr      = (volatile uint32 *)&(port->PDR0.U);
8000363c:	1b 0b 04 40 	addi %d4,%d11,64
        uint8            pdrIndex = (pinIndex / 8);
80003640:	8f d8 1f 20 	sh %d2,%d8,-3
        uint8            shift    = (pinIndex & 0x7U) * 4;
80003644:	8f 78 00 31 	and %d3,%d8,7
80003648:	06 23       	sh %d3,2
        __ldmst(&(pdr[pdrIndex]), (0xFUL << shift), (padDriver << shift));
8000364a:	06 22       	sh %d2,2
8000364c:	60 42       	mov.a %a2,%d4
8000364e:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
80003652:	3b f0 00 20 	mov %d2,15
80003656:	0f 32 00 20 	sh %d2,%d2,%d3
8000365a:	0f 3a 00 30 	sh %d3,%d10,%d3
                     ::"a"(address), "d"(mask), "d"((long long)value));
8000365e:	53 13 40 60 	mul.u %e6,%d3,1
    __asm__ volatile("mov %H2,%1 \n\
80003662:	02 27       	mov %d7,%d2
80003664:	49 46 40 08 	ldmst [%a4]0,%e6
    }
    IfxScuWdt_setCpuEndinit(passwd);
80003668:	02 94       	mov %d4,%d9
8000366a:	6d ff 5a ff 	call 8000351e <IfxScuWdt_setCpuEndinit>
}
8000366e:	00 90       	ret 

80003670 <IfxGtm_Tom_Timer_acknowledgeTimerIrq>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxGtm_Tom_Timer_acknowledgeTimerIrq(IfxGtm_Tom_Timer *driver)
{
80003670:	40 ae       	mov.aa %a14,%sp
    boolean event;

    event = IfxGtm_Tom_Ch_isZeroNotification(driver->tom, driver->timerChannel);
80003672:	19 43 14 00 	ld.w %d3,[%a4]20
80003676:	19 42 24 00 	ld.w %d2,[%a4]36
}


IFX_INLINE Ifx_GTM_TOM_CH *IfxGtm_Tom_Ch_getChannelPointer(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000367a:	06 62       	sh %d2,6
8000367c:	60 32       	mov.a %a2,%d3
8000367e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0

IFX_INLINE boolean IfxGtm_Tom_Ch_isZeroNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel)
{
    boolean         notify;
    Ifx_GTM_TOM_CH *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);
    notify = (tomCh->IRQ_NOTIFY.B.CCU0TC != 0u) ? TRUE : FALSE;
80003682:	d9 23 1c 00 	lea %a3,[%a2]28
80003686:	19 22 1c 00 	ld.w %d2,[%a2]28
8000368a:	6f 02 08 00 	jz.t %d2,0,8000369a <IfxGtm_Tom_Timer_acknowledgeTimerIrq+0x2a>
    tomCh->IRQ_NOTIFY.B.CCU0TC = 1;
8000368e:	54 32       	ld.w %d2,[%a3]
80003690:	b7 12 01 20 	insert %d2,%d2,1,0,1
80003694:	74 32       	st.w [%a3],%d2
    notify = (tomCh->IRQ_NOTIFY.B.CCU0TC != 0u) ? TRUE : FALSE;
80003696:	82 12       	mov %d2,1
}
80003698:	00 90       	ret 
    notify = (tomCh->IRQ_NOTIFY.B.CCU0TC != 0u) ? TRUE : FALSE;
8000369a:	82 02       	mov %d2,0
    }
    else
    {}

    return event;
}
8000369c:	00 90       	ret 

8000369e <IfxGtm_Tom_Timer_applyUpdate>:
    }
}


void IfxGtm_Tom_Timer_applyUpdate(IfxGtm_Tom_Timer *driver)
{
8000369e:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[0], driver->tgcGlobalControlApplyUpdate[0]);
800036a0:	99 42 18 00 	ld.a %a2,[%a4]24
}


IFX_INLINE void IfxGtm_Tom_Tgc_writeGlobalControl(Ifx_GTM_TOM_TGC *tgc, uint32 control)
{
    tgc->GLB_CTRL.U = control;
800036a4:	19 42 3c 00 	ld.w %d2,[%a4]60
800036a8:	74 22       	st.w [%a2],%d2

    if (driver->tgc[1])
800036aa:	99 42 1c 00 	ld.a %a2,[%a4]28
800036ae:	bd 02 05 00 	jz.a %a2,800036b8 <IfxGtm_Tom_Timer_applyUpdate+0x1a>
    {
        IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[1], driver->tgcGlobalControlApplyUpdate[1]);  /* Note: Write of 0 value has no effect */
800036b2:	19 42 00 10 	ld.w %d2,[%a4]64
800036b6:	74 22       	st.w [%a2],%d2
    }
}
800036b8:	00 90       	ret 

800036ba <IfxGtm_Tom_Timer_disableUpdate>:


void IfxGtm_Tom_Timer_disableUpdate(IfxGtm_Tom_Timer *driver)
{
800036ba:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[0], driver->tgcGlobalControlDisableUpdate[0]);
800036bc:	99 42 18 00 	ld.a %a2,[%a4]24
800036c0:	19 42 34 00 	ld.w %d2,[%a4]52
800036c4:	74 22       	st.w [%a2],%d2

    if (driver->tgc[1])
800036c6:	99 42 1c 00 	ld.a %a2,[%a4]28
800036ca:	bd 02 05 00 	jz.a %a2,800036d4 <IfxGtm_Tom_Timer_disableUpdate+0x1a>
    {
        IfxGtm_Tom_Tgc_writeGlobalControl(driver->tgc[1], driver->tgcGlobalControlDisableUpdate[1]); /* Note: Write of 0 value has no effect */
800036ce:	19 42 38 00 	ld.w %d2,[%a4]56
800036d2:	74 22       	st.w [%a2],%d2
    }
}
800036d4:	00 90       	ret 

800036d6 <IfxGtm_Tom_Timer_getPeriod>:
    return driver->offset;
}


Ifx_TimerValue IfxGtm_Tom_Timer_getPeriod(IfxGtm_Tom_Timer *driver)
{
800036d6:	40 ae       	mov.aa %a14,%sp
    return driver->base.period;
}
800036d8:	54 42       	ld.w %d2,[%a4]
800036da:	00 90       	ret 

800036dc <IfxGtm_Tom_Timer_setPeriod>:
    return status;
}


boolean IfxGtm_Tom_Timer_setPeriod(IfxGtm_Tom_Timer *driver, Ifx_TimerValue period)
{
800036dc:	40 ae       	mov.aa %a14,%sp
    driver->base.period = period;
800036de:	74 44       	st.w [%a4],%d4
    IfxGtm_Tom_Ch_setCompareZeroShadow(driver->tom, driver->timerChannel, (uint16)period);
800036e0:	19 43 24 00 	ld.w %d3,[%a4]36
800036e4:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800036e8:	06 63       	sh %d3,6
800036ea:	99 42 14 00 	ld.a %a2,[%a4]20
800036ee:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->SR0.U = shadowZero;
800036f2:	59 24 04 00 	st.w [%a2]4,%d4

    if (driver->triggerChannel != driver->timerChannel)
800036f6:	19 42 28 00 	ld.w %d2,[%a4]40
800036fa:	19 43 24 00 	ld.w %d3,[%a4]36
800036fe:	5f 32 0a 00 	jeq %d2,%d3,80003712 <IfxGtm_Tom_Timer_setPeriod+0x36>
    {
        IfxGtm_Tom_Ch_setCompareZeroShadow(driver->tom, driver->triggerChannel, (uint16)period);
80003702:	19 43 14 00 	ld.w %d3,[%a4]20
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003706:	06 62       	sh %d2,6
80003708:	60 32       	mov.a %a2,%d3
8000370a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    tomCh->SR0.U = shadowZero;
8000370e:	59 24 04 00 	st.w [%a2]4,%d4
    }

    return TRUE;
}
80003712:	82 12       	mov %d2,1
80003714:	00 90       	ret 

80003716 <IfxGtm_Tom_Timer_setFrequency>:
{
80003716:	40 ae       	mov.aa %a14,%sp
    Ifx_TimerValue period = IfxStdIf_Timer_sToTick(driver->base.clockFreq, 1.0f / frequency);
80003718:	19 43 08 00 	ld.w %d3,[%a4]8
8000371c:	7b 00 f8 23 	movh %d2,16256
80003720:	4b 42 51 20 	div.f %d2,%d2,%d4
 * \param  seconds time value in seconds to be converted
 * \return Return the converted time in timer ticks
 */
IFX_INLINE Ifx_TimerValue IfxStdIf_Timer_sToTick(float32 clockFreq, float32 seconds)
{
    return seconds * clockFreq;
80003724:	4b 23 41 20 	mul.f %d2,%d3,%d2
80003728:	4b 02 71 41 	ftouz %d4,%d2
    if ((period & (0xFFFF << 16)) != 0)
8000372c:	b7 04 10 20 	insert %d2,%d4,0,0,16
80003730:	df 02 04 00 	jeq %d2,0,80003738 <IfxGtm_Tom_Timer_setFrequency+0x22>
        status = FALSE;
80003734:	82 02       	mov %d2,0
}
80003736:	00 90       	ret 
        IfxGtm_Tom_Timer_setPeriod(driver, period);
80003738:	6d ff d2 ff 	call 800036dc <IfxGtm_Tom_Timer_setPeriod>
    boolean        status = TRUE;
8000373c:	82 12       	mov %d2,1
8000373e:	00 90       	ret 

80003740 <IfxGtm_Tom_Timer_setTrigger>:
    IfxGtm_Tom_Ch_setOneShotMode(driver->tom, driver->timerChannel, enabled);
}


void IfxGtm_Tom_Timer_setTrigger(IfxGtm_Tom_Timer *driver, Ifx_TimerValue triggerPoint)
{
80003740:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_Ch_setCompareOneShadow(driver->tom, driver->triggerChannel, (uint16)triggerPoint + 1);
80003742:	19 43 14 00 	ld.w %d3,[%a4]20
80003746:	19 42 28 00 	ld.w %d2,[%a4]40
8000374a:	37 04 70 40 	extr.u %d4,%d4,0,16
8000374e:	c2 14       	add %d4,1
80003750:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003754:	06 62       	sh %d2,6
80003756:	60 32       	mov.a %a2,%d3
80003758:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    tomCh->SR1.U = shadowOne;
8000375c:	59 24 08 00 	st.w [%a2]8,%d4
}
80003760:	00 90       	ret 

80003762 <IfxGtm_Tom_Timer_run>:
{
80003762:	40 ae       	mov.aa %a14,%sp
80003764:	40 4c       	mov.aa %a12,%a4
    IfxGtm_Tom_Tgc_enableChannels(driver->tgc[0], driver->channelsMask[0], 0, TRUE);
80003766:	99 4d 18 00 	ld.a %a13,[%a4]24
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
8000376a:	82 06       	mov %d6,0
8000376c:	82 05       	mov %d5,0
8000376e:	b9 44 2c 00 	ld.hu %d4,[%a4]44
80003772:	6d 00 f3 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
80003776:	59 d2 00 10 	st.w [%a13]64,%d2
        tgc->ENDIS_STAT.U = value;
8000377a:	59 d2 04 10 	st.w [%a13]68,%d2
    if (driver->tgc[1])
8000377e:	99 cd 1c 00 	ld.a %a13,[%a12]28
80003782:	bd 0d 0c 00 	jz.a %a13,8000379a <IfxGtm_Tom_Timer_run+0x38>
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
80003786:	82 06       	mov %d6,0
80003788:	82 05       	mov %d5,0
8000378a:	b9 c4 2e 00 	ld.hu %d4,[%a12]46
8000378e:	6d 00 e5 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
80003792:	59 d2 00 10 	st.w [%a13]64,%d2
        tgc->ENDIS_STAT.U = value;
80003796:	59 d2 04 10 	st.w [%a13]68,%d2
}
8000379a:	00 90       	ret 

8000379c <IfxGtm_Tom_Timer_updateInputFrequency>:
    }
}


void IfxGtm_Tom_Timer_updateInputFrequency(IfxGtm_Tom_Timer *driver)
{
8000379c:	40 ae       	mov.aa %a14,%sp
8000379e:	20 18       	sub.a %sp,24
800037a0:	40 4c       	mov.aa %a12,%a4
    driver->base.clockFreq = IfxGtm_Tom_Ch_getClockFrequency(driver->gtm, driver->tom, driver->timerChannel);
800037a2:	99 44 10 00 	ld.a %a4,[%a4]16
800037a6:	19 c2 24 00 	ld.w %d2,[%a12]36
    IfxGtm_Cmu_Fxclk     clkIndex[5] = {
800037aa:	91 00 00 26 	movh.a %a2,24576
800037ae:	d9 22 08 10 	lea %a2,[%a2]72 <60000048 <LCF_DSPR1_START+0x48>>
800037b2:	d9 e3 ec ff 	lea %a3,[%a14]-20 <60000048 <LCF_DSPR1_START+0x48>>
800037b6:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
800037ba:	89 34 48 01 	st.d [%a3+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
800037be:	09 24 48 01 	ld.d %e4,[%a2+]8 <60000008 <LCF_DSPR1_START+0x8>>
800037c2:	89 34 48 01 	st.d [%a3+]8 <60000008 <LCF_DSPR1_START+0x8>>,%e4
800037c6:	44 24       	ld.w %d4,[%a2+]
800037c8:	64 34       	st.w [%a3+],%d4
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800037ca:	06 62       	sh %d2,6
800037cc:	99 c2 14 00 	ld.a %a2,[%a12]20
800037d0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    clk = (IfxGtm_Tom_Ch_ClkSrc)tomCh->CTRL.B.CLK_SRC_SR;
800037d4:	54 22       	ld.w %d2,[%a2]
800037d6:	37 02 63 26 	extr.u %d2,%d2,12,3
    if (clk == IfxGtm_Tom_Ch_ClkSrc_noClock)
800037da:	df 52 06 80 	jne %d2,5,800037e6 <IfxGtm_Tom_Timer_updateInputFrequency+0x4a>
        return (float32)0.0f;
800037de:	82 02       	mov %d2,0
800037e0:	59 c2 08 00 	st.w [%a12]8,%d2
}
800037e4:	00 90       	ret 
        return IfxGtm_Cmu_getFxClkFrequency(gtm, clkIndex[clk], TRUE);
800037e6:	06 22       	sh %d2,2
800037e8:	01 e2 00 26 	addsc.a %a2,%a14,%d2,0
800037ec:	82 15       	mov %d5,1
800037ee:	19 24 ec ff 	ld.w %d4,[%a2]-20
800037f2:	6d 00 b1 09 	call 80004b54 <IfxGtm_Cmu_getFxClkFrequency>
800037f6:	1d ff f5 ff 	j 800037e0 <IfxGtm_Tom_Timer_updateInputFrequency+0x44>

800037fa <IfxGtm_Tom_Timer_addToChannelMask>:
{
800037fa:	40 ae       	mov.aa %a14,%sp
800037fc:	40 4c       	mov.aa %a12,%a4
    if (driver->timerChannel <= IfxGtm_Tom_Ch_7)
800037fe:	19 42 24 00 	ld.w %d2,[%a4]36
80003802:	8b 82 80 22 	ge %d2,%d2,8
80003806:	df 02 39 80 	jne %d2,0,80003878 <IfxGtm_Tom_Timer_addToChannelMask+0x7e>
        if (channel <= IfxGtm_Tom_Ch_7)
8000380a:	8b 84 80 22 	ge %d2,%d4,8
8000380e:	df 02 1b 80 	jne %d2,0,80003844 <IfxGtm_Tom_Timer_addToChannelMask+0x4a>
            driver->channelsMask[0]                 |= 1 << channel;
80003812:	c9 42 2c 00 	ld.h %d2,[%a4]44
80003816:	d7 12 01 24 	insert %d2,%d2,1,%d4,1
8000381a:	37 02 70 50 	extr.u %d5,%d2,0,16
8000381e:	f9 45 2c 00 	st.h [%a4]44,%d5
            driver->tgcGlobalControlDisableUpdate[0] = IfxGtm_Tom_Tgc_buildFeature(0, driver->channelsMask[0], IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80003822:	3b 00 01 60 	mov %d6,16
80003826:	82 04       	mov %d4,0
80003828:	6d 00 98 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
8000382c:	59 c2 34 00 	st.w [%a12]52,%d2
            driver->tgcGlobalControlApplyUpdate[0]   = IfxGtm_Tom_Tgc_buildFeature(driver->channelsMask[0], 0, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80003830:	3b 00 01 60 	mov %d6,16
80003834:	82 05       	mov %d5,0
80003836:	b9 c4 2c 00 	ld.hu %d4,[%a12]44
8000383a:	6d 00 8f 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
8000383e:	59 c2 3c 00 	st.w [%a12]60,%d2
80003842:	00 90       	ret 
            driver->channelsMask[1]                 |= 1 << (channel - IfxGtm_Tom_Ch_8);
80003844:	c2 84       	add %d4,-8
80003846:	c9 42 2e 00 	ld.h %d2,[%a4]46
8000384a:	d7 12 01 24 	insert %d2,%d2,1,%d4,1
8000384e:	37 02 70 50 	extr.u %d5,%d2,0,16
80003852:	f9 45 2e 00 	st.h [%a4]46,%d5
            driver->tgcGlobalControlDisableUpdate[1] = IfxGtm_Tom_Tgc_buildFeature(0, driver->channelsMask[1], IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80003856:	3b 00 01 60 	mov %d6,16
8000385a:	82 04       	mov %d4,0
8000385c:	6d 00 7e 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
80003860:	59 c2 38 00 	st.w [%a12]56,%d2
            driver->tgcGlobalControlApplyUpdate[1]   = IfxGtm_Tom_Tgc_buildFeature(driver->channelsMask[1], 0, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80003864:	3b 00 01 60 	mov %d6,16
80003868:	82 05       	mov %d5,0
8000386a:	b9 c4 2e 00 	ld.hu %d4,[%a12]46
8000386e:	6d 00 75 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
80003872:	59 c2 00 10 	st.w [%a12]64,%d2
80003876:	00 90       	ret 
        driver->channelsMask[0]                 |= 1 << (channel - IfxGtm_Tom_Ch_8);
80003878:	c2 84       	add %d4,-8
8000387a:	c9 42 2c 00 	ld.h %d2,[%a4]44
8000387e:	d7 12 01 24 	insert %d2,%d2,1,%d4,1
80003882:	37 02 70 50 	extr.u %d5,%d2,0,16
80003886:	f9 45 2c 00 	st.h [%a4]44,%d5
        driver->tgcGlobalControlDisableUpdate[0] = IfxGtm_Tom_Tgc_buildFeature(0, driver->channelsMask[0], IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
8000388a:	3b 00 01 60 	mov %d6,16
8000388e:	82 04       	mov %d4,0
80003890:	6d 00 64 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
80003894:	59 c2 34 00 	st.w [%a12]52,%d2
        driver->tgcGlobalControlApplyUpdate[0]   = IfxGtm_Tom_Tgc_buildFeature(driver->channelsMask[0], 0, IFX_GTM_TOM_TGC0_GLB_CTRL_UPEN_CTRL0_OFF);
80003898:	3b 00 01 60 	mov %d6,16
8000389c:	82 05       	mov %d5,0
8000389e:	b9 c4 2c 00 	ld.hu %d4,[%a12]44
800038a2:	6d 00 5b 0a 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
800038a6:	59 c2 3c 00 	st.w [%a12]60,%d2
}
800038aa:	00 90       	ret 

800038ac <IfxGtm_Tom_Timer_getOffset>:
{
800038ac:	40 ae       	mov.aa %a14,%sp
}
800038ae:	19 42 30 00 	ld.w %d2,[%a4]48
800038b2:	00 90       	ret 

800038b4 <IfxGtm_Tom_Timer_init>:
{
800038b4:	40 ae       	mov.aa %a14,%sp
800038b6:	40 4c       	mov.aa %a12,%a4
800038b8:	40 5d       	mov.aa %a13,%a5
    driver->gtm          = config->gtm;
800038ba:	d9 53 34 00 	lea %a3,[%a5]52
800038be:	19 52 34 00 	ld.w %d2,[%a5]52
800038c2:	59 42 10 00 	st.w [%a4]16,%d2
    driver->tomIndex     = config->tom;
800038c6:	19 52 38 00 	ld.w %d2,[%a5]56
800038ca:	59 42 20 00 	st.w [%a4]32,%d2
    driver->tom          = &config->gtm->TOM[config->tom];
800038ce:	1b 02 01 20 	addi %d2,%d2,16
800038d2:	8f b2 00 20 	sh %d2,%d2,11
800038d6:	54 33       	ld.w %d3,[%a3]
800038d8:	0b 23 00 50 	add %d5,%d3,%d2
800038dc:	59 45 14 00 	st.w [%a4]20,%d5
    driver->timerChannel = config->timerChannel;
800038e0:	19 54 3c 00 	ld.w %d4,[%a5]60
800038e4:	59 44 24 00 	st.w [%a4]36,%d4
    base->triggerEnabled = config->base.trigger.enabled;
800038e8:	39 52 10 00 	ld.bu %d2,[%a5]16
800038ec:	e9 42 04 00 	st.b [%a4]4,%d2
    if (base->triggerEnabled)
800038f0:	df 02 0d 00 	jeq %d2,0,8000390a <IfxGtm_Tom_Timer_init+0x56>
        if (config->triggerOut != NULL_PTR)
800038f4:	99 52 00 10 	ld.a %a2,[%a5]64
800038f8:	bd 02 5b 00 	jz.a %a2,800039ae <IfxGtm_Tom_Timer_init+0xfa>
            driver->triggerChannel = config->triggerOut->channel;
800038fc:	19 22 04 00 	ld.w %d2,[%a2]4
80003900:	59 42 28 00 	st.w [%a4]40,%d2
    boolean                result = TRUE;
80003904:	82 18       	mov %d8,1
80003906:	1d 00 05 00 	j 80003910 <IfxGtm_Tom_Timer_init+0x5c>
        driver->triggerChannel = driver->timerChannel; // Set to timer channel to disable its use
8000390a:	59 44 28 00 	st.w [%a4]40,%d4
    boolean                result = TRUE;
8000390e:	82 18       	mov %d8,1
    if (config->timerChannel <= 7)
80003910:	19 d2 3c 00 	ld.w %d2,[%a13]60
80003914:	8b 82 80 22 	ge %d2,%d2,8
80003918:	df 02 4e 80 	jne %d2,0,800039b4 <IfxGtm_Tom_Timer_init+0x100>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC0_GLB_CTRL;
8000391c:	1b 05 03 20 	addi %d2,%d5,48
        driver->tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 0);
80003920:	59 c2 18 00 	st.w [%a12]24,%d2
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC1_GLB_CTRL;
80003924:	1b 05 23 20 	addi %d2,%d5,560
        driver->tgc[1] = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 1);
80003928:	59 c2 1c 00 	st.w [%a12]28,%d2
    driver->channelsMask[0]                  = 0;
8000392c:	82 02       	mov %d2,0
8000392e:	f9 c2 2c 00 	st.h [%a12]44,%d2
    driver->tgcGlobalControlApplyUpdate[0]   = 0;
80003932:	82 03       	mov %d3,0
80003934:	59 c3 3c 00 	st.w [%a12]60,%d3
    driver->tgcGlobalControlDisableUpdate[0] = 0;
80003938:	59 c3 34 00 	st.w [%a12]52,%d3
    driver->channelsMask[1]                  = 0;
8000393c:	f9 c3 2e 00 	st.h [%a12]46,%d3
    driver->tgcGlobalControlApplyUpdate[1]   = 0;
80003940:	59 c3 00 10 	st.w [%a12]64,%d3
    driver->tgcGlobalControlDisableUpdate[1] = 0;
80003944:	59 c3 38 00 	st.w [%a12]56,%d3
    IfxGtm_Tom_Ch_setClockSource(driver->tom, driver->timerChannel, config->clock);
80003948:	19 d6 04 10 	ld.w %d6,[%a13]68
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000394c:	06 64       	sh %d4,6
8000394e:	60 52       	mov.a %a2,%d5
80003950:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
80003954:	54 23       	ld.w %d3,[%a2]
80003956:	37 63 03 36 	insert %d3,%d3,%d6,12,3
8000395a:	74 23       	st.w [%a2],%d3
    IfxGtm_Tom_Ch_setTriggerOutput(driver->tom, driver->timerChannel, IfxGtm_Tom_Ch_OutputTrigger_generate);
8000395c:	19 c2 24 00 	ld.w %d2,[%a12]36
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003960:	06 62       	sh %d2,6
80003962:	99 c2 14 00 	ld.a %a2,[%a12]20
80003966:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
8000396a:	54 23       	ld.w %d3,[%a2]
8000396c:	b7 13 01 3c 	insert %d3,%d3,1,24,1
80003970:	74 23       	st.w [%a2],%d3
    IfxGtm_Tom_Timer_updateInputFrequency(driver);
80003972:	40 c4       	mov.aa %a4,%a12
80003974:	6d ff 14 ff 	call 8000379c <IfxGtm_Tom_Timer_updateInputFrequency>
    if ((config->base.minResolution > 0) && ((1.0f / base->clockFreq) > config->base.minResolution))
80003978:	19 d2 0c 00 	ld.w %d2,[%a13]12
8000397c:	82 03       	mov %d3,0
8000397e:	4b 32 01 30 	cmp.f %d3,%d2,%d3
80003982:	6f 23 0d 00 	jz.t %d3,2,8000399c <IfxGtm_Tom_Timer_init+0xe8>
80003986:	19 c4 08 00 	ld.w %d4,[%a12]8
8000398a:	7b 00 f8 33 	movh %d3,16256
8000398e:	4b 43 51 30 	div.f %d3,%d3,%d4
80003992:	4b 32 01 20 	cmp.f %d2,%d2,%d3
80003996:	6f 02 03 00 	jz.t %d2,0,8000399c <IfxGtm_Tom_Timer_init+0xe8>
        result = FALSE;
8000399a:	82 08       	mov %d8,0
    result &= IfxGtm_Tom_Timer_setFrequency(driver, config->base.frequency);
8000399c:	54 d4       	ld.w %d4,[%a13]
8000399e:	40 c4       	mov.aa %a4,%a12
800039a0:	6d ff bb fe 	call 80003716 <IfxGtm_Tom_Timer_setFrequency>
800039a4:	26 28       	and %d8,%d2
    if (result == TRUE)
800039a6:	df 08 10 80 	jne %d8,0,800039c6 <IfxGtm_Tom_Timer_init+0x112>
}
800039aa:	02 82       	mov %d2,%d8
800039ac:	00 90       	ret 
            result = FALSE;
800039ae:	82 08       	mov %d8,0
800039b0:	1d ff b0 ff 	j 80003910 <IfxGtm_Tom_Timer_init+0x5c>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC1_GLB_CTRL;
800039b4:	1b 05 23 20 	addi %d2,%d5,560
        driver->tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 1);
800039b8:	59 c2 18 00 	st.w [%a12]24,%d2
        driver->tgc[1] = NULL_PTR; /* NOTE currently no concatenation between TOMs */
800039bc:	82 02       	mov %d2,0
800039be:	59 c2 1c 00 	st.w [%a12]28,%d2
800039c2:	1d ff b5 ff 	j 8000392c <IfxGtm_Tom_Timer_init+0x78>
        driver->offset = IfxStdIf_Timer_sToTick(driver->base.clockFreq, 1.0f / config->base.frequency * config->base.startOffset);
800039c6:	19 c3 08 00 	ld.w %d3,[%a12]8
800039ca:	54 d4       	ld.w %d4,[%a13]
800039cc:	7b 00 f8 23 	movh %d2,16256
800039d0:	4b 42 51 20 	div.f %d2,%d2,%d4
800039d4:	19 d4 30 00 	ld.w %d4,[%a13]48
800039d8:	4b 42 41 20 	mul.f %d2,%d2,%d4
800039dc:	4b 23 41 20 	mul.f %d2,%d3,%d2
800039e0:	4b 02 71 21 	ftouz %d2,%d2
800039e4:	59 c2 30 00 	st.w [%a12]48,%d2
        IfxGtm_Tom_Ch_setCounterValue(driver->tom, driver->timerChannel, driver->offset);
800039e8:	19 c3 24 00 	ld.w %d3,[%a12]36
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800039ec:	06 63       	sh %d3,6
800039ee:	99 c2 14 00 	ld.a %a2,[%a12]20
800039f2:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CN0.U = value;
800039f6:	59 22 14 00 	st.w [%a2]20,%d2
        maskShift = (config->timerChannel <= 7) ? 0 : 8;
800039fa:	19 d2 3c 00 	ld.w %d2,[%a13]60
800039fe:	8b 82 80 22 	ge %d2,%d2,8
80003a02:	df 02 53 80 	jne %d2,0,80003aa8 <IfxGtm_Tom_Timer_init+0x1f4>
80003a06:	82 09       	mov %d9,0
        IfxGtm_Tom_Timer_addToChannelMask(driver, driver->timerChannel);
80003a08:	19 c4 24 00 	ld.w %d4,[%a12]36
80003a0c:	40 c4       	mov.aa %a4,%a12
80003a0e:	6d ff f6 fe 	call 800037fa <IfxGtm_Tom_Timer_addToChannelMask>
        if (base->triggerEnabled)
80003a12:	39 c2 04 00 	ld.bu %d2,[%a12]4
80003a16:	df 02 3a 00 	jeq %d2,0,80003a8a <IfxGtm_Tom_Timer_init+0x1d6>
            IfxGtm_Tom_Ch triggerChannel     = driver->triggerChannel;
80003a1a:	19 c3 28 00 	ld.w %d3,[%a12]40
            uint16        triggerChannelMask = 1 << (triggerChannel - maskShift);
80003a1e:	0b 93 80 20 	sub %d2,%d3,%d9
80003a22:	82 19       	mov %d9,1
80003a24:	0f 29 00 90 	sh %d9,%d9,%d2
            IfxGtm_Tom_Ch_setSignalLevel(driver->tom, triggerChannel, config->base.trigger.risingEdgeAtPeriod ? Ifx_ActiveState_high : Ifx_ActiveState_low);
80003a28:	39 d2 28 00 	ld.bu %d2,[%a13]40
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003a2c:	8f 63 00 40 	sh %d4,%d3,6
80003a30:	99 c2 14 00 	ld.a %a2,[%a12]20
80003a34:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003a38:	df 02 3c 80 	jne %d2,0,80003ab0 <IfxGtm_Tom_Timer_init+0x1fc>
80003a3c:	82 05       	mov %d5,0
80003a3e:	54 22       	ld.w %d2,[%a2]
80003a40:	67 52 0b 20 	ins.t %d2,%d2,11,%d5,0
80003a44:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003a46:	99 c2 14 00 	ld.a %a2,[%a12]20
80003a4a:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CN0.U = value;
80003a4e:	19 c2 30 00 	ld.w %d2,[%a12]48
80003a52:	59 22 14 00 	st.w [%a2]20,%d2
            if (triggerChannel != driver->timerChannel)
80003a56:	19 c2 24 00 	ld.w %d2,[%a12]36
80003a5a:	5f 32 2e 80 	jne %d2,%d3,80003ab6 <IfxGtm_Tom_Timer_init+0x202>
            IfxGtm_Tom_Tgc_enableChannelsOutput(driver->tgc[0], triggerChannelMask, 0, FALSE);
80003a5e:	cc c6       	ld.a %a15,[%a12]24
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);
80003a60:	82 06       	mov %d6,0
80003a62:	82 05       	mov %d5,0
80003a64:	37 09 70 40 	extr.u %d4,%d9,0,16
80003a68:	6d 00 78 09 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->OUTEN_CTRL.U = value;
80003a6c:	59 f2 08 10 	st.w [%a15]72,%d2
            if ((config->base.trigger.outputEnabled) && (config->initPins == TRUE))
80003a70:	39 d2 29 00 	ld.bu %d2,[%a13]41
80003a74:	df 02 06 00 	jeq %d2,0,80003a80 <IfxGtm_Tom_Timer_init+0x1cc>
80003a78:	39 d2 10 10 	ld.bu %d2,[%a13]80
80003a7c:	df 12 47 00 	jeq %d2,1,80003b0a <IfxGtm_Tom_Timer_init+0x256>
            IfxGtm_Tom_Timer_setTrigger(driver, config->base.trigger.triggerPoint);
80003a80:	19 d4 14 00 	ld.w %d4,[%a13]20
80003a84:	40 c4       	mov.aa %a4,%a12
80003a86:	6d ff 5d fe 	call 80003740 <IfxGtm_Tom_Timer_setTrigger>
            boolean                timerHasIrq   = config->base.isrPriority > 0;
80003a8a:	b9 d2 04 00 	ld.hu %d2,[%a13]4
80003a8e:	8b 02 20 62 	ne %d6,%d2,0
            boolean                triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;
80003a92:	b9 d3 18 00 	ld.hu %d3,[%a13]24
80003a96:	df 03 44 00 	jeq %d3,0,80003b1e <IfxGtm_Tom_Timer_init+0x26a>
80003a9a:	39 c3 04 00 	ld.bu %d3,[%a12]4
80003a9e:	df 03 ce 80 	jne %d3,0,80003c3a <IfxGtm_Tom_Timer_init+0x386>
80003aa2:	82 05       	mov %d5,0
80003aa4:	1d 00 3e 00 	j 80003b20 <IfxGtm_Tom_Timer_init+0x26c>
        maskShift = (config->timerChannel <= 7) ? 0 : 8;
80003aa8:	3b 80 00 90 	mov %d9,8
80003aac:	1d ff ae ff 	j 80003a08 <IfxGtm_Tom_Timer_init+0x154>
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003ab0:	82 15       	mov %d5,1
80003ab2:	1d ff c6 ff 	j 80003a3e <IfxGtm_Tom_Timer_init+0x18a>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003ab6:	99 c2 14 00 	ld.a %a2,[%a12]20
80003aba:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.RST_CCU0 = (uint8)event;
80003abe:	54 22       	ld.w %d2,[%a2]
80003ac0:	b7 12 01 2a 	insert %d2,%d2,1,20,1
80003ac4:	74 22       	st.w [%a2],%d2
                IfxGtm_Tom_Ch_setClockSource(driver->tom, triggerChannel, config->clock);
80003ac6:	19 d3 04 10 	ld.w %d3,[%a13]68
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003aca:	99 c2 14 00 	ld.a %a2,[%a12]20
80003ace:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
80003ad2:	54 22       	ld.w %d2,[%a2]
80003ad4:	37 32 03 26 	insert %d2,%d2,%d3,12,3
80003ad8:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003ada:	99 c2 14 00 	ld.a %a2,[%a12]20
80003ade:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
80003ae2:	54 22       	ld.w %d2,[%a2]
80003ae4:	b7 02 01 2c 	insert %d2,%d2,0,24,1
80003ae8:	74 22       	st.w [%a2],%d2
                IfxGtm_Tom_Tgc_enableChannels(driver->tgc[0], triggerChannelMask, 0, FALSE);
80003aea:	cc c6       	ld.a %a15,[%a12]24
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
80003aec:	82 06       	mov %d6,0
80003aee:	82 05       	mov %d5,0
80003af0:	37 09 70 40 	extr.u %d4,%d9,0,16
80003af4:	6d 00 32 09 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
80003af8:	59 f2 00 10 	st.w [%a15]64,%d2
                IfxGtm_Tom_Timer_addToChannelMask(driver, driver->triggerChannel);
80003afc:	19 c4 28 00 	ld.w %d4,[%a12]40
80003b00:	40 c4       	mov.aa %a4,%a12
80003b02:	6d ff 7c fe 	call 800037fa <IfxGtm_Tom_Timer_addToChannelMask>
80003b06:	1d ff ac ff 	j 80003a5e <IfxGtm_Tom_Timer_init+0x1aa>
                IfxGtm_PinMap_setTomTout(config->triggerOut, config->base.trigger.outputMode, config->base.trigger.outputDriver);
80003b0a:	19 d5 24 00 	ld.w %d5,[%a13]36
80003b0e:	19 d4 20 00 	ld.w %d4,[%a13]32
80003b12:	99 d4 00 10 	ld.a %a4,[%a13]64
80003b16:	6d ff 25 ee 	call 80001760 <IfxGtm_PinMap_setTomTout>
80003b1a:	1d ff b3 ff 	j 80003a80 <IfxGtm_Tom_Timer_init+0x1cc>
            boolean                triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;
80003b1e:	82 05       	mov %d5,0
80003b20:	8f f5 0f 51 	and %d5,%d5,255
            if (driver->triggerChannel == driver->timerChannel)
80003b24:	19 c4 28 00 	ld.w %d4,[%a12]40
80003b28:	19 c3 24 00 	ld.w %d3,[%a12]36
80003b2c:	5f 34 8a 00 	jeq %d4,%d3,80003c40 <IfxGtm_Tom_Timer_init+0x38c>
                if (timerHasIrq)
80003b30:	df 02 41 00 	jeq %d2,0,80003bb2 <IfxGtm_Tom_Timer_init+0x2fe>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003b34:	06 63       	sh %d3,6
80003b36:	99 c2 14 00 	ld.a %a2,[%a12]20
80003b3a:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    en.U = tomCh->IRQ_EN.U;
80003b3e:	d9 23 20 00 	lea %a3,[%a2]32
80003b42:	19 24 20 00 	ld.w %d4,[%a2]32
80003b46:	02 42       	mov %d2,%d4
    tomCh->IRQ_EN.U            = IFX_ZEROS;
80003b48:	82 03       	mov %d3,0
80003b4a:	74 33       	st.w [%a3],%d3
    tomCh->IRQ_MODE.B.IRQ_MODE = mode;
80003b4c:	d9 23 28 00 	lea %a3,[%a2]40
80003b50:	19 23 28 00 	ld.w %d3,[%a2]40
80003b54:	b7 23 02 30 	insert %d3,%d3,2,0,2
80003b58:	74 33       	st.w [%a3],%d3
    tomCh->IRQ_EN.U            = en.U; /* Set the values back */
80003b5a:	d9 23 20 00 	lea %a3,[%a2]32
80003b5e:	59 24 20 00 	st.w [%a2]32,%d4
    en.B.CCU0TC_IRQ_EN         = interruptOnCompareZero ? 1 : 0;
80003b62:	b7 12 01 20 	insert %d2,%d2,1,0,1
    en.B.CCU1TC_IRQ_EN         = interruptOnCompareOne ? 1 : 0;
80003b66:	8f 22 c0 21 	andn %d2,%d2,2
    tomCh->IRQ_EN.U            = en.U;
80003b6a:	74 32       	st.w [%a3],%d2
                    src = IfxGtm_Tom_Ch_getSrcPointer(driver->gtm, config->tom, driver->timerChannel);
80003b6c:	19 d3 38 00 	ld.w %d3,[%a13]56
80003b70:	19 c2 24 00 	ld.w %d2,[%a12]36
    return &MODULE_SRC.GTM.GTM[0].TOM[tom][channel >> 1];
80003b74:	86 f2       	sha %d2,-1
80003b76:	06 33       	sh %d3,3
80003b78:	42 32       	add %d2,%d3
80003b7a:	06 22       	sh %d2,2
80003b7c:	7b 40 00 3f 	movh %d3,61444
80003b80:	1b 03 b8 39 	addi %d3,%d3,-25728
80003b84:	60 32       	mov.a %a2,%d3
80003b86:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
                    IfxSrc_init(src, config->base.isrProvider, config->base.isrPriority);
80003b8a:	19 d4 08 00 	ld.w %d4,[%a13]8
    src->B.SRPN = priority;
80003b8e:	39 d3 04 00 	ld.bu %d3,[%a13]4
80003b92:	54 22       	ld.w %d2,[%a2]
80003b94:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80003b98:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80003b9a:	54 22       	ld.w %d2,[%a2]
80003b9c:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80003ba0:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80003ba2:	54 22       	ld.w %d2,[%a2]
80003ba4:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80003ba8:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80003baa:	54 22       	ld.w %d2,[%a2]
80003bac:	b7 12 01 25 	insert %d2,%d2,1,10,1
80003bb0:	74 22       	st.w [%a2],%d2
                if (triggerHasIrq)
80003bb2:	df 05 8f 00 	jeq %d5,0,80003cd0 <IfxGtm_Tom_Timer_init+0x41c>
                    IfxGtm_Tom_Ch_setNotification(driver->tom, driver->triggerChannel, irqMode, FALSE, TRUE);
80003bb6:	19 c2 28 00 	ld.w %d2,[%a12]40
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003bba:	06 62       	sh %d2,6
80003bbc:	99 c2 14 00 	ld.a %a2,[%a12]20
80003bc0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    en.U = tomCh->IRQ_EN.U;
80003bc4:	d9 23 20 00 	lea %a3,[%a2]32
80003bc8:	19 23 20 00 	ld.w %d3,[%a2]32
    tomCh->IRQ_EN.U            = IFX_ZEROS;
80003bcc:	82 02       	mov %d2,0
80003bce:	74 32       	st.w [%a3],%d2
    tomCh->IRQ_MODE.B.IRQ_MODE = mode;
80003bd0:	d9 23 28 00 	lea %a3,[%a2]40
80003bd4:	19 22 28 00 	ld.w %d2,[%a2]40
80003bd8:	b7 22 02 20 	insert %d2,%d2,2,0,2
80003bdc:	74 32       	st.w [%a3],%d2
    tomCh->IRQ_EN.U            = en.U; /* Set the values back */
80003bde:	d9 23 20 00 	lea %a3,[%a2]32
80003be2:	59 23 20 00 	st.w [%a2]32,%d3
    en.B.CCU0TC_IRQ_EN         = interruptOnCompareZero ? 1 : 0;
80003be6:	8f 13 c0 31 	andn %d3,%d3,1
    en.B.CCU1TC_IRQ_EN         = interruptOnCompareOne ? 1 : 0;
80003bea:	b7 13 81 30 	insert %d3,%d3,1,1,1
    tomCh->IRQ_EN.U            = en.U;
80003bee:	74 33       	st.w [%a3],%d3
                    src = IfxGtm_Tom_Ch_getSrcPointer(driver->gtm, config->tom, driver->triggerChannel);
80003bf0:	19 d3 38 00 	ld.w %d3,[%a13]56
80003bf4:	19 c2 28 00 	ld.w %d2,[%a12]40
    return &MODULE_SRC.GTM.GTM[0].TOM[tom][channel >> 1];
80003bf8:	86 f2       	sha %d2,-1
80003bfa:	06 33       	sh %d3,3
80003bfc:	42 32       	add %d2,%d3
80003bfe:	06 22       	sh %d2,2
80003c00:	7b 40 00 3f 	movh %d3,61444
80003c04:	1b 03 b8 39 	addi %d3,%d3,-25728
80003c08:	60 32       	mov.a %a2,%d3
80003c0a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
                    IfxSrc_init(src, config->base.trigger.isrProvider, config->base.trigger.isrPriority);
80003c0e:	19 d4 1c 00 	ld.w %d4,[%a13]28
    src->B.SRPN = priority;
80003c12:	39 d3 18 00 	ld.bu %d3,[%a13]24
80003c16:	54 22       	ld.w %d2,[%a2]
80003c18:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80003c1c:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80003c1e:	54 22       	ld.w %d2,[%a2]
80003c20:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80003c24:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80003c26:	54 22       	ld.w %d2,[%a2]
80003c28:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80003c2c:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80003c2e:	54 22       	ld.w %d2,[%a2]
80003c30:	b7 12 01 25 	insert %d2,%d2,1,10,1
80003c34:	74 22       	st.w [%a2],%d2
}
80003c36:	1d 00 4d 00 	j 80003cd0 <IfxGtm_Tom_Timer_init+0x41c>
            boolean                triggerHasIrq = (config->base.trigger.isrPriority > 0) && base->triggerEnabled;
80003c3a:	82 15       	mov %d5,1
80003c3c:	1d ff 72 ff 	j 80003b20 <IfxGtm_Tom_Timer_init+0x26c>
                IfxGtm_Tom_Ch_setNotification(driver->tom, driver->timerChannel, timerHasIrq ? config->irqModeTimer : config->irqModeTrigger, timerHasIrq, triggerHasIrq);
80003c40:	19 c4 14 00 	ld.w %d4,[%a12]20
80003c44:	df 02 70 00 	jeq %d2,0,80003d24 <IfxGtm_Tom_Timer_init+0x470>
80003c48:	19 d7 08 10 	ld.w %d7,[%a13]72
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003c4c:	06 63       	sh %d3,6
80003c4e:	60 42       	mov.a %a2,%d4
80003c50:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    en.U = tomCh->IRQ_EN.U;
80003c54:	d9 23 20 00 	lea %a3,[%a2]32
80003c58:	19 20 20 00 	ld.w %d0,[%a2]32
80003c5c:	02 03       	mov %d3,%d0
    tomCh->IRQ_EN.U            = IFX_ZEROS;
80003c5e:	82 04       	mov %d4,0
80003c60:	74 34       	st.w [%a3],%d4
    tomCh->IRQ_MODE.B.IRQ_MODE = mode;
80003c62:	d9 23 28 00 	lea %a3,[%a2]40
80003c66:	19 24 28 00 	ld.w %d4,[%a2]40
80003c6a:	37 74 02 40 	insert %d4,%d4,%d7,0,2
80003c6e:	74 34       	st.w [%a3],%d4
    tomCh->IRQ_EN.U            = en.U; /* Set the values back */
80003c70:	d9 23 20 00 	lea %a3,[%a2]32
80003c74:	59 20 20 00 	st.w [%a2]32,%d0
    en.B.CCU0TC_IRQ_EN         = interruptOnCompareZero ? 1 : 0;
80003c78:	67 63 00 30 	ins.t %d3,%d3,0,%d6,0
    en.B.CCU1TC_IRQ_EN         = interruptOnCompareOne ? 1 : 0;
80003c7c:	67 53 01 30 	ins.t %d3,%d3,1,%d5,0
    tomCh->IRQ_EN.U            = en.U;
80003c80:	74 33       	st.w [%a3],%d3
                src = IfxGtm_Tom_Ch_getSrcPointer(driver->gtm, config->tom, driver->timerChannel);
80003c82:	19 d4 38 00 	ld.w %d4,[%a13]56
80003c86:	19 c3 24 00 	ld.w %d3,[%a12]36
    return &MODULE_SRC.GTM.GTM[0].TOM[tom][channel >> 1];
80003c8a:	86 f3       	sha %d3,-1
80003c8c:	06 34       	sh %d4,3
80003c8e:	42 43       	add %d3,%d4
80003c90:	06 23       	sh %d3,2
80003c92:	7b 40 00 4f 	movh %d4,61444
80003c96:	1b 04 b8 49 	addi %d4,%d4,-25728
80003c9a:	60 42       	mov.a %a2,%d4
80003c9c:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
                IfxSrc_init(src, timerHasIrq ? config->base.isrProvider : config->base.trigger.isrProvider, timerHasIrq ? config->base.isrPriority : config->base.trigger.isrPriority);
80003ca0:	df 02 46 00 	jeq %d2,0,80003d2c <IfxGtm_Tom_Timer_init+0x478>
80003ca4:	19 d4 08 00 	ld.w %d4,[%a13]8
80003ca8:	df 02 46 00 	jeq %d2,0,80003d34 <IfxGtm_Tom_Timer_init+0x480>
80003cac:	b9 d3 04 00 	ld.hu %d3,[%a13]4
    src->B.SRPN = priority;
80003cb0:	54 22       	ld.w %d2,[%a2]
80003cb2:	37 32 08 20 	insert %d2,%d2,%d3,0,8
80003cb6:	74 22       	st.w [%a2],%d2
    src->B.TOS  = typOfService;
80003cb8:	54 22       	ld.w %d2,[%a2]
80003cba:	37 42 82 25 	insert %d2,%d2,%d4,11,2
80003cbe:	74 22       	st.w [%a2],%d2
    src->B.CLRR = 1;
80003cc0:	54 22       	ld.w %d2,[%a2]
80003cc2:	b7 12 81 2c 	insert %d2,%d2,1,25,1
80003cc6:	74 22       	st.w [%a2],%d2
    src->B.SRE = 1;
80003cc8:	54 22       	ld.w %d2,[%a2]
80003cca:	b7 12 01 25 	insert %d2,%d2,1,10,1
80003cce:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc[0], driver->channelsMask[0], 0, 0, 0);
80003cd0:	99 cd 18 00 	ld.a %a13,[%a12]24
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
80003cd4:	82 06       	mov %d6,0
80003cd6:	82 05       	mov %d5,0
80003cd8:	b9 c4 2c 00 	ld.hu %d4,[%a12]44
80003cdc:	6d 00 3e 08 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
80003ce0:	02 29       	mov %d9,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
80003ce2:	3b 00 01 60 	mov %d6,16
80003ce6:	82 05       	mov %d5,0
80003ce8:	82 04       	mov %d4,0
80003cea:	6d 00 37 08 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
80003cee:	a6 92       	or %d2,%d9
80003cf0:	59 d2 08 00 	st.w [%a13]8,%d2
        IfxGtm_Tom_Tgc_trigger(driver->tgc[0]);
80003cf4:	99 c2 18 00 	ld.a %a2,[%a12]24
    tgc->GLB_CTRL.U = 1 << IFX_GTM_TOM_TGC0_GLB_CTRL_HOST_TRIG_OFF;
80003cf8:	82 12       	mov %d2,1
80003cfa:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc[0], 0, driver->channelsMask[0], 0, 0);
80003cfc:	99 cd 18 00 	ld.a %a13,[%a12]24
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
80003d00:	82 06       	mov %d6,0
80003d02:	b9 c5 2c 00 	ld.hu %d5,[%a12]44
80003d06:	82 04       	mov %d4,0
80003d08:	6d 00 28 08 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
80003d0c:	02 29       	mov %d9,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
80003d0e:	3b 00 01 60 	mov %d6,16
80003d12:	82 05       	mov %d5,0
80003d14:	82 04       	mov %d4,0
80003d16:	6d 00 21 08 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
80003d1a:	a6 92       	or %d2,%d9
80003d1c:	59 d2 08 00 	st.w [%a13]8,%d2
}
80003d20:	1d ff 45 fe 	j 800039aa <IfxGtm_Tom_Timer_init+0xf6>
                IfxGtm_Tom_Ch_setNotification(driver->tom, driver->timerChannel, timerHasIrq ? config->irqModeTimer : config->irqModeTrigger, timerHasIrq, triggerHasIrq);
80003d24:	19 d7 0c 10 	ld.w %d7,[%a13]76
80003d28:	1d ff 92 ff 	j 80003c4c <IfxGtm_Tom_Timer_init+0x398>
                IfxSrc_init(src, timerHasIrq ? config->base.isrProvider : config->base.trigger.isrProvider, timerHasIrq ? config->base.isrPriority : config->base.trigger.isrPriority);
80003d2c:	19 d4 1c 00 	ld.w %d4,[%a13]28
80003d30:	1d ff bc ff 	j 80003ca8 <IfxGtm_Tom_Timer_init+0x3f4>
80003d34:	b9 d3 18 00 	ld.hu %d3,[%a13]24
80003d38:	1d ff bc ff 	j 80003cb0 <IfxGtm_Tom_Timer_init+0x3fc>

80003d3c <IfxGtm_Tom_Timer_initConfig>:
{
80003d3c:	40 ae       	mov.aa %a14,%sp
80003d3e:	40 4c       	mov.aa %a12,%a4
80003d40:	80 58       	mov.d %d8,%a5
    IfxStdIf_Timer_initConfig(&config->base);
80003d42:	6d 00 fc 13 	call 8000653a <IfxStdIf_Timer_initConfig>
    config->gtm            = gtm;
80003d46:	59 c8 34 00 	st.w [%a12]52,%d8
    config->tom            = IfxGtm_Tom_0;
80003d4a:	82 02       	mov %d2,0
80003d4c:	59 c2 38 00 	st.w [%a12]56,%d2
    config->timerChannel   = IfxGtm_Tom_Ch_0;
80003d50:	59 c2 3c 00 	st.w [%a12]60,%d2
    config->triggerOut     = NULL_PTR;
80003d54:	59 c2 00 10 	st.w [%a12]64,%d2
    config->clock          = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk0;
80003d58:	59 c2 04 10 	st.w [%a12]68,%d2
    config->base.countDir  = IfxStdIf_Timer_CountDir_up;
80003d5c:	59 c2 2c 00 	st.w [%a12]44,%d2
    config->irqModeTimer   = IfxGtm_IrqMode_level;
80003d60:	59 c2 08 10 	st.w [%a12]72,%d2
    config->irqModeTrigger = IfxGtm_IrqMode_level;
80003d64:	59 c2 0c 10 	st.w [%a12]76,%d2
    config->initPins       = TRUE;
80003d68:	82 12       	mov %d2,1
80003d6a:	e9 c2 10 10 	st.b [%a12]80,%d2
}
80003d6e:	00 90       	ret 

80003d70 <IfxGtm_Tom_PwmHl_setDeadtime>:
    config->initPins = TRUE;
}


boolean IfxGtm_Tom_PwmHl_setDeadtime(IfxGtm_Tom_PwmHl *driver, float32 deadtime)
{
80003d70:	40 ae       	mov.aa %a14,%sp
    Ifx_TimerValue value = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, deadtime);
80003d72:	99 42 20 00 	ld.a %a2,[%a4]32
80003d76:	19 22 08 00 	ld.w %d2,[%a2]8
80003d7a:	4b 42 41 20 	mul.f %d2,%d2,%d4
80003d7e:	4b 02 71 21 	ftouz %d2,%d2
    driver->base.deadtime = value;
80003d82:	74 42       	st.w [%a4],%d2

    return TRUE;
}
80003d84:	82 12       	mov %d2,1
80003d86:	00 90       	ret 

80003d88 <IfxGtm_Tom_PwmHl_setMinPulse>:


boolean IfxGtm_Tom_PwmHl_setMinPulse(IfxGtm_Tom_PwmHl *driver, float32 minPulse)
{
80003d88:	40 ae       	mov.aa %a14,%sp
    Ifx_TimerValue value = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, minPulse);
80003d8a:	99 42 20 00 	ld.a %a2,[%a4]32
80003d8e:	19 22 08 00 	ld.w %d2,[%a2]8
80003d92:	4b 42 41 20 	mul.f %d2,%d2,%d4
80003d96:	4b 02 71 21 	ftouz %d2,%d2

    driver->base.minPulse = value + driver->base.deadtime;
80003d9a:	54 43       	ld.w %d3,[%a4]
80003d9c:	42 32       	add %d2,%d3
80003d9e:	59 42 04 00 	st.w [%a4]4,%d2
    driver->base.maxPulse = driver->timer->base.period - driver->base.minPulse;
80003da2:	54 23       	ld.w %d3,[%a2]
80003da4:	0b 23 80 20 	sub %d2,%d3,%d2
80003da8:	59 42 08 00 	st.w [%a4]8,%d2

    return TRUE;
}
80003dac:	82 12       	mov %d2,1
80003dae:	00 90       	ret 

80003db0 <IfxGtm_Tom_PwmHl_setMode>:


boolean IfxGtm_Tom_PwmHl_setMode(IfxGtm_Tom_PwmHl *driver, Ifx_Pwm_Mode mode)
{
80003db0:	40 ae       	mov.aa %a14,%sp
    boolean                result = TRUE;
    IfxGtm_Tom_PwmHl_Base *base   = &driver->base;

    if (base->mode != mode)
80003db2:	19 42 0c 00 	ld.w %d2,[%a4]12
80003db6:	5f 42 a4 00 	jeq %d2,%d4,80003efe <IfxGtm_Tom_PwmHl_setMode+0x14e>
    {
        if ((mode > Ifx_Pwm_Mode_off) || (IfxGtm_Tom_PwmHl_modes[mode].update == NULL_PTR))
80003dba:	ff 54 11 80 	jge.u %d4,5,80003ddc <IfxGtm_Tom_PwmHl_setMode+0x2c>
80003dbe:	91 00 00 28 	movh.a %a2,32768
80003dc2:	80 22       	mov.d %d2,%a2
80003dc4:	1b 82 48 20 	addi %d2,%d2,1160
80003dc8:	13 44 21 22 	madd %d2,%d2,%d4,20
80003dcc:	60 22       	mov.a %a2,%d2
80003dce:	19 22 08 00 	ld.w %d2,[%a2]8
80003dd2:	df 02 3c 00 	jeq %d2,0,80003e4a <IfxGtm_Tom_PwmHl_setMode+0x9a>
    boolean                result = TRUE;
80003dd6:	82 12       	mov %d2,1
80003dd8:	1d 00 04 00 	j 80003de0 <IfxGtm_Tom_PwmHl_setMode+0x30>
        {
            mode   = Ifx_Pwm_Mode_off;
            result = FALSE;
80003ddc:	82 02       	mov %d2,0
            mode   = Ifx_Pwm_Mode_off;
80003dde:	82 44       	mov %d4,4
        }

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, mode == IfxGtm_Tom_PwmHl_modes[mode].mode);

        base->mode             = mode;
80003de0:	59 44 0c 00 	st.w [%a4]12,%d4
        driver->update         = IfxGtm_Tom_PwmHl_modes[mode].update;
80003de4:	91 00 00 28 	movh.a %a2,32768
80003de8:	80 23       	mov.d %d3,%a2
80003dea:	1b 83 48 30 	addi %d3,%d3,1160
80003dee:	13 44 21 33 	madd %d3,%d3,%d4,20
80003df2:	60 32       	mov.a %a2,%d3
80003df4:	19 23 08 00 	ld.w %d3,[%a2]8
80003df8:	59 43 24 00 	st.w [%a4]36,%d3
        driver->updateAndShift = IfxGtm_Tom_PwmHl_modes[mode].updateAndShift;
80003dfc:	19 23 0c 00 	ld.w %d3,[%a2]12
80003e00:	59 43 28 00 	st.w [%a4]40,%d3
        driver->updatePulse    = IfxGtm_Tom_PwmHl_modes[mode].updatePulse;
80003e04:	19 23 10 00 	ld.w %d3,[%a2]16
80003e08:	59 43 2c 00 	st.w [%a4]44,%d3

        if (base->mode != Ifx_Pwm_Mode_off)
80003e0c:	df 44 0e 00 	jeq %d4,4,80003e28 <IfxGtm_Tom_PwmHl_setMode+0x78>
        {
            base->inverted = IfxGtm_Tom_PwmHl_modes[mode].inverted;
80003e10:	91 00 00 28 	movh.a %a2,32768
80003e14:	80 23       	mov.d %d3,%a2
80003e16:	1b 83 48 30 	addi %d3,%d3,1160
80003e1a:	13 44 21 33 	madd %d3,%d3,%d4,20
80003e1e:	60 32       	mov.a %a2,%d3
80003e20:	39 23 04 00 	ld.bu %d3,[%a2]4
80003e24:	e9 43 1c 00 	st.b [%a4]28,%d3
        }
        else
        {                       /* Keep previous inverted for off mode */
        }

        if (base->inverted)
80003e28:	39 43 1c 00 	ld.bu %d3,[%a4]28
80003e2c:	df 03 13 00 	jeq %d3,0,80003e52 <IfxGtm_Tom_PwmHl_setMode+0xa2>
        {
            driver->ccxTemp   = driver->coutx;
80003e30:	80 43       	mov.d %d3,%a4
80003e32:	1b 43 04 30 	addi %d3,%d3,68
80003e36:	59 43 10 10 	st.w [%a4]80,%d3
            driver->coutxTemp = driver->ccx;
80003e3a:	80 43       	mov.d %d3,%a4
80003e3c:	1b 83 03 30 	addi %d3,%d3,56
80003e40:	59 43 14 10 	st.w [%a4]84,%d3
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003e44:	82 04       	mov %d4,0
80003e46:	1d 00 3d 00 	j 80003ec0 <IfxGtm_Tom_PwmHl_setMode+0x110>
            result = FALSE;
80003e4a:	82 02       	mov %d2,0
            mode   = Ifx_Pwm_Mode_off;
80003e4c:	82 44       	mov %d4,4
80003e4e:	1d ff c9 ff 	j 80003de0 <IfxGtm_Tom_PwmHl_setMode+0x30>
        }
        else
        {
            driver->ccxTemp   = driver->ccx;
80003e52:	80 43       	mov.d %d3,%a4
80003e54:	1b 83 03 30 	addi %d3,%d3,56
80003e58:	59 43 10 10 	st.w [%a4]80,%d3
            driver->coutxTemp = driver->coutx;
80003e5c:	80 43       	mov.d %d3,%a4
80003e5e:	1b 43 04 30 	addi %d3,%d3,68
80003e62:	59 43 14 10 	st.w [%a4]84,%d3
80003e66:	1d ff ef ff 	j 80003e44 <IfxGtm_Tom_PwmHl_setMode+0x94>
                IfxGtm_Tom_Ch channel;

                channel = driver->ccx[channelIndex];
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
                    ? base->ccxActiveState
                    : IfxGtm_Tom_PwmHl_invertActiveState(driver->base.ccxActiveState));
80003e6a:	19 43 14 00 	ld.w %d3,[%a4]20
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
80003e6e:	8b 03 00 32 	eq %d3,%d3,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003e72:	06 65       	sh %d5,6
80003e74:	60 62       	mov.a %a2,%d6
80003e76:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003e7a:	df 13 37 00 	jeq %d3,1,80003ee8 <IfxGtm_Tom_PwmHl_setMode+0x138>
80003e7e:	82 05       	mov %d5,0
80003e80:	54 23       	ld.w %d3,[%a2]
80003e82:	67 53 0b 30 	ins.t %d3,%d3,11,%d5,0
80003e86:	74 23       	st.w [%a2],%d3

                channel = driver->coutx[channelIndex];
80003e88:	1b 14 01 30 	addi %d3,%d4,17
80003e8c:	06 23       	sh %d3,2
80003e8e:	01 43 00 26 	addsc.a %a2,%a4,%d3,0
80003e92:	54 25       	ld.w %d5,[%a2]
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
80003e94:	19 46 30 00 	ld.w %d6,[%a4]48
80003e98:	39 43 1c 00 	ld.bu %d3,[%a4]28
80003e9c:	df 03 29 00 	jeq %d3,0,80003eee <IfxGtm_Tom_PwmHl_setMode+0x13e>
                    ? IfxGtm_Tom_PwmHl_invertActiveState(driver->base.coutxActiveState)
80003ea0:	19 43 18 00 	ld.w %d3,[%a4]24
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
80003ea4:	8b 03 00 32 	eq %d3,%d3,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003ea8:	06 65       	sh %d5,6
80003eaa:	60 62       	mov.a %a2,%d6
80003eac:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80003eb0:	df 13 23 00 	jeq %d3,1,80003ef6 <IfxGtm_Tom_PwmHl_setMode+0x146>
80003eb4:	82 05       	mov %d5,0
80003eb6:	54 23       	ld.w %d3,[%a2]
80003eb8:	67 53 0b 30 	ins.t %d3,%d3,11,%d5,0
80003ebc:	74 23       	st.w [%a2],%d3
            for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80003ebe:	c2 14       	add %d4,1
80003ec0:	39 43 1d 00 	ld.bu %d3,[%a4]29
80003ec4:	7f 34 1c 80 	jge.u %d4,%d3,80003efc <IfxGtm_Tom_PwmHl_setMode+0x14c>
                channel = driver->ccx[channelIndex];
80003ec8:	1b e4 00 30 	addi %d3,%d4,14
80003ecc:	06 23       	sh %d3,2
80003ece:	01 43 00 26 	addsc.a %a2,%a4,%d3,0
80003ed2:	54 25       	ld.w %d5,[%a2]
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
80003ed4:	19 46 30 00 	ld.w %d6,[%a4]48
80003ed8:	39 43 1c 00 	ld.bu %d3,[%a4]28
80003edc:	df 03 c7 7f 	jeq %d3,0,80003e6a <IfxGtm_Tom_PwmHl_setMode+0xba>
80003ee0:	19 43 14 00 	ld.w %d3,[%a4]20
80003ee4:	1d ff c7 ff 	j 80003e72 <IfxGtm_Tom_PwmHl_setMode+0xc2>
80003ee8:	82 15       	mov %d5,1
80003eea:	1d ff cb ff 	j 80003e80 <IfxGtm_Tom_PwmHl_setMode+0xd0>
                IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, base->inverted
80003eee:	19 43 18 00 	ld.w %d3,[%a4]24
80003ef2:	1d ff db ff 	j 80003ea8 <IfxGtm_Tom_PwmHl_setMode+0xf8>
80003ef6:	82 15       	mov %d5,1
80003ef8:	1d ff df ff 	j 80003eb6 <IfxGtm_Tom_PwmHl_setMode+0x106>
80003efc:	00 90       	ret 
    boolean                result = TRUE;
80003efe:	82 12       	mov %d2,1
            }
        }
    }

    return result;
}
80003f00:	00 90       	ret 

80003f02 <IfxGtm_Tom_PwmHl_setOnTime>:


void IfxGtm_Tom_PwmHl_setOnTime(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
80003f02:	40 ae       	mov.aa %a14,%sp
    driver->update(driver, tOn);
80003f04:	99 42 24 00 	ld.a %a2,[%a4]36
80003f08:	2d 02 00 00 	calli %a2
}
80003f0c:	00 90       	ret 

80003f0e <IfxGtm_Tom_PwmHl_updateCenterAligned>:
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
}


IFX_STATIC void IfxGtm_Tom_PwmHl_updateCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
80003f0e:	40 ae       	mov.aa %a14,%sp
    uint8          channelIndex;
    Ifx_TimerValue period;
    Ifx_TimerValue deadtime = driver->base.deadtime;
80003f10:	54 47       	ld.w %d7,[%a4]

    period = driver->timer->base.period;
80003f12:	99 42 20 00 	ld.a %a2,[%a4]32
80003f16:	54 25       	ld.w %d5,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80003f18:	82 03       	mov %d3,0
80003f1a:	1d 00 5e 00 	j 80003fd6 <IfxGtm_Tom_PwmHl_updateCenterAligned+0xc8>
        else
        {}

        if ((x < driver->base.minPulse) || (x <= deadtime))
        {                       /* For deadtime condition: avoid leading edge of top channel to occur after the trailing edge */
            x = 0;
80003f1e:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80003f20:	5f 52 2e 00 	jeq %d2,%d5,80003f7c <IfxGtm_Tom_PwmHl_updateCenterAligned+0x6e>
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1) */);
        }
        else if (x == 0)
80003f24:	df 02 75 80 	jne %d2,0,8000400e <IfxGtm_Tom_PwmHl_updateCenterAligned+0x100>
        {
            cm0 = 1;
            cm1 = period + 2;
80003f28:	1b 25 00 20 	addi %d2,%d5,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80003f2c:	99 42 10 10 	ld.a %a2,[%a4]80
80003f30:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80003f34:	54 26       	ld.w %d6,[%a2]
80003f36:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003f3a:	06 66       	sh %d6,6
80003f3c:	99 42 30 00 	ld.a %a2,[%a4]48
80003f40:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80003f44:	82 16       	mov %d6,1
80003f46:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
80003f4a:	59 22 08 00 	st.w [%a2]8,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
80003f4e:	99 42 14 10 	ld.a %a2,[%a4]84
80003f52:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80003f56:	54 26       	ld.w %d6,[%a2]
80003f58:	1b 17 00 40 	addi %d4,%d7,1
80003f5c:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003f60:	06 66       	sh %d6,6
80003f62:	99 42 30 00 	ld.a %a2,[%a4]48
80003f66:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80003f6a:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
80003f6e:	59 22 08 00 	st.w [%a2]8,%d2
}
80003f72:	1d 00 2f 00 	j 80003fd0 <IfxGtm_Tom_PwmHl_updateCenterAligned+0xc2>
            x = 0;
80003f76:	82 02       	mov %d2,0
80003f78:	1d ff d4 ff 	j 80003f20 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x12>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
80003f7c:	99 42 10 10 	ld.a %a2,[%a4]80
80003f80:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80003f84:	54 21       	ld.w %d1,[%a2]
                period + 1 /* No compare event */,
80003f86:	37 05 70 20 	extr.u %d2,%d5,0,16
80003f8a:	1b 12 00 00 	addi %d0,%d2,1
80003f8e:	37 00 70 00 	extr.u %d0,%d0,0,16
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
80003f92:	1b 27 00 60 	addi %d6,%d7,2
80003f96:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003f9a:	06 61       	sh %d1,6
80003f9c:	99 42 30 00 	ld.a %a2,[%a4]48
80003fa0:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
80003fa4:	59 20 04 00 	st.w [%a2]4,%d0
    tomCh->SR1.U = shadowOne;
80003fa8:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
80003fac:	99 42 14 10 	ld.a %a2,[%a4]84
80003fb0:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80003fb4:	54 24       	ld.w %d4,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
80003fb6:	c2 22       	add %d2,2
80003fb8:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80003fbc:	06 64       	sh %d4,6
80003fbe:	99 42 30 00 	ld.a %a2,[%a4]48
80003fc2:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80003fc6:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
80003fca:	82 22       	mov %d2,2
80003fcc:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80003fd0:	c2 13       	add %d3,1
80003fd2:	8f f3 0f 31 	and %d3,%d3,255
80003fd6:	39 42 1d 00 	ld.bu %d2,[%a4]29
80003fda:	7f 23 4e 80 	jge.u %d3,%d2,80004076 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x168>
        x = tOn[channelIndex];
80003fde:	8f 23 00 40 	sh %d4,%d3,2
80003fe2:	01 54 00 26 	addsc.a %a2,%a5,%d4,0
80003fe6:	54 22       	ld.w %d2,[%a2]
        if (driver->base.inverted != FALSE)
80003fe8:	39 46 1c 00 	ld.bu %d6,[%a4]28
80003fec:	df 06 04 00 	jeq %d6,0,80003ff4 <IfxGtm_Tom_PwmHl_updateCenterAligned+0xe6>
            x = period - x;
80003ff0:	0b 25 80 20 	sub %d2,%d5,%d2
        if ((x < driver->base.minPulse) || (x <= deadtime))
80003ff4:	19 46 04 00 	ld.w %d6,[%a4]4
80003ff8:	3f 62 93 ff 	jlt.u %d2,%d6,80003f1e <IfxGtm_Tom_PwmHl_updateCenterAligned+0x10>
80003ffc:	7f 27 bd ff 	jge.u %d7,%d2,80003f76 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x68>
        else if (x > driver->base.maxPulse)
80004000:	19 46 08 00 	ld.w %d6,[%a4]8
80004004:	7f 26 8e ff 	jge.u %d6,%d2,80003f20 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x12>
            x = period;
80004008:	02 52       	mov %d2,%d5
8000400a:	1d ff 8b ff 	j 80003f20 <IfxGtm_Tom_PwmHl_updateCenterAligned+0x12>
        }
        else
        {                           /* x% duty cycle */
            cm1 = (period - x) / 2; // CM1
8000400e:	0b 25 80 60 	sub %d6,%d5,%d2
80004012:	06 f6       	sh %d6,-1
            cm0 = (period + x) / 2; // CM0
80004014:	42 52       	add %d2,%d5
80004016:	8f f2 1f 80 	sh %d8,%d2,-1
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1 + deadtime);
8000401a:	99 42 10 10 	ld.a %a2,[%a4]80
8000401e:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004022:	54 2a       	ld.w %d10,[%a2]
80004024:	37 02 f0 90 	extr.u %d9,%d2,1,16
80004028:	bb f0 ff 2f 	mov.u %d2,65535
8000402c:	26 28       	and %d8,%d2
8000402e:	37 07 70 00 	extr.u %d0,%d7,0,16
80004032:	0b 60 00 10 	add %d1,%d0,%d6
80004036:	37 01 70 10 	extr.u %d1,%d1,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000403a:	06 6a       	sh %d10,6
8000403c:	99 42 30 00 	ld.a %a2,[%a4]48
80004040:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->SR0.U = shadowZero;
80004044:	59 28 04 00 	st.w [%a2]4,%d8
    tomCh->SR1.U = shadowOne;
80004048:	59 21 08 00 	st.w [%a2]8,%d1
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
8000404c:	99 42 14 10 	ld.a %a2,[%a4]84
80004050:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004054:	54 21       	ld.w %d1,[%a2]
80004056:	0b 09 00 40 	add %d4,%d9,%d0
8000405a:	37 04 70 40 	extr.u %d4,%d4,0,16
8000405e:	26 62       	and %d2,%d6
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004060:	06 61       	sh %d1,6
80004062:	99 42 30 00 	ld.a %a2,[%a4]48
80004066:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
8000406a:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
8000406e:	59 22 08 00 	st.w [%a2]8,%d2
}
80004072:	1d ff af ff 	j 80003fd0 <IfxGtm_Tom_PwmHl_updateCenterAligned+0xc2>
        }
    }
}
80004076:	00 90       	ret 

80004078 <IfxGtm_Tom_PwmHl_updateEdgeAligned>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updateEdgeAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
80004078:	40 ae       	mov.aa %a14,%sp
    uint8          channelIndex;
    Ifx_TimerValue period;
    Ifx_TimerValue deadtime = driver->base.deadtime;
8000407a:	54 47       	ld.w %d7,[%a4]

    period = driver->timer->base.period;
8000407c:	99 42 20 00 	ld.a %a2,[%a4]32
80004080:	54 25       	ld.w %d5,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80004082:	82 03       	mov %d3,0
80004084:	1d 00 5e 00 	j 80004140 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xc8>
        else
        {}

        if ((x < driver->base.minPulse) || (x <= deadtime))
        {                       /* For deadtime condition: avoid leading edge of top channel to occur after the trailing edge */
            x = 0;
80004088:	82 00       	mov %d0,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
8000408a:	5f 50 2e 00 	jeq %d0,%d5,800040e6 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x6e>
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1) */);
        }
        else if (x == 0)
8000408e:	df 00 75 80 	jne %d0,0,80004178 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x100>
        {
            cm0 = 1;
            cm1 = period + 2;
80004092:	1b 25 00 20 	addi %d2,%d5,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80004096:	99 42 10 10 	ld.a %a2,[%a4]80
8000409a:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8000409e:	54 26       	ld.w %d6,[%a2]
800040a0:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800040a4:	06 66       	sh %d6,6
800040a6:	99 42 30 00 	ld.a %a2,[%a4]48
800040aa:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
800040ae:	82 16       	mov %d6,1
800040b0:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
800040b4:	59 22 08 00 	st.w [%a2]8,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
800040b8:	99 42 14 10 	ld.a %a2,[%a4]84
800040bc:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800040c0:	54 26       	ld.w %d6,[%a2]
800040c2:	1b 17 00 40 	addi %d4,%d7,1
800040c6:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800040ca:	06 66       	sh %d6,6
800040cc:	99 42 30 00 	ld.a %a2,[%a4]48
800040d0:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
800040d4:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
800040d8:	59 22 08 00 	st.w [%a2]8,%d2
}
800040dc:	1d 00 2f 00 	j 8000413a <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xc2>
            x = 0;
800040e0:	82 00       	mov %d0,0
800040e2:	1d ff d4 ff 	j 8000408a <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x12>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
800040e6:	99 42 10 10 	ld.a %a2,[%a4]80
800040ea:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800040ee:	54 21       	ld.w %d1,[%a2]
                period + 1 /* No compare event */,
800040f0:	37 05 70 20 	extr.u %d2,%d5,0,16
800040f4:	1b 12 00 00 	addi %d0,%d2,1
800040f8:	37 00 70 00 	extr.u %d0,%d0,0,16
                2 /* 1st compare event (issue: expected to be 1) */ + deadtime);
800040fc:	1b 27 00 60 	addi %d6,%d7,2
80004100:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004104:	06 61       	sh %d1,6
80004106:	99 42 30 00 	ld.a %a2,[%a4]48
8000410a:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
8000410e:	59 20 04 00 	st.w [%a2]4,%d0
    tomCh->SR1.U = shadowOne;
80004112:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
80004116:	99 42 14 10 	ld.a %a2,[%a4]84
8000411a:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8000411e:	54 24       	ld.w %d4,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
80004120:	c2 22       	add %d2,2
80004122:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004126:	06 64       	sh %d4,6
80004128:	99 42 30 00 	ld.a %a2,[%a4]48
8000412c:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80004130:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
80004134:	82 22       	mov %d2,2
80004136:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
8000413a:	c2 13       	add %d3,1
8000413c:	8f f3 0f 31 	and %d3,%d3,255
80004140:	39 42 1d 00 	ld.bu %d2,[%a4]29
80004144:	7f 23 44 80 	jge.u %d3,%d2,800041cc <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x154>
        x = tOn[channelIndex];
80004148:	8f 23 00 40 	sh %d4,%d3,2
8000414c:	01 54 00 26 	addsc.a %a2,%a5,%d4,0
80004150:	54 20       	ld.w %d0,[%a2]
        if (driver->base.inverted != FALSE)
80004152:	39 46 1c 00 	ld.bu %d6,[%a4]28
80004156:	df 06 04 00 	jeq %d6,0,8000415e <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xe6>
            x = period - x;
8000415a:	0b 05 80 00 	sub %d0,%d5,%d0
        if ((x < driver->base.minPulse) || (x <= deadtime))
8000415e:	19 46 04 00 	ld.w %d6,[%a4]4
80004162:	3f 60 93 ff 	jlt.u %d0,%d6,80004088 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x10>
80004166:	7f 07 bd ff 	jge.u %d7,%d0,800040e0 <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x68>
        else if (x > driver->base.maxPulse)
8000416a:	19 46 08 00 	ld.w %d6,[%a4]8
8000416e:	7f 06 8e ff 	jge.u %d6,%d0,8000408a <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x12>
            x = period;
80004172:	02 50       	mov %d0,%d5
80004174:	1d ff 8b ff 	j 8000408a <IfxGtm_Tom_PwmHl_updateEdgeAligned+0x12>
        }
        else
        {                       /* x% duty cycle */
            cm1 = 2;            // CM1, set to 2 due to a GTM issue. should be 1 according to spec
            cm0 = x;            // CM0, set to x+2 due to a GTM issue. should be x+1 according to spec
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1 + deadtime);
80004178:	99 42 10 10 	ld.a %a2,[%a4]80
8000417c:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004180:	54 28       	ld.w %d8,[%a2]
80004182:	37 00 70 10 	extr.u %d1,%d0,0,16
80004186:	37 07 70 20 	extr.u %d2,%d7,0,16
8000418a:	1b 22 00 60 	addi %d6,%d2,2
8000418e:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004192:	06 68       	sh %d8,6
80004194:	99 42 30 00 	ld.a %a2,[%a4]48
80004198:	01 28 00 26 	addsc.a %a2,%a2,%d8,0
    tomCh->SR0.U = shadowZero;
8000419c:	59 21 04 00 	st.w [%a2]4,%d1
    tomCh->SR1.U = shadowOne;
800041a0:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
800041a4:	99 42 14 10 	ld.a %a2,[%a4]84
800041a8:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800041ac:	54 24       	ld.w %d4,[%a2]
800041ae:	42 12       	add %d2,%d1
800041b0:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800041b4:	06 64       	sh %d4,6
800041b6:	99 42 30 00 	ld.a %a2,[%a4]48
800041ba:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
800041be:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
800041c2:	82 22       	mov %d2,2
800041c4:	59 22 08 00 	st.w [%a2]8,%d2
}
800041c8:	1d ff b9 ff 	j 8000413a <IfxGtm_Tom_PwmHl_updateEdgeAligned+0xc2>
        }
    }
}
800041cc:	00 90       	ret 

800041ce <IfxGtm_Tom_PwmHl_updateOff>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updateOff(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn)
{
800041ce:	40 ae       	mov.aa %a14,%sp
    IFX_UNUSED_PARAMETER(tOn)
    uint8 channelIndex;
    Ifx_TimerValue period;

    period = driver->timer->base.period;
800041d0:	99 42 20 00 	ld.a %a2,[%a4]32
800041d4:	54 27       	ld.w %d7,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
800041d6:	82 02       	mov %d2,0
800041d8:	1d 00 2d 00 	j 80004232 <IfxGtm_Tom_PwmHl_updateOff+0x64>
    {
        IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
800041dc:	8f 22 00 40 	sh %d4,%d2,2
800041e0:	99 42 10 10 	ld.a %a2,[%a4]80
800041e4:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800041e8:	54 26       	ld.w %d6,[%a2]
            2 /* 1 will keep the previous level */, period + 2);
800041ea:	37 07 70 30 	extr.u %d3,%d7,0,16
800041ee:	1b 23 00 50 	addi %d5,%d3,2
800041f2:	37 05 70 50 	extr.u %d5,%d5,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800041f6:	06 66       	sh %d6,6
800041f8:	99 42 30 00 	ld.a %a2,[%a4]48
800041fc:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80004200:	82 26       	mov %d6,2
80004202:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
80004206:	59 25 08 00 	st.w [%a2]8,%d5
        IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], period + 1, 2);
8000420a:	99 42 14 10 	ld.a %a2,[%a4]84
8000420e:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004212:	54 24       	ld.w %d4,[%a2]
80004214:	c2 13       	add %d3,1
80004216:	37 03 70 30 	extr.u %d3,%d3,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000421a:	06 64       	sh %d4,6
8000421c:	99 42 30 00 	ld.a %a2,[%a4]48
80004220:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80004224:	59 23 04 00 	st.w [%a2]4,%d3
    tomCh->SR1.U = shadowOne;
80004228:	59 26 08 00 	st.w [%a2]8,%d6
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
8000422c:	c2 12       	add %d2,1
8000422e:	8f f2 0f 21 	and %d2,%d2,255
80004232:	39 43 1d 00 	ld.bu %d3,[%a4]29
80004236:	3f 32 d3 ff 	jlt.u %d2,%d3,800041dc <IfxGtm_Tom_PwmHl_updateOff+0xe>
    }
}
8000423a:	00 90       	ret 

8000423c <IfxGtm_Tom_PwmHl_updateAndShiftOff>:
{
8000423c:	40 ae       	mov.aa %a14,%sp
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
8000423e:	a0 05       	mov.a %a5,0
80004240:	6d ff c7 ff 	call 800041ce <IfxGtm_Tom_PwmHl_updateOff>
}
80004244:	00 90       	ret 

80004246 <IfxGtm_Tom_PwmHl_updatePulse>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulse(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset)
{
80004246:	40 ae       	mov.aa %a14,%sp
    uint8          channelIndex;
    Ifx_TimerValue period;

    period = driver->timer->base.period;
80004248:	99 42 20 00 	ld.a %a2,[%a4]32
8000424c:	54 23       	ld.w %d3,[%a2]

    /* Top channels */
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
8000424e:	82 04       	mov %d4,0
80004250:	1d 00 38 00 	j 800042c0 <IfxGtm_Tom_PwmHl_updatePulse+0x7a>
        else
        {}

        if ((x < driver->base.minPulse) || (o > period))
        {
            x = 0;
80004254:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80004256:	5f 32 1f 00 	jeq %d2,%d3,80004294 <IfxGtm_Tom_PwmHl_updatePulse+0x4e>
        {   /* 100% duty cycle */
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
                period + 1 /* No compare event */,
                2 /* 1st compare event (issue: expected to be 1)*/);
        }
        else if (x == 0)
8000425a:	df 02 62 80 	jne %d2,0,8000431e <IfxGtm_Tom_PwmHl_updatePulse+0xd8>
        {
            cm0 = 1;
            cm1 = period + 2;
8000425e:	1b 23 00 20 	addi %d2,%d3,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80004262:	99 42 10 10 	ld.a %a2,[%a4]80
80004266:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
8000426a:	54 25       	ld.w %d5,[%a2]
8000426c:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004270:	06 65       	sh %d5,6
80004272:	99 42 30 00 	ld.a %a2,[%a4]48
80004276:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
8000427a:	82 15       	mov %d5,1
8000427c:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
80004280:	59 22 08 00 	st.w [%a2]8,%d2
}
80004284:	1d 00 1b 00 	j 800042ba <IfxGtm_Tom_PwmHl_updatePulse+0x74>
            x = 0;
80004288:	82 02       	mov %d2,0
8000428a:	1d ff e6 ff 	j 80004256 <IfxGtm_Tom_PwmHl_updatePulse+0x10>
            x = period;
8000428e:	02 32       	mov %d2,%d3
80004290:	1d ff e3 ff 	j 80004256 <IfxGtm_Tom_PwmHl_updatePulse+0x10>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
80004294:	99 42 10 10 	ld.a %a2,[%a4]80
80004298:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
8000429c:	54 25       	ld.w %d5,[%a2]
                period + 1 /* No compare event */,
8000429e:	1b 13 00 20 	addi %d2,%d3,1
800042a2:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800042a6:	06 65       	sh %d5,6
800042a8:	99 42 30 00 	ld.a %a2,[%a4]48
800042ac:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
800042b0:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
800042b4:	82 22       	mov %d2,2
800042b6:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
800042ba:	c2 14       	add %d4,1
800042bc:	8f f4 0f 41 	and %d4,%d4,255
800042c0:	39 42 1d 00 	ld.bu %d2,[%a4]29
800042c4:	7f 24 44 80 	jge.u %d4,%d2,8000434c <IfxGtm_Tom_PwmHl_updatePulse+0x106>
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex]);
800042c8:	99 42 20 00 	ld.a %a2,[%a4]32
800042cc:	19 25 08 00 	ld.w %d5,[%a2]8
800042d0:	8f 24 00 60 	sh %d6,%d4,2
800042d4:	01 56 00 26 	addsc.a %a2,%a5,%d6,0
800042d8:	54 22       	ld.w %d2,[%a2]
800042da:	4b 25 41 20 	mul.f %d2,%d5,%d2
800042de:	4b 02 71 21 	ftouz %d2,%d2
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex]);
800042e2:	01 66 00 26 	addsc.a %a2,%a6,%d6,0
800042e6:	54 27       	ld.w %d7,[%a2]
800042e8:	4b 75 41 50 	mul.f %d5,%d5,%d7
800042ec:	4b 05 71 51 	ftouz %d5,%d5
        if (driver->base.inverted != FALSE)
800042f0:	39 47 1c 00 	ld.bu %d7,[%a4]28
800042f4:	df 07 04 00 	jeq %d7,0,800042fc <IfxGtm_Tom_PwmHl_updatePulse+0xb6>
            x = period - x;
800042f8:	0b 23 80 20 	sub %d2,%d3,%d2
        if ((x < driver->base.minPulse) || (o > period))
800042fc:	19 47 04 00 	ld.w %d7,[%a4]4
80004300:	3f 72 aa ff 	jlt.u %d2,%d7,80004254 <IfxGtm_Tom_PwmHl_updatePulse+0xe>
80004304:	3f 53 c2 ff 	jlt.u %d3,%d5,80004288 <IfxGtm_Tom_PwmHl_updatePulse+0x42>
        else if ((x > driver->base.maxPulse) || (o + x > period))
80004308:	19 47 08 00 	ld.w %d7,[%a4]8
8000430c:	3f 27 c1 ff 	jlt.u %d7,%d2,8000428e <IfxGtm_Tom_PwmHl_updatePulse+0x48>
80004310:	0b 52 00 70 	add %d7,%d2,%d5
80004314:	7f 73 a1 ff 	jge.u %d3,%d7,80004256 <IfxGtm_Tom_PwmHl_updatePulse+0x10>
            x = period;
80004318:	02 32       	mov %d2,%d3
8000431a:	1d ff 9e ff 	j 80004256 <IfxGtm_Tom_PwmHl_updatePulse+0x10>
        }
        else
        {                /* x% duty cycle */
            cm1 = 2 + o; // CM1, set to 2 due to a GTM issue. should be 1 according to spec
8000431e:	1b 25 00 70 	addi %d7,%d5,2
            cm0 = o + x; // CM0, set to x+2 due to a GTM issue. should be x+1 according to spec
80004322:	42 25       	add %d5,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
80004324:	99 42 10 10 	ld.a %a2,[%a4]80
80004328:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
8000432c:	54 26       	ld.w %d6,[%a2]
8000432e:	bb f0 ff 2f 	mov.u %d2,65535
80004332:	26 25       	and %d5,%d2
80004334:	26 72       	and %d2,%d7
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004336:	06 66       	sh %d6,6
80004338:	99 42 30 00 	ld.a %a2,[%a4]48
8000433c:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80004340:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
80004344:	59 22 08 00 	st.w [%a2]8,%d2
}
80004348:	1d ff b9 ff 	j 800042ba <IfxGtm_Tom_PwmHl_updatePulse+0x74>
        }
    }

    /* Bottom channels */
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
8000434c:	82 04       	mov %d4,0
8000434e:	1d 00 36 00 	j 800043ba <IfxGtm_Tom_PwmHl_updatePulse+0x174>
        else
        {}

        if (x < driver->base.minPulse)
        {
            x = 0;
80004352:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80004354:	5f 32 1b 00 	jeq %d2,%d3,8000438a <IfxGtm_Tom_PwmHl_updatePulse+0x144>
        {   /* 100% duty cycle */
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1)*/);
        }
        else if (x == 0)
80004358:	df 02 5b 80 	jne %d2,0,8000440e <IfxGtm_Tom_PwmHl_updatePulse+0x1c8>
        {
            cm0 = 1;
            cm1 = period + 2;
8000435c:	1b 23 00 60 	addi %d6,%d3,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0, cm1);
80004360:	8f 24 00 20 	sh %d2,%d4,2
80004364:	99 42 14 10 	ld.a %a2,[%a4]84
80004368:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000436c:	54 25       	ld.w %d5,[%a2]
8000436e:	37 06 70 20 	extr.u %d2,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004372:	06 65       	sh %d5,6
80004374:	99 42 30 00 	ld.a %a2,[%a4]48
80004378:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
8000437c:	82 15       	mov %d5,1
8000437e:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
80004382:	59 22 08 00 	st.w [%a2]8,%d2
}
80004386:	1d 00 17 00 	j 800043b4 <IfxGtm_Tom_PwmHl_updatePulse+0x16e>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
8000438a:	8f 24 00 20 	sh %d2,%d4,2
8000438e:	99 42 14 10 	ld.a %a2,[%a4]84
80004392:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80004396:	54 25       	ld.w %d5,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
80004398:	1b 23 00 20 	addi %d2,%d3,2
8000439c:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800043a0:	06 65       	sh %d5,6
800043a2:	99 42 30 00 	ld.a %a2,[%a4]48
800043a6:	01 25 00 26 	addsc.a %a2,%a2,%d5,0
    tomCh->SR0.U = shadowZero;
800043aa:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
800043ae:	82 22       	mov %d2,2
800043b0:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
800043b4:	c2 14       	add %d4,1
800043b6:	8f f4 0f 41 	and %d4,%d4,255
800043ba:	39 42 1d 00 	ld.bu %d2,[%a4]29
800043be:	7f 24 42 80 	jge.u %d4,%d2,80004442 <IfxGtm_Tom_PwmHl_updatePulse+0x1fc>
        x = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, tOn[channelIndex + driver->base.channelCount]);
800043c2:	99 42 20 00 	ld.a %a2,[%a4]32
800043c6:	19 25 08 00 	ld.w %d5,[%a2]8
800043ca:	42 42       	add %d2,%d4
800043cc:	8f 22 00 60 	sh %d6,%d2,2
800043d0:	01 56 00 26 	addsc.a %a2,%a5,%d6,0
800043d4:	54 22       	ld.w %d2,[%a2]
800043d6:	4b 25 41 20 	mul.f %d2,%d5,%d2
800043da:	4b 02 71 21 	ftouz %d2,%d2
        o = IfxStdIf_Timer_sToTick(driver->timer->base.clockFreq, offset[channelIndex + driver->base.channelCount]);
800043de:	01 66 00 26 	addsc.a %a2,%a6,%d6,0
800043e2:	54 26       	ld.w %d6,[%a2]
800043e4:	4b 65 41 60 	mul.f %d6,%d5,%d6
800043e8:	4b 06 71 61 	ftouz %d6,%d6
        if (driver->base.inverted != FALSE)
800043ec:	39 45 1c 00 	ld.bu %d5,[%a4]28
800043f0:	df 05 04 00 	jeq %d5,0,800043f8 <IfxGtm_Tom_PwmHl_updatePulse+0x1b2>
            x = period - x;
800043f4:	0b 23 80 20 	sub %d2,%d3,%d2
        if (x < driver->base.minPulse)
800043f8:	19 45 04 00 	ld.w %d5,[%a4]4
800043fc:	3f 52 ab ff 	jlt.u %d2,%d5,80004352 <IfxGtm_Tom_PwmHl_updatePulse+0x10c>
        else if (x > driver->base.maxPulse)
80004400:	19 45 08 00 	ld.w %d5,[%a4]8
80004404:	7f 25 a8 ff 	jge.u %d5,%d2,80004354 <IfxGtm_Tom_PwmHl_updatePulse+0x10e>
            x = period;
80004408:	02 32       	mov %d2,%d3
8000440a:	1d ff a5 ff 	j 80004354 <IfxGtm_Tom_PwmHl_updatePulse+0x10e>
        }
        else
        {                /* x% duty cycle */
            cm1 = 2 + o; // CM1, set to 2 due to a GTM issue. should be 1 according to spec
8000440e:	1b 26 00 70 	addi %d7,%d6,2
            cm0 = o + x; // CM0, set to x+2 due to a GTM issue. should be x+1 according to spec
80004412:	0b 62 00 50 	add %d5,%d2,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0, cm1);
80004416:	8f 24 00 20 	sh %d2,%d4,2
8000441a:	99 42 14 10 	ld.a %a2,[%a4]84
8000441e:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80004422:	54 26       	ld.w %d6,[%a2]
80004424:	bb f0 ff 2f 	mov.u %d2,65535
80004428:	26 25       	and %d5,%d2
8000442a:	26 72       	and %d2,%d7
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000442c:	06 66       	sh %d6,6
8000442e:	99 42 30 00 	ld.a %a2,[%a4]48
80004432:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80004436:	59 25 04 00 	st.w [%a2]4,%d5
    tomCh->SR1.U = shadowOne;
8000443a:	59 22 08 00 	st.w [%a2]8,%d2
}
8000443e:	1d ff bb ff 	j 800043b4 <IfxGtm_Tom_PwmHl_updatePulse+0x16e>
        }
    }
}
80004442:	00 90       	ret 

80004444 <IfxGtm_Tom_PwmHl_updatePulseOff>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updatePulseOff(IfxGtm_Tom_PwmHl *driver, float32 *tOn, float32 *offset)
{
80004444:	40 ae       	mov.aa %a14,%sp
    IFX_UNUSED_PARAMETER(tOn)
    IFX_UNUSED_PARAMETER(offset)
    IfxGtm_Tom_PwmHl_updateOff(driver, NULL_PTR);
80004446:	a0 05       	mov.a %a5,0
80004448:	6d ff c3 fe 	call 800041ce <IfxGtm_Tom_PwmHl_updateOff>
}
8000444c:	00 90       	ret 

8000444e <IfxGtm_Tom_PwmHl_updateShiftCenterAligned>:


IFX_STATIC void IfxGtm_Tom_PwmHl_updateShiftCenterAligned(IfxGtm_Tom_PwmHl *driver, Ifx_TimerValue *tOn, Ifx_TimerValue *shift)
{
8000444e:	40 ae       	mov.aa %a14,%sp
80004450:	80 6b       	mov.d %d11,%a6
    uint8          channelIndex;
    Ifx_TimerValue period;
    Ifx_TimerValue deadtime = driver->base.deadtime;
80004452:	54 47       	ld.w %d7,[%a4]

    period = driver->timer->base.period;
80004454:	99 42 20 00 	ld.a %a2,[%a4]32
80004458:	54 25       	ld.w %d5,[%a2]

    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
8000445a:	82 03       	mov %d3,0
8000445c:	1d 00 5e 00 	j 80004518 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xca>
        else
        {}

        if ((x < driver->base.minPulse) || (x <= deadtime))
        {   /* For deadtime condition: avoid leading edge of top channel to occur after the trailing edge */
            x = 0;
80004460:	82 02       	mov %d2,0
        }
        else
        {}

        /* Special handling due to GTM issue */
        if (x == period)
80004462:	5f 52 2e 00 	jeq %d2,%d5,800044be <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x70>
                2 /* 1st compare event (issue: expected to be 1)*/ + deadtime);
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
                period + 2 /* No compare event, issues has been seen with +1 */,
                2 /* 1st compare event (issue: expected to be 1)*/);
        }
        else if (x == 0)
80004466:	df 02 75 80 	jne %d2,0,80004550 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x102>
        {
            cm0 = 1;
            cm1 = period + 2;
8000446a:	1b 25 00 20 	addi %d2,%d5,2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1);
8000446e:	99 42 10 10 	ld.a %a2,[%a4]80
80004472:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004476:	54 26       	ld.w %d6,[%a2]
80004478:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000447c:	06 66       	sh %d6,6
8000447e:	99 42 30 00 	ld.a %a2,[%a4]48
80004482:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
80004486:	82 16       	mov %d6,1
80004488:	59 26 04 00 	st.w [%a2]4,%d6
    tomCh->SR1.U = shadowOne;
8000448c:	59 22 08 00 	st.w [%a2]8,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
80004490:	99 42 14 10 	ld.a %a2,[%a4]84
80004494:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004498:	54 26       	ld.w %d6,[%a2]
8000449a:	1b 17 00 40 	addi %d4,%d7,1
8000449e:	37 04 70 40 	extr.u %d4,%d4,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800044a2:	06 66       	sh %d6,6
800044a4:	99 42 30 00 	ld.a %a2,[%a4]48
800044a8:	01 26 00 26 	addsc.a %a2,%a2,%d6,0
    tomCh->SR0.U = shadowZero;
800044ac:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
800044b0:	59 22 08 00 	st.w [%a2]8,%d2
}
800044b4:	1d 00 2f 00 	j 80004512 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xc4>
            x = 0;
800044b8:	82 02       	mov %d2,0
800044ba:	1d ff d4 ff 	j 80004462 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x14>
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex],
800044be:	99 42 10 10 	ld.a %a2,[%a4]80
800044c2:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800044c6:	54 21       	ld.w %d1,[%a2]
                period + 1 /* No compare event */,
800044c8:	37 05 70 20 	extr.u %d2,%d5,0,16
800044cc:	1b 12 00 00 	addi %d0,%d2,1
800044d0:	37 00 70 00 	extr.u %d0,%d0,0,16
                2 /* 1st compare event (issue: expected to be 1)*/ + deadtime);
800044d4:	1b 27 00 60 	addi %d6,%d7,2
800044d8:	37 06 70 60 	extr.u %d6,%d6,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800044dc:	06 61       	sh %d1,6
800044de:	99 42 30 00 	ld.a %a2,[%a4]48
800044e2:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
800044e6:	59 20 04 00 	st.w [%a2]4,%d0
    tomCh->SR1.U = shadowOne;
800044ea:	59 26 08 00 	st.w [%a2]8,%d6
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex],
800044ee:	99 42 14 10 	ld.a %a2,[%a4]84
800044f2:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800044f6:	54 24       	ld.w %d4,[%a2]
                period + 2 /* No compare event, issues has been seen with +1 */,
800044f8:	c2 22       	add %d2,2
800044fa:	37 02 70 20 	extr.u %d2,%d2,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800044fe:	06 64       	sh %d4,6
80004500:	99 42 30 00 	ld.a %a2,[%a4]48
80004504:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
    tomCh->SR0.U = shadowZero;
80004508:	59 22 04 00 	st.w [%a2]4,%d2
    tomCh->SR1.U = shadowOne;
8000450c:	82 22       	mov %d2,2
8000450e:	59 22 08 00 	st.w [%a2]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
80004512:	c2 13       	add %d3,1
80004514:	8f f3 0f 31 	and %d3,%d3,255
80004518:	39 42 1d 00 	ld.bu %d2,[%a4]29
8000451c:	7f 23 64 80 	jge.u %d3,%d2,800045e4 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x196>
        x = tOn[channelIndex];
80004520:	8f 23 00 40 	sh %d4,%d3,2
80004524:	01 54 00 26 	addsc.a %a2,%a5,%d4,0
80004528:	54 22       	ld.w %d2,[%a2]
        if (driver->base.inverted != FALSE)
8000452a:	39 46 1c 00 	ld.bu %d6,[%a4]28
8000452e:	df 06 04 00 	jeq %d6,0,80004536 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xe8>
            x = period - x;
80004532:	0b 25 80 20 	sub %d2,%d5,%d2
        if ((x < driver->base.minPulse) || (x <= deadtime))
80004536:	19 46 04 00 	ld.w %d6,[%a4]4
8000453a:	3f 62 93 ff 	jlt.u %d2,%d6,80004460 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x12>
8000453e:	7f 27 bd ff 	jge.u %d7,%d2,800044b8 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x6a>
        else if (x > driver->base.maxPulse)
80004542:	19 46 08 00 	ld.w %d6,[%a4]8
80004546:	7f 26 8e ff 	jge.u %d6,%d2,80004462 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x14>
            x = period;
8000454a:	02 52       	mov %d2,%d5
8000454c:	1d ff 8b ff 	j 80004462 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x14>
        }
        else
        {                           /* x% duty cycle */
            s = shift[channelIndex];
80004550:	60 b2       	mov.a %a2,%d11
80004552:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80004556:	54 26       	ld.w %d6,[%a2]

            if (s > 0)
80004558:	df 06 3e 00 	jeq %d6,0,800045d4 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x186>
            {
                s = __minX(s, (period - x) / 2 - 1);
8000455c:	0b 25 80 00 	sub %d0,%d5,%d2
80004560:	06 f0       	sh %d0,-1
80004562:	c2 f0       	add %d0,-1
80004564:	0b 60 90 61 	min.u %d6,%d0,%d6
            else
            {
                s = __maxX(s, (x - period) / 2 + 1);
            }

            cm1 = s + (period - x) / 2; // CM1
80004568:	0b 25 80 00 	sub %d0,%d5,%d2
8000456c:	06 f0       	sh %d0,-1
8000456e:	42 60       	add %d0,%d6
            cm0 = s + (period + x) / 2; // CM0
80004570:	42 52       	add %d2,%d5
80004572:	06 f2       	sh %d2,-1
80004574:	42 26       	add %d6,%d2
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->ccxTemp[channelIndex], cm0, cm1 + deadtime);
80004576:	99 42 10 10 	ld.a %a2,[%a4]80
8000457a:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
8000457e:	54 2a       	ld.w %d10,[%a2]
80004580:	37 06 70 90 	extr.u %d9,%d6,0,16
80004584:	bb f0 ff 2f 	mov.u %d2,65535
80004588:	0f 26 80 80 	and %d8,%d6,%d2
8000458c:	37 07 70 60 	extr.u %d6,%d7,0,16
80004590:	0b 06 00 10 	add %d1,%d6,%d0
80004594:	37 01 70 10 	extr.u %d1,%d1,0,16
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004598:	06 6a       	sh %d10,6
8000459a:	99 42 30 00 	ld.a %a2,[%a4]48
8000459e:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->SR0.U = shadowZero;
800045a2:	59 28 04 00 	st.w [%a2]4,%d8
    tomCh->SR1.U = shadowOne;
800045a6:	59 21 08 00 	st.w [%a2]8,%d1
            IfxGtm_Tom_Ch_setCompareShadow(driver->tom, driver->coutxTemp[channelIndex], cm0 + deadtime, cm1);
800045aa:	99 42 14 10 	ld.a %a2,[%a4]84
800045ae:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
800045b2:	54 21       	ld.w %d1,[%a2]
800045b4:	0b 69 00 40 	add %d4,%d9,%d6
800045b8:	37 04 70 40 	extr.u %d4,%d4,0,16
800045bc:	26 02       	and %d2,%d0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800045be:	06 61       	sh %d1,6
800045c0:	99 42 30 00 	ld.a %a2,[%a4]48
800045c4:	01 21 00 26 	addsc.a %a2,%a2,%d1,0
    tomCh->SR0.U = shadowZero;
800045c8:	59 24 04 00 	st.w [%a2]4,%d4
    tomCh->SR1.U = shadowOne;
800045cc:	59 22 08 00 	st.w [%a2]8,%d2
}
800045d0:	1d ff a1 ff 	j 80004512 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0xc4>
                s = __maxX(s, (x - period) / 2 + 1);
800045d4:	0b 52 80 00 	sub %d0,%d2,%d5
800045d8:	06 f0       	sh %d0,-1
800045da:	c2 10       	add %d0,1
800045dc:	0b 60 b0 61 	max.u %d6,%d0,%d6
800045e0:	1d ff c4 ff 	j 80004568 <IfxGtm_Tom_PwmHl_updateShiftCenterAligned+0x11a>
        }
    }
}
800045e4:	00 90       	ret 

800045e6 <IfxGtm_Tom_PwmHl_init>:
{
800045e6:	40 ae       	mov.aa %a14,%sp
800045e8:	20 18       	sub.a %sp,24
800045ea:	40 4c       	mov.aa %a12,%a4
800045ec:	40 5d       	mov.aa %a13,%a5
    IfxGtm_Tom_Timer *timer        = config->timer;
800045ee:	cc 59       	ld.a %a15,[%a5]36
    driver->base.mode             = Ifx_Pwm_Mode_init;
800045f0:	82 52       	mov %d2,5
800045f2:	59 42 0c 00 	st.w [%a4]12,%d2
    driver->timer                 = timer;
800045f6:	ec 48       	st.a [%a4]32,%a15
    driver->base.setMode          = 0;
800045f8:	82 02       	mov %d2,0
800045fa:	e9 42 10 00 	st.b [%a4]16,%d2
    driver->base.inverted         = FALSE;
800045fe:	e9 42 1c 00 	st.b [%a4]28,%d2
    driver->base.ccxActiveState   = config->base.ccxActiveState;
80004602:	19 52 1c 00 	ld.w %d2,[%a5]28
80004606:	59 42 14 00 	st.w [%a4]20,%d2
    driver->base.coutxActiveState = config->base.coutxActiveState;
8000460a:	19 52 20 00 	ld.w %d2,[%a5]32
8000460e:	59 42 18 00 	st.w [%a4]24,%d2
    driver->base.channelCount     = config->base.channelCount;
80004612:	39 52 08 00 	ld.bu %d2,[%a5]8
80004616:	e9 42 1d 00 	st.b [%a4]29,%d2
    IfxGtm_Tom_PwmHl_setDeadtime(driver, config->base.deadtime);
8000461a:	54 54       	ld.w %d4,[%a5]
8000461c:	6d ff aa fb 	call 80003d70 <IfxGtm_Tom_PwmHl_setDeadtime>
    IfxGtm_Tom_PwmHl_setMinPulse(driver, config->base.minPulse);
80004620:	19 d4 04 00 	ld.w %d4,[%a13]4
80004624:	40 c4       	mov.aa %a4,%a12
80004626:	6d ff b1 fb 	call 80003d88 <IfxGtm_Tom_PwmHl_setMinPulse>
    driver->tom = &(timer->gtm->TOM[config->tom]);
8000462a:	19 d2 28 00 	ld.w %d2,[%a13]40
8000462e:	1b 02 01 20 	addi %d2,%d2,16
80004632:	8f b2 00 20 	sh %d2,%d2,11
80004636:	48 43       	ld.w %d3,[%a15]16
80004638:	42 23       	add %d3,%d2
8000463a:	59 c3 30 00 	st.w [%a12]48,%d3
    if (config->ccx[0]->channel <= 7)
8000463e:	99 d2 2c 00 	ld.a %a2,[%a13]44
80004642:	d4 22       	ld.a %a2,[%a2]
80004644:	19 22 04 00 	ld.w %d2,[%a2]4
80004648:	8b 82 80 22 	ge %d2,%d2,8
8000464c:	df 02 1c 80 	jne %d2,0,80004684 <IfxGtm_Tom_PwmHl_init+0x9e>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC0_GLB_CTRL;
80004650:	1b 03 03 20 	addi %d2,%d3,48
        driver->tgc = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 0);
80004654:	59 c2 34 00 	st.w [%a12]52,%d2
    maskShift = (config->ccx[0]->channel <= 7) ? 0 : 8;
80004658:	99 d2 2c 00 	ld.a %a2,[%a13]44
8000465c:	d4 22       	ld.a %a2,[%a2]
8000465e:	19 22 04 00 	ld.w %d2,[%a2]4
80004662:	8b 82 80 22 	ge %d2,%d2,8
80004666:	df 02 15 80 	jne %d2,0,80004690 <IfxGtm_Tom_PwmHl_init+0xaa>
8000466a:	82 0f       	mov %d15,0
    IfxGtm_Tom_Ch_ClkSrc clock = IfxGtm_Tom_Ch_getClockSource(timer->tom, timer->timerChannel);
8000466c:	48 92       	ld.w %d2,[%a15]36
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000466e:	06 62       	sh %d2,6
80004670:	c8 52       	ld.a %a2,[%a15]20
80004672:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
    clk = (IfxGtm_Tom_Ch_ClkSrc)tomCh->CTRL.B.CLK_SRC_SR;
80004676:	54 2e       	ld.w %d14,[%a2]
80004678:	37 0e 63 e6 	extr.u %d14,%d14,12,3
    for (channelIndex = 0; channelIndex < config->base.channelCount; channelIndex++)
8000467c:	82 08       	mov %d8,0
    uint16            channelsMask = 0;
8000467e:	82 09       	mov %d9,0
    for (channelIndex = 0; channelIndex < config->base.channelCount; channelIndex++)
80004680:	1d 00 af 00 	j 800047de <IfxGtm_Tom_PwmHl_init+0x1f8>
        pointer = (Ifx_GTM_TOM_TGC *)&tom->TGC1_GLB_CTRL;
80004684:	1b 03 23 20 	addi %d2,%d3,560
        driver->tgc = IfxGtm_Tom_Ch_getTgcPointer(driver->tom, 1);
80004688:	59 c2 34 00 	st.w [%a12]52,%d2
8000468c:	1d ff e6 ff 	j 80004658 <IfxGtm_Tom_PwmHl_init+0x72>
    maskShift = (config->ccx[0]->channel <= 7) ? 0 : 8;
80004690:	da 08       	mov %d15,8
80004692:	1d ff ed ff 	j 8000466c <IfxGtm_Tom_PwmHl_init+0x86>
            : IfxGtm_Tom_PwmHl_invertActiveState(config->base.ccxActiveState));
80004696:	19 d2 1c 00 	ld.w %d2,[%a13]28
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
8000469a:	8b 02 00 22 	eq %d2,%d2,0
8000469e:	1d 00 cf 00 	j 8000483c <IfxGtm_Tom_PwmHl_init+0x256>
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
800046a2:	82 13       	mov %d3,1
800046a4:	1d 00 d2 00 	j 80004848 <IfxGtm_Tom_PwmHl_init+0x262>
            : IfxGtm_Tom_PwmHl_invertActiveState(config->base.ccxActiveState));
800046a8:	19 d2 1c 00 	ld.w %d2,[%a13]28
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
800046ac:	8b 02 00 22 	eq %d2,%d2,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800046b0:	60 92       	mov.a %a2,%d9
800046b2:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
800046b6:	df 12 f1 00 	jeq %d2,1,80004898 <IfxGtm_Tom_PwmHl_init+0x2b2>
800046ba:	82 03       	mov %d3,0
800046bc:	54 22       	ld.w %d2,[%a2]
800046be:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
800046c2:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800046c4:	99 c2 30 00 	ld.a %a2,[%a12]48
800046c8:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
    tomCh->CTRL.B.RST_CCU0 = (uint8)event;
800046cc:	54 22       	ld.w %d2,[%a2]
800046ce:	b7 12 01 2a 	insert %d2,%d2,1,20,1
800046d2:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800046d4:	99 c2 30 00 	ld.a %a2,[%a12]48
800046d8:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
800046dc:	54 22       	ld.w %d2,[%a2]
800046de:	b7 02 01 2c 	insert %d2,%d2,0,24,1
800046e2:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setCounterValue(driver->tom, channel, IfxGtm_Tom_Timer_getOffset(driver->timer));
800046e4:	19 ca 30 00 	ld.w %d10,[%a12]48
800046e8:	99 c4 20 00 	ld.a %a4,[%a12]32
800046ec:	6d ff e0 f8 	call 800038ac <IfxGtm_Tom_Timer_getOffset>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800046f0:	60 92       	mov.a %a2,%d9
800046f2:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CN0.U = value;
800046f6:	59 22 14 00 	st.w [%a2]20,%d2
        if (config->initPins == TRUE)
800046fa:	39 d2 34 00 	ld.bu %d2,[%a13]52
800046fe:	df 12 d0 00 	jeq %d2,1,8000489e <IfxGtm_Tom_PwmHl_init+0x2b8>
        channel                     = config->coutx[channelIndex]->channel;
80004702:	99 d2 30 00 	ld.a %a2,[%a13]48
80004706:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
8000470a:	d4 22       	ld.a %a2,[%a2]
8000470c:	19 2a 04 00 	ld.w %d10,[%a2]4
        driver->coutx[channelIndex] = channel;
80004710:	1b 18 01 30 	addi %d3,%d8,17
80004714:	06 23       	sh %d3,2
80004716:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
8000471a:	74 2a       	st.w [%a2],%d10
        channelMask                 = 1 << (channel - maskShift);
8000471c:	19 e2 ec ff 	ld.w %d2,[%a14]-20
80004720:	0b 2a 80 30 	sub %d3,%d10,%d2
80004724:	82 1b       	mov %d11,1
80004726:	0f 3b 00 b0 	sh %d11,%d11,%d3
8000472a:	37 0b 70 90 	extr.u %d9,%d11,0,16
        channelsMask               |= channelMask;
8000472e:	a6 d9       	or %d9,%d13
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004730:	06 6a       	sh %d10,6
80004732:	99 c2 30 00 	ld.a %a2,[%a12]48
80004736:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
8000473a:	54 22       	ld.w %d2,[%a2]
8000473c:	37 e2 03 26 	insert %d2,%d2,%d14,12,3
80004740:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, driver->base.inverted
80004742:	19 c3 30 00 	ld.w %d3,[%a12]48
80004746:	39 c2 1c 00 	ld.bu %d2,[%a12]28
8000474a:	df 02 cd 00 	jeq %d2,0,800048e4 <IfxGtm_Tom_PwmHl_init+0x2fe>
            ? IfxGtm_Tom_PwmHl_invertActiveState(config->base.coutxActiveState)
8000474e:	19 d2 20 00 	ld.w %d2,[%a13]32
    return activeState == Ifx_ActiveState_low ? Ifx_ActiveState_high : Ifx_ActiveState_low;
80004752:	8b 02 00 22 	eq %d2,%d2,0
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004756:	60 a2       	mov.a %a2,%d10
80004758:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
8000475c:	df 12 c8 00 	jeq %d2,1,800048ec <IfxGtm_Tom_PwmHl_init+0x306>
80004760:	82 03       	mov %d3,0
80004762:	54 22       	ld.w %d2,[%a2]
80004764:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
80004768:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_enableChannels(driver->tgc, channelMask, 0, TRUE);
8000476a:	19 cd 34 00 	ld.w %d13,[%a12]52
8000476e:	37 0b 70 b0 	extr.u %d11,%d11,0,16
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
80004772:	82 06       	mov %d6,0
80004774:	82 05       	mov %d5,0
80004776:	02 b4       	mov %d4,%d11
80004778:	6d 00 f0 02 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
8000477c:	60 d2       	mov.a %a2,%d13
8000477e:	59 22 00 10 	st.w [%a2]64,%d2
        tgc->ENDIS_STAT.U = value;
80004782:	59 22 04 10 	st.w [%a2]68,%d2
        IfxGtm_Tom_Tgc_enableChannelsOutput(driver->tgc, channelMask, 0, TRUE);
80004786:	19 cd 34 00 	ld.w %d13,[%a12]52
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);
8000478a:	82 06       	mov %d6,0
8000478c:	82 05       	mov %d5,0
8000478e:	02 b4       	mov %d4,%d11
80004790:	6d 00 e4 02 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->OUTEN_CTRL.U = value;
80004794:	60 d2       	mov.a %a2,%d13
80004796:	59 22 08 10 	st.w [%a2]72,%d2
        tgc->OUTEN_STAT.U = value;
8000479a:	59 22 0c 10 	st.w [%a2]76,%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000479e:	99 c2 30 00 	ld.a %a2,[%a12]48
800047a2:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CTRL.B.RST_CCU0 = (uint8)event;
800047a6:	54 22       	ld.w %d2,[%a2]
800047a8:	b7 12 01 2a 	insert %d2,%d2,1,20,1
800047ac:	74 22       	st.w [%a2],%d2
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800047ae:	99 c2 30 00 	ld.a %a2,[%a12]48
800047b2:	01 2a 00 26 	addsc.a %a2,%a2,%d10,0
    tomCh->CTRL.B.TRIGOUT = (uint8)trigger;
800047b6:	54 22       	ld.w %d2,[%a2]
800047b8:	b7 02 01 2c 	insert %d2,%d2,0,24,1
800047bc:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setCounterValue(driver->tom, channel, IfxGtm_Tom_Timer_getOffset(driver->timer));
800047be:	19 cb 30 00 	ld.w %d11,[%a12]48
800047c2:	99 c4 20 00 	ld.a %a4,[%a12]32
800047c6:	6d ff 73 f8 	call 800038ac <IfxGtm_Tom_Timer_getOffset>
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
800047ca:	60 a2       	mov.a %a2,%d10
800047cc:	01 2b 00 26 	addsc.a %a2,%a2,%d11,0
    tomCh->CN0.U = value;
800047d0:	59 22 14 00 	st.w [%a2]20,%d2
        if (config->initPins == TRUE)
800047d4:	39 d2 34 00 	ld.bu %d2,[%a13]52
800047d8:	df 12 8d 00 	jeq %d2,1,800048f2 <IfxGtm_Tom_PwmHl_init+0x30c>
    for (channelIndex = 0; channelIndex < config->base.channelCount; channelIndex++)
800047dc:	c2 18       	add %d8,1
800047de:	39 d2 08 00 	ld.bu %d2,[%a13]8
800047e2:	7f 28 ab 80 	jge.u %d8,%d2,80004938 <IfxGtm_Tom_PwmHl_init+0x352>
        channel                   = config->ccx[channelIndex]->channel;
800047e6:	8f 28 00 c0 	sh %d12,%d8,2
800047ea:	99 d2 2c 00 	ld.a %a2,[%a13]44
800047ee:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800047f2:	d4 22       	ld.a %a2,[%a2]
800047f4:	19 22 04 00 	ld.w %d2,[%a2]4
        driver->ccx[channelIndex] = channel;
800047f8:	1b e8 00 30 	addi %d3,%d8,14
800047fc:	06 23       	sh %d3,2
800047fe:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80004802:	74 22       	st.w [%a2],%d2
        channelMask               = 1 << (channel - maskShift);
80004804:	59 ef ec ff 	st.w [%a14]-20,%d15
80004808:	0b f2 80 30 	sub %d3,%d2,%d15
8000480c:	82 1a       	mov %d10,1
8000480e:	0f 3a 00 a0 	sh %d10,%d10,%d3
80004812:	37 0a 70 d0 	extr.u %d13,%d10,0,16
        channelsMask             |= channelMask;
80004816:	a6 9d       	or %d13,%d9
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
80004818:	8f 62 00 90 	sh %d9,%d2,6
8000481c:	99 c2 30 00 	ld.a %a2,[%a12]48
80004820:	01 29 00 26 	addsc.a %a2,%a2,%d9,0
    tomCh->CTRL.B.CLK_SRC_SR = (uint8)clock;
80004824:	54 22       	ld.w %d2,[%a2]
80004826:	37 e2 03 26 	insert %d2,%d2,%d14,12,3
8000482a:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, !driver->base.inverted
8000482c:	19 c3 30 00 	ld.w %d3,[%a12]48
80004830:	39 c2 1c 00 	ld.bu %d2,[%a12]28
80004834:	df 02 31 ff 	jne %d2,0,80004696 <IfxGtm_Tom_PwmHl_init+0xb0>
80004838:	19 d2 1c 00 	ld.w %d2,[%a13]28
    return (Ifx_GTM_TOM_CH *)((uint32)&tom->CH0.CTRL.U + 0x40 * channel);
8000483c:	60 92       	mov.a %a2,%d9
8000483e:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80004842:	df 12 30 7f 	jeq %d2,1,800046a2 <IfxGtm_Tom_PwmHl_init+0xbc>
80004846:	82 03       	mov %d3,0
80004848:	54 22       	ld.w %d2,[%a2]
8000484a:	67 32 0b 20 	ins.t %d2,%d2,11,%d3,0
8000484e:	74 22       	st.w [%a2],%d2
        IfxGtm_Tom_Tgc_enableChannels(driver->tgc, channelMask, 0, TRUE); /* Write the SOUR outout with !SL */
80004850:	19 cb 34 00 	ld.w %d11,[%a12]52
80004854:	37 0a 70 a0 	extr.u %d10,%d10,0,16
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_ENDIS_CTRL_ENDIS_CTRL0_OFF);
80004858:	82 06       	mov %d6,0
8000485a:	82 05       	mov %d5,0
8000485c:	02 a4       	mov %d4,%d10
8000485e:	6d 00 7d 02 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->ENDIS_CTRL.U = value;
80004862:	60 b2       	mov.a %a2,%d11
80004864:	59 22 00 10 	st.w [%a2]64,%d2
        tgc->ENDIS_STAT.U = value;
80004868:	59 22 04 10 	st.w [%a2]68,%d2
        IfxGtm_Tom_Tgc_enableChannelsOutput(driver->tgc, channelMask, 0, TRUE);
8000486c:	19 cb 34 00 	ld.w %d11,[%a12]52
    value = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_OUTEN_CTRL_OUTEN_CTRL0_OFF);
80004870:	82 06       	mov %d6,0
80004872:	82 05       	mov %d5,0
80004874:	02 a4       	mov %d4,%d10
80004876:	6d 00 71 02 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
        tgc->OUTEN_CTRL.U = value;
8000487a:	60 b2       	mov.a %a2,%d11
8000487c:	59 22 08 10 	st.w [%a2]72,%d2
        tgc->OUTEN_STAT.U = value;
80004880:	59 22 0c 10 	st.w [%a2]76,%d2
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, driver->base.inverted
80004884:	19 c3 30 00 	ld.w %d3,[%a12]48
80004888:	39 c2 1c 00 	ld.bu %d2,[%a12]28
8000488c:	df 02 0e 7f 	jeq %d2,0,800046a8 <IfxGtm_Tom_PwmHl_init+0xc2>
80004890:	19 d2 1c 00 	ld.w %d2,[%a13]28
80004894:	1d ff 0e ff 	j 800046b0 <IfxGtm_Tom_PwmHl_init+0xca>
    tomCh->CTRL.B.SL = (activeState == Ifx_ActiveState_high) ? 1u : 0u;
80004898:	82 13       	mov %d3,1
8000489a:	1d ff 11 ff 	j 800046bc <IfxGtm_Tom_PwmHl_init+0xd6>
            IfxGtm_PinMap_setTomTout(config->ccx[channelIndex],
8000489e:	99 d2 2c 00 	ld.a %a2,[%a13]44
800048a2:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800048a6:	19 d5 10 00 	ld.w %d5,[%a13]16
800048aa:	19 d4 0c 00 	ld.w %d4,[%a13]12
800048ae:	d4 24       	ld.a %a4,[%a2]
800048b0:	6d ff 58 e7 	call 80001760 <IfxGtm_PinMap_setTomTout>
            IfxPort_setPinState(config->ccx[channelIndex]->pin.port, config->ccx[channelIndex]->pin.pinIndex, config->base.ccxActiveState ? IfxPort_State_low : IfxPort_State_high);
800048b4:	99 d2 2c 00 	ld.a %a2,[%a13]44
800048b8:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800048bc:	d4 22       	ld.a %a2,[%a2]
800048be:	99 23 10 00 	ld.a %a3,[%a2]16
800048c2:	39 22 14 00 	ld.bu %d2,[%a2]20
800048c6:	19 d3 1c 00 	ld.w %d3,[%a13]28
800048ca:	df 03 0a 00 	jeq %d3,0,800048de <IfxGtm_Tom_PwmHl_init+0x2f8>
800048ce:	7b 10 00 30 	movh %d3,1
    port->OMR.U = action << pinIndex;
800048d2:	0f 23 00 20 	sh %d2,%d3,%d2
800048d6:	59 32 04 00 	st.w [%a3]4,%d2
}
800048da:	1d ff 14 ff 	j 80004702 <IfxGtm_Tom_PwmHl_init+0x11c>
800048de:	82 13       	mov %d3,1
800048e0:	1d ff f9 ff 	j 800048d2 <IfxGtm_Tom_PwmHl_init+0x2ec>
        IfxGtm_Tom_Ch_setSignalLevel(driver->tom, channel, driver->base.inverted
800048e4:	19 d2 20 00 	ld.w %d2,[%a13]32
800048e8:	1d ff 37 ff 	j 80004756 <IfxGtm_Tom_PwmHl_init+0x170>
800048ec:	82 13       	mov %d3,1
800048ee:	1d ff 3a ff 	j 80004762 <IfxGtm_Tom_PwmHl_init+0x17c>
            IfxGtm_PinMap_setTomTout(config->coutx[channelIndex],
800048f2:	99 d2 30 00 	ld.a %a2,[%a13]48
800048f6:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
800048fa:	19 d5 10 00 	ld.w %d5,[%a13]16
800048fe:	19 d4 0c 00 	ld.w %d4,[%a13]12
80004902:	d4 24       	ld.a %a4,[%a2]
80004904:	6d ff 2e e7 	call 80001760 <IfxGtm_PinMap_setTomTout>
            IfxPort_setPinState(config->coutx[channelIndex]->pin.port, config->coutx[channelIndex]->pin.pinIndex, config->base.coutxActiveState ? IfxPort_State_low : IfxPort_State_high);
80004908:	99 d2 30 00 	ld.a %a2,[%a13]48
8000490c:	01 2c 00 26 	addsc.a %a2,%a2,%d12,0
80004910:	d4 22       	ld.a %a2,[%a2]
80004912:	99 23 10 00 	ld.a %a3,[%a2]16
80004916:	39 22 14 00 	ld.bu %d2,[%a2]20
8000491a:	19 d3 20 00 	ld.w %d3,[%a13]32
8000491e:	df 03 0a 00 	jeq %d3,0,80004932 <IfxGtm_Tom_PwmHl_init+0x34c>
80004922:	7b 10 00 30 	movh %d3,1
    port->OMR.U = action << pinIndex;
80004926:	0f 23 00 20 	sh %d2,%d3,%d2
8000492a:	59 32 04 00 	st.w [%a3]4,%d2
}
8000492e:	1d ff 57 ff 	j 800047dc <IfxGtm_Tom_PwmHl_init+0x1f6>
80004932:	82 13       	mov %d3,1
80004934:	1d ff f9 ff 	j 80004926 <IfxGtm_Tom_PwmHl_init+0x340>
    IfxGtm_Tom_PwmHl_setMode(driver, Ifx_Pwm_Mode_off);
80004938:	82 44       	mov %d4,4
8000493a:	40 c4       	mov.aa %a4,%a12
8000493c:	6d ff 3a fa 	call 80003db0 <IfxGtm_Tom_PwmHl_setMode>
    Ifx_TimerValue tOn[IFXGTM_TOM_PWMHL_MAX_NUM_CHANNELS] = {0};
80004940:	82 02       	mov %d2,0
80004942:	59 e2 f4 ff 	st.w [%a14]-12,%d2
80004946:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000494a:	59 e2 fc ff 	st.w [%a14]-4,%d2
    IfxGtm_Tom_PwmHl_updateOff(driver, tOn);     /* tOn do not need defined values */
8000494e:	d9 e5 f4 ff 	lea %a5,[%a14]-12
80004952:	40 c4       	mov.aa %a4,%a12
80004954:	6d ff 3d fc 	call 800041ce <IfxGtm_Tom_PwmHl_updateOff>
    IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc, channelsMask, 0, 0, 0);
80004958:	99 cd 34 00 	ld.a %a13,[%a12]52
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
8000495c:	82 06       	mov %d6,0
8000495e:	82 05       	mov %d5,0
80004960:	02 94       	mov %d4,%d9
80004962:	6d 00 fb 01 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
80004966:	02 28       	mov %d8,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
80004968:	3b 00 01 60 	mov %d6,16
8000496c:	82 05       	mov %d5,0
8000496e:	82 04       	mov %d4,0
80004970:	6d 00 f4 01 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
80004974:	a6 82       	or %d2,%d8
80004976:	59 d2 08 00 	st.w [%a13]8,%d2
    IfxGtm_Tom_Tgc_trigger(driver->tgc);
8000497a:	99 c2 34 00 	ld.a %a2,[%a12]52
    tgc->GLB_CTRL.U = 1 << IFX_GTM_TOM_TGC0_GLB_CTRL_HOST_TRIG_OFF;
8000497e:	82 12       	mov %d2,1
80004980:	74 22       	st.w [%a2],%d2
    IfxGtm_Tom_Tgc_setChannelsForceUpdate(driver->tgc, 0, channelsMask, 0, 0);
80004982:	99 cd 34 00 	ld.a %a13,[%a12]52
    regEnable        = IfxGtm_Tom_Tgc_buildFeature(enableMask, disableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_FUPD_CTRL0_OFF);
80004986:	82 06       	mov %d6,0
80004988:	02 95       	mov %d5,%d9
8000498a:	82 04       	mov %d4,0
8000498c:	6d 00 e6 01 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
80004990:	02 28       	mov %d8,%d2
    regReset         = IfxGtm_Tom_Tgc_buildFeature(resetEnableMask, resetDisableMask, IFX_GTM_TOM_TGC0_FUPD_CTRL_RSTCN0_CH0_OFF);
80004992:	3b 00 01 60 	mov %d6,16
80004996:	82 05       	mov %d5,0
80004998:	82 04       	mov %d4,0
8000499a:	6d 00 df 01 	call 80004d58 <IfxGtm_Tom_Tgc_buildFeature>
    tgc->FUPD_CTRL.U = regEnable | regReset;
8000499e:	a6 82       	or %d2,%d8
800049a0:	59 d2 08 00 	st.w [%a13]8,%d2
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
800049a4:	82 08       	mov %d8,0
800049a6:	1d 00 15 00 	j 800049d0 <IfxGtm_Tom_PwmHl_init+0x3ea>
        IfxGtm_Tom_Timer_addToChannelMask(timer, driver->ccx[channelIndex]);
800049aa:	1b e8 00 20 	addi %d2,%d8,14
800049ae:	06 22       	sh %d2,2
800049b0:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800049b4:	54 24       	ld.w %d4,[%a2]
800049b6:	40 f4       	mov.aa %a4,%a15
800049b8:	6d ff 21 f7 	call 800037fa <IfxGtm_Tom_Timer_addToChannelMask>
        IfxGtm_Tom_Timer_addToChannelMask(timer, driver->coutx[channelIndex]);
800049bc:	1b 18 01 20 	addi %d2,%d8,17
800049c0:	06 22       	sh %d2,2
800049c2:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800049c6:	54 24       	ld.w %d4,[%a2]
800049c8:	40 f4       	mov.aa %a4,%a15
800049ca:	6d ff 18 f7 	call 800037fa <IfxGtm_Tom_Timer_addToChannelMask>
    for (channelIndex = 0; channelIndex < driver->base.channelCount; channelIndex++)
800049ce:	c2 18       	add %d8,1
800049d0:	39 c2 1d 00 	ld.bu %d2,[%a12]29
800049d4:	3f 28 eb ff 	jlt.u %d8,%d2,800049aa <IfxGtm_Tom_PwmHl_init+0x3c4>
}
800049d8:	82 12       	mov %d2,1
800049da:	00 90       	ret 

800049dc <IfxGtm_Tom_PwmHl_initConfig>:
{
800049dc:	40 ae       	mov.aa %a14,%sp
800049de:	40 4c       	mov.aa %a12,%a4
    IfxStdIf_PwmHl_initConfig(&config->base);
800049e0:	6d 00 96 0d 	call 8000650c <IfxStdIf_PwmHl_initConfig>
    config->timer    = NULL_PTR;
800049e4:	82 02       	mov %d2,0
800049e6:	59 c2 24 00 	st.w [%a12]36,%d2
    config->tom      = IfxGtm_Tom_0;
800049ea:	59 c2 28 00 	st.w [%a12]40,%d2
    config->ccx      = NULL_PTR;
800049ee:	59 c2 2c 00 	st.w [%a12]44,%d2
    config->coutx    = NULL_PTR;
800049f2:	59 c2 30 00 	st.w [%a12]48,%d2
    config->initPins = TRUE;
800049f6:	82 12       	mov %d2,1
800049f8:	e9 c2 34 00 	st.b [%a12]52,%d2
}
800049fc:	00 90       	ret 

800049fe <IfxGtm_enable>:
    IfxScuWdt_setCpuEndinit(psw);
}


void IfxGtm_enable(Ifx_GTM *gtm)
{
800049fe:	40 ae       	mov.aa %a14,%sp
80004a00:	80 49       	mov.d %d9,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004a02:	6d ff 71 f5 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80004a06:	02 28       	mov %d8,%d2

    IfxScuWdt_clearCpuEndinit(psw);
80004a08:	02 24       	mov %d4,%d2
80004a0a:	6d ff 04 f4 	call 80003212 <IfxScuWdt_clearCpuEndinit>
    gtm->CLC.B.DISR = 0;
80004a0e:	7b a0 00 20 	movh %d2,10
80004a12:	1b 02 d0 2f 	addi %d2,%d2,-768
80004a16:	60 92       	mov.a %a2,%d9
80004a18:	01 22 00 46 	addsc.a %a4,%a2,%d2,0
80004a1c:	54 43       	ld.w %d3,[%a4]
80004a1e:	8f 13 c0 31 	andn %d3,%d3,1
80004a22:	74 43       	st.w [%a4],%d3
    IfxScuWdt_setCpuEndinit(psw);
80004a24:	02 84       	mov %d4,%d8
80004a26:	6d ff 7c f5 	call 8000351e <IfxScuWdt_setCpuEndinit>
}
80004a2a:	00 90       	ret 

80004a2c <IfxGtm_getSysClkFrequency>:


float32 IfxGtm_getSysClkFrequency(void)
{
80004a2c:	40 ae       	mov.aa %a14,%sp
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.GTMDIV;
80004a2e:	6d ff 61 f1 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
80004a32:	91 30 00 2f 	movh.a %a2,61443
80004a36:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
80004a3a:	54 23       	ld.w %d3,[%a2]
80004a3c:	37 03 64 36 	extr.u %d3,%d3,12,4
80004a40:	4b 03 41 31 	itof %d3,%d3
    return IfxScuCcu_getGtmFrequency();
}
80004a44:	4b 32 51 20 	div.f %d2,%d2,%d3
80004a48:	00 90       	ret 

80004a4a <IfxGtm_Cmu_enableClocks>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxGtm_Cmu_enableClocks(Ifx_GTM *gtm, uint32 clkMask)
{
80004a4a:	40 ae       	mov.aa %a14,%sp
    gtm->CMU.CLK_EN.U = clkMask;
80004a4c:	59 44 00 c0 	st.w [%a4]768,%d4
}
80004a50:	00 90       	ret 

80004a52 <IfxGtm_Cmu_getModuleFrequency>:
    return IfxGtm_Cmu_getModuleFrequency(gtm) * multiplier;
}


float32 IfxGtm_Cmu_getModuleFrequency(Ifx_GTM *gtm)
{
80004a52:	40 ae       	mov.aa %a14,%sp
    return IfxGtm_getSysClkFrequency();
80004a54:	6d ff ec ff 	call 80004a2c <IfxGtm_getSysClkFrequency>
}
80004a58:	00 90       	ret 

80004a5a <IfxGtm_Cmu_getGclkFrequency>:
{
80004a5a:	40 ae       	mov.aa %a14,%sp
    float32 N          = gtm->CMU.GCLK_DEN.B.GCLK_DEN;
80004a5c:	19 42 08 c0 	ld.w %d2,[%a4]776
80004a60:	37 02 78 20 	extr.u %d2,%d2,0,24
80004a64:	4b 02 61 81 	utof %d8,%d2
    float32 Z          = gtm->CMU.GCLK_NUM.B.GCLK_NUM;
80004a68:	19 42 04 c0 	ld.w %d2,[%a4]772
80004a6c:	37 02 78 20 	extr.u %d2,%d2,0,24
80004a70:	4b 02 61 21 	utof %d2,%d2
    float32 multiplier = N / Z;
80004a74:	4b 28 51 80 	div.f %d8,%d8,%d2
    return IfxGtm_Cmu_getModuleFrequency(gtm) * multiplier;
80004a78:	6d ff ed ff 	call 80004a52 <IfxGtm_Cmu_getModuleFrequency>
}
80004a7c:	4b 82 41 20 	mul.f %d2,%d2,%d8
80004a80:	00 90       	ret 

80004a82 <IfxGtm_Cmu_isClkClockEnabled>:


boolean IfxGtm_Cmu_isClkClockEnabled(Ifx_GTM *gtm, IfxGtm_Cmu_Clk clkIndex)
{
80004a82:	40 ae       	mov.aa %a14,%sp
    return ((gtm->CMU.CLK_EN.U >> (2 * clkIndex)) & IFX_GTM_CMU_CLK_EN_EN_CLK0_MSK) == 0x3;
80004a84:	19 43 00 c0 	ld.w %d3,[%a4]768
80004a88:	8f 14 00 20 	sh %d2,%d4,1
80004a8c:	57 03 62 22 	extr.u %d2,%d3,%d2,2
}
80004a90:	8b 32 00 22 	eq %d2,%d2,3
80004a94:	00 90       	ret 

80004a96 <IfxGtm_Cmu_getClkFrequency>:
{
80004a96:	40 ae       	mov.aa %a14,%sp
80004a98:	40 4c       	mov.aa %a12,%a4
80004a9a:	02 48       	mov %d8,%d4
80004a9c:	8f f5 0f 91 	and %d9,%d5,255
    if ((IfxGtm_Cmu_isClkClockEnabled(gtm, clkIndex) != FALSE) || (assumeEnabled != FALSE))
80004aa0:	6d ff f1 ff 	call 80004a82 <IfxGtm_Cmu_isClkClockEnabled>
80004aa4:	df 02 04 80 	jne %d2,0,80004aac <IfxGtm_Cmu_getClkFrequency+0x16>
80004aa8:	df 09 49 00 	jeq %d9,0,80004b3a <IfxGtm_Cmu_getClkFrequency+0xa4>
        switch (clkIndex)
80004aac:	df 68 2c 00 	jeq %d8,6,80004b04 <IfxGtm_Cmu_getClkFrequency+0x6e>
80004ab0:	ff 78 15 80 	jge.u %d8,7,80004ada <IfxGtm_Cmu_getClkFrequency+0x44>
80004ab4:	ff 68 45 80 	jge.u %d8,6,80004b3e <IfxGtm_Cmu_getClkFrequency+0xa8>
            frequency = IfxGtm_Cmu_getGclkFrequency(gtm) / (gtm->CMU.CLK0_5[clkIndex].CTRL.B.CLK_CNT + 1);
80004ab8:	40 c4       	mov.aa %a4,%a12
80004aba:	6d ff d0 ff 	call 80004a5a <IfxGtm_Cmu_getGclkFrequency>
80004abe:	1b 38 0c 30 	addi %d3,%d8,195
80004ac2:	06 23       	sh %d3,2
80004ac4:	01 c3 00 c6 	addsc.a %a12,%a12,%d3,0
80004ac8:	54 c3       	ld.w %d3,[%a12]
80004aca:	37 03 78 30 	extr.u %d3,%d3,0,24
80004ace:	c2 13       	add %d3,1
80004ad0:	4b 03 41 31 	itof %d3,%d3
80004ad4:	4b 32 51 20 	div.f %d2,%d2,%d3
            break;
80004ad8:	00 90       	ret 
        switch (clkIndex)
80004ada:	df 78 13 80 	jne %d8,7,80004b00 <IfxGtm_Cmu_getClkFrequency+0x6a>
            if (gtm->CMU.CLK_7.CTRL.B.CLK7_SEL == 0)
80004ade:	19 c2 28 c0 	ld.w %d2,[%a12]808
80004ae2:	ef 82 27 80 	jnz.t %d2,24,80004b30 <IfxGtm_Cmu_getClkFrequency+0x9a>
                frequency = IfxGtm_Cmu_getGclkFrequency(gtm) / (gtm->CMU.CLK_7.CTRL.B.CLK_CNT + 1);
80004ae6:	40 c4       	mov.aa %a4,%a12
80004ae8:	6d ff b9 ff 	call 80004a5a <IfxGtm_Cmu_getGclkFrequency>
80004aec:	19 c3 28 c0 	ld.w %d3,[%a12]808
80004af0:	37 03 78 30 	extr.u %d3,%d3,0,24
80004af4:	c2 13       	add %d3,1
80004af6:	4b 03 41 31 	itof %d3,%d3
80004afa:	4b 32 51 20 	div.f %d2,%d2,%d3
80004afe:	00 90       	ret 
        switch (clkIndex)
80004b00:	82 02       	mov %d2,0
80004b02:	00 90       	ret 
            if (gtm->CMU.CLK_6.CTRL.B.CLK6_SEL == 0)
80004b04:	19 c2 24 c0 	ld.w %d2,[%a12]804
80004b08:	ef 82 0f 80 	jnz.t %d2,24,80004b26 <IfxGtm_Cmu_getClkFrequency+0x90>
                frequency = IfxGtm_Cmu_getGclkFrequency(gtm) / (gtm->CMU.CLK_6.CTRL.B.CLK_CNT + 1);
80004b0c:	40 c4       	mov.aa %a4,%a12
80004b0e:	6d ff a6 ff 	call 80004a5a <IfxGtm_Cmu_getGclkFrequency>
80004b12:	19 c3 24 c0 	ld.w %d3,[%a12]804
80004b16:	37 03 78 30 	extr.u %d3,%d3,0,24
80004b1a:	c2 13       	add %d3,1
80004b1c:	4b 03 41 31 	itof %d3,%d3
80004b20:	4b 32 51 20 	div.f %d2,%d2,%d3
80004b24:	00 90       	ret 
                frequency = IfxGtm_Dpll_getSubIncFrequency(gtm, IfxGtm_Dpll_SubInc_2);
80004b26:	82 14       	mov %d4,1
80004b28:	40 c4       	mov.aa %a4,%a12
80004b2a:	6d 00 14 01 	call 80004d52 <IfxGtm_Dpll_getSubIncFrequency>
80004b2e:	00 90       	ret 
                frequency = IfxGtm_Dpll_getSubIncFrequency(gtm, IfxGtm_Dpll_SubInc_1);
80004b30:	82 04       	mov %d4,0
80004b32:	40 c4       	mov.aa %a4,%a12
80004b34:	6d 00 0f 01 	call 80004d52 <IfxGtm_Dpll_getSubIncFrequency>
80004b38:	00 90       	ret 
        frequency = 0.0f;
80004b3a:	82 02       	mov %d2,0
80004b3c:	00 90       	ret 
        switch (clkIndex)
80004b3e:	82 02       	mov %d2,0
}
80004b40:	00 90       	ret 

80004b42 <IfxGtm_Cmu_isFxClockEnabled>:
    return ((gtm->CMU.CLK_EN.U >> (2 * clkIndex + 16)) & IFX_GTM_CMU_CLK_EN_EN_CLK0_MSK) == 0x3;
}


boolean IfxGtm_Cmu_isFxClockEnabled(Ifx_GTM *gtm)
{
80004b42:	40 ae       	mov.aa %a14,%sp
    return gtm->CMU.CLK_EN.B.EN_FXCLK == 0x3;
80004b44:	19 42 00 c0 	ld.w %d2,[%a4]768
80004b48:	37 02 62 2b 	extr.u %d2,%d2,22,2
}
80004b4c:	8b 32 00 22 	eq %d2,%d2,3
80004b50:	00 90       	ret 

80004b52 <IfxGtm_Cmu_isFxClockEnabled_end>:
	...

80004b54 <IfxGtm_Cmu_getFxClkFrequency>:
{
80004b54:	40 ae       	mov.aa %a14,%sp
80004b56:	40 4c       	mov.aa %a12,%a4
80004b58:	02 49       	mov %d9,%d4
80004b5a:	8f f5 0f 81 	and %d8,%d5,255
    if (IfxGtm_Cmu_isFxClockEnabled(gtm) || (assumeEnabled != FALSE))
80004b5e:	6d ff f2 ff 	call 80004b42 <IfxGtm_Cmu_isFxClockEnabled>
80004b62:	df 02 04 80 	jne %d2,0,80004b6a <IfxGtm_Cmu_getFxClkFrequency+0x16>
80004b66:	df 08 57 00 	jeq %d8,0,80004c14 <IfxGtm_Cmu_getFxClkFrequency+0xc0>
        fxSelect = gtm->CMU.FXCLK.CTRL.B.FXCLK_SEL;
80004b6a:	19 c2 04 d0 	ld.w %d2,[%a12]836
80004b6e:	8f f2 00 21 	and %d2,%d2,15
80004b72:	02 23       	mov %d3,%d2
        if (fxSelect == 0)
80004b74:	df 02 0f 00 	jeq %d2,0,80004b92 <IfxGtm_Cmu_getFxClkFrequency+0x3e>
        else if (fxSelect <= 6)
80004b78:	bf 72 24 80 	jlt.u %d2,7,80004bc0 <IfxGtm_Cmu_getFxClkFrequency+0x6c>
        else if (fxSelect == 7)
80004b7c:	df 72 2a 00 	jeq %d2,7,80004bd0 <IfxGtm_Cmu_getFxClkFrequency+0x7c>
        else if (fxSelect == 8)
80004b80:	3b 80 00 20 	mov %d2,8
80004b84:	5f 23 2d 00 	jeq %d3,%d2,80004bde <IfxGtm_Cmu_getFxClkFrequency+0x8a>
            frequency = IfxGtm_Cmu_getGclkFrequency(gtm);
80004b88:	40 c4       	mov.aa %a4,%a12
80004b8a:	6d ff 68 ff 	call 80004a5a <IfxGtm_Cmu_getGclkFrequency>
80004b8e:	1d 00 05 00 	j 80004b98 <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = IfxGtm_Cmu_getGclkFrequency(gtm);
80004b92:	40 c4       	mov.aa %a4,%a12
80004b94:	6d ff 63 ff 	call 80004a5a <IfxGtm_Cmu_getGclkFrequency>
        switch (clkIndex)
80004b98:	ff 59 40 80 	jge.u %d9,5,80004c18 <IfxGtm_Cmu_getFxClkFrequency+0xc4>
80004b9c:	91 00 00 28 	movh.a %a2,32768
80004ba0:	d9 22 ac e4 	lea %a2,[%a2]19372 <80004bac <IfxGtm_Cmu_getFxClkFrequency+0x58>>
80004ba4:	01 29 02 26 	addsc.a %a2,%a2,%d9,2
80004ba8:	dc 02       	ji %a2
80004baa:	00 00       	nop 
80004bac:	1d 00 37 00 	j 80004c1a <IfxGtm_Cmu_getFxClkFrequency+0xc6>
80004bb0:	1d 00 1e 00 	j 80004bec <IfxGtm_Cmu_getFxClkFrequency+0x98>
80004bb4:	1d 00 21 00 	j 80004bf6 <IfxGtm_Cmu_getFxClkFrequency+0xa2>
80004bb8:	1d 00 24 00 	j 80004c00 <IfxGtm_Cmu_getFxClkFrequency+0xac>
80004bbc:	1d 00 27 00 	j 80004c0a <IfxGtm_Cmu_getFxClkFrequency+0xb6>
            frequency = IfxGtm_Cmu_getClkFrequency(gtm, (IfxGtm_Cmu_Clk)(fxSelect - 1), assumeEnabled);
80004bc0:	02 85       	mov %d5,%d8
80004bc2:	1b f2 ff 4f 	addi %d4,%d2,-1
80004bc6:	40 c4       	mov.aa %a4,%a12
80004bc8:	6d ff 67 ff 	call 80004a96 <IfxGtm_Cmu_getClkFrequency>
80004bcc:	1d ff e6 ff 	j 80004b98 <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = IfxGtm_Cmu_getClkFrequency(gtm, IfxGtm_Cmu_Clk_6, assumeEnabled);
80004bd0:	02 85       	mov %d5,%d8
80004bd2:	82 64       	mov %d4,6
80004bd4:	40 c4       	mov.aa %a4,%a12
80004bd6:	6d ff 60 ff 	call 80004a96 <IfxGtm_Cmu_getClkFrequency>
80004bda:	1d ff df ff 	j 80004b98 <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = IfxGtm_Cmu_getClkFrequency(gtm, IfxGtm_Cmu_Clk_7, assumeEnabled);
80004bde:	02 85       	mov %d5,%d8
80004be0:	82 74       	mov %d4,7
80004be2:	40 c4       	mov.aa %a4,%a12
80004be4:	6d ff 59 ff 	call 80004a96 <IfxGtm_Cmu_getClkFrequency>
80004be8:	1d ff d8 ff 	j 80004b98 <IfxGtm_Cmu_getFxClkFrequency+0x44>
            frequency = frequency / 16;
80004bec:	7b 00 d8 33 	movh %d3,15744
80004bf0:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
80004bf4:	00 90       	ret 
            frequency = frequency / 256;
80004bf6:	7b 00 b8 33 	movh %d3,15232
80004bfa:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
80004bfe:	00 90       	ret 
            frequency = frequency / 4096;
80004c00:	7b 00 98 33 	movh %d3,14720
80004c04:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
80004c08:	00 90       	ret 
            frequency = frequency / 65536;
80004c0a:	7b 00 78 33 	movh %d3,14208
80004c0e:	4b 32 41 20 	mul.f %d2,%d2,%d3
            break;
80004c12:	00 90       	ret 
        frequency = 0.0f;
80004c14:	82 02       	mov %d2,0
80004c16:	00 90       	ret 
            frequency = 0.0f;
80004c18:	82 02       	mov %d2,0
}
80004c1a:	00 90       	ret 

80004c1c <IfxGtm_Cmu_setClkFrequency>:
    }
}


void IfxGtm_Cmu_setClkFrequency(Ifx_GTM *gtm, IfxGtm_Cmu_Clk clkIndex, float32 frequency)
{
80004c1c:	40 ae       	mov.aa %a14,%sp
80004c1e:	40 4c       	mov.aa %a12,%a4
80004c20:	02 48       	mov %d8,%d4
80004c22:	02 59       	mov %d9,%d5
    float32 t   = (IfxGtm_Cmu_getGclkFrequency(gtm) / frequency) - 1;
80004c24:	6d ff 1b ff 	call 80004a5a <IfxGtm_Cmu_getGclkFrequency>
80004c28:	4b 92 51 50 	div.f %d5,%d2,%d9
80004c2c:	7b 00 f8 23 	movh %d2,16256
80004c30:	6b 02 31 55 	sub.f %d5,%d5,%d2
    uint32  cnt = (uint32)t;
80004c34:	4b 05 71 91 	ftouz %d9,%d5

    if ((t - (float32)cnt) > 0.5f)
80004c38:	4b 09 61 21 	utof %d2,%d9
80004c3c:	6b 02 31 25 	sub.f %d2,%d5,%d2
80004c40:	7b 00 f0 33 	movh %d3,16128
80004c44:	4b 32 01 20 	cmp.f %d2,%d2,%d3
80004c48:	6f 22 03 00 	jz.t %d2,2,80004c4e <IfxGtm_Cmu_setClkFrequency+0x32>
    {                           /* Round to nearest */
        cnt++;
80004c4c:	c2 19       	add %d9,1
    }

    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004c4e:	6d ff 4b f4 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80004c52:	02 2a       	mov %d10,%d2
    IfxScuWdt_clearCpuEndinit(psw);
80004c54:	02 24       	mov %d4,%d2
80004c56:	6d ff de f2 	call 80003212 <IfxScuWdt_clearCpuEndinit>

    switch (clkIndex)
80004c5a:	df 68 1e 00 	jeq %d8,6,80004c96 <IfxGtm_Cmu_setClkFrequency+0x7a>
80004c5e:	ff 78 11 80 	jge.u %d8,7,80004c80 <IfxGtm_Cmu_setClkFrequency+0x64>
80004c62:	ff 68 0b 80 	jge.u %d8,6,80004c78 <IfxGtm_Cmu_setClkFrequency+0x5c>
    case IfxGtm_Cmu_Clk_1:
    case IfxGtm_Cmu_Clk_2:
    case IfxGtm_Cmu_Clk_3:
    case IfxGtm_Cmu_Clk_4:
    case IfxGtm_Cmu_Clk_5:
        gtm->CMU.CLK0_5[clkIndex].CTRL.B.CLK_CNT = cnt;
80004c66:	1b 38 0c 20 	addi %d2,%d8,195
80004c6a:	06 22       	sh %d2,2
80004c6c:	01 c2 00 c6 	addsc.a %a12,%a12,%d2,0
80004c70:	54 c2       	ld.w %d2,[%a12]
80004c72:	37 92 18 20 	insert %d2,%d2,%d9,0,24
80004c76:	74 c2       	st.w [%a12],%d2
        break;
    default:
        break;
    }

    IfxScuWdt_setCpuEndinit(psw);
80004c78:	02 a4       	mov %d4,%d10
80004c7a:	6d ff 52 f4 	call 8000351e <IfxScuWdt_setCpuEndinit>
}
80004c7e:	00 90       	ret 
    switch (clkIndex)
80004c80:	df 78 fc ff 	jne %d8,7,80004c78 <IfxGtm_Cmu_setClkFrequency+0x5c>
        gtm->CMU.CLK_7.CTRL.B.CLK_CNT = cnt;
80004c84:	d9 c2 28 c0 	lea %a2,[%a12]808
80004c88:	19 c2 28 c0 	ld.w %d2,[%a12]808
80004c8c:	37 92 18 20 	insert %d2,%d2,%d9,0,24
80004c90:	74 22       	st.w [%a2],%d2
        break;
80004c92:	1d ff f3 ff 	j 80004c78 <IfxGtm_Cmu_setClkFrequency+0x5c>
        gtm->CMU.CLK_6.CTRL.B.CLK_CNT = cnt;
80004c96:	d9 c2 24 c0 	lea %a2,[%a12]804
80004c9a:	19 c2 24 c0 	ld.w %d2,[%a12]804
80004c9e:	37 92 18 20 	insert %d2,%d2,%d9,0,24
80004ca2:	74 22       	st.w [%a2],%d2
        break;
80004ca4:	1d ff ea ff 	j 80004c78 <IfxGtm_Cmu_setClkFrequency+0x5c>

80004ca8 <IfxGtm_Cmu_setGclkFrequency>:
    IfxScuWdt_setCpuEndinit(psw);
}


void IfxGtm_Cmu_setGclkFrequency(Ifx_GTM *gtm, float32 frequency)
{
80004ca8:	40 ae       	mov.aa %a14,%sp
80004caa:	40 4c       	mov.aa %a12,%a4
80004cac:	02 48       	mov %d8,%d4
    float32 f;
    float32 bestDistance = frequency;

    float32 fIn          = IfxGtm_Cmu_getModuleFrequency(gtm);
80004cae:	6d ff d2 fe 	call 80004a52 <IfxGtm_Cmu_getModuleFrequency>
    float32 bestDistance = frequency;
80004cb2:	02 85       	mov %d5,%d8
    uint32  z, n, nBest = 1, zBest = 1;
80004cb4:	82 19       	mov %d9,1
80004cb6:	02 9a       	mov %d10,%d9
    float32 t;

#if 1

    for (z = 1; z < 0xFFFFFF; z++)
80004cb8:	02 94       	mov %d4,%d9
80004cba:	1d 00 22 00 	j 80004cfe <IfxGtm_Cmu_setGclkFrequency+0x56>
                bestDistance = distance;
                nBest        = n;
                zBest        = z;
            }

            if (bestDistance < 0.1f)
80004cbe:	7b d0 dc 63 	movh %d6,15821
80004cc2:	1b d6 cc 6c 	addi %d6,%d6,-13107
80004cc6:	4b 65 01 60 	cmp.f %d6,%d5,%d6
80004cca:	6f 06 16 80 	jnz.t %d6,0,80004cf6 <IfxGtm_Cmu_setGclkFrequency+0x4e>
        for (n = z; n > 0; n--)
80004cce:	c2 f3       	add %d3,-1
80004cd0:	df 03 14 00 	jeq %d3,0,80004cf8 <IfxGtm_Cmu_setGclkFrequency+0x50>
            f        = t * n;
80004cd4:	4b 03 61 61 	utof %d6,%d3
80004cd8:	4b 06 41 60 	mul.f %d6,%d6,%d0
            distance = fabsf(frequency - f);
80004cdc:	6b 06 31 68 	sub.f %d6,%d8,%d6
80004ce0:	b7 06 81 6f 	insert %d6,%d6,0,31,1
            if (distance < bestDistance)
80004ce4:	4b 65 01 70 	cmp.f %d7,%d5,%d6
80004ce8:	6f 27 eb 7f 	jz.t %d7,2,80004cbe <IfxGtm_Cmu_setGclkFrequency+0x16>
                zBest        = z;
80004cec:	02 49       	mov %d9,%d4
                nBest        = n;
80004cee:	02 3a       	mov %d10,%d3
                bestDistance = distance;
80004cf0:	02 65       	mov %d5,%d6
80004cf2:	1d ff e6 ff 	j 80004cbe <IfxGtm_Cmu_setGclkFrequency+0x16>
            {
                endLoop = TRUE;
80004cf6:	82 13       	mov %d3,1
                break;
            }
        }

        if (endLoop)
80004cf8:	df 03 0f 80 	jne %d3,0,80004d16 <IfxGtm_Cmu_setGclkFrequency+0x6e>
    for (z = 1; z < 0xFFFFFF; z++)
80004cfc:	c2 14       	add %d4,1
80004cfe:	7b 00 10 30 	movh %d3,256
80004d02:	c2 e3       	add %d3,-2
80004d04:	3f 43 09 80 	jlt.u %d3,%d4,80004d16 <IfxGtm_Cmu_setGclkFrequency+0x6e>
        t = fIn / z;
80004d08:	4b 04 61 01 	utof %d0,%d4
80004d0c:	4b 02 51 00 	div.f %d0,%d2,%d0
        for (n = z; n > 0; n--)
80004d10:	02 43       	mov %d3,%d4
80004d12:	1d ff df ff 	j 80004cd0 <IfxGtm_Cmu_setGclkFrequency+0x28>
        }
    }

#endif

    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80004d16:	6d ff e7 f3 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80004d1a:	02 28       	mov %d8,%d2
    IfxScuWdt_clearCpuEndinit(psw);
80004d1c:	02 24       	mov %d4,%d2
80004d1e:	6d ff 7a f2 	call 80003212 <IfxScuWdt_clearCpuEndinit>
    gtm->CMU.GCLK_NUM.B.GCLK_NUM = zBest;
80004d22:	b7 09 08 9c 	insert %d9,%d9,0,24,8
80004d26:	d9 c2 04 c0 	lea %a2,[%a12]772
80004d2a:	19 c3 04 c0 	ld.w %d3,[%a12]772
80004d2e:	37 93 18 30 	insert %d3,%d3,%d9,0,24
80004d32:	74 23       	st.w [%a2],%d3
    gtm->CMU.GCLK_NUM.B.GCLK_NUM = zBest;   /* write twice to be sure */
80004d34:	54 23       	ld.w %d3,[%a2]
80004d36:	37 93 18 30 	insert %d3,%d3,%d9,0,24
80004d3a:	74 23       	st.w [%a2],%d3
    gtm->CMU.GCLK_DEN.B.GCLK_DEN = nBest;
80004d3c:	d9 c2 08 c0 	lea %a2,[%a12]776
80004d40:	19 c3 08 c0 	ld.w %d3,[%a12]776
80004d44:	37 a3 18 30 	insert %d3,%d3,%d10,0,24
80004d48:	74 23       	st.w [%a2],%d3
    IfxScuWdt_setCpuEndinit(psw);
80004d4a:	02 84       	mov %d4,%d8
80004d4c:	6d ff e9 f3 	call 8000351e <IfxScuWdt_setCpuEndinit>
}
80004d50:	00 90       	ret 

80004d52 <IfxGtm_Dpll_getSubIncFrequency>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

float32 IfxGtm_Dpll_getSubIncFrequency(Ifx_GTM *gtm, IfxGtm_Dpll_SubInc index)
{
80004d52:	40 ae       	mov.aa %a14,%sp
    IFX_UNUSED_PARAMETER(gtm)
    IFX_UNUSED_PARAMETER(index)
    return 0.0F;
}
80004d54:	82 02       	mov %d2,0
80004d56:	00 90       	ret 

80004d58 <IfxGtm_Tom_Tgc_buildFeature>:
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint32 IfxGtm_Tom_Tgc_buildFeature(uint16 enableMask, uint16 disableMask, uint8 bitfieldOffset)
{
80004d58:	40 ae       	mov.aa %a14,%sp
    uint8  i;
    uint32 reg  = 0;
    uint32 mask = enableMask | (disableMask << 16);
80004d5a:	8f 05 01 50 	sh %d5,%d5,16
80004d5e:	a6 54       	or %d4,%d5
    uint32 reg  = 0;
80004d60:	82 02       	mov %d2,0

    for (i = 0; i < IFXGTM_TOM_NUM_TGC_CHANNELS; i++)
80004d62:	82 03       	mov %d3,0
80004d64:	1d 00 06 00 	j 80004d70 <IfxGtm_Tom_Tgc_buildFeature+0x18>
        if (mask & 0x10000)
        {
            reg |= IfxGtm_FeatureControl_disable << shift;
        }

        mask = mask >> 1;
80004d68:	06 f4       	sh %d4,-1
    for (i = 0; i < IFXGTM_TOM_NUM_TGC_CHANNELS; i++)
80004d6a:	c2 13       	add %d3,1
80004d6c:	8f f3 0f 31 	and %d3,%d3,255
80004d70:	ff 83 17 80 	jge.u %d3,8,80004d9e <IfxGtm_Tom_Tgc_buildFeature+0x46>
        uint8 shift = (i * 2) + bitfieldOffset;
80004d74:	8f 13 00 50 	sh %d5,%d3,1
80004d78:	8f f5 0f 51 	and %d5,%d5,255
80004d7c:	42 65       	add %d5,%d6
80004d7e:	8f f5 0f 51 	and %d5,%d5,255
        if (mask & 0x1)
80004d82:	6f 04 06 00 	jz.t %d4,0,80004d8e <IfxGtm_Tom_Tgc_buildFeature+0x36>
            reg |= IfxGtm_FeatureControl_enable << shift;
80004d86:	82 27       	mov %d7,2
80004d88:	0f 57 00 70 	sh %d7,%d7,%d5
80004d8c:	a6 72       	or %d2,%d7
        if (mask & 0x10000)
80004d8e:	ef 04 ed 7f 	jz.t %d4,16,80004d68 <IfxGtm_Tom_Tgc_buildFeature+0x10>
            reg |= IfxGtm_FeatureControl_disable << shift;
80004d92:	82 17       	mov %d7,1
80004d94:	0f 57 00 70 	sh %d7,%d7,%d5
80004d98:	a6 72       	or %d2,%d7
80004d9a:	1d ff e7 ff 	j 80004d68 <IfxGtm_Tom_Tgc_buildFeature+0x10>
    }

    return reg;
}
80004d9e:	00 90       	ret 

80004da0 <IfxCpu_Trap_memoryManagementError>:
{
80004da0:	40 ae       	mov.aa %a14,%sp
80004da2:	20 08       	sub.a %sp,8
}

IFX_INLINE void* Ifx__getA11(void)
{
    uint32 *res;
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80004da4:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004da6:	8f f4 0f 41 	and %d4,%d4,255
    reg.U = __mfcr(CPU_CORE_ID);
80004daa:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004dae:	8f 72 00 21 	and %d2,%d2,7
80004db2:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004db6:	80 22       	mov.d %d2,%a2
80004db8:	0f 54 a0 30 	or %d3,%d4,%d5
80004dbc:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_MME_HOOK(trapWatch);
80004dc0:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80004dc4:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004dc6:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004dca:	00 80       	rfe 
}
80004dcc:	00 90       	ret 

80004dce <IfxCpu_Trap_internalProtectionError>:
{
80004dce:	40 ae       	mov.aa %a14,%sp
80004dd0:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80004dd2:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004dd4:	b7 14 18 44 	insert %d4,%d4,1,8,24
80004dd8:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004ddc:	8f 72 00 21 	and %d2,%d2,7
80004de0:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004de4:	80 22       	mov.d %d2,%a2
80004de6:	0f 54 a0 30 	or %d3,%d4,%d5
80004dea:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IPE_HOOK(trapWatch);
80004dee:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80004df2:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004df4:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004df8:	00 80       	rfe 
}
80004dfa:	00 90       	ret 

80004dfc <IfxCpu_Trap_instructionError>:
{
80004dfc:	40 ae       	mov.aa %a14,%sp
80004dfe:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80004e00:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004e02:	b7 24 18 44 	insert %d4,%d4,2,8,24
80004e06:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004e0a:	8f 72 00 21 	and %d2,%d2,7
80004e0e:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004e12:	80 22       	mov.d %d2,%a2
80004e14:	0f 54 a0 30 	or %d3,%d4,%d5
80004e18:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_IE_HOOK(trapWatch);
80004e1c:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80004e20:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004e22:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004e26:	00 80       	rfe 
}
80004e28:	00 90       	ret 

80004e2a <IfxCpu_Trap_contextManagementError>:
{
80004e2a:	40 ae       	mov.aa %a14,%sp
80004e2c:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80004e2e:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004e30:	b7 34 18 44 	insert %d4,%d4,3,8,24
80004e34:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004e38:	8f 72 00 21 	and %d2,%d2,7
80004e3c:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004e40:	80 22       	mov.d %d2,%a2
80004e42:	0f 54 a0 30 	or %d3,%d4,%d5
80004e46:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_CME_HOOK(trapWatch);
80004e4a:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80004e4e:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004e50:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004e54:	00 80       	rfe 
}
80004e56:	00 90       	ret 

80004e58 <IfxCpu_Trap_busError>:
{
80004e58:	40 ae       	mov.aa %a14,%sp
80004e5a:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80004e5c:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004e5e:	b7 44 18 44 	insert %d4,%d4,4,8,24
80004e62:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004e66:	8f 72 00 21 	and %d2,%d2,7
80004e6a:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004e6e:	80 22       	mov.d %d2,%a2
80004e70:	0f 54 a0 30 	or %d3,%d4,%d5
80004e74:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_BE_HOOK(trapWatch);
80004e78:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80004e7c:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004e7e:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004e82:	00 80       	rfe 
}
80004e84:	00 90       	ret 

80004e86 <IfxCpu_Trap_assertion>:
{
80004e86:	40 ae       	mov.aa %a14,%sp
80004e88:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80004e8a:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004e8c:	8f f4 0f 41 	and %d4,%d4,255
80004e90:	3b 00 50 20 	mov %d2,1280
80004e94:	a6 24       	or %d4,%d2
80004e96:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004e9a:	8f 72 00 21 	and %d2,%d2,7
80004e9e:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004ea2:	80 22       	mov.d %d2,%a2
80004ea4:	0f 54 a0 30 	or %d3,%d4,%d5
80004ea8:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_ASSERT_HOOK(trapWatch);
80004eac:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm__ volatile ("debug" : : : "memory");
80004eb0:	00 a0       	debug 
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004eb2:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004eb6:	00 80       	rfe 
}
80004eb8:	00 90       	ret 

80004eba <IfxCpu_Trap_systemCall_Cpu0>:
{
80004eba:	40 ae       	mov.aa %a14,%sp
80004ebc:	20 08       	sub.a %sp,8
    __asm__ volatile ("mov.aa %0, %%a11": "=a" (res) : :"a11");
80004ebe:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004ec0:	b7 64 18 44 	insert %d4,%d4,6,8,24
80004ec4:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004ec8:	8f 72 00 21 	and %d2,%d2,7
80004ecc:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004ed0:	80 22       	mov.d %d2,%a2
80004ed2:	0f 54 a0 30 	or %d3,%d4,%d5
80004ed6:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU0_HOOK(trapWatch);
80004eda:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004ede:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004ee2:	00 80       	rfe 
}
80004ee4:	00 90       	ret 

80004ee6 <IfxCpu_Trap_systemCall_Cpu1>:
{
80004ee6:	40 ae       	mov.aa %a14,%sp
80004ee8:	20 08       	sub.a %sp,8
80004eea:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004eec:	b7 64 18 44 	insert %d4,%d4,6,8,24
80004ef0:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004ef4:	8f 72 00 21 	and %d2,%d2,7
80004ef8:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004efc:	80 22       	mov.d %d2,%a2
80004efe:	0f 54 a0 30 	or %d3,%d4,%d5
80004f02:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU1_HOOK(trapWatch);
80004f06:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004f0a:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004f0e:	00 80       	rfe 
}
80004f10:	00 90       	ret 

80004f12 <IfxCpu_Trap_systemCall_Cpu2>:
{
80004f12:	40 ae       	mov.aa %a14,%sp
80004f14:	20 08       	sub.a %sp,8
80004f16:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004f18:	b7 64 18 44 	insert %d4,%d4,6,8,24
80004f1c:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004f20:	8f 72 00 21 	and %d2,%d2,7
80004f24:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004f28:	80 22       	mov.d %d2,%a2
80004f2a:	0f 54 a0 30 	or %d3,%d4,%d5
80004f2e:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_SYSCALL_CPU2_HOOK(trapWatch);
80004f32:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004f36:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004f3a:	00 80       	rfe 
}
80004f3c:	00 90       	ret 

80004f3e <IfxCpu_Trap_nonMaskableInterrupt>:
{
80004f3e:	40 ae       	mov.aa %a14,%sp
80004f40:	20 08       	sub.a %sp,8
80004f42:	40 b2       	mov.aa %a2,%a11
    trapInfo.tId    = tin;
80004f44:	b7 74 18 44 	insert %d4,%d4,7,8,24
80004f48:	4d c0 e1 2f 	mfcr %d2,$core_id
    trapInfo.tCpu   = IfxCpu_getCoreId();
80004f4c:	8f 72 00 21 	and %d2,%d2,7
80004f50:	8f 02 01 50 	sh %d5,%d2,16
    return trapInfo;
80004f54:	80 22       	mov.d %d2,%a2
80004f56:	0f 54 a0 30 	or %d3,%d4,%d5
80004f5a:	89 e2 78 f9 	st.d [%a14]-8,%e2
    IFX_CFG_CPU_TRAP_NMI_HOOK(trapWatch);    
80004f5e:	09 e2 78 f9 	ld.d %e2,[%a14]-8
    __asm("rslcx"); /* Restore lower context before returning. lower context was stored in the trap vector */
80004f62:	0d 00 40 02 	rslcx 
    __asm("rfe");
80004f66:	00 80       	rfe 
}
80004f68:	00 90       	ret 

80004f6a <IfxCpu_getIndex>:
    return cpuMode;
}


IfxCpu_ResourceCpu IfxCpu_getIndex(Ifx_CPU *cpu)
{
80004f6a:	40 ae       	mov.aa %a14,%sp
    IfxCpu_ResourceCpu result;
    uint32             index;
    result = IfxCpu_ResourceCpu_none;

    for (index = 0; index < IFXCPU_NUM_MODULES; index++)
80004f6c:	82 02       	mov %d2,0
80004f6e:	1d 00 03 00 	j 80004f74 <IfxCpu_getIndex+0xa>
80004f72:	c2 12       	add %d2,1
80004f74:	ff 32 18 80 	jge.u %d2,3,80004fa4 <IfxCpu_getIndex+0x3a>
    {
        if (IfxCpu_cfg_indexMap[index].module == cpu)
80004f78:	8f 32 00 30 	sh %d3,%d2,3
80004f7c:	91 00 00 28 	movh.a %a2,32768
80004f80:	d9 22 00 c0 	lea %a2,[%a2]768 <80000300 <IfxCpu_cfg_indexMap>>
80004f84:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80004f88:	54 23       	ld.w %d3,[%a2]
80004f8a:	80 44       	mov.d %d4,%a4
80004f8c:	5f 43 f3 ff 	jne %d3,%d4,80004f72 <IfxCpu_getIndex+0x8>
        {
            result = (IfxCpu_ResourceCpu)IfxCpu_cfg_indexMap[index].index;
80004f90:	06 32       	sh %d2,3
80004f92:	91 00 00 28 	movh.a %a2,32768
80004f96:	d9 22 00 c0 	lea %a2,[%a2]768 <80000300 <IfxCpu_cfg_indexMap>>
80004f9a:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80004f9e:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80004fa2:	00 90       	ret 
    result = IfxCpu_ResourceCpu_none;
80004fa4:	82 32       	mov %d2,3
        }
    }

    return result;
}
80004fa6:	00 90       	ret 

80004fa8 <IfxCpu_getCoreMode>:
{
80004fa8:	40 ae       	mov.aa %a14,%sp
80004faa:	80 48       	mov.d %d8,%a4
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
80004fac:	6d ff df ff 	call 80004f6a <IfxCpu_getIndex>


IFX_INLINE IfxCpu_ResourceCpu IfxCpu_getCoreIndex(void)
{
    Ifx_CPU_CORE_ID reg;
    reg.U = __mfcr(CPU_CORE_ID);
80004fb0:	4d c0 e1 3f 	mfcr %d3,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80004fb4:	8f 73 00 31 	and %d3,%d3,7
    if (IfxCpu_getCoreIndex() != index)
80004fb8:	5f 32 22 00 	jeq %d2,%d3,80004ffc <IfxCpu_getCoreMode+0x54>
        dbgsr = cpu->DBGSR;
80004fbc:	bb 00 d0 3f 	mov.u %d3,64768
80004fc0:	60 82       	mov.a %a2,%d8
80004fc2:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80004fc6:	54 23       	ld.w %d3,[%a2]
    if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_halt)
80004fc8:	37 03 e2 40 	extr.u %d4,%d3,1,2
80004fcc:	df 14 1c 00 	jeq %d4,1,80005004 <IfxCpu_getCoreMode+0x5c>
        if (dbgsr.B.HALT == (uint32)IfxCpu_DBGST_HALT_run)
80004fd0:	df 04 1c 80 	jne %d4,0,80005008 <IfxCpu_getCoreMode+0x60>
            pmcsr_val = &MODULE_SCU.PMCSR[index];
80004fd4:	06 22       	sh %d2,2
80004fd6:	7b 30 00 3f 	movh %d3,61443
80004fda:	1b 43 0d 36 	addi %d3,%d3,24788
80004fde:	60 32       	mov.a %a2,%d3
80004fe0:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
            if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_normalMode)
80004fe4:	54 22       	ld.w %d2,[%a2]
80004fe6:	37 02 63 24 	extr.u %d2,%d2,8,3
80004fea:	df 12 11 00 	jeq %d2,1,8000500c <IfxCpu_getCoreMode+0x64>
                if (pmcsr_val->B.PMST == (uint32)IfxCpu_PMCSR_PMST_idleMode)
80004fee:	54 22       	ld.w %d2,[%a2]
80004ff0:	37 02 63 24 	extr.u %d2,%d2,8,3
80004ff4:	df 32 0e 00 	jeq %d2,3,80005010 <IfxCpu_getCoreMode+0x68>
    cpuMode = IfxCpu_CoreMode_unknown;
80004ff8:	82 52       	mov %d2,5
80004ffa:	00 90       	ret 
        dbgsr.U = __mfcr(CPU_DBGSR);
80004ffc:	4d 00 d0 3f 	mfcr %d3,$dbgsr
80005000:	1d ff e4 ff 	j 80004fc8 <IfxCpu_getCoreMode+0x20>
        cpuMode = IfxCpu_CoreMode_halt;
80005004:	82 02       	mov %d2,0
80005006:	00 90       	ret 
            cpuMode = IfxCpu_CoreMode_unknown;
80005008:	82 52       	mov %d2,5
8000500a:	00 90       	ret 
                cpuMode = IfxCpu_CoreMode_run;
8000500c:	82 12       	mov %d2,1
8000500e:	00 90       	ret 
                    cpuMode = IfxCpu_CoreMode_idle;
80005010:	82 22       	mov %d2,2
}
80005012:	00 90       	ret 

80005014 <IfxCpu_setCoreMode>:
    *lock = 0;
}


boolean IfxCpu_setCoreMode(Ifx_CPU *cpu, IfxCpu_CoreMode mode)
{
80005014:	40 ae       	mov.aa %a14,%sp
80005016:	80 4c       	mov.d %d12,%a4
80005018:	02 48       	mov %d8,%d4
    uint8              reqslp;
    boolean            retValue;
    IfxCpu_ResourceCpu index = IfxCpu_getIndex(cpu);
8000501a:	6d ff a8 ff 	call 80004f6a <IfxCpu_getIndex>
8000501e:	02 2a       	mov %d10,%d2

    /*Modes such as HALT, SLEEP and STBY are not handled at CPU level */
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
80005020:	8b 08 20 42 	ne %d4,%d8,0
80005024:	8b 38 20 32 	ne %d3,%d8,3
80005028:	26 43       	and %d3,%d4
                || (mode == IfxCpu_CoreMode_stby)) ? FALSE : TRUE;
8000502a:	df 03 0a 00 	jeq %d3,0,8000503e <IfxCpu_setCoreMode+0x2a>
8000502e:	df 48 05 00 	jeq %d8,4,80005038 <IfxCpu_setCoreMode+0x24>
80005032:	82 19       	mov %d9,1
80005034:	1d 00 06 00 	j 80005040 <IfxCpu_setCoreMode+0x2c>
80005038:	82 09       	mov %d9,0
8000503a:	1d 00 03 00 	j 80005040 <IfxCpu_setCoreMode+0x2c>
8000503e:	82 09       	mov %d9,0
    retValue = ((mode == IfxCpu_CoreMode_halt) || (mode == IfxCpu_CoreMode_sleep)
80005040:	8f f9 0f 91 	and %d9,%d9,255

    reqslp = (mode == IfxCpu_CoreMode_idle) ? IfxScu_PMCSR_REQSLP_Idle : IfxScu_PMCSR_REQSLP_Run;
80005044:	8b 28 00 82 	eq %d8,%d8,2

    if (retValue == TRUE)
80005048:	df 09 04 80 	jne %d9,0,80005050 <IfxCpu_setCoreMode+0x3c>
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
        }
    }

    return retValue;
}
8000504c:	02 92       	mov %d2,%d9
8000504e:	00 90       	ret 
    reg.U = __mfcr(CPU_CORE_ID);
80005050:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80005054:	8f 72 00 21 	and %d2,%d2,7
        if (IfxCpu_getCoreIndex() != index)
80005058:	5f 2a 24 00 	jeq %d10,%d2,800050a0 <IfxCpu_setCoreMode+0x8c>
            uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
8000505c:	6d ff 56 f2 	call 80003508 <IfxScuWdt_getSafetyWatchdogPassword>
80005060:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearSafetyEndinit(safetyWdtPw);
80005062:	02 24       	mov %d4,%d2
80005064:	6d ff fc f0 	call 8000325c <IfxScuWdt_clearSafetyEndinit>
            MODULE_SCU.PMCSR[(uint32)IfxCpu_getIndex(cpu)].B.REQSLP = reqslp;
80005068:	1b 5a 03 20 	addi %d2,%d10,53
8000506c:	06 22       	sh %d2,2
8000506e:	7b 30 00 3f 	movh %d3,61443
80005072:	1b 03 00 36 	addi %d3,%d3,24576
80005076:	60 32       	mov.a %a2,%d3
80005078:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
8000507c:	54 23       	ld.w %d3,[%a2]
8000507e:	37 83 02 30 	insert %d3,%d3,%d8,0,2
80005082:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setSafetyEndinit(safetyWdtPw);
80005084:	02 b4       	mov %d4,%d11
80005086:	6d ff 71 f2 	call 80003568 <IfxScuWdt_setSafetyEndinit>
            cpu->DBGSR.B.HALT = 2; /*reset the HALT bit, if it is already done it is no harm in writing again */
8000508a:	bb 00 d0 2f 	mov.u %d2,64768
8000508e:	60 c2       	mov.a %a2,%d12
80005090:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80005094:	54 22       	ld.w %d2,[%a2]
80005096:	b7 22 82 20 	insert %d2,%d2,2,1,2
8000509a:	74 22       	st.w [%a2],%d2
8000509c:	1d ff d8 ff 	j 8000504c <IfxCpu_setCoreMode+0x38>
            uint16 cpuWdtPw = IfxScuWdt_getCpuWatchdogPassword();
800050a0:	6d ff 22 f2 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
800050a4:	02 2b       	mov %d11,%d2
            IfxScuWdt_clearCpuEndinit(cpuWdtPw);
800050a6:	02 24       	mov %d4,%d2
800050a8:	6d ff b5 f0 	call 80003212 <IfxScuWdt_clearCpuEndinit>
            MODULE_SCU.PMCSR[(uint32)index].B.REQSLP = reqslp;
800050ac:	1b 5a 03 20 	addi %d2,%d10,53
800050b0:	06 22       	sh %d2,2
800050b2:	7b 30 00 3f 	movh %d3,61443
800050b6:	1b 03 00 36 	addi %d3,%d3,24576
800050ba:	60 32       	mov.a %a2,%d3
800050bc:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800050c0:	54 23       	ld.w %d3,[%a2]
800050c2:	37 83 02 30 	insert %d3,%d3,%d8,0,2
800050c6:	74 23       	st.w [%a2],%d3
            IfxScuWdt_setCpuEndinit(cpuWdtPw);
800050c8:	02 b4       	mov %d4,%d11
800050ca:	6d ff 2a f2 	call 8000351e <IfxScuWdt_setCpuEndinit>
800050ce:	1d ff bf ff 	j 8000504c <IfxCpu_setCoreMode+0x38>

800050d2 <IfxCpu_setProgramCounter>:


boolean IfxCpu_setProgramCounter(Ifx_CPU *cpu, uint32 programCounter)
{
800050d2:	40 ae       	mov.aa %a14,%sp
    reg.U = __mfcr(CPU_CORE_ID);
800050d4:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800050d8:	8f 72 00 21 	and %d2,%d2,7
    if (cpu < IfxCpu_ResourceCpu_none)
800050dc:	ff 32 17 80 	jge.u %d2,3,8000510a <IfxCpu_setProgramCounter+0x38>
        module = (Ifx_CPU *)IfxCpu_cfg_indexMap[cpu].module;
800050e0:	06 32       	sh %d2,3
800050e2:	91 00 00 28 	movh.a %a2,32768
800050e6:	d9 22 00 c0 	lea %a2,[%a2]768 <80000300 <IfxCpu_cfg_indexMap>>
800050ea:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
800050ee:	54 22       	ld.w %d2,[%a2]
    boolean retVal = TRUE;

    if (cpu == IfxCpu_getAddress(IfxCpu_getCoreIndex()))
800050f0:	80 43       	mov.d %d3,%a4
800050f2:	5f 23 0f 00 	jeq %d3,%d2,80005110 <IfxCpu_setProgramCounter+0x3e>
    {
        retVal = FALSE;
    }
    else
    {
        cpu->PC.B.PC = programCounter >> 1;
800050f6:	bb 80 e0 2f 	mov.u %d2,65032
800050fa:	01 42 00 46 	addsc.a %a4,%a4,%d2,0
800050fe:	54 42       	ld.w %d2,[%a4]
80005100:	37 24 01 20 	insert %d2,%d4,%d2,0,1
80005104:	74 42       	st.w [%a4],%d2
    boolean retVal = TRUE;
80005106:	82 12       	mov %d2,1
80005108:	00 90       	ret 
        module = NULL_PTR;
8000510a:	82 02       	mov %d2,0
8000510c:	1d ff f2 ff 	j 800050f0 <IfxCpu_setProgramCounter+0x1e>
        retVal = FALSE;
80005110:	82 02       	mov %d2,0
    }

    return retVal;
}
80005112:	00 90       	ret 

80005114 <IfxCpu_startCore>:
    return retVal;
}


boolean IfxCpu_startCore(Ifx_CPU *cpu, uint32 programCounter)
{
80005114:	40 ae       	mov.aa %a14,%sp
80005116:	80 49       	mov.d %d9,%a4
    boolean retVal = TRUE;

    /* Set the PC for Core 1 */
    retVal &= IfxCpu_setProgramCounter(cpu, programCounter);
80005118:	6d ff dd ff 	call 800050d2 <IfxCpu_setProgramCounter>
8000511c:	8f 12 00 81 	and %d8,%d2,1
    /* Get the mode for Core 1 and set it to RUNNING */

    /* Core not running already */
    if (IfxCpu_getCoreMode(cpu) == IfxCpu_CoreMode_halt)
80005120:	60 94       	mov.a %a4,%d9
80005122:	6d ff 43 ff 	call 80004fa8 <IfxCpu_getCoreMode>
80005126:	df 02 04 00 	jeq %d2,0,8000512e <IfxCpu_startCore+0x1a>
    {
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
    }

    return retVal;
}
8000512a:	02 82       	mov %d2,%d8
8000512c:	00 90       	ret 
        retVal &= IfxCpu_setCoreMode(cpu, IfxCpu_CoreMode_run);
8000512e:	82 14       	mov %d4,1
80005130:	60 94       	mov.a %a4,%d9
80005132:	6d ff 71 ff 	call 80005014 <IfxCpu_setCoreMode>
80005136:	26 28       	and %d8,%d2
80005138:	1d ff f9 ff 	j 8000512a <IfxCpu_startCore+0x16>

8000513c <IfxCpu_waitEvent>:


boolean IfxCpu_waitEvent(IfxCpu_syncEvent *event, uint32 timeoutMilliSec)
{
8000513c:	40 ae       	mov.aa %a14,%sp
8000513e:	40 4c       	mov.aa %a12,%a4
80005140:	02 48       	mov %d8,%d4
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
80005142:	80 42       	mov.d %d2,%a4
80005144:	b7 02 1c 20 	insert %d2,%d2,0,0,28
80005148:	7b 00 00 3d 	movh %d3,53248
8000514c:	5f 32 28 00 	jeq %d2,%d3,8000519c <IfxCpu_waitEvent+0x60>
    return IfxScuCcu_getSourceFrequency() / SCU_CCUCON1.B.STMDIV;
80005150:	6d ff d0 ed 	call 80002cf0 <IfxScuCcu_getSourceFrequency>
80005154:	91 30 00 2f 	movh.a %a2,61443
80005158:	d9 22 34 06 	lea %a2,[%a2]24628 <f0036034 <_SMALL_DATA4_+0x6002e034>>
8000515c:	54 23       	ld.w %d3,[%a2]
8000515e:	37 03 64 34 	extr.u %d3,%d3,8,4
80005162:	4b 03 41 31 	itof %d3,%d3
80005166:	4b 32 51 20 	div.f %d2,%d2,%d3

    boolean          errorcnt      = 0U;
    /* Divide with 1000, gives the count value equivalent to milliseconds */
    uint32           stmCount      = (uint32)((IfxScuCcu_getStmFrequency() / 1000) * timeoutMilliSec);
8000516a:	7b a0 47 34 	movh %d3,17530
8000516e:	4b 32 51 20 	div.f %d2,%d2,%d3
80005172:	4b 08 61 41 	utof %d4,%d8
80005176:	4b 24 41 40 	mul.f %d4,%d4,%d2
8000517a:	4b 04 71 31 	ftouz %d3,%d4
    uint32           stmCountBegin = STM0_TIM0.U;
8000517e:	85 f4 10 00 	ld.w %d4,f0000010 <_SMALL_DATA4_+0x5fff8010>

    while ((*sync & IFXCPU_CFG_ALLCORE_DONE) != IFXCPU_CFG_ALLCORE_DONE)
80005182:	54 c2       	ld.w %d2,[%a12]
80005184:	8f 72 00 21 	and %d2,%d2,7
80005188:	df 72 18 00 	jeq %d2,7,800051b8 <IfxCpu_waitEvent+0x7c>
    __asm__ volatile ("nop" : : : "memory");
8000518c:	00 00       	nop 
    {
        __nop();

        if ((uint32)(STM0_TIM0.U - stmCountBegin) >= stmCount)
8000518e:	85 f2 10 00 	ld.w %d2,f0000010 <_SMALL_DATA4_+0x5fff8010>
80005192:	a2 42       	sub %d2,%d4
80005194:	3f 32 f7 ff 	jlt.u %d2,%d3,80005182 <IfxCpu_waitEvent+0x46>
        {
            errorcnt = 1;
80005198:	82 12       	mov %d2,1
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

    return errorcnt;
}
8000519a:	00 90       	ret 
    volatile uint32 *sync          = (volatile uint32 *)IFXCPU_GLB_ADDR_DSPR(__mfcr(CPU_CORE_ID), event);
8000519c:	80 42       	mov.d %d2,%a4
8000519e:	b7 02 0c 3a 	insert %d3,%d2,0,20,12
800051a2:	b7 f3 03 3e 	insert %d3,%d3,15,28,3
800051a6:	4d c0 e1 2f 	mfcr %d2,$core_id
800051aa:	8f c2 01 20 	sh %d2,%d2,28
800051ae:	0b 23 80 20 	sub %d2,%d3,%d2
800051b2:	60 2c       	mov.a %a12,%d2
800051b4:	1d ff ce ff 	j 80005150 <IfxCpu_waitEvent+0x14>
    boolean          errorcnt      = 0U;
800051b8:	82 02       	mov %d2,0
800051ba:	00 90       	ret 

800051bc <IfxCpu_emitEvent>:


void IfxCpu_emitEvent(IfxCpu_syncEvent *event)
{
800051bc:	40 ae       	mov.aa %a14,%sp
    Ifx__imaskldmst(event, 1, __mfcr(CPU_CORE_ID), 1);
800051be:	4d c0 e1 2f 	mfcr %d2,$core_id
800051c2:	82 13       	mov %d3,1
800051c4:	57 30 21 22 	imask %e2,%d3,%d2,1
800051c8:	49 42 40 08 	ldmst [%a4]0,%e2
}
800051cc:	00 90       	ret 

800051ce <Ifx_Cpp_Init>:
#pragma section
#elif defined(__DCC__)
#pragma section CONST
#endif
static void Ifx_Cpp_Init(void)
{
800051ce:	40 ae       	mov.aa %a14,%sp
    Ifx_C_Init();           /*Initialization of C runtime variables */
800051d0:	6d 00 d9 09 	call 80006582 <Ifx_C_Init>
#elif defined (__HIGHTEC__)
extern void _init(void); /* cpp initialization */
    _init();
#elif defined (__GNUC__) && !defined(__HIGHTEC__)
    extern void _init(void); /* cpp initialization */
    _init();
800051d4:	6d 00 a8 18 	call 80008324 <_init>
#endif
}
800051d8:	00 90       	ret 

800051da <hardware_init_hook>:
{}
800051da:	00 90       	ret 

800051dc <software_init_hook>:
{}
800051dc:	00 90       	ret 

800051de <_Core0_start>:
    uint16 password;

    /* Read Password from CON0 register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CON0.B.PW;
800051de:	91 30 00 2f 	movh.a %a2,61443
800051e2:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
    __setareg(sp, __USTACK(0));
800051e6:	91 20 00 37 	movh.a %a3,28674
800051ea:	37 02 6e 21 	extr.u %d2,%d2,2,14
800051ee:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800051f2:	8f f2 83 81 	xor %d8,%d2,63
800051f6:	80 32       	mov.d %d2,%a3
800051f8:	1b 02 60 29 	addi %d2,%d2,-27136
800051fc:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
800051fe:	0d 00 80 04 	dsync 
    __mtcr(CPU_PSW, IFXCSTART0_PSW_DEFAULT);
80005202:	3b 00 98 20 	mov %d2,2432
80005206:	cd 42 e0 0f 	mtcr $psw,%d2
    pcxi  = __mfcr(CPU_PCXI);
8000520a:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART0_PCX_O_S_DEFAULT; /*0xfff00000; */
8000520e:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
80005212:	cd 02 e0 0f 	mtcr $pcxi,%d2
    if (enable)
    {                           /* Step 3: Initiate invalidation of current cache contents if any */
        Ifx_CPU_PCON1 pcon1;
        pcon1.U       = 0;
        pcon1.B.PCINV = 1;
        __mtcr(CPU_PCON1, pcon1.U);
80005216:	82 12       	mov %d2,1
80005218:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
8000521c:	4d c0 e1 2f 	mfcr %d2,$core_id
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80005220:	8f 72 00 21 	and %d2,%d2,7
    }

    uint32 coreIndex   = IfxCpu_getCoreIndex();
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80005224:	01 22 03 26 	addsc.a %a2,%a2,%d2,3
80005228:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
8000522c:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000522e:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80005230:	37 02 6e 21 	extr.u %d2,%d2,2,14
    /*PCACHE enable steps */
    {                           /* Step 1: Set PCBYP to 0 if cache is enabled */
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
80005234:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80005238:	6f 13 41 81 	jnz.t %d3,1,800054ba <_Core0_start+0x2dc>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000523c:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005240:	54 22       	ld.w %d2,[%a2]
80005242:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005246:	a6 32       	or %d2,%d3
80005248:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000524c:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
8000524e:	54 22       	ld.w %d2,[%a2]
80005250:	6f 02 ff ff 	jnz.t %d2,0,8000524e <_Core0_start+0x70>
        Ifx_CPU_PCON0 pcon0;
        pcon0.U       = 0;
        pcon0.B.PCBYP = enable ? 0 : 1; /*depending on the enable bypass bit is reset/set */
        __mtcr(CPU_PCON0, pcon0.U);
80005254:	82 02       	mov %d2,0
80005256:	cd c2 20 09 	mtcr $pcon0,%d2
}


IFX_INLINE void IfxScuWdt_setCpuEndinitInline(Ifx_SCU_WDTCPU *watchdog, uint16 password)
{
    if (watchdog->CON0.B.LCK)
8000525a:	54 22       	ld.w %d2,[%a2]
8000525c:	6f 12 09 00 	jz.t %d2,1,8000526e <_Core0_start+0x90>
    {
        /* see Table 1 (Pass.word Access Bit Pattern Requirements) */
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                           (0 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005260:	54 22       	ld.w %d2,[%a2]
80005262:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005266:	a6 32       	or %d2,%d3
80005268:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000526c:	74 22       	st.w [%a2],%d2

    /* Set ENDINT and set LCK bit in Config_0 register */
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
                       (1 << IFX_SCU_WDTCPU_CON0_LCK_OFF) |
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000526e:	54 22       	ld.w %d2,[%a2]
80005270:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005274:	a6 32       	or %d2,%d3
80005276:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000527a:	74 22       	st.w [%a2],%d2

    /* read back ENDINIT and wait until it has been set */
    while (watchdog->CON0.B.ENDINIT == 0)
8000527c:	54 22       	ld.w %d2,[%a2]
8000527e:	6f 02 ff 7f 	jz.t %d2,0,8000527c <_Core0_start+0x9e>
    __asm__ volatile ("isync" : : : "memory");
80005282:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80005286:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
8000528a:	7b 30 00 3f 	movh %d3,61443
8000528e:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
80005292:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80005296:	13 c2 20 23 	madd %d2,%d3,%d2,12
8000529a:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
8000529c:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
8000529e:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
800052a0:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
800052a4:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800052a8:	6f 13 fd 80 	jnz.t %d3,1,800054a2 <_Core0_start+0x2c4>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800052ac:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800052b0:	54 22       	ld.w %d2,[%a2]
800052b2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800052b6:	a6 32       	or %d2,%d3
800052b8:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800052bc:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800052be:	54 22       	ld.w %d2,[%a2]
800052c0:	6f 02 ff ff 	jnz.t %d2,0,800052be <_Core0_start+0xe0>
        __mtcr(CPU_DCON0, dcon0.U);
800052c4:	82 22       	mov %d2,2
800052c6:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
800052ca:	54 22       	ld.w %d2,[%a2]
800052cc:	6f 12 09 00 	jz.t %d2,1,800052de <_Core0_start+0x100>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800052d0:	54 22       	ld.w %d2,[%a2]
800052d2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800052d6:	a6 32       	or %d2,%d3
800052d8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800052dc:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800052de:	54 22       	ld.w %d2,[%a2]
800052e0:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800052e4:	a6 32       	or %d2,%d3
800052e6:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800052ea:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
800052ec:	54 22       	ld.w %d2,[%a2]
800052ee:	6f 02 ff 7f 	jz.t %d2,0,800052ec <_Core0_start+0x10e>
800052f2:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
800052f6:	91 30 00 2f 	movh.a %a2,61443
800052fa:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
800052fe:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005302:	8f 28 00 30 	sh %d3,%d8,2
    if (watchdog->CON0.B.LCK)
80005306:	6f 12 09 00 	jz.t %d2,1,80005318 <_Core0_start+0x13a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000530a:	54 22       	ld.w %d2,[%a2]
8000530c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005310:	a6 32       	or %d2,%d3
80005312:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005316:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005318:	91 30 00 2f 	movh.a %a2,61443
8000531c:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80005320:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80005324:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005328:	a6 32       	or %d2,%d3
8000532a:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000532e:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80005330:	54 22       	ld.w %d2,[%a2]
80005332:	6f 02 ff ff 	jnz.t %d2,0,80005330 <_Core0_start+0x152>
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(0));
80005336:	91 00 00 38 	movh.a %a3,32768
8000533a:	80 32       	mov.d %d2,%a3
8000533c:	1b 02 10 20 	addi %d2,%d2,256
80005340:	cd 42 e2 0f 	mtcr $btv,%d2
    __mtcr(CPU_BIV, (uint32)__INTTAB(0));
80005344:	91 f0 01 38 	movh.a %a3,32799
80005348:	80 32       	mov.d %d2,%a3
8000534a:	1b 02 00 24 	addi %d2,%d2,16384
8000534e:	cd 02 e2 0f 	mtcr $biv,%d2
    __mtcr(CPU_ISP, (uint32)__ISTACK(0));
80005352:	91 20 00 37 	movh.a %a3,28674
80005356:	80 32       	mov.d %d2,%a3
80005358:	1b 02 b0 29 	addi %d2,%d2,-25856
8000535c:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
80005360:	54 22       	ld.w %d2,[%a2]
80005362:	6f 12 09 00 	jz.t %d2,1,80005374 <_Core0_start+0x196>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005366:	54 22       	ld.w %d2,[%a2]
80005368:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000536c:	a6 32       	or %d2,%d3
8000536e:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005372:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005374:	91 30 00 2f 	movh.a %a2,61443
80005378:	19 22 00 46 	ld.w %d2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
8000537c:	d9 22 00 46 	lea %a2,[%a2]24832 <f0036100 <_SMALL_DATA4_+0x6002e100>>
80005380:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005384:	a6 32       	or %d2,%d3
80005386:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000538a:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
8000538c:	54 22       	ld.w %d2,[%a2]
8000538e:	6f 02 ff 7f 	jz.t %d2,0,8000538c <_Core0_start+0x1ae>
    __setareg(a0, __SDATA1(0));
80005392:	91 10 00 26 	movh.a %a2,24577
80005396:	80 22       	mov.d %d2,%a2
80005398:	1b 02 00 28 	addi %d2,%d2,-32768
8000539c:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(0));
8000539e:	91 10 00 28 	movh.a %a2,32769
800053a2:	80 22       	mov.d %d2,%a2
800053a4:	1b 02 00 28 	addi %d2,%d2,-32768
800053a8:	60 21       	mov.a %a1,%d2
    __setareg(a8, __SDATA3(0));
800053aa:	91 10 00 28 	movh.a %a2,32769
800053ae:	80 22       	mov.d %d2,%a2
800053b0:	1b 02 00 28 	addi %d2,%d2,-32768
800053b4:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(0));
800053b6:	91 10 00 29 	movh.a %a2,36865
800053ba:	80 22       	mov.d %d2,%a2
800053bc:	1b 02 00 28 	addi %d2,%d2,-32768
800053c0:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
800053c2:	91 20 00 37 	movh.a %a3,28674
800053c6:	91 20 00 27 	movh.a %a2,28674
800053ca:	d9 33 c0 09 	lea %a3,[%a3]-25600 <70019c00 <__CSA0>>
800053ce:	d9 22 c0 0b 	lea %a2,[%a2]-17408 <7001bc00 <__CSA0_END>>
800053d2:	01 32 20 20 	sub.a %a2,%a2,%a3
800053d6:	80 22       	mov.d %d2,%a2
800053d8:	8f a2 1f 70 	sh %d7,%d2,-6
    uint32 *prvCsa      = csaBegin;
800053dc:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
800053de:	1b d7 ff 0f 	addi %d0,%d7,-3
    for (k = 0U; k < numOfCsa; k++)
800053e2:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
800053e4:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800053e6:	7b f0 00 40 	movh %d4,15
    for (k = 0U; k < numOfCsa; k++)
800053ea:	df 07 27 00 	jeq %d7,0,80005438 <_Core0_start+0x25a>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800053ee:	37 02 70 53 	extr.u %d5,%d2,6,16
800053f2:	8f 42 1f 60 	sh %d6,%d2,-12
800053f6:	26 46       	and %d6,%d4
800053f8:	a6 65       	or %d5,%d6
        if (k == 0U)
800053fa:	df 03 16 00 	jeq %d3,0,80005426 <_Core0_start+0x248>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
800053fe:	74 25       	st.w [%a2],%d5
        if (k == (numOfCsa - 3U))
80005400:	5f 03 04 80 	jne %d3,%d0,80005408 <_Core0_start+0x22a>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
80005404:	cd c5 e3 0f 	mtcr $lcx,%d5
    for (k = 0U; k < numOfCsa; k++)
80005408:	c2 13       	add %d3,1
8000540a:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
8000540c:	1b 02 04 50 	addi %d5,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80005410:	5f 37 0f 00 	jeq %d7,%d3,8000542e <_Core0_start+0x250>
        nxtCsa += 16U;           /* next CSA */
80005414:	02 52       	mov %d2,%d5
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80005416:	37 02 70 53 	extr.u %d5,%d2,6,16
8000541a:	8f 42 1f 60 	sh %d6,%d2,-12
8000541e:	26 46       	and %d6,%d4
80005420:	a6 65       	or %d5,%d6
        if (k == 0U)
80005422:	df 03 ee ff 	jne %d3,0,800053fe <_Core0_start+0x220>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
80005426:	cd 85 e3 0f 	mtcr $fcx,%d5
8000542a:	1d ff eb ff 	j 80005400 <_Core0_start+0x222>
8000542e:	1b f7 ff 2f 	addi %d2,%d7,-1
80005432:	06 62       	sh %d2,6
80005434:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
80005438:	82 02       	mov %d2,0
8000543a:	74 22       	st.w [%a2],%d2
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
8000543c:	6d ff 66 f0 	call 80003508 <IfxScuWdt_getSafetyWatchdogPassword>
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
80005440:	02 84       	mov %d4,%d8
        uint16 safetyWdtPassword = IfxScuWdt_getSafetyWatchdogPassword();
80005442:	02 29       	mov %d9,%d2
        IfxScuWdt_disableCpuWatchdog(cpuWdtPassword);
80005444:	6d ff 34 ef 	call 800032ac <IfxScuWdt_disableCpuWatchdog>
        IfxScuWdt_disableSafetyWatchdog(safetyWdtPassword);
80005448:	02 94       	mov %d4,%d9
8000544a:	6d ff 70 ef 	call 8000332a <IfxScuWdt_disableSafetyWatchdog>
       	hardware_init_hook();
8000544e:	6d ff c6 fe 	call 800051da <hardware_init_hook>
        Ifx_Cpp_Init();
80005452:	6d ff be fe 	call 800051ce <Ifx_Cpp_Init>
       	software_init_hook();
80005456:	6d ff c3 fe 	call 800051dc <software_init_hook>
        IfxScuWdt_enableCpuWatchdog(cpuWdtPassword);
8000545a:	02 84       	mov %d4,%d8
8000545c:	6d ff b6 ef 	call 800033c8 <IfxScuWdt_enableCpuWatchdog>
        IfxScuWdt_enableSafetyWatchdog(safetyWdtPassword);
80005460:	02 94       	mov %d4,%d9
80005462:	6d ff f2 ef 	call 80003446 <IfxScuWdt_enableSafetyWatchdog>
    IFXCPU_CSTART_CCU_INIT_HOOK();
80005466:	91 00 00 48 	movh.a %a4,32768
8000546a:	d9 44 50 00 	lea %a4,[%a4]1040 <80000410 <IfxScuCcu_defaultClockConfig>>
8000546e:	6d ff 31 ed 	call 80002ed0 <IfxScuCcu_init>
    (void)IfxCpu_startCore(&MODULE_CPU1, (uint32)&_Core1_start);       /*The status returned by function call is ignored */
80005472:	91 00 00 28 	movh.a %a2,32768
80005476:	80 22       	mov.d %d2,%a2
80005478:	1b 22 4d 45 	addi %d4,%d2,21714
8000547c:	91 30 88 4f 	movh.a %a4,63619
80005480:	6d ff 4a fe 	call 80005114 <IfxCpu_startCore>
    (void)IfxCpu_startCore(&MODULE_CPU2, (uint32)&_Core2_start);       /*The status returned by function call is ignored */
80005484:	91 00 00 28 	movh.a %a2,32768
80005488:	80 22       	mov.d %d2,%a2
8000548a:	1b 02 77 45 	addi %d4,%d2,22384
8000548e:	91 50 88 4f 	movh.a %a4,63621
80005492:	6d ff 41 fe 	call 80005114 <IfxCpu_startCore>
    __non_return_call(core0_main);
80005496:	91 00 00 28 	movh.a %a2,32768
8000549a:	d9 22 ee 46 	lea %a2,[%a2]27950 <80006d2e <core0_main>>
8000549e:	dc 02       	ji %a2
}
800054a0:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800054a2:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800054a4:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800054a8:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800054ac:	0f 34 a0 20 	or %d2,%d4,%d3
800054b0:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800054b4:	74 22       	st.w [%a2],%d2
800054b6:	1d ff fd fe 	j 800052b0 <_Core0_start+0xd2>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800054ba:	54 24       	ld.w %d4,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800054bc:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800054c0:	b7 04 10 40 	insert %d4,%d4,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800054c4:	0f 34 a0 20 	or %d2,%d4,%d3
800054c8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800054cc:	74 22       	st.w [%a2],%d2
800054ce:	1d ff b9 fe 	j 80005240 <_Core0_start+0x62>

800054d2 <_Core1_start>:
    password  = watchdog->CON0.B.PW;
800054d2:	91 30 00 2f 	movh.a %a2,61443
800054d6:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800054da:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800054de:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[1]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(1);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(1));
800054e2:	91 20 00 26 	movh.a %a2,24578
800054e6:	8f f2 83 41 	xor %d4,%d2,63
800054ea:	80 22       	mov.d %d2,%a2
800054ec:	1b 02 60 2b 	addi %d2,%d2,-18944
800054f0:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
800054f2:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART1_PSW_DEFAULT);    /* 0x00000980 */
800054f6:	3b 00 98 20 	mov %d2,2432
800054fa:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
800054fe:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART1_PCX_O_S_DEFAULT; /*0xfff00000; */
80005502:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
80005506:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
8000550a:	82 12       	mov %d2,1
8000550c:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
80005510:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80005514:	7b 30 00 3f 	movh %d3,61443
80005518:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000551c:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80005520:	13 c2 20 23 	madd %d2,%d3,%d2,12
80005524:	60 22       	mov.a %a2,%d2
80005526:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80005528:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000552a:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
8000552e:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80005532:	6f 13 13 81 	jnz.t %d3,1,80005758 <_Core1_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005536:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000553a:	54 22       	ld.w %d2,[%a2]
8000553c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005540:	a6 32       	or %d2,%d3
80005542:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005546:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80005548:	54 22       	ld.w %d2,[%a2]
8000554a:	6f 02 ff ff 	jnz.t %d2,0,80005548 <_Core1_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
8000554e:	82 02       	mov %d2,0
80005550:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
80005554:	54 22       	ld.w %d2,[%a2]
80005556:	6f 12 09 00 	jz.t %d2,1,80005568 <_Core1_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000555a:	54 22       	ld.w %d2,[%a2]
8000555c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005560:	a6 32       	or %d2,%d3
80005562:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005566:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005568:	54 22       	ld.w %d2,[%a2]
8000556a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000556e:	a6 32       	or %d2,%d3
80005570:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005574:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80005576:	54 22       	ld.w %d2,[%a2]
80005578:	6f 02 ff 7f 	jz.t %d2,0,80005576 <_Core1_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
8000557c:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
80005580:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80005584:	7b 30 00 3f 	movh %d3,61443
80005588:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000558c:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80005590:	13 c2 20 23 	madd %d2,%d3,%d2,12
80005594:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
80005596:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80005598:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
8000559a:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
8000559e:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800055a2:	6f 13 cf 80 	jnz.t %d3,1,80005740 <_Core1_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800055a6:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800055aa:	54 22       	ld.w %d2,[%a2]
800055ac:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800055b0:	a6 32       	or %d2,%d3
800055b2:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800055b6:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800055b8:	54 22       	ld.w %d2,[%a2]
800055ba:	6f 02 ff ff 	jnz.t %d2,0,800055b8 <_Core1_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
800055be:	82 02       	mov %d2,0
800055c0:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
800055c4:	54 22       	ld.w %d2,[%a2]
800055c6:	6f 12 09 00 	jz.t %d2,1,800055d8 <_Core1_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800055ca:	54 22       	ld.w %d2,[%a2]
800055cc:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800055d0:	a6 32       	or %d2,%d3
800055d2:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800055d6:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800055d8:	54 22       	ld.w %d2,[%a2]
800055da:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800055de:	a6 32       	or %d2,%d3
800055e0:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800055e4:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
800055e6:	54 22       	ld.w %d2,[%a2]
800055e8:	6f 02 ff 7f 	jz.t %d2,0,800055e6 <_Core1_start+0x114>
800055ec:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
800055f0:	91 30 00 2f 	movh.a %a2,61443
800055f4:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
800055f8:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800055fc:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
800055fe:	6f 12 09 00 	jz.t %d2,1,80005610 <_Core1_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005602:	54 22       	ld.w %d2,[%a2]
80005604:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005608:	a6 42       	or %d2,%d4
8000560a:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000560e:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005610:	91 30 00 2f 	movh.a %a2,61443
80005614:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80005618:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
8000561c:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005620:	a6 42       	or %d2,%d4
80005622:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005626:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80005628:	54 22       	ld.w %d2,[%a2]
8000562a:	6f 02 ff ff 	jnz.t %d2,0,80005628 <_Core1_start+0x156>

    /* Clear the ENDINIT bit in the WDT_CON1 register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(1));
8000562e:	91 f0 01 38 	movh.a %a3,32799
80005632:	80 32       	mov.d %d2,%a3
80005634:	1b 02 20 26 	addi %d2,%d2,25088
80005638:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(1));
8000563c:	91 f0 01 38 	movh.a %a3,32799
80005640:	80 32       	mov.d %d2,%a3
80005642:	1b 02 00 24 	addi %d2,%d2,16384
80005646:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(1));
8000564a:	91 20 00 36 	movh.a %a3,24578
8000564e:	80 32       	mov.d %d2,%a3
80005650:	1b 02 b0 2b 	addi %d2,%d2,-17664
80005654:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
80005658:	54 22       	ld.w %d2,[%a2]
8000565a:	6f 12 09 00 	jz.t %d2,1,8000566c <_Core1_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000565e:	54 22       	ld.w %d2,[%a2]
80005660:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005664:	a6 42       	or %d2,%d4
80005666:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000566a:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000566c:	91 30 00 2f 	movh.a %a2,61443
80005670:	19 22 0c 46 	ld.w %d2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80005674:	d9 22 0c 46 	lea %a2,[%a2]24844 <f003610c <_SMALL_DATA4_+0x6002e10c>>
80005678:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000567c:	a6 42       	or %d2,%d4
8000567e:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005682:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80005684:	54 22       	ld.w %d2,[%a2]
80005686:	6f 02 ff 7f 	jz.t %d2,0,80005684 <_Core1_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[1], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(1));
8000568a:	91 10 00 26 	movh.a %a2,24577
8000568e:	80 22       	mov.d %d2,%a2
80005690:	1b 02 00 28 	addi %d2,%d2,-32768
80005694:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(1));
80005696:	91 10 00 28 	movh.a %a2,32769
8000569a:	80 22       	mov.d %d2,%a2
8000569c:	1b 02 00 28 	addi %d2,%d2,-32768
800056a0:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialised */
    __setareg(a8, __SDATA3(1));
800056a2:	91 10 00 28 	movh.a %a2,32769
800056a6:	80 22       	mov.d %d2,%a2
800056a8:	1b 02 00 28 	addi %d2,%d2,-32768
800056ac:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(1));
800056ae:	91 10 00 29 	movh.a %a2,36865
800056b2:	80 22       	mov.d %d2,%a2
800056b4:	1b 02 00 28 	addi %d2,%d2,-32768
800056b8:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
800056ba:	91 20 00 36 	movh.a %a3,24578
800056be:	91 20 00 26 	movh.a %a2,24578
800056c2:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <6001bc00 <__CSA1>>
800056c6:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <6001dc00 <__CSA1_END>>
800056ca:	01 32 20 20 	sub.a %a2,%a2,%a3
800056ce:	80 22       	mov.d %d2,%a2
800056d0:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
800056d4:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
800056d6:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
800056da:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
800056dc:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800056de:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
800056e2:	df 06 27 00 	jeq %d6,0,80005730 <_Core1_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800056e6:	37 02 70 43 	extr.u %d4,%d2,6,16
800056ea:	8f 42 1f 50 	sh %d5,%d2,-12
800056ee:	26 75       	and %d5,%d7
800056f0:	a6 54       	or %d4,%d5
        if (k == 0U)
800056f2:	df 03 16 00 	jeq %d3,0,8000571e <_Core1_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
800056f6:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
800056f8:	5f 03 04 80 	jne %d3,%d0,80005700 <_Core1_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
800056fc:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
80005700:	c2 13       	add %d3,1
80005702:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
80005704:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
80005708:	5f 36 0f 00 	jeq %d6,%d3,80005726 <_Core1_start+0x254>
        nxtCsa += 16U;           /* next CSA */
8000570c:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
8000570e:	37 02 70 43 	extr.u %d4,%d2,6,16
80005712:	8f 42 1f 50 	sh %d5,%d2,-12
80005716:	26 75       	and %d5,%d7
80005718:	a6 54       	or %d4,%d5
        if (k == 0U)
8000571a:	df 03 ee ff 	jne %d3,0,800056f6 <_Core1_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
8000571e:	cd 84 e3 0f 	mtcr $fcx,%d4
80005722:	1d ff eb ff 	j 800056f8 <_Core1_start+0x226>
80005726:	1b f6 ff 2f 	addi %d2,%d6,-1
8000572a:	06 62       	sh %d2,6
8000572c:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
80005730:	82 02       	mov %d2,0
80005732:	74 22       	st.w [%a2],%d2

    IfxCpu_initCSA((uint32 *)__CSA(1), (uint32 *)__CSA_END(1));

    /*Call main function of Cpu0 */
    __non_return_call(core1_main);
80005734:	91 00 00 28 	movh.a %a2,32768
80005738:	d9 22 d0 66 	lea %a2,[%a2]28048 <80006d90 <core1_main>>
8000573c:	dc 02       	ji %a2
}
8000573e:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005740:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005742:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005746:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000574a:	0f 35 a0 20 	or %d2,%d5,%d3
8000574e:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005752:	74 22       	st.w [%a2],%d2
80005754:	1d ff 2b ff 	j 800055aa <_Core1_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005758:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000575a:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000575e:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005762:	0f 35 a0 20 	or %d2,%d5,%d3
80005766:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
8000576a:	74 22       	st.w [%a2],%d2
8000576c:	1d ff e7 fe 	j 8000553a <_Core1_start+0x68>

80005770 <_Core2_start>:
    password  = watchdog->CON0.B.PW;
80005770:	91 30 00 2f 	movh.a %a2,61443
80005774:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80005778:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
8000577c:	37 02 6e 21 	extr.u %d2,%d2,2,14
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[2]);

    IFX_CFG_CPU_CSTART_PRE_C_INIT_HOOK(2);  /*Test Stack, CSA and Cache */

    /* Load user stack pointer */
    __setareg(sp, __USTACK(2));
80005780:	91 20 00 25 	movh.a %a2,20482
80005784:	8f f2 83 41 	xor %d4,%d2,63
80005788:	80 22       	mov.d %d2,%a2
8000578a:	1b 02 60 2b 	addi %d2,%d2,-18944
8000578e:	60 2a       	mov.a %sp,%d2
    __asm__ volatile ("dsync" : : : "memory");
80005790:	0d 00 80 04 	dsync 
    __dsync();

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    __mtcr(CPU_PSW, IFXCSTART2_PSW_DEFAULT);    /* 0x00000980 */
80005794:	3b 00 98 20 	mov %d2,2432
80005798:	cd 42 e0 0f 	mtcr $psw,%d2

    /* Set the PCXS and PCXO to its reset value in case of a warm start */
    pcxi  = __mfcr(CPU_PCXI);
8000579c:	4d 00 e0 2f 	mfcr %d2,$pcxi
    pcxi &= IFXCSTART2_PCX_O_S_DEFAULT; /*0xfff00000; */
800057a0:	b7 02 14 20 	insert %d2,%d2,0,0,20
    __mtcr(CPU_PCXI, pcxi);
800057a4:	cd 02 e0 0f 	mtcr $pcxi,%d2
        __mtcr(CPU_PCON1, pcon1.U);
800057a8:	82 12       	mov %d2,1
800057aa:	cd 42 20 09 	mtcr $pcon1,%d2
    reg.U = __mfcr(CPU_CORE_ID);
800057ae:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800057b2:	7b 30 00 3f 	movh %d3,61443
800057b6:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
800057ba:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
800057be:	13 c2 20 23 	madd %d2,%d3,%d2,12
800057c2:	60 22       	mov.a %a2,%d2
800057c4:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
800057c6:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
800057c8:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
800057cc:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
800057d0:	6f 13 13 81 	jnz.t %d3,1,800059f6 <_Core2_start+0x286>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800057d4:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800057d8:	54 22       	ld.w %d2,[%a2]
800057da:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800057de:	a6 32       	or %d2,%d3
800057e0:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800057e4:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800057e6:	54 22       	ld.w %d2,[%a2]
800057e8:	6f 02 ff ff 	jnz.t %d2,0,800057e6 <_Core2_start+0x76>
        __mtcr(CPU_PCON0, pcon0.U);
800057ec:	82 02       	mov %d2,0
800057ee:	cd c2 20 09 	mtcr $pcon0,%d2
    if (watchdog->CON0.B.LCK)
800057f2:	54 22       	ld.w %d2,[%a2]
800057f4:	6f 12 09 00 	jz.t %d2,1,80005806 <_Core2_start+0x96>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800057f8:	54 22       	ld.w %d2,[%a2]
800057fa:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800057fe:	a6 32       	or %d2,%d3
80005800:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005804:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005806:	54 22       	ld.w %d2,[%a2]
80005808:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000580c:	a6 32       	or %d2,%d3
8000580e:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005812:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80005814:	54 22       	ld.w %d2,[%a2]
80005816:	6f 02 ff 7f 	jz.t %d2,0,80005814 <_Core2_start+0xa4>
    __asm__ volatile ("isync" : : : "memory");
8000581a:	0d 00 c0 04 	isync 
    reg.U = __mfcr(CPU_CORE_ID);
8000581e:	4d c0 e1 2f 	mfcr %d2,$core_id
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
80005822:	7b 30 00 3f 	movh %d3,61443
80005826:	1b 03 10 36 	addi %d3,%d3,24832
    return (IfxCpu_ResourceCpu)reg.B.CORE_ID;
8000582a:	8f 72 00 21 	and %d2,%d2,7
    uint16 wdtPassword = IfxScuWdt_getCpuWatchdogPasswordInline(&MODULE_SCU.WDTCPU[coreIndex]);
8000582e:	13 c2 20 23 	madd %d2,%d3,%d2,12
80005832:	60 22       	mov.a %a2,%d2
    password  = watchdog->CON0.B.PW;
80005834:	54 22       	ld.w %d2,[%a2]
    if (watchdog->CON0.B.LCK)
80005836:	54 23       	ld.w %d3,[%a2]
    password  = watchdog->CON0.B.PW;
80005838:	37 02 6e 21 	extr.u %d2,%d2,2,14
        IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[coreIndex], wdtPassword);
8000583c:	8f f2 83 21 	xor %d2,%d2,63
    if (watchdog->CON0.B.LCK)
80005840:	6f 13 cf 80 	jnz.t %d3,1,800059de <_Core2_start+0x26e>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005844:	8f 22 00 30 	sh %d3,%d2,2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005848:	54 22       	ld.w %d2,[%a2]
8000584a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000584e:	a6 32       	or %d2,%d3
80005850:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005854:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
80005856:	54 22       	ld.w %d2,[%a2]
80005858:	6f 02 ff ff 	jnz.t %d2,0,80005856 <_Core2_start+0xe6>
        __mtcr(CPU_DCON0, dcon0.U);
8000585c:	82 02       	mov %d2,0
8000585e:	cd 02 04 09 	mtcr $dcon0,%d2
    if (watchdog->CON0.B.LCK)
80005862:	54 22       	ld.w %d2,[%a2]
80005864:	6f 12 09 00 	jz.t %d2,1,80005876 <_Core2_start+0x106>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005868:	54 22       	ld.w %d2,[%a2]
8000586a:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000586e:	a6 32       	or %d2,%d3
80005870:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005874:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
80005876:	54 22       	ld.w %d2,[%a2]
80005878:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000587c:	a6 32       	or %d2,%d3
8000587e:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005882:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80005884:	54 22       	ld.w %d2,[%a2]
80005886:	6f 02 ff 7f 	jz.t %d2,0,80005884 <_Core2_start+0x114>
8000588a:	0d 00 c0 04 	isync 
    if (watchdog->CON0.B.LCK)
8000588e:	91 30 00 2f 	movh.a %a2,61443
80005892:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80005896:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000589a:	06 24       	sh %d4,2
    if (watchdog->CON0.B.LCK)
8000589c:	6f 12 09 00 	jz.t %d2,1,800058ae <_Core2_start+0x13e>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800058a0:	54 22       	ld.w %d2,[%a2]
800058a2:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800058a6:	a6 42       	or %d2,%d4
800058a8:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800058ac:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800058ae:	91 30 00 2f 	movh.a %a2,61443
800058b2:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
800058b6:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
800058ba:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800058be:	a6 42       	or %d2,%d4
800058c0:	8f 22 40 21 	or %d2,%d2,2
    watchdog->CON0.U = (0 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800058c4:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 1)
800058c6:	54 22       	ld.w %d2,[%a2]
800058c8:	6f 02 ff ff 	jnz.t %d2,0,800058c6 <_Core2_start+0x156>

    /* Clear the ENDINIT bit in the Password register, inline funtion */
    IfxScuWdt_clearCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* Load Base Address of Trap Vector Table. */
    __mtcr(CPU_BTV, (uint32)__TRAPTAB(2));
800058cc:	91 f0 01 38 	movh.a %a3,32799
800058d0:	80 32       	mov.d %d2,%a3
800058d2:	1b 02 10 26 	addi %d2,%d2,24832
800058d6:	cd 42 e2 0f 	mtcr $btv,%d2

    /* Load Base Address of Interrupt Vector Table. we will do this later in the program */
    __mtcr(CPU_BIV, (uint32)__INTTAB(2));
800058da:	91 f0 01 38 	movh.a %a3,32799
800058de:	80 32       	mov.d %d2,%a3
800058e0:	1b 02 00 24 	addi %d2,%d2,16384
800058e4:	cd 02 e2 0f 	mtcr $biv,%d2

    /* Load interupt stack pointer. */
    __mtcr(CPU_ISP, (uint32)__ISTACK(2));
800058e8:	91 20 00 35 	movh.a %a3,20482
800058ec:	80 32       	mov.d %d2,%a3
800058ee:	1b 02 b0 2b 	addi %d2,%d2,-17664
800058f2:	cd 82 e2 0f 	mtcr $isp,%d2
    if (watchdog->CON0.B.LCK)
800058f6:	54 22       	ld.w %d2,[%a2]
800058f8:	6f 12 09 00 	jz.t %d2,1,8000590a <_Core2_start+0x19a>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800058fc:	54 22       	ld.w %d2,[%a2]
800058fe:	b7 02 10 20 	insert %d2,%d2,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005902:	a6 42       	or %d2,%d4
80005904:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005908:	74 22       	st.w [%a2],%d2
                       (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
8000590a:	91 30 00 2f 	movh.a %a2,61443
8000590e:	19 22 18 46 	ld.w %d2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80005912:	d9 22 18 46 	lea %a2,[%a2]24856 <f0036118 <_SMALL_DATA4_+0x6002e118>>
80005916:	b7 02 10 20 	insert %d2,%d2,0,0,16
                       (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
8000591a:	a6 42       	or %d2,%d4
8000591c:	8f 32 40 21 	or %d2,%d2,3
    watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005920:	74 22       	st.w [%a2],%d2
    while (watchdog->CON0.B.ENDINIT == 0)
80005922:	54 22       	ld.w %d2,[%a2]
80005924:	6f 02 ff 7f 	jz.t %d2,0,80005922 <_Core2_start+0x1b2>

    IfxScuWdt_setCpuEndinitInline(&MODULE_SCU.WDTCPU[2], wdtPassword);

    /* initialize SDA base pointers */
    __setareg(a0, __SDATA1(2));
80005928:	91 10 00 26 	movh.a %a2,24577
8000592c:	80 22       	mov.d %d2,%a2
8000592e:	1b 02 00 28 	addi %d2,%d2,-32768
80005932:	60 20       	mov.a %a0,%d2
    __setareg(a1, __SDATA2(2));
80005934:	91 10 00 28 	movh.a %a2,32769
80005938:	80 22       	mov.d %d2,%a2
8000593a:	1b 02 00 28 	addi %d2,%d2,-32768
8000593e:	60 21       	mov.a %a1,%d2

    /* These to be un commented if A8 and A9 are required to be initialized */
    __setareg(a8, __SDATA3(2));
80005940:	91 10 00 28 	movh.a %a2,32769
80005944:	80 22       	mov.d %d2,%a2
80005946:	1b 02 00 28 	addi %d2,%d2,-32768
8000594a:	60 28       	mov.a %a8,%d2
    __setareg(a9, __SDATA4(2));
8000594c:	91 10 00 29 	movh.a %a2,36865
80005950:	80 22       	mov.d %d2,%a2
80005952:	1b 02 00 28 	addi %d2,%d2,-32768
80005956:	60 29       	mov.a %a9,%d2
    uint32  numOfCsa    = (((uint32)csaEnd - (uint32)csaBegin) / 64U);
80005958:	91 20 00 35 	movh.a %a3,20482
8000595c:	91 20 00 25 	movh.a %a2,20482
80005960:	d9 33 c0 0b 	lea %a3,[%a3]-17408 <5001bc00 <__CSA2>>
80005964:	d9 22 c0 0d 	lea %a2,[%a2]-9216 <5001dc00 <__CSA2_END>>
80005968:	01 32 20 20 	sub.a %a2,%a2,%a3
8000596c:	80 22       	mov.d %d2,%a2
8000596e:	8f a2 1f 60 	sh %d6,%d2,-6
    uint32 *prvCsa      = csaBegin;
80005972:	40 32       	mov.aa %a2,%a3
        if (k == (numOfCsa - 3U))
80005974:	1b d6 ff 0f 	addi %d0,%d6,-3
    for (k = 0U; k < numOfCsa; k++)
80005978:	82 03       	mov %d3,0
    uint32 *nxtCsa      = csaBegin;
8000597a:	80 32       	mov.d %d2,%a3
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
8000597c:	7b f0 00 70 	movh %d7,15
    for (k = 0U; k < numOfCsa; k++)
80005980:	df 06 27 00 	jeq %d6,0,800059ce <_Core2_start+0x25e>
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
80005984:	37 02 70 43 	extr.u %d4,%d2,6,16
80005988:	8f 42 1f 50 	sh %d5,%d2,-12
8000598c:	26 75       	and %d5,%d7
8000598e:	a6 54       	or %d4,%d5
        if (k == 0U)
80005990:	df 03 16 00 	jeq %d3,0,800059bc <_Core2_start+0x24c>
            *prvCsa = nxt_cxi_val;  /* Store null pointer in last CSA (= very first time!) */
80005994:	74 24       	st.w [%a2],%d4
        if (k == (numOfCsa - 3U))
80005996:	5f 03 04 80 	jne %d3,%d0,8000599e <_Core2_start+0x22e>
            __mtcr(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
8000599a:	cd c4 e3 0f 	mtcr $lcx,%d4
    for (k = 0U; k < numOfCsa; k++)
8000599e:	c2 13       	add %d3,1
800059a0:	60 22       	mov.a %a2,%d2
        nxtCsa += 16U;           /* next CSA */
800059a2:	1b 02 04 40 	addi %d4,%d2,64
    for (k = 0U; k < numOfCsa; k++)
800059a6:	5f 36 0f 00 	jeq %d6,%d3,800059c4 <_Core2_start+0x254>
        nxtCsa += 16U;           /* next CSA */
800059aa:	02 42       	mov %d2,%d4
        nxt_cxi_val = ((uint32)nxtCsa & (0XFU << 28U)) >> 12U | ((uint32)nxtCsa & (0XFFFFU << 6U)) >> 6U;
800059ac:	37 02 70 43 	extr.u %d4,%d2,6,16
800059b0:	8f 42 1f 50 	sh %d5,%d2,-12
800059b4:	26 75       	and %d5,%d7
800059b6:	a6 54       	or %d4,%d5
        if (k == 0U)
800059b8:	df 03 ee ff 	jne %d3,0,80005994 <_Core2_start+0x224>
            __mtcr(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
800059bc:	cd 84 e3 0f 	mtcr $fcx,%d4
800059c0:	1d ff eb ff 	j 80005996 <_Core2_start+0x226>
800059c4:	1b f6 ff 2f 	addi %d2,%d6,-1
800059c8:	06 62       	sh %d2,6
800059ca:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
    *prvCsa = 0U;
800059ce:	82 02       	mov %d2,0
800059d0:	74 22       	st.w [%a2],%d2
    /* Setup the context save area linked list. */

    IfxCpu_initCSA((uint32 *)__CSA(2), (uint32 *)__CSA_END(2));

    /*Call main function of Cpu0 */
    __non_return_call(core2_main);
800059d2:	91 00 00 28 	movh.a %a2,32768
800059d6:	d9 22 fe 66 	lea %a2,[%a2]28094 <80006dbe <core2_main>>
800059da:	dc 02       	ji %a2
}
800059dc:	00 90       	ret 
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800059de:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800059e0:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800059e4:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800059e8:	0f 35 a0 20 	or %d2,%d5,%d3
800059ec:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
800059f0:	74 22       	st.w [%a2],%d2
800059f2:	1d ff 2b ff 	j 80005848 <_Core2_start+0xd8>
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800059f6:	54 25       	ld.w %d5,[%a2]
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
800059f8:	8f 22 00 30 	sh %d3,%d2,2
                           (watchdog->CON0.B.REL << IFX_SCU_WDTCPU_CON0_REL_OFF);
800059fc:	b7 05 10 50 	insert %d5,%d5,0,0,16
                           (password << IFX_SCU_WDTCPU_CON0_PW_OFF) |
80005a00:	0f 35 a0 20 	or %d2,%d5,%d3
80005a04:	8f 12 40 21 	or %d2,%d2,1
        watchdog->CON0.U = (1 << IFX_SCU_WDTCPU_CON0_ENDINIT_OFF) |
80005a08:	74 22       	st.w [%a2],%d2
80005a0a:	1d ff e7 fe 	j 800057d8 <_Core2_start+0x68>

80005a0e <IfxAsclin_enableModule>:
    IfxAsclin_enableRxFifoOverflowFlag(asclin, rfoEnable);  /* enables Rx fifo Overflow error*/
}


void IfxAsclin_enableModule(Ifx_ASCLIN *asclin)
{
80005a0e:	40 ae       	mov.aa %a14,%sp
80005a10:	40 4c       	mov.aa %a12,%a4
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
80005a12:	6d ff 69 ed 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80005a16:	02 28       	mov %d8,%d2
    IfxScuWdt_clearCpuEndinit(psw);           /* clears the endinit protection*/
80005a18:	02 24       	mov %d4,%d2
80005a1a:	6d ff fc eb 	call 80003212 <IfxScuWdt_clearCpuEndinit>
}


IFX_INLINE void IfxAsclin_setEnableModuleRequest(Ifx_ASCLIN *asclin)
{
    asclin->CLC.B.DISR = 0;
80005a1e:	54 c3       	ld.w %d3,[%a12]
80005a20:	8f 13 c0 31 	andn %d3,%d3,1
80005a24:	74 c3       	st.w [%a12],%d3
    IfxAsclin_setEnableModuleRequest(asclin); /* enables the module*/
    IfxScuWdt_setCpuEndinit(psw);             /* sets the endinit protection back on*/
80005a26:	02 84       	mov %d4,%d8
80005a28:	6d ff 7b ed 	call 8000351e <IfxScuWdt_setCpuEndinit>
}
80005a2c:	00 90       	ret 

80005a2e <IfxAsclin_enableModule_end>:
	...

80005a30 <IfxAsclin_getFaFrequency>:
    return module;
}


float32 IfxAsclin_getFaFrequency(Ifx_ASCLIN *asclin)
{
80005a30:	40 ae       	mov.aa %a14,%sp
    return asclin->CSR.B.CLKSEL;
80005a32:	19 42 0c 10 	ld.w %d2,[%a4]76
80005a36:	8f f2 01 21 	and %d2,%d2,31
    float32               frequency;
    IfxAsclin_ClockSource clockSource = (IfxAsclin_ClockSource)IfxAsclin_getClockSource(asclin);    /* gets the current clock source*/

    switch (clockSource)
80005a3a:	1b f2 ff 3f 	addi %d3,%d2,-1
80005a3e:	8b 03 a1 22 	ge.u %d2,%d3,16
80005a42:	df 02 38 80 	jne %d2,0,80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a46:	91 00 00 28 	movh.a %a2,32768
80005a4a:	d9 22 94 95 	lea %a2,[%a2]23124 <80005a54 <IfxAsclin_getFaFrequency+0x24>>
80005a4e:	01 23 02 26 	addsc.a %a2,%a2,%d3,2
80005a52:	dc 02       	ji %a2
80005a54:	1d 00 20 00 	j 80005a94 <IfxAsclin_getFaFrequency+0x64>
80005a58:	1d 00 21 00 	j 80005a9a <IfxAsclin_getFaFrequency+0x6a>
80005a5c:	1d 00 2b 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a60:	1d 00 20 00 	j 80005aa0 <IfxAsclin_getFaFrequency+0x70>
80005a64:	1d 00 27 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a68:	1d 00 25 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a6c:	1d 00 23 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a70:	1d 00 1b 00 	j 80005aa6 <IfxAsclin_getFaFrequency+0x76>
80005a74:	1d 00 1f 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a78:	1d 00 1d 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a7c:	1d 00 1b 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a80:	1d 00 19 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a84:	1d 00 17 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a88:	1d 00 15 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a8c:	1d 00 13 00 	j 80005ab2 <IfxAsclin_getFaFrequency+0x82>
80005a90:	1d 00 0e 00 	j 80005aac <IfxAsclin_getFaFrequency+0x7c>
    {
    case IfxAsclin_ClockSource_noClock: /* gets the respective frequency*/
        frequency = 0.0f;
        break;
    case IfxAsclin_ClockSource_kernelClock:
        frequency = IfxScuCcu_getSpbFrequency();
80005a94:	6d ff d6 e9 	call 80002e40 <IfxScuCcu_getSpbFrequency>
        break;
80005a98:	00 90       	ret 
    case IfxAsclin_ClockSource_oscillatorClock:
        frequency = IfxScuCcu_getOsc0Frequency();
80005a9a:	6d ff 5c e8 	call 80002b52 <IfxScuCcu_getOsc0Frequency>
        break;
80005a9e:	00 90       	ret 
    case IfxAsclin_ClockSource_flexRayClock:
        frequency = IfxScuCcu_getPllErayFrequency();
80005aa0:	6d ff 7e e8 	call 80002b9c <IfxScuCcu_getPllErayFrequency>
        break;
80005aa4:	00 90       	ret 
    case IfxAsclin_ClockSource_ascFastClock:
        frequency = IfxScuCcu_getBaud2Frequency();
80005aa6:	6d ff b5 e9 	call 80002e10 <IfxScuCcu_getBaud2Frequency>
        break;
80005aaa:	00 90       	ret 
    case IfxAsclin_ClockSource_ascSlowClock:
        frequency = IfxScuCcu_getBaud1Frequency();
80005aac:	6d ff 9a e9 	call 80002de0 <IfxScuCcu_getBaud1Frequency>
        break;
80005ab0:	00 90       	ret 
    switch (clockSource)
80005ab2:	82 02       	mov %d2,0
        frequency = 0.0f;
        break;
    }

    return frequency;
}
80005ab4:	00 90       	ret 

80005ab6 <IfxAsclin_getFaFrequency_end>:
	...

80005ab8 <IfxAsclin_getIndex>:


IfxAsclin_Index IfxAsclin_getIndex(Ifx_ASCLIN *asclin)
{
80005ab8:	40 ae       	mov.aa %a14,%sp
    uint32          index;
    IfxAsclin_Index result;

    result = IfxAsclin_Index_none;

    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80005aba:	82 02       	mov %d2,0
80005abc:	ff 42 1b 80 	jge.u %d2,4,80005af2 <IfxAsclin_getIndex+0x3a>
    {
        if (IfxAsclin_cfg_indexMap[index].module == asclin)
80005ac0:	8f 32 00 30 	sh %d3,%d2,3
80005ac4:	91 00 00 28 	movh.a %a2,32768
80005ac8:	d9 22 20 b0 	lea %a2,[%a2]736 <800002e0 <IfxAsclin_cfg_indexMap>>
80005acc:	01 23 00 26 	addsc.a %a2,%a2,%d3,0
80005ad0:	54 23       	ld.w %d3,[%a2]
80005ad2:	80 44       	mov.d %d4,%a4
80005ad4:	5f 43 05 00 	jeq %d3,%d4,80005ade <IfxAsclin_getIndex+0x26>
    for (index = 0; index < IFXASCLIN_NUM_MODULES; index++)
80005ad8:	c2 12       	add %d2,1
80005ada:	1d ff f1 ff 	j 80005abc <IfxAsclin_getIndex+0x4>
        {
            result = (IfxAsclin_Index)IfxAsclin_cfg_indexMap[index].index;
80005ade:	06 32       	sh %d2,3
80005ae0:	91 00 00 28 	movh.a %a2,32768
80005ae4:	d9 22 20 b0 	lea %a2,[%a2]736 <800002e0 <IfxAsclin_cfg_indexMap>>
80005ae8:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80005aec:	19 22 04 00 	ld.w %d2,[%a2]4
            break;
80005af0:	00 90       	ret 
    result = IfxAsclin_Index_none;
80005af2:	82 f2       	mov %d2,-1
        }
    }

    return result;
}
80005af4:	00 90       	ret 

80005af6 <IfxAsclin_getPdFrequency>:
    return (IfxAsclin_getPdFrequency(asclin) * asclin->BRG.B.NUMERATOR) / asclin->BRG.B.DENOMINATOR;
}


float32 IfxAsclin_getPdFrequency(Ifx_ASCLIN *asclin)
{
80005af6:	40 ae       	mov.aa %a14,%sp
80005af8:	40 4c       	mov.aa %a12,%a4
    return IfxAsclin_getFaFrequency(asclin) / (asclin->BITCON.B.PRESCALER + 1);
80005afa:	6d ff 9b ff 	call 80005a30 <IfxAsclin_getFaFrequency>
80005afe:	19 c3 14 00 	ld.w %d3,[%a12]20
80005b02:	b7 03 14 36 	insert %d3,%d3,0,12,20
80005b06:	c2 13       	add %d3,1
80005b08:	4b 03 41 31 	itof %d3,%d3
}
80005b0c:	4b 32 51 20 	div.f %d2,%d2,%d3
80005b10:	00 90       	ret 

80005b12 <IfxAsclin_getSrcPointerEr>:
    return IfxAsclin_getOvsFrequency(asclin) / (asclin->BITCON.B.OVERSAMPLING + 1);
}


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerEr(Ifx_ASCLIN *asclin)
{
80005b12:	40 ae       	mov.aa %a14,%sp
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].ERR);
80005b14:	6d ff d2 ff 	call 80005ab8 <IfxAsclin_getIndex>
80005b18:	53 c2 20 20 	mul %d2,%d2,12
80005b1c:	1b 82 00 20 	addi %d2,%d2,8
}
80005b20:	91 40 00 2f 	movh.a %a2,61444
80005b24:	d9 22 00 28 	lea %a2,[%a2]-32640 <f0038080 <_SMALL_DATA4_+0x60030080>>
80005b28:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80005b2c:	00 90       	ret 

80005b2e <IfxAsclin_getSrcPointerRx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerRx(Ifx_ASCLIN *asclin)
{
80005b2e:	40 ae       	mov.aa %a14,%sp
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].RX);
80005b30:	6d ff c4 ff 	call 80005ab8 <IfxAsclin_getIndex>
80005b34:	53 c2 20 20 	mul %d2,%d2,12
80005b38:	c2 42       	add %d2,4
}
80005b3a:	91 40 00 2f 	movh.a %a2,61444
80005b3e:	d9 22 00 28 	lea %a2,[%a2]-32640 <f0038080 <_SMALL_DATA4_+0x60030080>>
80005b42:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80005b46:	00 90       	ret 

80005b48 <IfxAsclin_getSrcPointerTx>:


volatile Ifx_SRC_SRCR *IfxAsclin_getSrcPointerTx(Ifx_ASCLIN *asclin)
{
80005b48:	40 ae       	mov.aa %a14,%sp
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.ASCLIN.ASCLIN[IfxAsclin_getIndex(asclin)].TX);
80005b4a:	6d ff b7 ff 	call 80005ab8 <IfxAsclin_getIndex>
}
80005b4e:	91 40 00 2f 	movh.a %a2,61444
80005b52:	d9 22 00 28 	lea %a2,[%a2]-32640 <f0038080 <_SMALL_DATA4_+0x60030080>>
80005b56:	01 22 03 26 	addsc.a %a2,%a2,%d2,3
80005b5a:	01 22 02 26 	addsc.a %a2,%a2,%d2,2
80005b5e:	00 90       	ret 

80005b60 <IfxAsclin_read8>:
    return count;
}


uint32 IfxAsclin_read8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80005b60:	40 ae       	mov.aa %a14,%sp
80005b62:	80 55       	mov.d %d5,%a5
80005b64:	02 42       	mov %d2,%d4
    volatile Ifx_ASCLIN_RXDATA *rxData = (volatile Ifx_ASCLIN_RXDATA *)&asclin->RXDATA.U;

    while (count > 0)
80005b66:	1d 00 08 00 	j 80005b76 <IfxAsclin_read8+0x16>
    {
        *data++ = (uint8)rxData->U;
80005b6a:	19 43 08 10 	ld.w %d3,[%a4]72
80005b6e:	60 55       	mov.a %a5,%d5
80005b70:	24 53       	st.b [%a5+],%d3
        count--;
80005b72:	c2 f2       	add %d2,-1
        *data++ = (uint8)rxData->U;
80005b74:	80 55       	mov.d %d5,%a5
    while (count > 0)
80005b76:	df 02 fa ff 	jne %d2,0,80005b6a <IfxAsclin_read8+0xa>
    }

    return count;
}
80005b7a:	00 90       	ret 

80005b7c <IfxAsclin_setClockSource>:
    return TRUE;
}


void IfxAsclin_setClockSource(Ifx_ASCLIN *asclin, IfxAsclin_ClockSource clockSource)
{
80005b7c:	40 ae       	mov.aa %a14,%sp
    asclin->CSR.B.CLKSEL = clockSource; /* selects the given clock source*/
80005b7e:	d9 42 0c 10 	lea %a2,[%a4]76
80005b82:	19 42 0c 10 	ld.w %d2,[%a4]76
80005b86:	37 42 05 20 	insert %d2,%d2,%d4,0,5
80005b8a:	74 22       	st.w [%a2],%d2

    /* Waits TW or polls for CSR.CON to change */
    if (clockSource == IfxAsclin_ClockSource_noClock)
80005b8c:	df 04 07 80 	jne %d4,0,80005b9a <IfxAsclin_setClockSource+0x1e>
    return asclin->CSR.B.CON;
80005b90:	19 42 0c 10 	ld.w %d2,[%a4]76
    {
        while (IfxAsclin_getClockStatus(asclin) != 0U)
80005b94:	bf 02 fe 7f 	jlt %d2,0,80005b90 <IfxAsclin_setClockSource+0x14>
80005b98:	00 90       	ret 
80005b9a:	19 42 0c 10 	ld.w %d2,[%a4]76
        {}
    }
    else
    {
        while (IfxAsclin_getClockStatus(asclin) != 1U)
80005b9e:	ff 02 fe 7f 	jge %d2,0,80005b9a <IfxAsclin_setClockSource+0x1e>
        {}
    }
}
80005ba2:	00 90       	ret 

80005ba4 <IfxAsclin_setBitTiming>:
{
80005ba4:	40 ae       	mov.aa %a14,%sp
80005ba6:	20 10       	sub.a %sp,16
80005ba8:	40 4c       	mov.aa %a12,%a4
80005baa:	02 48       	mov %d8,%d4
80005bac:	02 5a       	mov %d10,%d5
80005bae:	02 69       	mov %d9,%d6
80005bb0:	59 e7 f4 ff 	st.w [%a14]-12,%d7
    return asclin->CSR.B.CLKSEL;
80005bb4:	19 42 0c 10 	ld.w %d2,[%a4]76
80005bb8:	8f f2 01 21 	and %d2,%d2,31
80005bbc:	60 2f       	mov.a %a15,%d2
    float32               fpd = IfxAsclin_getPdFrequency(asclin);
80005bbe:	6d ff 9c ff 	call 80005af6 <IfxAsclin_getPdFrequency>
    oversampling = (IfxAsclin_OversamplingFactor)__maxu((oversampling + 1), 4);
80005bc2:	c2 1a       	add %d10,1
    __asm__ volatile ("max.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80005bc4:	82 43       	mov %d3,4
80005bc6:	0b 3a b0 31 	max.u %d3,%d10,%d3
80005bca:	60 3d       	mov.a %a13,%d3
80005bcc:	82 13       	mov %d3,1
80005bce:	0b 39 b0 31 	max.u %d3,%d9,%d3
80005bd2:	59 e3 f8 ff 	st.w [%a14]-8,%d3
    fOvs         = baudrate * oversampling;
80005bd6:	80 d3       	mov.d %d3,%a13
80005bd8:	4b 03 61 41 	utof %d4,%d3
80005bdc:	4b 84 41 40 	mul.f %d4,%d4,%d8
    float32               limit      = 0.001f * fOvs;                    // save the error limit
80005be0:	7b 30 a8 e3 	movh %d14,14979
80005be4:	1b fe 26 e1 	addi %d14,%d14,4719
80005be8:	4b e4 41 e0 	mul.f %d14,%d4,%d14
    d = (uint32)(fpd / fOvs);
80005bec:	4b 42 51 c0 	div.f %d12,%d2,%d4
80005bf0:	4b 0c 71 c1 	ftouz %d12,%d12
    f              = (fpd * n) / d;
80005bf4:	4b 0c 61 31 	utof %d3,%d12
80005bf8:	4b 32 51 30 	div.f %d3,%d2,%d3
    relError       = __absf(fOvs - f);
80005bfc:	6b 03 31 14 	sub.f %d1,%d4,%d3
80005c00:	82 03       	mov %d3,0
80005c02:	4b 31 01 30 	cmp.f %d3,%d1,%d3
80005c06:	6f 03 10 80 	jnz.t %d3,0,80005c26 <IfxAsclin_setBitTiming+0x82>
    if (relError <= limit)
80005c0a:	4b e1 01 30 	cmp.f %d3,%d1,%d14
80005c0e:	87 33 a0 30 	or.t %d3,%d3,0,%d3,1
80005c12:	df 03 0e 80 	jne %d3,0,80005c2e <IfxAsclin_setBitTiming+0x8a>
    boolean               terminated = FALSE;
80005c16:	82 0f       	mov %d15,0
    dBest          = d;
80005c18:	59 ec fc ff 	st.w [%a14]-4,%d12
    adder_facL_min = 0;
80005c1c:	82 06       	mov %d6,0
    nBest          = n;
80005c1e:	82 1d       	mov %d13,1
    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80005c20:	82 20       	mov %d0,2
80005c22:	1d 00 37 00 	j 80005c90 <IfxAsclin_setBitTiming+0xec>
    relError       = __absf(fOvs - f);
80005c26:	9b 01 00 18 	addih %d1,%d1,32768
80005c2a:	1d ff f0 ff 	j 80005c0a <IfxAsclin_setBitTiming+0x66>
        terminated = TRUE;
80005c2e:	82 1f       	mov %d15,1
80005c30:	1d ff f4 ff 	j 80005c18 <IfxAsclin_setBitTiming+0x74>
            adder_facH = 1;
80005c34:	82 19       	mov %d9,1
            adder_facL = 1;
80005c36:	02 95       	mov %d5,%d9
        for (count = adder_facL; count <= adder_facH; count++)
80005c38:	1d 00 07 00 	j 80005c46 <IfxAsclin_setBitTiming+0xa2>
            newRelError = __absf(fOvs - f);
80005c3c:	9b 03 00 38 	addih %d3,%d3,32768
80005c40:	1d 00 16 00 	j 80005c6c <IfxAsclin_setBitTiming+0xc8>
        for (count = adder_facL; count <= adder_facH; count++)
80005c44:	c2 15       	add %d5,1
80005c46:	3f 59 1e 80 	jlt.u %d9,%d5,80005c82 <IfxAsclin_setBitTiming+0xde>
            f           = (fpd * n) / (n * d + count);
80005c4a:	4b 00 61 81 	utof %d8,%d0
80005c4e:	4b 28 41 80 	mul.f %d8,%d8,%d2
80005c52:	0b 5b 00 a0 	add %d10,%d11,%d5
80005c56:	4b 0a 61 31 	utof %d3,%d10
80005c5a:	4b 38 51 30 	div.f %d3,%d8,%d3
            newRelError = __absf(fOvs - f);
80005c5e:	6b 03 31 34 	sub.f %d3,%d4,%d3
80005c62:	82 08       	mov %d8,0
80005c64:	4b 83 01 80 	cmp.f %d8,%d3,%d8
80005c68:	6f 08 ea ff 	jnz.t %d8,0,80005c3c <IfxAsclin_setBitTiming+0x98>
            if (relError > (newRelError))
80005c6c:	4b 31 01 80 	cmp.f %d8,%d1,%d3
80005c70:	6f 28 ea 7f 	jz.t %d8,2,80005c44 <IfxAsclin_setBitTiming+0xa0>
                adder_facL_min = count;
80005c74:	02 56       	mov %d6,%d5
                relError       = newRelError;
80005c76:	02 31       	mov %d1,%d3
                nBest          = n;
80005c78:	02 0d       	mov %d13,%d0
                dBest          = (n * d + count);
80005c7a:	59 ea fc ff 	st.w [%a14]-4,%d10
80005c7e:	1d ff e3 ff 	j 80005c44 <IfxAsclin_setBitTiming+0xa0>
        if (relError <= limit)
80005c82:	4b e1 01 30 	cmp.f %d3,%d1,%d14
80005c86:	87 33 a0 30 	or.t %d3,%d3,0,%d3,1
80005c8a:	df 03 16 80 	jne %d3,0,80005cb6 <IfxAsclin_setBitTiming+0x112>
    for (n = 2; ((!terminated) && ((n * d) <= 0xFFF)); n++)
80005c8e:	c2 10       	add %d0,1
80005c90:	df 0f 13 80 	jne %d15,0,80005cb6 <IfxAsclin_setBitTiming+0x112>
80005c94:	73 c0 0a b0 	mul %d11,%d0,%d12
80005c98:	3b 00 00 31 	mov %d3,4096
80005c9c:	7f 3b 0d 80 	jge.u %d11,%d3,80005cb6 <IfxAsclin_setBitTiming+0x112>
        if (n == 2)
80005ca0:	df 20 ca 7f 	jeq %d0,2,80005c34 <IfxAsclin_setBitTiming+0x90>
            adder_facL = (adder_facL_min * n) / nBest;
80005ca4:	73 60 0a 80 	mul %d8,%d0,%d6
80005ca8:	4b d8 11 82 	div.u %e8,%d8,%d13
80005cac:	02 85       	mov %d5,%d8
            adder_facH = adder_facL + 1;
80005cae:	1b 18 00 90 	addi %d9,%d8,1
80005cb2:	1d ff ca ff 	j 80005c46 <IfxAsclin_setBitTiming+0xa2>
    IfxAsclin_setClockSource(asclin, IfxAsclin_ClockSource_noClock);
80005cb6:	82 04       	mov %d4,0
80005cb8:	40 c4       	mov.aa %a4,%a12
80005cba:	6d ff 61 ff 	call 80005b7c <IfxAsclin_setClockSource>
    asclin->BRG.B.DENOMINATOR = dBest;
80005cbe:	d9 c2 20 00 	lea %a2,[%a12]32
80005cc2:	19 c2 20 00 	ld.w %d2,[%a12]32
80005cc6:	19 e3 fc ff 	ld.w %d3,[%a14]-4
80005cca:	37 32 0c 20 	insert %d2,%d2,%d3,0,12
80005cce:	74 22       	st.w [%a2],%d2
    asclin->BRG.B.NUMERATOR   = nBest;
80005cd0:	54 22       	ld.w %d2,[%a2]
80005cd2:	37 d2 0c 28 	insert %d2,%d2,%d13,16,12
80005cd6:	74 22       	st.w [%a2],%d2
    asclin->BITCON.B.OVERSAMPLING = oversampling - 1;
80005cd8:	80 d3       	mov.d %d3,%a13
80005cda:	c2 f3       	add %d3,-1
80005cdc:	d9 c2 14 00 	lea %a2,[%a12]20
80005ce0:	19 c2 14 00 	ld.w %d2,[%a12]20
80005ce4:	37 32 04 28 	insert %d2,%d2,%d3,16,4
80005ce8:	74 22       	st.w [%a2],%d2
    asclin->BITCON.B.SAMPLEPOINT = samplepoint;
80005cea:	54 22       	ld.w %d2,[%a2]
80005cec:	19 e3 f8 ff 	ld.w %d3,[%a14]-8
80005cf0:	37 32 04 2c 	insert %d2,%d2,%d3,24,4
80005cf4:	74 22       	st.w [%a2],%d2
    asclin->BITCON.B.SM = medianFilter ? 1 : 0;
80005cf6:	19 e2 f4 ff 	ld.w %d2,[%a14]-12
80005cfa:	8b 02 20 72 	ne %d7,%d2,0
80005cfe:	54 22       	ld.w %d2,[%a2]
80005d00:	67 72 1f 20 	ins.t %d2,%d2,31,%d7,0
80005d04:	74 22       	st.w [%a2],%d2
    IfxAsclin_setClockSource(asclin, source);
80005d06:	80 f4       	mov.d %d4,%a15
80005d08:	40 c4       	mov.aa %a4,%a12
80005d0a:	6d ff 39 ff 	call 80005b7c <IfxAsclin_setClockSource>
}
80005d0e:	82 12       	mov %d2,1
80005d10:	00 90       	ret 

80005d12 <IfxAsclin_write8>:
    return count;
}


uint32 IfxAsclin_write8(Ifx_ASCLIN *asclin, uint8 *data, uint32 count)
{
80005d12:	40 ae       	mov.aa %a14,%sp
80005d14:	80 53       	mov.d %d3,%a5
80005d16:	02 42       	mov %d2,%d4
    volatile Ifx_ASCLIN_TXDATA *txData = (volatile Ifx_ASCLIN_TXDATA *)&asclin->TXDATA.U;

    while ((count > 0))
80005d18:	1d 00 08 00 	j 80005d28 <IfxAsclin_write8+0x16>
    {
        txData->U = *data++;
80005d1c:	60 35       	mov.a %a5,%d3
80005d1e:	04 53       	ld.bu %d3,[%a5+]
80005d20:	59 43 04 10 	st.w [%a4]68,%d3
        count--;
80005d24:	c2 f2       	add %d2,-1
        txData->U = *data++;
80005d26:	80 53       	mov.d %d3,%a5
    while ((count > 0))
80005d28:	df 02 fa ff 	jne %d2,0,80005d1c <IfxAsclin_write8+0xa>
    }

    return count;
}
80005d2c:	00 90       	ret 

80005d2e <IfxAsclin_Asc_read>:
    }
}


boolean IfxAsclin_Asc_read(IfxAsclin_Asc *asclin, void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80005d2e:	40 ae       	mov.aa %a14,%sp
80005d30:	40 6c       	mov.aa %a12,%a6
    Ifx_SizeT left = Ifx_Fifo_read(asclin->rx, data, *count, timeout);
80005d32:	0b 45 10 68 	mov %e6,%d5,%d4
80005d36:	94 64       	ld.h %d4,[%a6]
80005d38:	99 44 08 00 	ld.a %a4,[%a4]8
80005d3c:	6d ff 68 de 	call 80001a0c <Ifx_Fifo_read>

    *count -= left;
80005d40:	94 c3       	ld.h %d3,[%a12]
80005d42:	a2 23       	sub %d3,%d2
80005d44:	b4 c3       	st.h [%a12],%d3

    return left == 0;
}
80005d46:	8b 02 00 22 	eq %d2,%d2,0
80005d4a:	00 90       	ret 

80005d4c <IfxAsclin_Asc_isrTransmit>:
{
80005d4c:	40 ae       	mov.aa %a14,%sp
80005d4e:	20 18       	sub.a %sp,24
80005d50:	40 4c       	mov.aa %a12,%a4
    reg.U = __mfcr(CPU_ICR);
80005d52:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80005d56:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80005d5a:	0d 00 40 03 	disable 
    __asm__ volatile ("nop" : : : "memory");
80005d5e:	00 00       	nop 
    result  = stm->TIM0.U;
80005d60:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80005d64:	19 26 10 00 	ld.w %d6,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80005d68:	19 22 2c 00 	ld.w %d2,[%a2]44
80005d6c:	02 25       	mov %d5,%d2
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005d6e:	02 62       	mov %d2,%d6
80005d70:	b7 05 81 3f 	insert %d3,%d5,0,31,1
    if (enabled != FALSE)
80005d74:	df 04 04 00 	jeq %d4,0,80005d7c <IfxAsclin_Asc_isrTransmit+0x30>
        __enable();
80005d78:	0d 00 00 03 	enable 
    asclin->txTimestamp = IfxStm_now();
80005d7c:	89 c2 58 09 	st.d [%a12]24,%e2
    asclin->sendCount++;
80005d80:	d9 c2 14 00 	lea %a2,[%a12]20
80005d84:	19 c2 14 00 	ld.w %d2,[%a12]20
80005d88:	c2 12       	add %d2,1
80005d8a:	74 22       	st.w [%a2],%d2
    if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
80005d8c:	99 c4 04 00 	ld.a %a4,[%a12]4
 *
 * \return Returns the size of the data in the buffer in bytes
 */
IFX_INLINE Ifx_SizeT Ifx_Fifo_readCount(Ifx_Fifo *fifo)
{
    return fifo->shared.count;
80005d90:	c9 48 04 00 	ld.h %d8,[%a4]4
80005d94:	df 08 3e 00 	jeq %d8,0,80005e10 <IfxAsclin_Asc_isrTransmit+0xc4>
        switch (asclin->dataBufferMode)
80005d98:	19 c2 10 00 	ld.w %d2,[%a12]16
80005d9c:	df 02 05 00 	jeq %d2,0,80005da6 <IfxAsclin_Asc_isrTransmit+0x5a>
80005da0:	df 12 26 00 	jeq %d2,1,80005dec <IfxAsclin_Asc_isrTransmit+0xa0>
80005da4:	00 90       	ret 
            volatile uint8 hw_tx_fill_level = 0;
80005da6:	82 02       	mov %d2,0
80005da8:	e9 e2 ef ff 	st.b [%a14]-17,%d2
            count            = Ifx_Fifo_readCount(asclin->tx); /*SW FIFO fill level*/
80005dac:	37 08 70 80 	extr.u %d8,%d8,0,16
            hw_tx_fill_level = IfxAsclin_getTxFifoFillLevel(asclin->asclin);
80005db0:	d4 c2       	ld.a %a2,[%a12]
}


IFX_INLINE uint8 IfxAsclin_getTxFifoFillLevel(Ifx_ASCLIN *asclin)
{
    return asclin->TXFIFOCON.B.FILL;
80005db2:	19 22 0c 00 	ld.w %d2,[%a2]12
80005db6:	37 02 65 28 	extr.u %d2,%d2,16,5
80005dba:	e9 e2 ef ff 	st.b [%a14]-17,%d2
            i_count          = (16 - hw_tx_fill_level);
80005dbe:	39 e2 ef ff 	ld.bu %d2,[%a14]-17
80005dc2:	8b 02 01 21 	rsub %d2,%d2,16
80005dc6:	37 02 70 20 	extr.u %d2,%d2,0,16
            if (i_count > count)
80005dca:	3f 28 03 80 	jlt.u %d8,%d2,80005dd0 <IfxAsclin_Asc_isrTransmit+0x84>
            i_count          = (16 - hw_tx_fill_level);
80005dce:	02 28       	mov %d8,%d2
            Ifx_Fifo_read(asclin->tx, &ascData[0], i_count, TIME_NULL);
80005dd0:	d2 06       	mov %e6,0
80005dd2:	37 08 50 40 	extr %d4,%d8,0,16
80005dd6:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80005dda:	6d ff 19 de 	call 80001a0c <Ifx_Fifo_read>
            IfxAsclin_write8(asclin->asclin, &ascData[0], i_count);
80005dde:	02 84       	mov %d4,%d8
80005de0:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80005de4:	d4 c4       	ld.a %a4,[%a12]
80005de6:	6d ff 96 ff 	call 80005d12 <IfxAsclin_write8>
        break;
80005dea:	00 90       	ret 
            Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
80005dec:	d2 06       	mov %e6,0
80005dee:	3b c0 00 40 	mov %d4,12
80005df2:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80005df6:	6d ff 0b de 	call 80001a0c <Ifx_Fifo_read>
            ascData = packedData.data;
80005dfa:	39 e2 f8 ff 	ld.bu %d2,[%a14]-8
80005dfe:	e9 e2 ef ff 	st.b [%a14]-17,%d2
            IfxAsclin_write8(asclin->asclin, &ascData, 1);
80005e02:	82 14       	mov %d4,1
80005e04:	d9 e5 ef ff 	lea %a5,[%a14]-17
80005e08:	d4 c4       	ld.a %a4,[%a12]
80005e0a:	6d ff 84 ff 	call 80005d12 <IfxAsclin_write8>
        break;
80005e0e:	00 90       	ret 
        asclin->txInProgress = FALSE;
80005e10:	82 02       	mov %d2,0
80005e12:	e9 c2 0c 00 	st.b [%a12]12,%d2
}
80005e16:	00 90       	ret 

80005e18 <IfxAsclin_Asc_isrReceive>:
{
80005e18:	40 ae       	mov.aa %a14,%sp
80005e1a:	20 20       	sub.a %sp,32
80005e1c:	40 4c       	mov.aa %a12,%a4
    switch (asclin->dataBufferMode)
80005e1e:	19 42 10 00 	ld.w %d2,[%a4]16
80005e22:	df 02 05 00 	jeq %d2,0,80005e2c <IfxAsclin_Asc_isrReceive+0x14>
80005e26:	df 12 34 00 	jeq %d2,1,80005e8e <IfxAsclin_Asc_isrReceive+0x76>
80005e2a:	00 90       	ret 
        count = IfxAsclin_getRxFifoFillLevel(asclin->asclin);
80005e2c:	d4 44       	ld.a %a4,[%a4]
    return asclin->RXFIFOCON.B.FILL;
80005e2e:	19 48 10 00 	ld.w %d8,[%a4]16
80005e32:	37 08 65 88 	extr.u %d8,%d8,16,5
        IfxAsclin_read8(asclin->asclin, &ascData[0], count);
80005e36:	02 84       	mov %d4,%d8
80005e38:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80005e3c:	6d ff 92 fe 	call 80005b60 <IfxAsclin_read8>
        if (Ifx_Fifo_write(asclin->rx, &ascData[0], count, TIME_NULL) != 0)
80005e40:	d2 06       	mov %e6,0
80005e42:	02 84       	mov %d4,%d8
80005e44:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80005e48:	99 c4 08 00 	ld.a %a4,[%a12]8
80005e4c:	6d ff 99 de 	call 80001b7e <Ifx_Fifo_write>
80005e50:	df 02 42 00 	jeq %d2,0,80005ed4 <IfxAsclin_Asc_isrReceive+0xbc>
            asclin->rxSwFifoOverflow = TRUE;
80005e54:	82 12       	mov %d2,1
80005e56:	e9 c2 0d 00 	st.b [%a12]13,%d2
80005e5a:	00 90       	ret 
            packedData.timestamp = IfxStm_now();
80005e5c:	59 e5 e4 ff 	st.w [%a14]-28,%d5
80005e60:	59 e2 e8 ff 	st.w [%a14]-24,%d2
            IfxAsclin_read8(asclin->asclin, &ascData[0], 1);
80005e64:	82 14       	mov %d4,1
80005e66:	d9 e5 f0 ff 	lea %a5,[%a14]-16
80005e6a:	d4 c4       	ld.a %a4,[%a12]
80005e6c:	6d ff 7a fe 	call 80005b60 <IfxAsclin_read8>
            packedData.data      = ascData[0];
80005e70:	39 e2 f0 ff 	ld.bu %d2,[%a14]-16
80005e74:	e9 e2 ec ff 	st.b [%a14]-20,%d2
            if (Ifx_Fifo_write(asclin->rx, &packedData, sizeof(packedData), TIME_NULL) != 0)
80005e78:	d2 06       	mov %e6,0
80005e7a:	3b c0 00 40 	mov %d4,12
80005e7e:	d9 e5 e4 ff 	lea %a5,[%a14]-28
80005e82:	99 c4 08 00 	ld.a %a4,[%a12]8
80005e86:	6d ff 7c de 	call 80001b7e <Ifx_Fifo_write>
80005e8a:	df 02 20 80 	jne %d2,0,80005eca <IfxAsclin_Asc_isrReceive+0xb2>
        while (IfxAsclin_getRxFifoFillLevel(asclin->asclin) > 0)
80005e8e:	d4 c2       	ld.a %a2,[%a12]
80005e90:	19 22 10 00 	ld.w %d2,[%a2]16
80005e94:	37 02 65 28 	extr.u %d2,%d2,16,5
80005e98:	df 02 1e 00 	jeq %d2,0,80005ed4 <IfxAsclin_Asc_isrReceive+0xbc>
    reg.U = __mfcr(CPU_ICR);
80005e9c:	4d c0 e2 4f 	mfcr %d4,$icr
    return reg.B.IE != 0;
80005ea0:	37 04 e1 47 	extr.u %d4,%d4,15,1
    __disable();
80005ea4:	0d 00 40 03 	disable 
80005ea8:	00 00       	nop 
    result  = stm->TIM0.U;
80005eaa:	c5 f2 00 00 	lea %a2,f0000000 <_SMALL_DATA4_+0x5fff8000>
80005eae:	19 25 10 00 	ld.w %d5,[%a2]16
    result |= ((uint64)stm->CAP.U) << 32;
80005eb2:	19 22 2c 00 	ld.w %d2,[%a2]44
80005eb6:	8f 05 40 51 	or %d5,%d5,0
    stmNow         = (Ifx_TickTime)IfxStm_get(IFXSTM_DEFAULT_TIMER) & TIME_INFINITE;
80005eba:	b7 02 81 2f 	insert %d2,%d2,0,31,1
    if (enabled != FALSE)
80005ebe:	df 04 cf 7f 	jeq %d4,0,80005e5c <IfxAsclin_Asc_isrReceive+0x44>
        __enable();
80005ec2:	0d 00 00 03 	enable 
80005ec6:	1d ff cb ff 	j 80005e5c <IfxAsclin_Asc_isrReceive+0x44>
                asclin->rxSwFifoOverflow = TRUE;
80005eca:	82 12       	mov %d2,1
80005ecc:	e9 c2 0d 00 	st.b [%a12]13,%d2
80005ed0:	1d ff df ff 	j 80005e8e <IfxAsclin_Asc_isrReceive+0x76>
}
80005ed4:	00 90       	ret 

80005ed6 <IfxAsclin_Asc_blockingRead>:
{
80005ed6:	40 ae       	mov.aa %a14,%sp
80005ed8:	20 08       	sub.a %sp,8
80005eda:	80 48       	mov.d %d8,%a4
    Ifx_SizeT count = 1;
80005edc:	82 12       	mov %d2,1
80005ede:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    while (IfxAsclin_Asc_read(asclin, &data, &count, TIME_INFINITE) != TRUE)
80005ee2:	82 f4       	mov %d4,-1
80005ee4:	82 f5       	mov %d5,-1
80005ee6:	06 f5       	sh %d5,-1
80005ee8:	d9 e6 fe ff 	lea %a6,[%a14]-2
80005eec:	d9 e5 fd ff 	lea %a5,[%a14]-3
80005ef0:	60 84       	mov.a %a4,%d8
80005ef2:	6d ff 1e ff 	call 80005d2e <IfxAsclin_Asc_read>
80005ef6:	df 12 f6 ff 	jne %d2,1,80005ee2 <IfxAsclin_Asc_blockingRead+0xc>
}
80005efa:	39 e2 fd ff 	ld.bu %d2,[%a14]-3
80005efe:	00 90       	ret 

80005f00 <IfxAsclin_Asc_initModule>:
{
80005f00:	40 ae       	mov.aa %a14,%sp
80005f02:	40 4f       	mov.aa %a15,%a4
80005f04:	40 5d       	mov.aa %a13,%a5
    Ifx_ASCLIN      *asclinSFR = config->asclin;                        /* pointer to ASCLIN registers*/
80005f06:	d4 5c       	ld.a %a12,[%a5]
    asclin->asclin = asclinSFR;                                         /* adding register pointer to module handler*/
80005f08:	f4 4c       	st.a [%a4],%a12
    IfxAsclin_enableModule(asclinSFR);                                  /* enabling the module*/
80005f0a:	40 c4       	mov.aa %a4,%a12
80005f0c:	6d ff 81 fd 	call 80005a0e <IfxAsclin_enableModule>
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock); /* disabling the clock*/
80005f10:	82 04       	mov %d4,0
80005f12:	40 c4       	mov.aa %a4,%a12
80005f14:	6d ff 34 fe 	call 80005b7c <IfxAsclin_setClockSource>
}


IFX_INLINE void IfxAsclin_setFrameMode(Ifx_ASCLIN *asclin, IfxAsclin_FrameMode mode)
{
    asclin->FRAMECON.B.MODE = mode;
80005f18:	d9 c2 18 00 	lea %a2,[%a12]24
80005f1c:	19 c2 18 00 	ld.w %d2,[%a12]24
80005f20:	b7 02 02 28 	insert %d2,%d2,0,16,2
80005f24:	74 22       	st.w [%a2],%d2
    IfxAsclin_setPrescaler(asclinSFR, config->baudrate.prescaler);      /* sets the prescaler */
80005f26:	b9 d3 08 00 	ld.hu %d3,[%a13]8
}


IFX_INLINE void IfxAsclin_setPrescaler(Ifx_ASCLIN *asclin, uint16 prescaler)
{
    asclin->BITCON.B.PRESCALER = prescaler - 1;
80005f2a:	c2 f3       	add %d3,-1
80005f2c:	d9 c2 14 00 	lea %a2,[%a12]20
80005f30:	19 c2 14 00 	ld.w %d2,[%a12]20
80005f34:	37 32 0c 20 	insert %d2,%d2,%d3,0,12
80005f38:	74 22       	st.w [%a2],%d2
    IfxAsclin_setClockSource(asclinSFR, config->clockSource);           /* temporary set the clock source for baudrate configuration*/
80005f3a:	19 d4 18 10 	ld.w %d4,[%a13]88
80005f3e:	40 c4       	mov.aa %a4,%a12
80005f40:	6d ff 1e fe 	call 80005b7c <IfxAsclin_setClockSource>
    status = (IfxAsclin_Status)IfxAsclin_setBitTiming(asclinSFR,        /* setting the baudrate bit fields to generate the required baudrate*/
80005f44:	19 d7 10 00 	ld.w %d7,[%a13]16
80005f48:	19 d6 14 00 	ld.w %d6,[%a13]20
80005f4c:	19 d5 0c 00 	ld.w %d5,[%a13]12
80005f50:	19 d4 04 00 	ld.w %d4,[%a13]4
80005f54:	40 c4       	mov.aa %a4,%a12
80005f56:	6d ff 27 fe 	call 80005ba4 <IfxAsclin_setBitTiming>
80005f5a:	02 2a       	mov %d10,%d2
    IfxAsclin_setClockSource(asclinSFR, IfxAsclin_ClockSource_noClock);              /* disabling the clock again*/
80005f5c:	82 04       	mov %d4,0
80005f5e:	40 c4       	mov.aa %a4,%a12
80005f60:	6d ff 0e fe 	call 80005b7c <IfxAsclin_setClockSource>
    IfxAsclin_enableLoopBackMode(asclinSFR, config->loopBack);                       /* selecting the loopback mode */
80005f64:	39 d4 2c 10 	ld.bu %d4,[%a13]108
    asclin->IOCR.B.LB = enable ? 1 : 0;
80005f68:	8b 04 20 42 	ne %d4,%d4,0
80005f6c:	d9 c2 04 00 	lea %a2,[%a12]4
80005f70:	19 c3 04 00 	ld.w %d3,[%a12]4
80005f74:	67 43 1c 30 	ins.t %d3,%d3,28,%d4,0
80005f78:	74 23       	st.w [%a2],%d3
    IfxAsclin_enableParity(asclinSFR, config->frame.parityBit);                      /* setting parity enable */
80005f7a:	39 d4 30 00 	ld.bu %d4,[%a13]48
    asclin->FRAMECON.B.PEN = enable ? 1 : 0;
80005f7e:	8b 04 20 42 	ne %d4,%d4,0
80005f82:	d9 c2 18 00 	lea %a2,[%a12]24
80005f86:	19 c3 18 00 	ld.w %d3,[%a12]24
80005f8a:	67 43 1e 30 	ins.t %d3,%d3,30,%d4,0
80005f8e:	74 23       	st.w [%a2],%d3
    IfxAsclin_setParityType(asclinSFR, config->frame.parityType);                    /* setting parity type (odd/even)*/
80005f90:	19 d2 28 00 	ld.w %d2,[%a13]40
    asclin->FRAMECON.B.ODD = type;
80005f94:	d9 c2 18 00 	lea %a2,[%a12]24
80005f98:	19 c3 18 00 	ld.w %d3,[%a12]24
80005f9c:	67 23 1f 30 	ins.t %d3,%d3,31,%d2,0
80005fa0:	74 23       	st.w [%a2],%d3
    IfxAsclin_setStopBit(asclinSFR, config->frame.stopBit);                          /* setting the stop bit */
80005fa2:	19 d2 1c 00 	ld.w %d2,[%a13]28
}


IFX_INLINE void IfxAsclin_setStopBit(Ifx_ASCLIN *asclin, IfxAsclin_StopBit stopBit)
{
    asclin->FRAMECON.B.STOP = stopBit;
80005fa6:	d9 c2 18 00 	lea %a2,[%a12]24
80005faa:	19 c3 18 00 	ld.w %d3,[%a12]24
80005fae:	37 23 83 34 	insert %d3,%d3,%d2,9,3
80005fb2:	74 23       	st.w [%a2],%d3
    IfxAsclin_setShiftDirection(asclinSFR, config->frame.shiftDir);                  /* setting the shift direction */
80005fb4:	19 d2 24 00 	ld.w %d2,[%a13]36
    asclin->FRAMECON.B.MSB = dir;
80005fb8:	d9 c2 18 00 	lea %a2,[%a12]24
80005fbc:	19 c3 18 00 	ld.w %d3,[%a12]24
80005fc0:	67 23 1c 30 	ins.t %d3,%d3,28,%d2,0
80005fc4:	74 23       	st.w [%a2],%d3
    IfxAsclin_setDataLength(asclinSFR, config->frame.dataLength);                    /* setting the data length */
80005fc6:	19 d2 2c 00 	ld.w %d2,[%a13]44
    asclin->DATCON.B.DATLEN = length;
80005fca:	d9 c2 1c 00 	lea %a2,[%a12]28
80005fce:	19 c3 1c 00 	ld.w %d3,[%a12]28
80005fd2:	37 23 04 30 	insert %d3,%d3,%d2,0,4
80005fd6:	74 23       	st.w [%a2],%d3
    IfxAsclin_setTxFifoInletWidth(asclinSFR, config->fifo.inWidth);                  /* setting Tx FIFO inlet width */
80005fd8:	19 d2 34 00 	ld.w %d2,[%a13]52
}


IFX_INLINE void IfxAsclin_setTxFifoInletWidth(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInletWidth width)
{
    asclin->TXFIFOCON.B.INW = width;
80005fdc:	d9 c2 0c 00 	lea %a2,[%a12]12
80005fe0:	19 c3 0c 00 	ld.w %d3,[%a12]12
80005fe4:	37 23 02 33 	insert %d3,%d3,%d2,6,2
80005fe8:	74 23       	st.w [%a2],%d3
    IfxAsclin_setRxFifoOutletWidth(asclinSFR, config->fifo.outWidth);                /* setting Rx FIFO outlet width */
80005fea:	19 d2 38 00 	ld.w %d2,[%a13]56
    asclin->RXFIFOCON.B.OUTW = width;
80005fee:	d9 c2 10 00 	lea %a2,[%a12]16
80005ff2:	19 c3 10 00 	ld.w %d3,[%a12]16
80005ff6:	37 23 02 33 	insert %d3,%d3,%d2,6,2
80005ffa:	74 23       	st.w [%a2],%d3
    IfxAsclin_setIdleDelay(asclinSFR, config->frame.idleDelay);                      /* setting idle delay */
80005ffc:	19 d2 18 00 	ld.w %d2,[%a13]24
    asclin->FRAMECON.B.IDLE = delay;
80006000:	d9 c2 18 00 	lea %a2,[%a12]24
80006004:	19 c3 18 00 	ld.w %d3,[%a12]24
80006008:	37 23 03 33 	insert %d3,%d3,%d2,6,3
8000600c:	74 23       	st.w [%a2],%d3
    IfxAsclin_setTxFifoInterruptLevel(asclinSFR, config->fifo.txFifoInterruptLevel); /* setting Tx FIFO level at which a Tx interrupt will be triggered*/
8000600e:	19 d2 3c 00 	ld.w %d2,[%a13]60
    __asm__ volatile ("min.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
80006012:	3b f0 00 40 	mov %d4,15
80006016:	0b 42 90 21 	min.u %d2,%d2,%d4
}


IFX_INLINE void IfxAsclin_setTxFifoInterruptLevel(Ifx_ASCLIN *asclin, IfxAsclin_TxFifoInterruptLevel level)
{
    asclin->TXFIFOCON.B.INTLEVEL = __minu(level, 15);
8000601a:	d9 c2 0c 00 	lea %a2,[%a12]12
8000601e:	19 c3 0c 00 	ld.w %d3,[%a12]12
80006022:	37 23 04 34 	insert %d3,%d3,%d2,8,4
80006026:	74 23       	st.w [%a2],%d3
    IfxAsclin_setRxFifoInterruptLevel(asclinSFR, config->fifo.rxFifoInterruptLevel); /* setting Rx FIFO interrupt level at which a Rx interrupt will be triggered*/
80006028:	19 d2 00 10 	ld.w %d2,[%a13]64
8000602c:	0b 42 90 41 	min.u %d4,%d2,%d4
    asclin->RXFIFOCON.B.INTLEVEL = __minu(level, 15);
80006030:	d9 c2 10 00 	lea %a2,[%a12]16
80006034:	19 c3 10 00 	ld.w %d3,[%a12]16
80006038:	37 43 04 34 	insert %d3,%d3,%d4,8,4
8000603c:	74 23       	st.w [%a2],%d3
    IfxAsclin_setFrameMode(asclinSFR, config->frame.frameMode);                      /* selecting the frame mode*/
8000603e:	19 d2 20 00 	ld.w %d2,[%a13]32
    asclin->FRAMECON.B.MODE = mode;
80006042:	d9 c2 18 00 	lea %a2,[%a12]24
80006046:	19 c3 18 00 	ld.w %d3,[%a12]24
8000604a:	37 23 02 38 	insert %d3,%d3,%d2,16,2
8000604e:	74 23       	st.w [%a2],%d3
    const IfxAsclin_Asc_Pins *pins = config->pins;
80006050:	19 d8 14 10 	ld.w %d8,[%a13]84
    if (pins != NULL_PTR)
80006054:	df 08 8c 00 	jeq %d8,0,8000616c <IfxAsclin_Asc_initModule+0x26c>
        IfxAsclin_Cts_In *cts = pins->cts;
80006058:	60 82       	mov.a %a2,%d8
8000605a:	54 29       	ld.w %d9,[%a2]
        if (cts != NULL_PTR)
8000605c:	df 09 2c 00 	jeq %d9,0,800060b4 <IfxAsclin_Asc_initModule+0x1b4>
            IfxAsclin_initCtsPin(cts, pins->ctsMode, pins->pinDriver);
80006060:	19 25 04 00 	ld.w %d5,[%a2]4
80006064:	19 2b 20 00 	ld.w %d11,[%a2]32
    if (cts->pin.port != NULL_PTR)
80006068:	60 92       	mov.a %a2,%d9
8000606a:	99 24 04 00 	ld.a %a4,[%a2]4
8000606e:	bd 04 23 00 	jz.a %a4,800060b4 <IfxAsclin_Asc_initModule+0x1b4>
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
80006072:	39 24 08 00 	ld.bu %d4,[%a2]8
80006076:	6d ff a1 ea 	call 800035b8 <IfxPort_setPinMode>
        IfxPort_setPinPadDriver(cts->pin.port, cts->pin.pinIndex, padDriver);
8000607a:	02 b5       	mov %d5,%d11
8000607c:	60 92       	mov.a %a2,%d9
8000607e:	39 24 08 00 	ld.bu %d4,[%a2]8
80006082:	99 24 04 00 	ld.a %a4,[%a2]4
80006086:	6d ff d0 ea 	call 80003626 <IfxPort_setPinPadDriver>
        IfxAsclin_enableCts(cts->module, TRUE);
8000608a:	60 92       	mov.a %a2,%d9
8000608c:	d4 22       	ld.a %a2,[%a2]
    asclin->IOCR.B.CTSEN = enable ? 1 : 0;
8000608e:	d9 23 04 00 	lea %a3,[%a2]4
80006092:	19 23 04 00 	ld.w %d3,[%a2]4
80006096:	b7 13 81 3e 	insert %d3,%d3,1,29,1
8000609a:	74 33       	st.w [%a3],%d3
        IfxAsclin_setCtsInput(cts->module, (IfxAsclin_CtsInputSelect)cts->select);
8000609c:	60 92       	mov.a %a2,%d9
8000609e:	d4 22       	ld.a %a2,[%a2]
800060a0:	60 93       	mov.a %a3,%d9
800060a2:	19 32 0c 00 	ld.w %d2,[%a3]12
    asclin->IOCR.B.CTS = ctsi;
800060a6:	d9 23 04 00 	lea %a3,[%a2]4
800060aa:	19 23 04 00 	ld.w %d3,[%a2]4
800060ae:	37 23 02 38 	insert %d3,%d3,%d2,16,2
800060b2:	74 33       	st.w [%a3],%d3
        IfxAsclin_Rx_In *rx = pins->rx;
800060b4:	60 82       	mov.a %a2,%d8
800060b6:	19 29 08 00 	ld.w %d9,[%a2]8
        if (rx != NULL_PTR)
800060ba:	df 09 23 00 	jeq %d9,0,80006100 <IfxAsclin_Asc_initModule+0x200>
            IfxAsclin_initRxPin(rx, pins->rxMode, pins->pinDriver);
800060be:	19 25 0c 00 	ld.w %d5,[%a2]12
800060c2:	19 2b 20 00 	ld.w %d11,[%a2]32
    if (rx->pin.port != NULL_PTR)
800060c6:	60 92       	mov.a %a2,%d9
800060c8:	99 24 04 00 	ld.a %a4,[%a2]4
800060cc:	bd 04 1a 00 	jz.a %a4,80006100 <IfxAsclin_Asc_initModule+0x200>
800060d0:	39 24 08 00 	ld.bu %d4,[%a2]8
800060d4:	6d ff 72 ea 	call 800035b8 <IfxPort_setPinMode>
        IfxPort_setPinPadDriver(rx->pin.port, rx->pin.pinIndex, padDriver);
800060d8:	02 b5       	mov %d5,%d11
800060da:	60 92       	mov.a %a2,%d9
800060dc:	39 24 08 00 	ld.bu %d4,[%a2]8
800060e0:	99 24 04 00 	ld.a %a4,[%a2]4
800060e4:	6d ff a1 ea 	call 80003626 <IfxPort_setPinPadDriver>
        IfxAsclin_setRxInput(rx->module, (IfxAsclin_RxInputSelect)rx->select);
800060e8:	60 92       	mov.a %a2,%d9
800060ea:	d4 22       	ld.a %a2,[%a2]
800060ec:	60 93       	mov.a %a3,%d9
800060ee:	19 32 0c 00 	ld.w %d2,[%a3]12
    asclin->IOCR.B.ALTI = alti;
800060f2:	d9 23 04 00 	lea %a3,[%a2]4
800060f6:	19 23 04 00 	ld.w %d3,[%a2]4
800060fa:	37 23 03 30 	insert %d3,%d3,%d2,0,3
800060fe:	74 33       	st.w [%a3],%d3
        IfxAsclin_Rts_Out *rts = pins->rts;
80006100:	60 82       	mov.a %a2,%d8
80006102:	19 29 10 00 	ld.w %d9,[%a2]16
        if (rts != NULL_PTR)
80006106:	df 09 18 00 	jeq %d9,0,80006136 <IfxAsclin_Asc_initModule+0x236>
            IfxAsclin_initRtsPin(rts, pins->rtsMode, pins->pinDriver);
8000610a:	19 25 14 00 	ld.w %d5,[%a2]20
8000610e:	19 2b 20 00 	ld.w %d11,[%a2]32
    IfxPort_setPinModeOutput(rts->pin.port, rts->pin.pinIndex, outputMode, rts->select);
80006112:	60 92       	mov.a %a2,%d9
80006114:	19 22 0c 00 	ld.w %d2,[%a2]12
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80006118:	a6 25       	or %d5,%d2
8000611a:	39 24 08 00 	ld.bu %d4,[%a2]8
8000611e:	99 24 04 00 	ld.a %a4,[%a2]4
80006122:	6d ff 4b ea 	call 800035b8 <IfxPort_setPinMode>
    IfxPort_setPinPadDriver(rts->pin.port, rts->pin.pinIndex, padDriver);
80006126:	02 b5       	mov %d5,%d11
80006128:	60 92       	mov.a %a2,%d9
8000612a:	39 24 08 00 	ld.bu %d4,[%a2]8
8000612e:	99 24 04 00 	ld.a %a4,[%a2]4
80006132:	6d ff 7a ea 	call 80003626 <IfxPort_setPinPadDriver>
        IfxAsclin_Tx_Out *tx = pins->tx;
80006136:	60 82       	mov.a %a2,%d8
80006138:	19 29 18 00 	ld.w %d9,[%a2]24
        if (tx != NULL_PTR)
8000613c:	df 09 18 00 	jeq %d9,0,8000616c <IfxAsclin_Asc_initModule+0x26c>
            IfxAsclin_initTxPin(tx, pins->txMode, pins->pinDriver);
80006140:	19 22 1c 00 	ld.w %d2,[%a2]28
80006144:	19 28 20 00 	ld.w %d8,[%a2]32
    IfxPort_setPinModeOutput(tx->pin.port, tx->pin.pinIndex, outputMode, tx->select);
80006148:	60 92       	mov.a %a2,%d9
8000614a:	19 25 0c 00 	ld.w %d5,[%a2]12
8000614e:	a6 25       	or %d5,%d2
80006150:	39 24 08 00 	ld.bu %d4,[%a2]8
80006154:	99 24 04 00 	ld.a %a4,[%a2]4
80006158:	6d ff 30 ea 	call 800035b8 <IfxPort_setPinMode>
    IfxPort_setPinPadDriver(tx->pin.port, tx->pin.pinIndex, padDriver);
8000615c:	02 85       	mov %d5,%d8
8000615e:	60 92       	mov.a %a2,%d9
80006160:	39 24 08 00 	ld.bu %d4,[%a2]8
80006164:	99 24 04 00 	ld.a %a4,[%a2]4
80006168:	6d ff 5f ea 	call 80003626 <IfxPort_setPinPadDriver>
    IfxAsclin_setClockSource(asclinSFR, config->clockSource); /* select the clock source*/
8000616c:	19 d4 18 10 	ld.w %d4,[%a13]88
80006170:	40 c4       	mov.aa %a4,%a12
80006172:	6d ff 05 fd 	call 80005b7c <IfxAsclin_setClockSource>
    asclin->FLAGSENABLE.U = 0x00000000;
80006176:	82 03       	mov %d3,0
80006178:	59 c3 00 10 	st.w [%a12]64,%d3
    asclin->FLAGSCLEAR.U = 0xFFFFFFFF;
8000617c:	82 f2       	mov %d2,-1
8000617e:	59 c2 3c 00 	st.w [%a12]60,%d2
    asclin->errorFlags.ALL = 0;
80006182:	28 e3       	st.b [%a15]14,%d3
    if (config->errorFlags.flags.parityError)
80006184:	39 d3 1c 10 	ld.bu %d3,[%a13]92
80006188:	6f 03 09 00 	jz.t %d3,0,8000619a <IfxAsclin_Asc_initModule+0x29a>
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
8000618c:	d9 c2 00 10 	lea %a2,[%a12]64
80006190:	19 c3 00 10 	ld.w %d3,[%a12]64
80006194:	b7 13 01 38 	insert %d3,%d3,1,16,1
80006198:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.frameError)
8000619a:	39 d3 1c 10 	ld.bu %d3,[%a13]92
8000619e:	6f 13 09 00 	jz.t %d3,1,800061b0 <IfxAsclin_Asc_initModule+0x2b0>
    asclin->FLAGSENABLE.B.FEE = enable ? 1 : 0;
800061a2:	d9 c2 00 10 	lea %a2,[%a12]64
800061a6:	19 c3 00 10 	ld.w %d3,[%a12]64
800061aa:	b7 13 01 39 	insert %d3,%d3,1,18,1
800061ae:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.rxFifoOverflow)
800061b0:	39 d3 1c 10 	ld.bu %d3,[%a13]92
800061b4:	6f 23 09 00 	jz.t %d3,2,800061c6 <IfxAsclin_Asc_initModule+0x2c6>
    asclin->FLAGSENABLE.B.RFOE = enable ? 1 : 0;
800061b8:	d9 c2 00 10 	lea %a2,[%a12]64
800061bc:	19 c3 00 10 	ld.w %d3,[%a12]64
800061c0:	b7 13 01 3d 	insert %d3,%d3,1,26,1
800061c4:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.rxFifoUnderflow)
800061c6:	39 d3 1c 10 	ld.bu %d3,[%a13]92
800061ca:	6f 33 09 00 	jz.t %d3,3,800061dc <IfxAsclin_Asc_initModule+0x2dc>
    asclin->FLAGSENABLE.B.RFUE = enable ? 1 : 0;
800061ce:	d9 c2 00 10 	lea %a2,[%a12]64
800061d2:	19 c3 00 10 	ld.w %d3,[%a12]64
800061d6:	b7 13 81 3d 	insert %d3,%d3,1,27,1
800061da:	74 23       	st.w [%a2],%d3
    if (config->errorFlags.flags.txFifoOverflow)
800061dc:	39 d3 1c 10 	ld.bu %d3,[%a13]92
800061e0:	6f 43 09 00 	jz.t %d3,4,800061f2 <IfxAsclin_Asc_initModule+0x2f2>
    asclin->FLAGSENABLE.B.TFOE = enable ? 1 : 0;
800061e4:	d9 c2 00 10 	lea %a2,[%a12]64
800061e8:	19 c3 00 10 	ld.w %d3,[%a12]64
800061ec:	b7 13 01 3f 	insert %d3,%d3,1,30,1
800061f0:	74 23       	st.w [%a2],%d3
    asclin->rxSwFifoOverflow = FALSE;
800061f2:	82 03       	mov %d3,0
800061f4:	28 d3       	st.b [%a15]13,%d3
    asclin->txInProgress     = FALSE;
800061f6:	28 c3       	st.b [%a15]12,%d3
    asclin->dataBufferMode = config->dataBufferMode;
800061f8:	19 d3 30 10 	ld.w %d3,[%a13]112
800061fc:	68 43       	st.w [%a15]16,%d3
    asclin->txTimestamp    = 0;
800061fe:	d2 04       	mov %e4,0
80006200:	89 f4 58 09 	st.d [%a15]24,%e4
    asclin->sendCount      = 0;
80006204:	82 02       	mov %d2,0
80006206:	68 52       	st.w [%a15]20,%d2
    switch (asclin->dataBufferMode)
80006208:	df 03 82 00 	jeq %d3,0,8000630c <IfxAsclin_Asc_initModule+0x40c>
8000620c:	df 13 83 80 	jne %d3,1,80006312 <IfxAsclin_Asc_initModule+0x412>
        elementSize = sizeof(Ifx_DataBufferMode_TimeStampSingle);
80006210:	3b c0 00 80 	mov %d8,12
    if (config->txBuffer != NULL_PTR)
80006214:	99 d4 20 10 	ld.a %a4,[%a13]96
80006218:	bd 04 80 00 	jz.a %a4,80006318 <IfxAsclin_Asc_initModule+0x418>
        asclin->tx = Ifx_Fifo_init(config->txBuffer, config->txBufferSize, elementSize);
8000621c:	02 85       	mov %d5,%d8
8000621e:	c9 d4 1e 10 	ld.h %d4,[%a13]94
80006222:	6d ff ba db 	call 80001996 <Ifx_Fifo_init>
80006226:	e8 12       	st.a [%a15]4,%a2
    if (config->rxBuffer != NULL_PTR)
80006228:	99 d4 28 10 	ld.a %a4,[%a13]104
8000622c:	bd 04 7e 00 	jz.a %a4,80006328 <IfxAsclin_Asc_initModule+0x428>
        asclin->rx = Ifx_Fifo_init(config->rxBuffer, config->rxBufferSize, elementSize);
80006230:	02 85       	mov %d5,%d8
80006232:	c9 d4 24 10 	ld.h %d4,[%a13]100
80006236:	6d ff b0 db 	call 80001996 <Ifx_Fifo_init>
8000623a:	e8 22       	st.a [%a15]8,%a2
    IfxSrc_Tos tos = config->interrupt.typeOfService;
8000623c:	19 d8 10 10 	ld.w %d8,[%a13]80
    if ((config->interrupt.rxPriority > 0) || (tos == IfxSrc_Tos_dma))
80006240:	b9 d3 0a 10 	ld.hu %d3,[%a13]74
80006244:	df 03 04 80 	jne %d3,0,8000624c <IfxAsclin_Asc_initModule+0x34c>
80006248:	df 38 1e 80 	jne %d8,3,80006284 <IfxAsclin_Asc_initModule+0x384>
        src = IfxAsclin_getSrcPointerRx(asclinSFR);
8000624c:	40 c4       	mov.aa %a4,%a12
8000624e:	6d ff 70 fc 	call 80005b2e <IfxAsclin_getSrcPointerRx>
    src->B.SRPN = priority;
80006252:	39 d2 0a 10 	ld.bu %d2,[%a13]74
80006256:	54 23       	ld.w %d3,[%a2]
80006258:	37 23 08 30 	insert %d3,%d3,%d2,0,8
8000625c:	74 23       	st.w [%a2],%d3
    src->B.TOS  = typOfService;
8000625e:	54 23       	ld.w %d3,[%a2]
80006260:	37 83 82 35 	insert %d3,%d3,%d8,11,2
80006264:	74 23       	st.w [%a2],%d3
    src->B.CLRR = 1;
80006266:	54 23       	ld.w %d3,[%a2]
80006268:	b7 13 81 3c 	insert %d3,%d3,1,25,1
8000626c:	74 23       	st.w [%a2],%d3
    asclin->FLAGSENABLE.B.RFLE = enable ? 1 : 0;
8000626e:	d9 c3 00 10 	lea %a3,[%a12]64
80006272:	19 c3 00 10 	ld.w %d3,[%a12]64
80006276:	b7 13 01 3e 	insert %d3,%d3,1,28,1
8000627a:	74 33       	st.w [%a3],%d3
    src->B.SRE = 1;
8000627c:	54 23       	ld.w %d3,[%a2]
8000627e:	b7 13 01 35 	insert %d3,%d3,1,10,1
80006282:	74 23       	st.w [%a2],%d3
    if ((config->interrupt.txPriority > 0) || (tos == IfxSrc_Tos_dma))
80006284:	b9 d3 08 10 	ld.hu %d3,[%a13]72
80006288:	df 03 04 80 	jne %d3,0,80006290 <IfxAsclin_Asc_initModule+0x390>
8000628c:	df 38 1e 80 	jne %d8,3,800062c8 <IfxAsclin_Asc_initModule+0x3c8>
        src = IfxAsclin_getSrcPointerTx(asclinSFR);
80006290:	40 c4       	mov.aa %a4,%a12
80006292:	6d ff 5b fc 	call 80005b48 <IfxAsclin_getSrcPointerTx>
    src->B.SRPN = priority;
80006296:	39 d2 08 10 	ld.bu %d2,[%a13]72
8000629a:	54 23       	ld.w %d3,[%a2]
8000629c:	37 23 08 30 	insert %d3,%d3,%d2,0,8
800062a0:	74 23       	st.w [%a2],%d3
    src->B.TOS  = typOfService;
800062a2:	54 23       	ld.w %d3,[%a2]
800062a4:	37 83 82 35 	insert %d3,%d3,%d8,11,2
800062a8:	74 23       	st.w [%a2],%d3
    src->B.CLRR = 1;
800062aa:	54 23       	ld.w %d3,[%a2]
800062ac:	b7 13 81 3c 	insert %d3,%d3,1,25,1
800062b0:	74 23       	st.w [%a2],%d3
    asclin->FLAGSENABLE.B.TFLE = enable ? 1 : 0;
800062b2:	d9 c3 00 10 	lea %a3,[%a12]64
800062b6:	19 c3 00 10 	ld.w %d3,[%a12]64
800062ba:	b7 13 81 3f 	insert %d3,%d3,1,31,1
800062be:	74 33       	st.w [%a3],%d3
    src->B.SRE = 1;
800062c0:	54 23       	ld.w %d3,[%a2]
800062c2:	b7 13 01 35 	insert %d3,%d3,1,10,1
800062c6:	74 23       	st.w [%a2],%d3
    if (config->interrupt.erPriority > 0) /*These interrupts are not serviced by dma*/
800062c8:	b9 d3 0c 10 	ld.hu %d3,[%a13]76
800062cc:	df 03 36 80 	jne %d3,0,80006338 <IfxAsclin_Asc_initModule+0x438>
    asclin->RXFIFOCON.B.ENI = enable ? 1 : 0;
800062d0:	d9 c2 10 00 	lea %a2,[%a12]16
800062d4:	19 c3 10 00 	ld.w %d3,[%a12]16
800062d8:	b7 13 81 30 	insert %d3,%d3,1,1,1
800062dc:	74 23       	st.w [%a2],%d3
    asclin->TXFIFOCON.B.ENO = enable ? 1 : 0;
800062de:	d9 c2 0c 00 	lea %a2,[%a12]12
800062e2:	19 c3 0c 00 	ld.w %d3,[%a12]12
800062e6:	b7 13 81 30 	insert %d3,%d3,1,1,1
800062ea:	74 23       	st.w [%a2],%d3
    asclin->RXFIFOCON.B.FLUSH = 1;
800062ec:	d9 c2 10 00 	lea %a2,[%a12]16
800062f0:	19 c3 10 00 	ld.w %d3,[%a12]16
800062f4:	b7 13 01 30 	insert %d3,%d3,1,0,1
800062f8:	74 23       	st.w [%a2],%d3
    asclin->TXFIFOCON.B.FLUSH = 1;
800062fa:	d9 c2 0c 00 	lea %a2,[%a12]12
800062fe:	19 c3 0c 00 	ld.w %d3,[%a12]12
80006302:	b7 13 01 30 	insert %d3,%d3,1,0,1
80006306:	74 23       	st.w [%a2],%d3
}
80006308:	02 a2       	mov %d2,%d10
8000630a:	00 90       	ret 
    switch (asclin->dataBufferMode)
8000630c:	82 18       	mov %d8,1
8000630e:	1d ff 83 ff 	j 80006214 <IfxAsclin_Asc_initModule+0x314>
        elementSize = 0;
80006312:	82 08       	mov %d8,0
80006314:	1d ff 80 ff 	j 80006214 <IfxAsclin_Asc_initModule+0x314>
        asclin->tx = Ifx_Fifo_create(config->txBufferSize, elementSize);
80006318:	02 85       	mov %d5,%d8
8000631a:	c9 d4 1e 10 	ld.h %d4,[%a13]94
8000631e:	6d ff 62 db 	call 800019e2 <Ifx_Fifo_create>
80006322:	e8 12       	st.a [%a15]4,%a2
80006324:	1d ff 82 ff 	j 80006228 <IfxAsclin_Asc_initModule+0x328>
        asclin->rx = Ifx_Fifo_create(config->rxBufferSize, elementSize);
80006328:	02 85       	mov %d5,%d8
8000632a:	c9 d4 24 10 	ld.h %d4,[%a13]100
8000632e:	6d ff 5a db 	call 800019e2 <Ifx_Fifo_create>
80006332:	e8 22       	st.a [%a15]8,%a2
80006334:	1d ff 84 ff 	j 8000623c <IfxAsclin_Asc_initModule+0x33c>
        src = IfxAsclin_getSrcPointerEr(asclinSFR);
80006338:	40 c4       	mov.aa %a4,%a12
8000633a:	6d ff ec fb 	call 80005b12 <IfxAsclin_getSrcPointerEr>
    src->B.SRPN = priority;
8000633e:	39 d2 0c 10 	ld.bu %d2,[%a13]76
80006342:	54 23       	ld.w %d3,[%a2]
80006344:	37 23 08 30 	insert %d3,%d3,%d2,0,8
80006348:	74 23       	st.w [%a2],%d3
    src->B.TOS  = typOfService;
8000634a:	54 23       	ld.w %d3,[%a2]
8000634c:	37 83 82 35 	insert %d3,%d3,%d8,11,2
80006350:	74 23       	st.w [%a2],%d3
    src->B.CLRR = 1;
80006352:	54 23       	ld.w %d3,[%a2]
80006354:	b7 13 81 3c 	insert %d3,%d3,1,25,1
80006358:	74 23       	st.w [%a2],%d3
    asclin->FLAGSENABLE.B.PEE = enable ? 1 : 0;
8000635a:	d9 c3 00 10 	lea %a3,[%a12]64
8000635e:	19 c3 00 10 	ld.w %d3,[%a12]64
80006362:	b7 13 01 38 	insert %d3,%d3,1,16,1
80006366:	74 33       	st.w [%a3],%d3
    src->B.SRE = 1;
80006368:	54 23       	ld.w %d3,[%a2]
8000636a:	b7 13 01 35 	insert %d3,%d3,1,10,1
8000636e:	74 23       	st.w [%a2],%d3
}
80006370:	1d ff b0 ff 	j 800062d0 <IfxAsclin_Asc_initModule+0x3d0>

80006374 <IfxAsclin_Asc_initModuleConfig>:
{
80006374:	40 ae       	mov.aa %a14,%sp
    config->asclin = asclin;
80006376:	f4 45       	st.a [%a4],%a5
    config->loopBack = FALSE;                                                  /* no loop back*/
80006378:	82 02       	mov %d2,0
8000637a:	e9 42 2c 10 	st.b [%a4]108,%d2
    config->clockSource           = IfxAsclin_ClockSource_kernelClock;         /* kernel clock, fclc*/
8000637e:	82 13       	mov %d3,1
80006380:	59 43 18 10 	st.w [%a4]88,%d3
    config->baudrate.prescaler    = 1;                                         /* default prescaler*/
80006384:	f9 43 08 00 	st.h [%a4]8,%d3
    config->baudrate.baudrate     = 115200;                                    /* default baudrate (the fractional dividier setup will be calculated in initModule*/
80006388:	7b 10 7e 24 	movh %d2,18401
8000638c:	59 42 04 00 	st.w [%a4]4,%d2
    config->baudrate.oversampling = IfxAsclin_OversamplingFactor_4;            /* default oversampling factor*/
80006390:	82 34       	mov %d4,3
80006392:	59 44 0c 00 	st.w [%a4]12,%d4
    config->bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_one;       /* one sample per bit*/
80006396:	82 02       	mov %d2,0
80006398:	59 42 10 00 	st.w [%a4]16,%d2
    config->bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_3;   /* sample point position at 3*/
8000639c:	59 44 14 00 	st.w [%a4]20,%d4
    config->frame.idleDelay               = IfxAsclin_IdleDelay_0;             /* no idle delay*/
800063a0:	59 42 18 00 	st.w [%a4]24,%d2
    config->frame.stopBit                 = IfxAsclin_StopBit_1;               /* one stop bit*/
800063a4:	59 43 1c 00 	st.w [%a4]28,%d3
    config->frame.frameMode               = IfxAsclin_FrameMode_asc;           /* ASC mode*/
800063a8:	59 43 20 00 	st.w [%a4]32,%d3
    config->frame.shiftDir                = IfxAsclin_ShiftDirection_lsbFirst; /* shift diection LSB first*/
800063ac:	59 42 24 00 	st.w [%a4]36,%d2
    config->frame.parityBit               = FALSE;                             /* disable parity*/
800063b0:	e9 42 30 00 	st.b [%a4]48,%d2
    config->frame.parityType              = IfxAsclin_ParityType_even;         /* even parity (if parity enabled)*/
800063b4:	59 42 28 00 	st.w [%a4]40,%d2
    config->frame.dataLength              = IfxAsclin_DataLength_8;            /* number of bits per transfer 8*/
800063b8:	82 74       	mov %d4,7
800063ba:	59 44 2c 00 	st.w [%a4]44,%d4
    config->fifo.inWidth              = IfxAsclin_TxFifoInletWidth_1;          /* 8-bit wide write*/
800063be:	59 43 34 00 	st.w [%a4]52,%d3
    config->fifo.outWidth             = IfxAsclin_RxFifoOutletWidth_1;         /* 8-bit wide read*/
800063c2:	59 43 38 00 	st.w [%a4]56,%d3
    config->fifo.txFifoInterruptLevel = IfxAsclin_TxFifoInterruptLevel_0;      /* txFifoInterruptLevel = 0. optimised to write upto 16 bytes at a time */
800063c6:	59 42 3c 00 	st.w [%a4]60,%d2
    config->fifo.rxFifoInterruptLevel = IfxAsclin_RxFifoInterruptLevel_1;
800063ca:	59 42 00 10 	st.w [%a4]64,%d2
    config->fifo.buffMode             = IfxAsclin_ReceiveBufferMode_rxFifo;    /* RxFIFO*/
800063ce:	59 42 04 10 	st.w [%a4]68,%d2
    config->interrupt.rxPriority    = 0;                                       /* receive interrupt priority 0*/
800063d2:	f9 42 0a 10 	st.h [%a4]74,%d2
    config->interrupt.txPriority    = 0;                                       /* transmit interrupt priority 0*/
800063d6:	f9 42 08 10 	st.h [%a4]72,%d2
    config->interrupt.erPriority    = 0;                                       /* error interrupt priority 0*/
800063da:	f9 42 0c 10 	st.h [%a4]76,%d2
    config->interrupt.typeOfService = IfxSrc_Tos_cpu0;                         /* type of service CPU0*/
800063de:	59 42 10 10 	st.w [%a4]80,%d2
    config->errorFlags.ALL = ~0;                                               /* all error flags enabled*/
800063e2:	82 f3       	mov %d3,-1
800063e4:	e9 43 1c 10 	st.b [%a4]92,%d3
    config->pins           = NULL_PTR;                                         /* pins to null pointer*/
800063e8:	59 42 14 10 	st.w [%a4]84,%d2
    config->rxBuffer       = NULL_PTR;                                         /* Rx Fifo buffer*/
800063ec:	59 42 28 10 	st.w [%a4]104,%d2
    config->txBuffer       = NULL_PTR;                                         /* Tx Fifo buffer*/
800063f0:	59 42 20 10 	st.w [%a4]96,%d2
    config->txBufferSize   = 0;                                                /* Rx Fifo buffer size*/
800063f4:	f9 42 1e 10 	st.h [%a4]94,%d2
    config->rxBufferSize   = 0;                                                /* Rx Fifo buffer size*/
800063f8:	f9 42 24 10 	st.h [%a4]100,%d2
    config->dataBufferMode = Ifx_DataBufferMode_normal;
800063fc:	59 42 30 10 	st.w [%a4]112,%d2
}
80006400:	00 90       	ret 

80006402 <IfxAsclin_Asc_initiateTransmission>:
{
80006402:	40 ae       	mov.aa %a14,%sp
80006404:	20 10       	sub.a %sp,16
80006406:	40 4c       	mov.aa %a12,%a4
    if (asclin->txInProgress == FALSE)     /* Send first byte: send init */
80006408:	39 42 0c 00 	ld.bu %d2,[%a4]12
8000640c:	df 02 17 80 	jne %d2,0,8000643a <IfxAsclin_Asc_initiateTransmission+0x38>
        if (Ifx_Fifo_isEmpty(asclin->tx) == FALSE)
80006410:	99 44 04 00 	ld.a %a4,[%a4]4
80006414:	c9 42 04 00 	ld.h %d2,[%a4]4
80006418:	df 02 11 00 	jeq %d2,0,8000643a <IfxAsclin_Asc_initiateTransmission+0x38>
            asclin->txInProgress = TRUE;
8000641c:	82 12       	mov %d2,1
8000641e:	e9 c2 0c 00 	st.b [%a12]12,%d2
            switch (asclin->dataBufferMode)
80006422:	19 c2 10 00 	ld.w %d2,[%a12]16
80006426:	df 02 0b 00 	jeq %d2,0,8000643c <IfxAsclin_Asc_initiateTransmission+0x3a>
8000642a:	df 12 11 00 	jeq %d2,1,8000644c <IfxAsclin_Asc_initiateTransmission+0x4a>
            IfxAsclin_write8(asclin->asclin, &data, 1);
8000642e:	82 14       	mov %d4,1
80006430:	d9 e5 f3 ff 	lea %a5,[%a14]-13
80006434:	d4 c4       	ld.a %a4,[%a12]
80006436:	6d ff 6e fc 	call 80005d12 <IfxAsclin_write8>
}
8000643a:	00 90       	ret 
                Ifx_Fifo_read(asclin->tx, &data, 1, TIME_NULL);
8000643c:	d2 06       	mov %e6,0
8000643e:	82 14       	mov %d4,1
80006440:	d9 e5 f3 ff 	lea %a5,[%a14]-13
80006444:	6d ff e4 da 	call 80001a0c <Ifx_Fifo_read>
            break;
80006448:	1d ff f3 ff 	j 8000642e <IfxAsclin_Asc_initiateTransmission+0x2c>
                Ifx_Fifo_read(asclin->tx, &packedData, sizeof(packedData), TIME_NULL);
8000644c:	d2 06       	mov %e6,0
8000644e:	3b c0 00 40 	mov %d4,12
80006452:	d9 e5 f4 ff 	lea %a5,[%a14]-12
80006456:	6d ff db da 	call 80001a0c <Ifx_Fifo_read>
                data = packedData.data;
8000645a:	39 e2 fc ff 	ld.bu %d2,[%a14]-4
8000645e:	e9 e2 f3 ff 	st.b [%a14]-13,%d2
            break;
80006462:	1d ff e6 ff 	j 8000642e <IfxAsclin_Asc_initiateTransmission+0x2c>

80006466 <IfxAsclin_Asc_write>:
    return TRUE;
}


boolean IfxAsclin_Asc_write(IfxAsclin_Asc *asclin, const void *data, Ifx_SizeT *count, Ifx_TickTime timeout)
{
80006466:	40 ae       	mov.aa %a14,%sp
80006468:	40 4c       	mov.aa %a12,%a4
8000646a:	80 5b       	mov.d %d11,%a5
8000646c:	40 6d       	mov.aa %a13,%a6
8000646e:	02 4a       	mov %d10,%d4
80006470:	02 59       	mov %d9,%d5
    Ifx_SizeT left;
    boolean   result       = TRUE;
    boolean   tx_status    = asclin->txInProgress;
80006472:	39 43 0c 00 	ld.bu %d3,[%a4]12
    uint16    tx_fifo_size = (uint16)asclin->tx->size;
80006476:	99 44 04 00 	ld.a %a4,[%a4]4
8000647a:	c9 42 18 00 	ld.h %d2,[%a4]24
8000647e:	b9 48 18 00 	ld.hu %d8,[%a4]24

    if (*count != 0)
80006482:	94 64       	ld.h %d4,[%a6]
80006484:	df 04 31 00 	jeq %d4,0,800064e6 <IfxAsclin_Asc_write+0x80>
    {
        if ((!tx_status) && (*count > tx_fifo_size))                 /*Transmission not initialised and data size is greater than S/W FIFO*/
80006488:	df 03 04 80 	jne %d3,0,80006490 <IfxAsclin_Asc_write+0x2a>
8000648c:	3f 48 11 00 	jlt %d8,%d4,800064ae <IfxAsclin_Asc_write+0x48>
            IfxAsclin_Asc_initiateTransmission(asclin); /*Will initiate transmission only if txInProgress is False, otherwise interrupts will continue to push data to H/W FIFO*/
        }

        else
        {
            left = Ifx_Fifo_write(asclin->tx, data, *count, timeout);
80006490:	02 a6       	mov %d6,%d10
80006492:	02 97       	mov %d7,%d9
80006494:	60 b5       	mov.a %a5,%d11
80006496:	6d ff 74 db 	call 80001b7e <Ifx_Fifo_write>
8000649a:	02 28       	mov %d8,%d2
            IfxAsclin_Asc_initiateTransmission(asclin);
8000649c:	40 c4       	mov.aa %a4,%a12
8000649e:	6d ff b2 ff 	call 80006402 <IfxAsclin_Asc_initiateTransmission>
        }

        *count -= left;
800064a2:	94 d2       	ld.h %d2,[%a13]
800064a4:	a2 82       	sub %d2,%d8
800064a6:	b4 d2       	st.h [%a13],%d2
        result  = left == 0;
800064a8:	8b 08 00 22 	eq %d2,%d8,0
800064ac:	00 90       	ret 
            Ifx_Fifo_write(asclin->tx, data, tx_fifo_size, timeout); /*Fill upto the S/W FIFO size and initiate transmission*/
800064ae:	02 a6       	mov %d6,%d10
800064b0:	02 57       	mov %d7,%d5
800064b2:	02 24       	mov %d4,%d2
800064b4:	6d ff 65 db 	call 80001b7e <Ifx_Fifo_write>
            IfxAsclin_Asc_initiateTransmission(asclin);
800064b8:	40 c4       	mov.aa %a4,%a12
800064ba:	6d ff a4 ff 	call 80006402 <IfxAsclin_Asc_initiateTransmission>
            left = Ifx_Fifo_write(asclin->tx, (((const uint8 *)data) + tx_fifo_size), (*count) - tx_fifo_size, timeout);
800064be:	b9 d4 00 00 	ld.hu %d4,[%a13]0
800064c2:	a2 84       	sub %d4,%d8
800064c4:	02 a6       	mov %d6,%d10
800064c6:	02 97       	mov %d7,%d9
800064c8:	37 04 50 40 	extr %d4,%d4,0,16
800064cc:	60 b2       	mov.a %a2,%d11
800064ce:	01 28 00 56 	addsc.a %a5,%a2,%d8,0
800064d2:	99 c4 04 00 	ld.a %a4,[%a12]4
800064d6:	6d ff 54 db 	call 80001b7e <Ifx_Fifo_write>
800064da:	02 28       	mov %d8,%d2
            IfxAsclin_Asc_initiateTransmission(asclin); /*Will initiate transmission only if txInProgress is False, otherwise interrupts will continue to push data to H/W FIFO*/
800064dc:	40 c4       	mov.aa %a4,%a12
800064de:	6d ff 92 ff 	call 80006402 <IfxAsclin_Asc_initiateTransmission>
800064e2:	1d ff e0 ff 	j 800064a2 <IfxAsclin_Asc_write+0x3c>
    boolean   result       = TRUE;
800064e6:	82 12       	mov %d2,1
    }

    return result;
}
800064e8:	00 90       	ret 

800064ea <IfxAsclin_Asc_blockingWrite>:
{
800064ea:	40 ae       	mov.aa %a14,%sp
800064ec:	20 10       	sub.a %sp,16
800064ee:	e9 e4 f4 ff 	st.b [%a14]-12,%d4
    Ifx_SizeT count = 1;
800064f2:	82 12       	mov %d2,1
800064f4:	f9 e2 fe ff 	st.h [%a14]-2,%d2
    return IfxAsclin_Asc_write(asclin, &data, &count, TIME_INFINITE);
800064f8:	82 f4       	mov %d4,-1
800064fa:	82 f5       	mov %d5,-1
800064fc:	06 f5       	sh %d5,-1
800064fe:	d9 e6 fe ff 	lea %a6,[%a14]-2
80006502:	d9 e5 f4 ff 	lea %a5,[%a14]-12
80006506:	6d ff b0 ff 	call 80006466 <IfxAsclin_Asc_write>
}
8000650a:	00 90       	ret 

8000650c <IfxStdIf_PwmHl_initConfig>:
 */

#include "IfxStdIf_PwmHl.h"

void IfxStdIf_PwmHl_initConfig(IfxStdIf_PwmHl_Config *config)
{
8000650c:	40 ae       	mov.aa %a14,%sp
    config->deadtime         = 0;
8000650e:	82 02       	mov %d2,0
80006510:	74 42       	st.w [%a4],%d2
    config->minPulse         = 0;
80006512:	59 42 04 00 	st.w [%a4]4,%d2
    config->channelCount     = 0;
80006516:	82 02       	mov %d2,0
80006518:	e9 42 08 00 	st.b [%a4]8,%d2
    config->emergencyEnabled = FALSE;
8000651c:	e9 42 09 00 	st.b [%a4]9,%d2
    config->outputMode       = IfxPort_OutputMode_pushPull;
80006520:	3b 00 08 20 	mov %d2,128
80006524:	59 42 0c 00 	st.w [%a4]12,%d2
    config->outputDriver     = IfxPort_PadDriver_cmosAutomotiveSpeed1;
80006528:	82 02       	mov %d2,0
8000652a:	59 42 10 00 	st.w [%a4]16,%d2
    config->ccxActiveState   = Ifx_ActiveState_high;
8000652e:	82 12       	mov %d2,1
80006530:	59 42 1c 00 	st.w [%a4]28,%d2
    config->coutxActiveState = Ifx_ActiveState_high;
80006534:	59 42 20 00 	st.w [%a4]32,%d2
}
80006538:	00 90       	ret 

8000653a <IfxStdIf_Timer_initConfig>:
 */

#include "IfxStdIf_Timer.h"

void IfxStdIf_Timer_initConfig(IfxStdIf_Timer_Config *config)
{
8000653a:	40 ae       	mov.aa %a14,%sp
    config->frequency                  = 1000;
8000653c:	7b a0 47 24 	movh %d2,17530
80006540:	74 42       	st.w [%a4],%d2
    config->isrPriority                = 0;
80006542:	82 02       	mov %d2,0
80006544:	f9 42 04 00 	st.h [%a4]4,%d2
    config->isrProvider                = IfxSrc_Tos_cpu0;
80006548:	82 03       	mov %d3,0
8000654a:	59 43 08 00 	st.w [%a4]8,%d3
    config->minResolution              = 0;
8000654e:	82 04       	mov %d4,0
80006550:	59 44 0c 00 	st.w [%a4]12,%d4
    config->trigger.outputMode         = IfxPort_OutputMode_pushPull;
80006554:	3b 00 08 50 	mov %d5,128
80006558:	59 45 20 00 	st.w [%a4]32,%d5
    config->trigger.outputDriver       = IfxPort_PadDriver_cmosAutomotiveSpeed1;
8000655c:	59 43 24 00 	st.w [%a4]36,%d3
    config->trigger.risingEdgeAtPeriod = FALSE;
80006560:	e9 42 28 00 	st.b [%a4]40,%d2
    config->trigger.outputEnabled      = FALSE;
80006564:	e9 42 29 00 	st.b [%a4]41,%d2
    config->trigger.enabled            = FALSE;
80006568:	e9 42 10 00 	st.b [%a4]16,%d2
    config->trigger.triggerPoint       = 0;
8000656c:	59 43 14 00 	st.w [%a4]20,%d3
    config->trigger.isrPriority        = 0;
80006570:	f9 43 18 00 	st.h [%a4]24,%d3
    config->trigger.isrProvider        = IfxSrc_Tos_cpu0;
80006574:	59 43 1c 00 	st.w [%a4]28,%d3
    config->countDir                   = IfxStdIf_Timer_CountDir_up;
80006578:	59 43 2c 00 	st.w [%a4]44,%d3
    config->startOffset 					   = 0.0;
8000657c:	59 44 30 00 	st.w [%a4]48,%d4
}
80006580:	00 90       	ret 

80006582 <Ifx_C_Init>:
 *
 * Parameters: Nil
 * Return: Nil
 */
void Ifx_C_Init(void)
{
80006582:	40 ae       	mov.aa %a14,%sp
80006584:	20 08       	sub.a %sp,8
    IfxStart_CTablePtr pBlockDest, pBlockSrc;
    uint32             uiLength, uiCnt;
    uint32            *pTable;
    /* clear table */
    pTable = (uint32 *)&__clear_table;
80006586:	91 00 00 28 	movh.a %a2,32768
8000658a:	d9 22 6c 30 	lea %a2,[%a2]1260 <800004ec <__clear_table>>

    while (pTable)
8000658e:	1d 00 32 00 	j 800065f2 <Ifx_C_Init+0x70>
            break;
        }

        uiCnt = uiLength / 8;

        while (uiCnt--)
80006592:	91 00 00 28 	movh.a %a2,32768
80006596:	d9 22 54 50 	lea %a2,[%a2]1364 <80000554 <__copy_table>>
8000659a:	1d 00 7c 00 	j 80006692 <Ifx_C_Init+0x110>
            *pBlockDest.ullPtr++ = 0;
8000659e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800065a2:	80 22       	mov.d %d2,%a2
800065a4:	1b 82 00 20 	addi %d2,%d2,8
800065a8:	59 e2 fc ff 	st.w [%a14]-4,%d2
800065ac:	d2 02       	mov %e2,0
800065ae:	89 22 40 09 	st.d [%a2],%e2
        while (uiCnt--)
800065b2:	02 52       	mov %d2,%d5
800065b4:	1b f2 ff 5f 	addi %d5,%d2,-1
800065b8:	df 02 f3 ff 	jne %d2,0,8000659e <Ifx_C_Init+0x1c>
        if (uiLength & 0x4)
800065bc:	6f 24 0a 00 	jz.t %d4,2,800065d0 <Ifx_C_Init+0x4e>
            *pBlockDest.uiPtr++ = 0;
800065c0:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800065c4:	80 22       	mov.d %d2,%a2
800065c6:	c2 42       	add %d2,4
800065c8:	59 e2 fc ff 	st.w [%a14]-4,%d2
800065cc:	82 02       	mov %d2,0
800065ce:	74 22       	st.w [%a2],%d2
        if (uiLength & 0x2)
800065d0:	6f 14 0a 00 	jz.t %d4,1,800065e4 <Ifx_C_Init+0x62>
            *pBlockDest.usPtr++ = 0;
800065d4:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800065d8:	80 22       	mov.d %d2,%a2
800065da:	c2 22       	add %d2,2
800065dc:	59 e2 fc ff 	st.w [%a14]-4,%d2
800065e0:	82 02       	mov %d2,0
800065e2:	b4 22       	st.h [%a2],%d2
        if (uiLength & 0x1)
800065e4:	6f 04 06 00 	jz.t %d4,0,800065f0 <Ifx_C_Init+0x6e>
            *pBlockDest.ucPtr = 0;
800065e8:	99 e2 fc ff 	ld.a %a2,[%a14]-4
800065ec:	82 02       	mov %d2,0
800065ee:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
800065f0:	40 32       	mov.aa %a2,%a3
    while (pTable)
800065f2:	bd 02 d0 7f 	jz.a %a2,80006592 <Ifx_C_Init+0x10>
        pBlockDest.uiPtr = (uint32 *)*pTable++;
800065f6:	d9 23 08 00 	lea %a3,[%a2]8
800065fa:	54 22       	ld.w %d2,[%a2]
800065fc:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
80006600:	19 24 04 00 	ld.w %d4,[%a2]4
        if (uiLength == 0xFFFFFFFF)
80006604:	df f4 c7 7f 	jeq %d4,-1,80006592 <Ifx_C_Init+0x10>
        uiCnt = uiLength / 8;
80006608:	8f d4 1f 20 	sh %d2,%d4,-3
        while (uiCnt--)
8000660c:	1d ff d4 ff 	j 800065b4 <Ifx_C_Init+0x32>
        {
            *pBlockDest.ullPtr++ = *pBlockSrc.ullPtr++;
80006610:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006614:	80 22       	mov.d %d2,%a2
80006616:	1b 82 00 20 	addi %d2,%d2,8
8000661a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000661e:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80006622:	80 32       	mov.d %d2,%a3
80006624:	1b 82 00 20 	addi %d2,%d2,8
80006628:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000662c:	09 26 40 09 	ld.d %e6,[%a2]
80006630:	89 36 40 09 	st.d [%a3],%e6
        while (uiCnt--)
80006634:	02 42       	mov %d2,%d4
80006636:	1b f2 ff 4f 	addi %d4,%d2,-1
8000663a:	df 02 eb ff 	jne %d2,0,80006610 <Ifx_C_Init+0x8e>
        }

        if (uiLength & 0x4)
8000663e:	6f 23 10 00 	jz.t %d3,2,8000665e <Ifx_C_Init+0xdc>
        {
            *pBlockDest.uiPtr++ = *pBlockSrc.uiPtr++;
80006642:	99 e2 f8 ff 	ld.a %a2,[%a14]-8
80006646:	80 22       	mov.d %d2,%a2
80006648:	c2 42       	add %d2,4
8000664a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000664e:	99 e3 fc ff 	ld.a %a3,[%a14]-4
80006652:	80 32       	mov.d %d2,%a3
80006654:	c2 42       	add %d2,4
80006656:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000665a:	54 22       	ld.w %d2,[%a2]
8000665c:	74 32       	st.w [%a3],%d2
        }

        if (uiLength & 0x2)
8000665e:	6f 13 11 00 	jz.t %d3,1,80006680 <Ifx_C_Init+0xfe>
        {
            *pBlockDest.usPtr++ = *pBlockSrc.usPtr++;
80006662:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80006666:	80 32       	mov.d %d2,%a3
80006668:	c2 22       	add %d2,2
8000666a:	59 e2 f8 ff 	st.w [%a14]-8,%d2
8000666e:	99 e2 fc ff 	ld.a %a2,[%a14]-4
80006672:	80 22       	mov.d %d2,%a2
80006674:	c2 22       	add %d2,2
80006676:	59 e2 fc ff 	st.w [%a14]-4,%d2
8000667a:	b9 32 00 00 	ld.hu %d2,[%a3]0
8000667e:	b4 22       	st.h [%a2],%d2
        }

        if (uiLength & 0x1)
80006680:	6f 03 08 00 	jz.t %d3,0,80006690 <Ifx_C_Init+0x10e>
        {
            *pBlockDest.ucPtr = *pBlockSrc.ucPtr;
80006684:	99 e3 f8 ff 	ld.a %a3,[%a14]-8
80006688:	99 e2 fc ff 	ld.a %a2,[%a14]-4
8000668c:	14 32       	ld.bu %d2,[%a3]
8000668e:	34 22       	st.b [%a2],%d2
        while (uiCnt--)
80006690:	60 52       	mov.a %a2,%d5
    while (pTable)
80006692:	bd 02 14 00 	jz.a %a2,800066ba <Ifx_C_Init+0x138>
        pBlockSrc.uiPtr  = (uint32 *)*pTable++;
80006696:	54 22       	ld.w %d2,[%a2]
80006698:	59 e2 f8 ff 	st.w [%a14]-8,%d2
        pBlockDest.uiPtr = (uint32 *)*pTable++;
8000669c:	19 22 04 00 	ld.w %d2,[%a2]4
800066a0:	59 e2 fc ff 	st.w [%a14]-4,%d2
        uiLength         = *pTable++;
800066a4:	80 22       	mov.d %d2,%a2
800066a6:	1b c2 00 50 	addi %d5,%d2,12
800066aa:	19 23 08 00 	ld.w %d3,[%a2]8
        if (uiLength == 0xFFFFFFFF)
800066ae:	df f3 06 00 	jeq %d3,-1,800066ba <Ifx_C_Init+0x138>
        uiCnt = uiLength / 8;
800066b2:	8f d3 1f 20 	sh %d2,%d3,-3
        while (uiCnt--)
800066b6:	1d ff c0 ff 	j 80006636 <Ifx_C_Init+0xb4>
        }
    }
}
800066ba:	00 90       	ret 

800066bc <redled_buzzer_cycle>:
#include "GPIO.h"
#include "Header_USER.h"

static uint32 led_buzzerCounter = 0;  // LED 부저 깜빡임 카운터

void redled_buzzer_cycle(void){
800066bc:	40 ae       	mov.aa %a14,%sp
    if(Mode_flag == 1 && Ultra_flag == 1 && Ultra_select == 0 ){
800066be:	91 00 00 26 	movh.a %a2,24576
800066c2:	19 22 f0 10 	ld.w %d2,[%a2]3184 <60000c70 <Mode_flag>>
800066c6:	df 12 18 00 	jeq %d2,1,800066f6 <redled_buzzer_cycle+0x3a>
            IfxPort_togglePin(PORT_R_LED);
            IfxPort_togglePin(PORT_BUZZER);
            led_buzzerCounter = 0;
        }
    }
    else if(Mode_flag == 1 && Ultra_flag == 2 && Ultra_select == 0 ){
800066ca:	df 12 43 00 	jeq %d2,1,80006750 <redled_buzzer_cycle+0x94>
            IfxPort_togglePin(PORT_R_LED);
            IfxPort_togglePin(PORT_BUZZER);
            led_buzzerCounter = 0;
        }
    }
    else if(Mode_flag == 1 && Ultra_flag == 3 && Ultra_select == 0 ){
800066ce:	df 12 6e 00 	jeq %d2,1,800067aa <redled_buzzer_cycle+0xee>
        IfxPort_setPinLow(PORT_R_LED);
        IfxPort_setPinLow(PORT_BUZZER);
    }
    else if(Mode_flag == 1 && Ultra_select == 1){
800066d2:	df 12 86 00 	jeq %d2,1,800067de <redled_buzzer_cycle+0x122>
            IfxPort_setPinHigh(PORT_R_LED);
            IfxPort_setPinHigh(PORT_BUZZER);
    }
    else if(Mode_flag == 0){
800066d6:	df 02 0f 80 	jne %d2,0,800066f4 <redled_buzzer_cycle+0x38>
    port->OMR.U = action << pinIndex;
800066da:	91 40 00 2f 	movh.a %a2,61444
800066de:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800066e2:	7b 00 01 20 	movh %d2,16
800066e6:	d9 23 04 00 	lea %a3,[%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>
800066ea:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
800066ee:	7b 80 00 20 	movh %d2,8
800066f2:	74 32       	st.w [%a3],%d2
        IfxPort_setPinLow(PORT_R_LED);
        IfxPort_setPinLow(PORT_BUZZER);
    }
}
800066f4:	00 90       	ret 
    if(Mode_flag == 1 && Ultra_flag == 1 && Ultra_select == 0 ){
800066f6:	91 00 00 26 	movh.a %a2,24576
800066fa:	19 23 c0 10 	ld.w %d3,[%a2]3136 <60000c40 <Ultra_flag>>
800066fe:	df 13 e6 ff 	jne %d3,1,800066ca <redled_buzzer_cycle+0xe>
80006702:	91 00 00 26 	movh.a %a2,24576
80006706:	19 23 fc 00 	ld.w %d3,[%a2]3132 <60000c3c <Ultra_select>>
8000670a:	df 03 e0 ff 	jne %d3,0,800066ca <redled_buzzer_cycle+0xe>
        led_buzzerCounter++;
8000670e:	91 00 00 26 	movh.a %a2,24576
80006712:	d9 23 f0 00 	lea %a3,[%a2]3120 <60000c30 <led_buzzerCounter>>
80006716:	54 32       	ld.w %d2,[%a3]
80006718:	c2 12       	add %d2,1
8000671a:	59 22 f0 00 	st.w [%a2]3120 <60000c30 <led_buzzerCounter>>,%d2
        if (led_buzzerCounter >= 2)  // 100ms * 2 = 200ms
8000671e:	bf 22 eb ff 	jlt.u %d2,2,800066f4 <redled_buzzer_cycle+0x38>
80006722:	91 40 00 2f 	movh.a %a2,61444
80006726:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
8000672a:	7b 00 01 20 	movh %d2,16
8000672e:	1b 02 01 20 	addi %d2,%d2,16
80006732:	d9 23 04 00 	lea %a3,[%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>
80006736:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
8000673a:	7b 80 00 20 	movh %d2,8
8000673e:	1b 82 00 20 	addi %d2,%d2,8
80006742:	74 32       	st.w [%a3],%d2
            led_buzzerCounter = 0;
80006744:	91 00 00 26 	movh.a %a2,24576
80006748:	82 02       	mov %d2,0
8000674a:	59 22 f0 00 	st.w [%a2]3120 <60000c30 <led_buzzerCounter>>,%d2
8000674e:	00 90       	ret 
    else if(Mode_flag == 1 && Ultra_flag == 2 && Ultra_select == 0 ){
80006750:	91 00 00 26 	movh.a %a2,24576
80006754:	19 23 c0 10 	ld.w %d3,[%a2]3136 <60000c40 <Ultra_flag>>
80006758:	df 23 bb ff 	jne %d3,2,800066ce <redled_buzzer_cycle+0x12>
8000675c:	91 00 00 26 	movh.a %a2,24576
80006760:	19 23 fc 00 	ld.w %d3,[%a2]3132 <60000c3c <Ultra_select>>
80006764:	df 03 b5 ff 	jne %d3,0,800066ce <redled_buzzer_cycle+0x12>
        led_buzzerCounter++;
80006768:	91 00 00 26 	movh.a %a2,24576
8000676c:	d9 23 f0 00 	lea %a3,[%a2]3120 <60000c30 <led_buzzerCounter>>
80006770:	54 32       	ld.w %d2,[%a3]
80006772:	c2 12       	add %d2,1
80006774:	59 22 f0 00 	st.w [%a2]3120 <60000c30 <led_buzzerCounter>>,%d2
        if (led_buzzerCounter >= 5)  // 100ms * 2 = 200ms
80006778:	bf 52 be ff 	jlt.u %d2,5,800066f4 <redled_buzzer_cycle+0x38>
8000677c:	91 40 00 2f 	movh.a %a2,61444
80006780:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
80006784:	7b 00 01 20 	movh %d2,16
80006788:	1b 02 01 20 	addi %d2,%d2,16
8000678c:	d9 23 04 00 	lea %a3,[%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>
80006790:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80006794:	7b 80 00 20 	movh %d2,8
80006798:	1b 82 00 20 	addi %d2,%d2,8
8000679c:	74 32       	st.w [%a3],%d2
            led_buzzerCounter = 0;
8000679e:	91 00 00 26 	movh.a %a2,24576
800067a2:	82 02       	mov %d2,0
800067a4:	59 22 f0 00 	st.w [%a2]3120 <60000c30 <led_buzzerCounter>>,%d2
800067a8:	00 90       	ret 
    else if(Mode_flag == 1 && Ultra_flag == 3 && Ultra_select == 0 ){
800067aa:	91 00 00 26 	movh.a %a2,24576
800067ae:	19 23 c0 10 	ld.w %d3,[%a2]3136 <60000c40 <Ultra_flag>>
800067b2:	df 33 90 ff 	jne %d3,3,800066d2 <redled_buzzer_cycle+0x16>
800067b6:	91 00 00 26 	movh.a %a2,24576
800067ba:	19 23 fc 00 	ld.w %d3,[%a2]3132 <60000c3c <Ultra_select>>
800067be:	df 03 8a ff 	jne %d3,0,800066d2 <redled_buzzer_cycle+0x16>
800067c2:	91 40 00 2f 	movh.a %a2,61444
800067c6:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800067ca:	7b 00 01 20 	movh %d2,16
800067ce:	d9 23 04 00 	lea %a3,[%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>
800067d2:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
800067d6:	7b 80 00 20 	movh %d2,8
800067da:	74 32       	st.w [%a3],%d2
}
800067dc:	00 90       	ret 
    else if(Mode_flag == 1 && Ultra_select == 1){
800067de:	91 00 00 26 	movh.a %a2,24576
800067e2:	19 23 fc 00 	ld.w %d3,[%a2]3132 <60000c3c <Ultra_select>>
800067e6:	df 13 78 ff 	jne %d3,1,800066d6 <redled_buzzer_cycle+0x1a>
    port->OMR.U = action << pinIndex;
800067ea:	91 40 00 2f 	movh.a %a2,61444
800067ee:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800067f2:	3b 00 01 20 	mov %d2,16
800067f6:	d9 23 04 00 	lea %a3,[%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>
800067fa:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
800067fe:	3b 80 00 20 	mov %d2,8
80006802:	74 32       	st.w [%a3],%d2
}
80006804:	00 90       	ret 

80006806 <rgb_led_color>:

void rgb_led_color(void){
80006806:	40 ae       	mov.aa %a14,%sp
    if(GtmPwmHl.duty[0] >= 0 && GtmPwmHl.duty[0] <= 0.3){    // 0~30 초록
80006808:	91 00 00 26 	movh.a %a2,24576
8000680c:	d9 22 d8 20 	lea %a2,[%a2]3224 <60000c98 <GtmPwmHl>>
80006810:	19 28 1c 20 	ld.w %d8,[%a2]156 <6000009c <_impure_data+0x38>>
80006814:	82 02       	mov %d2,0
80006816:	4b 28 01 20 	cmp.f %d2,%d8,%d2
8000681a:	87 22 a2 20 	or.t %d2,%d2,2,%d2,1
8000681e:	df 02 2c 00 	jeq %d2,0,80006876 <rgb_led_color+0x70>
80006822:	02 84       	mov %d4,%d8
80006824:	6d 00 eb 02 	call 80006dfa <__extendsfdf2>
80006828:	7b 30 33 63 	movh %d6,13107
8000682c:	1b 36 33 63 	addi %d6,%d6,13107
80006830:	7b 30 fd 73 	movh %d7,16339
80006834:	1b 37 33 73 	addi %d7,%d7,13107
80006838:	0b 23 10 48 	mov %e4,%d3,%d2
8000683c:	6d 00 2c 05 	call 80007294 <__ledf2>
80006840:	ff 12 1b 00 	jge %d2,1,80006876 <rgb_led_color+0x70>
    port->OMR.U = action << pinIndex;
80006844:	91 40 00 2f 	movh.a %a2,61444
80006848:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
8000684c:	7b 00 08 20 	movh %d2,128
80006850:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80006854:	91 40 00 2f 	movh.a %a2,61444
80006858:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
8000685c:	3b 00 02 20 	mov %d2,32
80006860:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80006864:	91 40 00 2f 	movh.a %a2,61444
80006868:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
8000686c:	7b 00 01 20 	movh %d2,16
80006870:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
}
80006874:	00 90       	ret 
        IfxPort_setPinLow(PORT_R_RGB);
        IfxPort_setPinHigh(PORT_G_RGB);
        IfxPort_setPinLow(PORT_B_RGB);
    }
    else if(GtmPwmHl.duty[0] > 0.3 && GtmPwmHl.duty[0] <= 0.6){   // 31~60 노랑
80006876:	02 84       	mov %d4,%d8
80006878:	6d 00 c1 02 	call 80006dfa <__extendsfdf2>
8000687c:	02 2a       	mov %d10,%d2
8000687e:	02 39       	mov %d9,%d3
80006880:	7b 30 33 63 	movh %d6,13107
80006884:	1b 36 33 63 	addi %d6,%d6,13107
80006888:	7b 30 fd 73 	movh %d7,16339
8000688c:	1b 37 33 73 	addi %d7,%d7,13107
80006890:	02 24       	mov %d4,%d2
80006892:	02 35       	mov %d5,%d3
80006894:	6d 00 e0 04 	call 80007254 <__gtdf2>
80006898:	bf 12 29 00 	jlt %d2,1,800068ea <rgb_led_color+0xe4>
8000689c:	7b 30 33 63 	movh %d6,13107
800068a0:	1b 36 33 63 	addi %d6,%d6,13107
800068a4:	7b 30 fe 73 	movh %d7,16355
800068a8:	1b 37 33 73 	addi %d7,%d7,13107
800068ac:	02 a4       	mov %d4,%d10
800068ae:	02 95       	mov %d5,%d9
800068b0:	6d 00 f2 04 	call 80007294 <__ledf2>
800068b4:	ff 12 1b 00 	jge %d2,1,800068ea <rgb_led_color+0xe4>
    port->OMR.U = action << pinIndex;
800068b8:	91 40 00 2f 	movh.a %a2,61444
800068bc:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800068c0:	3b 00 08 20 	mov %d2,128
800068c4:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
800068c8:	91 40 00 2f 	movh.a %a2,61444
800068cc:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800068d0:	3b 00 02 20 	mov %d2,32
800068d4:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
800068d8:	91 40 00 2f 	movh.a %a2,61444
800068dc:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
800068e0:	7b 00 01 20 	movh %d2,16
800068e4:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
}
800068e8:	00 90       	ret 
        IfxPort_setPinHigh(PORT_R_RGB);
        IfxPort_setPinHigh(PORT_G_RGB);
        IfxPort_setPinLow(PORT_B_RGB);
    }
    else if(GtmPwmHl.duty[0] > 0.6 && GtmPwmHl.duty[0] <= 1){     // 61~100 빨강
800068ea:	7b 30 33 63 	movh %d6,13107
800068ee:	1b 36 33 63 	addi %d6,%d6,13107
800068f2:	7b 30 fe 73 	movh %d7,16355
800068f6:	1b 37 33 73 	addi %d7,%d7,13107
800068fa:	02 a4       	mov %d4,%d10
800068fc:	02 95       	mov %d5,%d9
800068fe:	6d 00 ab 04 	call 80007254 <__gtdf2>
80006902:	bf 12 0a 00 	jlt %d2,1,80006916 <rgb_led_color+0x110>
80006906:	7b 00 f8 23 	movh %d2,16256
8000690a:	4b 28 01 20 	cmp.f %d2,%d8,%d2
8000690e:	87 22 a0 20 	or.t %d2,%d2,0,%d2,1
80006912:	df 02 03 80 	jne %d2,0,80006918 <rgb_led_color+0x112>
        IfxPort_setPinLow(PORT_R_RGB);
        IfxPort_setPinLow(PORT_G_RGB);
        IfxPort_setPinHigh(PORT_B_RGB);
    }
}
80006916:	00 90       	ret 
    port->OMR.U = action << pinIndex;
80006918:	91 40 00 2f 	movh.a %a2,61444
8000691c:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
80006920:	7b 00 08 20 	movh %d2,128
80006924:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80006928:	91 40 00 2f 	movh.a %a2,61444
8000692c:	d9 22 00 0b 	lea %a2,[%a2]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80006930:	7b 00 02 20 	movh %d2,32
80006934:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80006938:	91 40 00 2f 	movh.a %a2,61444
8000693c:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80006940:	3b 00 01 20 	mov %d2,16
80006944:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
80006948:	1d ff e7 ff 	j 80006916 <rgb_led_color+0x110>

8000694c <blue_led_onoff>:

void blue_led_onoff(void){
8000694c:	40 ae       	mov.aa %a14,%sp
    if(Mode_flag == 0 || Sudden_accel_flag == 1){IfxPort_setPinLow(PORT_B_LED);}
8000694e:	91 00 00 26 	movh.a %a2,24576
80006952:	19 22 f0 10 	ld.w %d2,[%a2]3184 <60000c70 <Mode_flag>>
80006956:	df 02 0b 00 	jeq %d2,0,8000696c <blue_led_onoff+0x20>
8000695a:	91 00 00 26 	movh.a %a2,24576
8000695e:	19 23 d4 20 	ld.w %d3,[%a2]3220 <60000c94 <Sudden_accel_flag>>
80006962:	df 13 05 00 	jeq %d3,1,8000696c <blue_led_onoff+0x20>
    else if(Mode_flag == 1){IfxPort_setPinHigh(PORT_B_LED);}
80006966:	df 12 0c 00 	jeq %d2,1,8000697e <blue_led_onoff+0x32>
}
8000696a:	00 90       	ret 
8000696c:	91 40 00 2f 	movh.a %a2,61444
80006970:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
80006974:	7b 00 02 20 	movh %d2,32
80006978:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
}
8000697c:	00 90       	ret 
    port->OMR.U = action << pinIndex;
8000697e:	91 40 00 2f 	movh.a %a2,61444
80006982:	d9 22 00 8a 	lea %a2,[%a2]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
80006986:	3b 00 02 20 	mov %d2,32
8000698a:	59 22 04 00 	st.w [%a2]4 <f0040004 <_SMALL_DATA4_+0x60038004>>,%d2
8000698e:	1d ff ee ff 	j 8000696a <blue_led_onoff+0x1e>

80006992 <init_GPIO>:
 */

#include "GPIO.h"

void init_GPIO(void)
{
80006992:	40 ae       	mov.aa %a14,%sp
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)(index | mode));
80006994:	3b 00 08 50 	mov %d5,128
80006998:	82 44       	mov %d4,4
8000699a:	91 40 00 4f 	movh.a %a4,61444
8000699e:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800069a2:	6d ff 0b e6 	call 800035b8 <IfxPort_setPinMode>
800069a6:	3b 00 08 50 	mov %d5,128
800069aa:	82 54       	mov %d4,5
800069ac:	91 40 00 4f 	movh.a %a4,61444
800069b0:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800069b4:	6d ff 02 e6 	call 800035b8 <IfxPort_setPinMode>
800069b8:	3b 00 08 50 	mov %d5,128
800069bc:	82 74       	mov %d4,7
800069be:	91 40 00 4f 	movh.a %a4,61444
800069c2:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800069c6:	6d ff f9 e5 	call 800035b8 <IfxPort_setPinMode>
800069ca:	3b 00 08 50 	mov %d5,128
800069ce:	82 54       	mov %d4,5
800069d0:	91 40 00 4f 	movh.a %a4,61444
800069d4:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
800069d8:	6d ff f0 e5 	call 800035b8 <IfxPort_setPinMode>
800069dc:	3b 00 08 50 	mov %d5,128
800069e0:	82 44       	mov %d4,4
800069e2:	91 40 00 4f 	movh.a %a4,61444
800069e6:	d9 44 00 0a 	lea %a4,[%a4]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
800069ea:	6d ff e7 e5 	call 800035b8 <IfxPort_setPinMode>
800069ee:	3b 00 08 50 	mov %d5,128
800069f2:	82 34       	mov %d4,3
800069f4:	91 40 00 4f 	movh.a %a4,61444
800069f8:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
800069fc:	6d ff de e5 	call 800035b8 <IfxPort_setPinMode>
80006a00:	3b 00 08 50 	mov %d5,128
80006a04:	82 24       	mov %d4,2
80006a06:	91 40 00 4f 	movh.a %a4,61444
80006a0a:	d9 44 00 0b 	lea %a4,[%a4]-20480 <f003b000 <_SMALL_DATA4_+0x60033000>>
80006a0e:	6d ff d5 e5 	call 800035b8 <IfxPort_setPinMode>
80006a12:	3b 00 08 50 	mov %d5,128
80006a16:	82 64       	mov %d4,6
80006a18:	91 40 00 4f 	movh.a %a4,61444
80006a1c:	d9 44 40 4b 	lea %a4,[%a4]-19200 <f003b500 <_SMALL_DATA4_+0x60033500>>
80006a20:	6d ff cc e5 	call 800035b8 <IfxPort_setPinMode>
80006a24:	3b 00 08 50 	mov %d5,128
80006a28:	82 64       	mov %d4,6
80006a2a:	91 40 00 4f 	movh.a %a4,61444
80006a2e:	d9 44 00 4b 	lea %a4,[%a4]-20224 <f003b100 <_SMALL_DATA4_+0x60033100>>
80006a32:	6d ff c3 e5 	call 800035b8 <IfxPort_setPinMode>
    IfxPort_setPinMode(port, pinIndex, (IfxPort_Mode)mode);
80006a36:	3b 00 01 50 	mov %d5,16
80006a3a:	82 04       	mov %d4,0
80006a3c:	91 40 00 4f 	movh.a %a4,61444
80006a40:	d9 44 00 8a 	lea %a4,[%a4]-24064 <f003a200 <_SMALL_DATA4_+0x60032200>>
80006a44:	6d ff ba e5 	call 800035b8 <IfxPort_setPinMode>
80006a48:	3b 80 00 50 	mov %d5,8
80006a4c:	82 04       	mov %d4,0
80006a4e:	91 40 00 4f 	movh.a %a4,61444
80006a52:	d9 44 00 0a 	lea %a4,[%a4]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80006a56:	6d ff b1 e5 	call 800035b8 <IfxPort_setPinMode>
80006a5a:	3b 80 00 50 	mov %d5,8
80006a5e:	82 14       	mov %d4,1
80006a60:	91 40 00 4f 	movh.a %a4,61444
80006a64:	d9 44 00 0a 	lea %a4,[%a4]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80006a68:	6d ff a8 e5 	call 800035b8 <IfxPort_setPinMode>
80006a6c:	3b 80 00 50 	mov %d5,8
80006a70:	02 54       	mov %d4,%d5
80006a72:	91 40 00 4f 	movh.a %a4,61444
80006a76:	d9 44 00 0a 	lea %a4,[%a4]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80006a7a:	6d ff 9f e5 	call 800035b8 <IfxPort_setPinMode>
80006a7e:	3b 80 00 50 	mov %d5,8
80006a82:	82 24       	mov %d4,2
80006a84:	91 40 00 4f 	movh.a %a4,61444
80006a88:	d9 44 00 4b 	lea %a4,[%a4]-20224 <f003b100 <_SMALL_DATA4_+0x60033100>>
80006a8c:	6d ff 96 e5 	call 800035b8 <IfxPort_setPinMode>
    IfxPort_setPinModeInput(PORT_SW1, IfxPort_InputMode_pullUp);
    IfxPort_setPinModeInput(PORT_ENCODER_A, IfxPort_InputMode_pullDown);
    IfxPort_setPinModeInput(PORT_ENCODER_B, IfxPort_InputMode_pullDown);
    IfxPort_setPinModeInput(PORT_ECHO_MAIN, IfxPort_InputMode_pullDown);
    IfxPort_setPinModeInput(PORT_ECHO_SUB, IfxPort_InputMode_pullDown);
}
80006a90:	00 90       	ret 

80006a92 <low_pass_filter>:

float alpha_Encoder = 0.01;   // 저역 필터의 alpha 값 (컷오프 주파수에 따라 조정)


// LOW pass filter
float low_pass_filter(float input, float alpha) {
80006a92:	40 ae       	mov.aa %a14,%sp
    float output = alpha * input + (1 - alpha) * prev_output_low;
80006a94:	4b 45 41 40 	mul.f %d4,%d5,%d4
80006a98:	7b 00 f8 23 	movh %d2,16256
80006a9c:	6b 05 31 22 	sub.f %d2,%d2,%d5
80006aa0:	91 00 00 26 	movh.a %a2,24576
80006aa4:	d9 23 f4 00 	lea %a3,[%a2]3124 <60000c34 <prev_output_low>>
80006aa8:	54 33       	ld.w %d3,[%a3]
80006aaa:	4b 32 41 20 	mul.f %d2,%d2,%d3
80006aae:	6b 02 21 24 	add.f %d2,%d4,%d2
    prev_output_low = output;  // 이전 출력 값 업데이트
80006ab2:	74 32       	st.w [%a3],%d2
    return output;
}
80006ab4:	00 90       	ret 

80006ab6 <Encoder>:


void Encoder(void){
80006ab6:	40 ae       	mov.aa %a14,%sp
    return (__getbit(&port->IN.U, pinIndex) != 0) ? TRUE : FALSE;
80006ab8:	91 40 00 2f 	movh.a %a2,61444
80006abc:	d9 22 00 0a 	lea %a2,[%a2]-24576 <f003a000 <_SMALL_DATA4_+0x60032000>>
80006ac0:	d9 23 24 00 	lea %a3,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
80006ac4:	19 22 24 00 	ld.w %d2,[%a2]36 <f0040024 <_SMALL_DATA4_+0x60038024>>
80006ac8:	8f 12 00 51 	and %d5,%d2,1
80006acc:	54 33       	ld.w %d3,[%a3]
80006ace:	37 03 e1 40 	extr.u %d4,%d3,1,1
    uint8 A = IfxPort_getPinState(PORT_ENCODER_A);
    uint8 B = IfxPort_getPinState(PORT_ENCODER_B);

    uint8 state = 0;

    if      (A==0 && B==0){state = 0;}
80006ad2:	87 23 21 20 	or.t %d2,%d3,1,%d2,0
80006ad6:	df 02 14 00 	jeq %d2,0,80006afe <Encoder+0x48>
    else if (A==1 && B==0){state = 1;}
80006ada:	02 53       	mov %d3,%d5
80006adc:	8f 14 80 21 	xor %d2,%d4,1
80006ae0:	26 52       	and %d2,%d5
80006ae2:	df 02 0d 80 	jne %d2,0,80006afc <Encoder+0x46>
    else if (A==1 && B==1){state = 2;}
80006ae6:	26 43       	and %d3,%d4
80006ae8:	df 03 3c 80 	jne %d3,0,80006b60 <Encoder+0xaa>
    else if (A==0 && B==1){state = 3;}
80006aec:	8f 15 80 21 	xor %d2,%d5,1
80006af0:	26 42       	and %d2,%d4
80006af2:	df 02 06 00 	jeq %d2,0,80006afe <Encoder+0x48>
80006af6:	82 32       	mov %d2,3
80006af8:	1d 00 03 00 	j 80006afe <Encoder+0x48>
    else if (A==1 && B==0){state = 1;}
80006afc:	82 12       	mov %d2,1

    if      (state-state_old==1 || state-state_old==-3) {encoderCNT++; encoderDir = 1;}
80006afe:	91 00 00 26 	movh.a %a2,24576
80006b02:	39 23 f0 50 	ld.bu %d3,[%a2]3440 <60000d70 <state_old>>
80006b06:	0b 32 80 30 	sub %d3,%d2,%d3
80006b0a:	8b 13 00 42 	eq %d4,%d3,1
80006b0e:	8b d3 ff 44 	or.eq %d4,%d3,-3
80006b12:	df 04 2a 00 	jeq %d4,0,80006b66 <Encoder+0xb0>
80006b16:	91 00 00 26 	movh.a %a2,24576
80006b1a:	d9 23 ec 50 	lea %a3,[%a2]3436 <60000d6c <encoderCNT>>
80006b1e:	54 33       	ld.w %d3,[%a3]
80006b20:	c2 13       	add %d3,1
80006b22:	59 23 ec 50 	st.w [%a2]3436 <60000d6c <encoderCNT>>,%d3
80006b26:	91 00 00 26 	movh.a %a2,24576
80006b2a:	82 13       	mov %d3,1
80006b2c:	59 23 e8 50 	st.w [%a2]3432 <60000d68 <encoderDir>>,%d3
    else if (state-state_old==-1 || state-state_old==3) {encoderCNT--; encoderDir = -1;}

    //theta = encoderCNT*0.01*0.25*360;

    theta = (float)encoderCNT*360/48;
80006b30:	91 00 00 26 	movh.a %a2,24576
80006b34:	19 23 ec 50 	ld.w %d3,[%a2]3436 <60000d6c <encoderCNT>>
80006b38:	4b 03 41 31 	itof %d3,%d3
80006b3c:	7b 40 3b 44 	movh %d4,17332
80006b40:	4b 43 41 30 	mul.f %d3,%d3,%d4
80006b44:	7b 00 24 44 	movh %d4,16960
80006b48:	4b 43 51 30 	div.f %d3,%d3,%d4
80006b4c:	91 00 00 26 	movh.a %a2,24576
80006b50:	d9 22 e4 50 	lea %a2,[%a2]3428 <60000d64 <theta>>
80006b54:	74 23       	st.w [%a2],%d3

    state_old = state;
80006b56:	91 00 00 26 	movh.a %a2,24576
80006b5a:	e9 22 f0 50 	st.b [%a2]3440 <60000d70 <state_old>>,%d2

}
80006b5e:	00 90       	ret 
    else if (A==1 && B==1){state = 2;}
80006b60:	82 22       	mov %d2,2
80006b62:	1d ff ce ff 	j 80006afe <Encoder+0x48>
    else if (state-state_old==-1 || state-state_old==3) {encoderCNT--; encoderDir = -1;}
80006b66:	8b f3 1f 42 	eq %d4,%d3,-1
80006b6a:	8b 33 e0 44 	or.eq %d4,%d3,3
80006b6e:	df 04 e1 7f 	jeq %d4,0,80006b30 <Encoder+0x7a>
80006b72:	91 00 00 26 	movh.a %a2,24576
80006b76:	d9 23 ec 50 	lea %a3,[%a2]3436 <60000d6c <encoderCNT>>
80006b7a:	54 33       	ld.w %d3,[%a3]
80006b7c:	c2 f3       	add %d3,-1
80006b7e:	59 23 ec 50 	st.w [%a2]3436 <60000d6c <encoderCNT>>,%d3
80006b82:	91 00 00 26 	movh.a %a2,24576
80006b86:	82 f3       	mov %d3,-1
80006b88:	59 23 e8 50 	st.w [%a2]3432 <60000d68 <encoderDir>>,%d3
80006b8c:	1d ff d2 ff 	j 80006b30 <Encoder+0x7a>

80006b90 <radiantospeed>:



void radiantospeed(void)
{
80006b90:	40 ae       	mov.aa %a14,%sp
    float32 deltaT = 0.001; // 0.001

    float Raw_Speed = theta/deltaT;
80006b92:	91 00 00 26 	movh.a %a2,24576
80006b96:	d9 22 e4 50 	lea %a2,[%a2]3428 <60000d64 <theta>>
80006b9a:	54 22       	ld.w %d2,[%a2]
    //float Raw_Speed = theta;
    // low pass filter 적용
    float LPF_theta = low_pass_filter(Raw_Speed,alpha_Encoder);
80006b9c:	91 00 00 26 	movh.a %a2,24576
80006ba0:	d9 22 64 60 	lea %a2,[%a2]1444 <600005a4 <alpha_Encoder>>
80006ba4:	54 25       	ld.w %d5,[%a2]
80006ba6:	7b 30 a8 43 	movh %d4,14979
80006baa:	1b f4 26 41 	addi %d4,%d4,4719
80006bae:	4b 42 51 40 	div.f %d4,%d2,%d4
80006bb2:	6d ff 70 ff 	call 80006a92 <low_pass_filter>

    //velocity_rad = Filtered_speed;
    velocity_rad = LPF_theta;
80006bb6:	91 00 00 26 	movh.a %a2,24576
80006bba:	d9 22 dc 50 	lea %a2,[%a2]3420 <60000d5c <velocity_rad>>
80006bbe:	74 22       	st.w [%a2],%d2
    //velocity_rad = HPF_theta;

    //velocity_rad = theta / deltaT;
    //velocity_rpm = velocity_rad*9.5493;
    encoderCNT = 0;
80006bc0:	91 00 00 26 	movh.a %a2,24576
80006bc4:	82 02       	mov %d2,0
80006bc6:	59 22 ec 50 	st.w [%a2]3436 <60000d6c <encoderCNT>>,%d2

   //  return velocity_rpm;
}
80006bca:	00 90       	ret 

80006bcc <init_ADC_Group>:
 */


#include "ADC.h"

void init_ADC_Group(void){
80006bcc:	40 ae       	mov.aa %a14,%sp
80006bce:	20 a8       	sub.a %sp,168
    IfxVadc_Adc_Config  adcConf;
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);
80006bd0:	91 20 00 5f 	movh.a %a5,61442
80006bd4:	d9 e4 d8 ff 	lea %a4,[%a14]-40
80006bd8:	6d ff 2d de 	call 80002832 <IfxVadc_Adc_initModuleConfig>
    IfxVadc_Adc_initModule(&Vadc, &adcConf);
80006bdc:	91 00 00 c6 	movh.a %a12,24576
80006be0:	d9 cc f0 70 	lea %a12,[%a12]3568 <60000df0 <Vadc>>
80006be4:	d9 e5 d8 ff 	lea %a5,[%a14]-40 <60000df0 <Vadc>>
80006be8:	40 c4       	mov.aa %a4,%a12
80006bea:	6d ff 9a dd 	call 8000271e <IfxVadc_Adc_initModule>

    IfxVadc_Adc_GroupConfig  adcGroupConf;
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &Vadc);
80006bee:	40 c5       	mov.aa %a5,%a12
80006bf0:	d9 e4 dc df 	lea %a4,[%a14]-164
80006bf4:	6d ff 7a dd 	call 800026e8 <IfxVadc_Adc_initGroupConfig>

    adcGroupConf.groupId = IfxVadc_GroupId_4;
80006bf8:	82 42       	mov %d2,4
80006bfa:	59 e2 e0 df 	st.w [%a14]-160,%d2
    adcGroupConf.master = adcGroupConf.groupId;
80006bfe:	59 e2 e4 df 	st.w [%a14]-156,%d2

    adcGroupConf.arbiter.requestSlotScanEnabled = TRUE;
80006c02:	82 12       	mov %d2,1
80006c04:	e9 e2 d5 ff 	st.b [%a14]-43,%d2
    adcGroupConf.scanRequest.autoscanEnabled = TRUE;
80006c08:	e9 e2 f8 df 	st.b [%a14]-136,%d2

    adcGroupConf.scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;
80006c0c:	82 12       	mov %d2,1
80006c0e:	59 e2 c4 ef 	st.w [%a14]-124,%d2

    IfxVadc_Adc_initGroup(&adcGroup4, &adcGroupConf);
80006c12:	d9 e5 dc df 	lea %a5,[%a14]-164
80006c16:	91 00 00 46 	movh.a %a4,24576
80006c1a:	d9 44 e4 70 	lea %a4,[%a4]3556 <60000de4 <adcGroup4>>
80006c1e:	6d ff 23 db 	call 80002264 <IfxVadc_Adc_initGroup>
}
80006c22:	00 90       	ret 

80006c24 <init_ADC_G4_SingleCh>:

void init_ADC_G4_SingleCh(uint8 Channel){
80006c24:	40 ae       	mov.aa %a14,%sp
80006c26:	20 40       	sub.a %sp,64
80006c28:	8f f4 0f 81 	and %d8,%d4,255
    IfxVadc_Adc_ChannelConfig   adcChannelConfigInfo;
    uint32 ulTemp = ((uint32)1u << Channel);
80006c2c:	82 19       	mov %d9,1
80006c2e:	0f 89 00 90 	sh %d9,%d9,%d8

    IfxVadc_Adc_initChannelConfig(&adcChannelConfigInfo, &adcGroup4);
80006c32:	91 00 00 c6 	movh.a %a12,24576
80006c36:	d9 cc e4 70 	lea %a12,[%a12]3556 <60000de4 <adcGroup4>>
80006c3a:	40 c5       	mov.aa %a5,%a12
80006c3c:	d9 e4 c4 ff 	lea %a4,[%a14]-60
80006c40:	6d ff 07 db 	call 8000224e <IfxVadc_Adc_initChannelConfig>

    adcChannelConfigInfo.channelId       = (IfxVadc_ChannelId) Channel;
80006c44:	59 e8 dc ff 	st.w [%a14]-36,%d8
    adcChannelConfigInfo.resultRegister  = (IfxVadc_ChannelResult)Channel;
80006c48:	59 e8 e8 ff 	st.w [%a14]-24,%d8

    IfxVadc_Adc_initChannel(&adcG4Channel[Channel], &adcChannelConfigInfo);
80006c4c:	d9 e5 c4 ff 	lea %a5,[%a14]-60
80006c50:	91 00 00 46 	movh.a %a4,24576
80006c54:	d9 44 c4 60 	lea %a4,[%a4]3460 <60000d84 <adcG4Channel>>
80006c58:	01 48 03 46 	addsc.a %a4,%a4,%d8,3
80006c5c:	01 48 02 46 	addsc.a %a4,%a4,%d8,2
80006c60:	6d ff e5 d9 	call 8000202a <IfxVadc_Adc_initChannel>
}


IFX_INLINE void IfxVadc_Adc_setScan(IfxVadc_Adc_Group *group, uint32 channels, uint32 mask)
{
    IfxVadc_setScan(group->group, channels, mask);
80006c64:	02 95       	mov %d5,%d9
80006c66:	02 94       	mov %d4,%d9
80006c68:	99 c4 04 00 	ld.a %a4,[%a12]4 <60000004 <LCF_DSPR1_START+0x4>>
80006c6c:	6d ff ab d9 	call 80001fc2 <IfxVadc_setScan>

    IfxVadc_Adc_setScan(&adcGroup4, ulTemp, ulTemp);
}
80006c70:	00 90       	ret 

80006c72 <init_ADC_G4_Channel>:

void init_ADC_G4_Channel(void){
80006c72:	40 ae       	mov.aa %a14,%sp
    init_ADC_G4_SingleCh(ADC_G4_CH0);
80006c74:	82 04       	mov %d4,0
80006c76:	6d ff d7 ff 	call 80006c24 <init_ADC_G4_SingleCh>
    init_ADC_G4_SingleCh(ADC_G4_CH1);
80006c7a:	82 14       	mov %d4,1
80006c7c:	6d ff d4 ff 	call 80006c24 <init_ADC_G4_SingleCh>
    init_ADC_G4_SingleCh(ADC_G4_CH2);
80006c80:	82 24       	mov %d4,2
80006c82:	6d ff d1 ff 	call 80006c24 <init_ADC_G4_SingleCh>
    init_ADC_G4_SingleCh(ADC_G4_CH3);
80006c86:	82 34       	mov %d4,3
80006c88:	6d ff ce ff 	call 80006c24 <init_ADC_G4_SingleCh>
    init_ADC_G4_SingleCh(ADC_G4_CH4);
80006c8c:	82 44       	mov %d4,4
80006c8e:	6d ff cb ff 	call 80006c24 <init_ADC_G4_SingleCh>
    init_ADC_G4_SingleCh(ADC_G4_CH5);
80006c92:	82 54       	mov %d4,5
80006c94:	6d ff c8 ff 	call 80006c24 <init_ADC_G4_SingleCh>
    init_ADC_G4_SingleCh(ADC_G4_CH6);
80006c98:	82 64       	mov %d4,6
80006c9a:	6d ff c5 ff 	call 80006c24 <init_ADC_G4_SingleCh>
    init_ADC_G4_SingleCh(ADC_G4_CH7);
80006c9e:	82 74       	mov %d4,7
80006ca0:	6d ff c2 ff 	call 80006c24 <init_ADC_G4_SingleCh>
}


IFX_INLINE void IfxVadc_Adc_startScan(IfxVadc_Adc_Group *group)
{
    IfxVadc_startScan(group->group);
80006ca4:	91 00 00 26 	movh.a %a2,24576
80006ca8:	d9 22 e4 70 	lea %a2,[%a2]3556 <60000de4 <adcGroup4>>
80006cac:	b0 42       	add.a %a2,4
80006cae:	d4 22       	ld.a %a2,[%a2]
    group->ASMR.B.LDEV = 1;     /* set Load event. Channels stored in ASSEL will be copied into pending register and conversion will start */
80006cb0:	d9 23 24 20 	lea %a3,[%a2]164
80006cb4:	19 22 24 20 	ld.w %d2,[%a2]164
80006cb8:	b7 12 81 24 	insert %d2,%d2,1,9,1
80006cbc:	74 32       	st.w [%a3],%d2

    IfxVadc_Adc_startScan(&adcGroup4);
}
80006cbe:	00 90       	ret 

80006cc0 <ADC_G4_GetData>:

void ADC_G4_GetData(void){
80006cc0:	40 ae       	mov.aa %a14,%sp
    Ifx_VADC_RES        ADC_result;

    uint8 ch;
    for(ch = ADC_G4_CH0; ch<ADC_G4_MAX; ch++){
80006cc2:	82 03       	mov %d3,0
80006cc4:	1d 00 25 00 	j 80006d0e <ADC_G4_GetData+0x4e>
    return IfxVadc_getResult(channel->group->group, channel->resultreg);
80006cc8:	91 00 00 26 	movh.a %a2,24576
80006ccc:	80 22       	mov.d %d2,%a2
80006cce:	1b 42 d8 20 	addi %d2,%d2,3460
80006cd2:	13 c3 20 22 	madd %d2,%d2,%d3,12
80006cd6:	60 22       	mov.a %a2,%d2
80006cd8:	99 23 08 00 	ld.a %a3,[%a2]8
80006cdc:	19 34 04 00 	ld.w %d4,[%a3]4
80006ce0:	19 22 04 00 	ld.w %d2,[%a2]4
    tmpResult.U = group->RES[resultIdx].U;
80006ce4:	1b 02 0a 20 	addi %d2,%d2,160
80006ce8:	06 22       	sh %d2,2
80006cea:	60 42       	mov.a %a2,%d4
80006cec:	01 22 00 26 	addsc.a %a2,%a2,%d2,0
80006cf0:	54 22       	ld.w %d2,[%a2]
        do{
            ADC_result = IfxVadc_Adc_getResult(&adcG4Channel[ch]);
        }while(!ADC_result.B.VF);
80006cf2:	ff 02 eb 7f 	jge %d2,0,80006cc8 <ADC_G4_GetData+0x8>

        ADC_G4_RAWDATA[ch] = ADC_result.B.RESULT;
80006cf6:	8f 13 00 40 	sh %d4,%d3,1
80006cfa:	91 00 00 26 	movh.a %a2,24576
80006cfe:	d9 22 f4 50 	lea %a2,[%a2]3444 <60000d74 <ADC_G4_RAWDATA>>
80006d02:	01 24 00 26 	addsc.a %a2,%a2,%d4,0
80006d06:	b4 22       	st.h [%a2],%d2
    for(ch = ADC_G4_CH0; ch<ADC_G4_MAX; ch++){
80006d08:	c2 13       	add %d3,1
80006d0a:	8f f3 0f 31 	and %d3,%d3,255
80006d0e:	bf 83 dd ff 	jlt.u %d3,8,80006cc8 <ADC_G4_GetData+0x8>
    IfxVadc_startScan(group->group);
80006d12:	91 00 00 26 	movh.a %a2,24576
80006d16:	d9 22 e4 70 	lea %a2,[%a2]3556 <60000de4 <adcGroup4>>
80006d1a:	b0 42       	add.a %a2,4
80006d1c:	d4 22       	ld.a %a2,[%a2]
    group->ASMR.B.LDEV = 1;     /* set Load event. Channels stored in ASSEL will be copied into pending register and conversion will start */
80006d1e:	d9 23 24 20 	lea %a3,[%a2]164
80006d22:	19 22 24 20 	ld.w %d2,[%a2]164
80006d26:	b7 12 81 24 	insert %d2,%d2,1,9,1
80006d2a:	74 32       	st.w [%a3],%d2
    }

    IfxVadc_Adc_startScan(&adcGroup4);
}
80006d2c:	00 90       	ret 

80006d2e <core0_main>:

IfxCpu_syncEvent g_cpuSyncEvent = 0;


void core0_main(void)
{
80006d2e:	40 ae       	mov.aa %a14,%sp
    __enable();
80006d30:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80006d34:	6d ff d8 e3 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80006d38:	02 24       	mov %d4,%d2
80006d3a:	6d ff b9 e2 	call 800032ac <IfxScuWdt_disableCpuWatchdog>
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
80006d3e:	6d ff e5 e3 	call 80003508 <IfxScuWdt_getSafetyWatchdogPassword>
80006d42:	02 24       	mov %d4,%d2
80006d44:	6d ff f3 e2 	call 8000332a <IfxScuWdt_disableSafetyWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80006d48:	91 00 00 c6 	movh.a %a12,24576
80006d4c:	d9 cc f8 00 	lea %a12,[%a12]3128 <60000c38 <g_cpuSyncEvent>>
80006d50:	40 c4       	mov.aa %a4,%a12
80006d52:	6d ff 35 f2 	call 800051bc <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80006d56:	82 14       	mov %d4,1
80006d58:	40 c4       	mov.aa %a4,%a12
80006d5a:	6d ff f1 f1 	call 8000513c <IfxCpu_waitEvent>

    init_GPIO();
80006d5e:	6d ff 1a fe 	call 80006992 <init_GPIO>
    init_STM();
80006d62:	6d ff 3e d2 	call 800011de <init_STM>
    init_ADC_Group();
80006d66:	6d ff 33 ff 	call 80006bcc <init_ADC_Group>
    init_ADC_G4_Channel();
80006d6a:	6d ff 84 ff 	call 80006c72 <init_ADC_G4_Channel>
    init_GTM();
80006d6e:	6d ff 9c d3 	call 800014a6 <init_GTM>
    init_UART_PC();
80006d72:	6d ff 9e ce 	call 80000aae <init_UART_PC>
    init_UART_SUB();
80006d76:	6d ff 3e d0 	call 80000df2 <init_UART_SUB>
    init_PID();
80006d7a:	6d ff 51 d4 	call 8000161c <init_PID>
    Sudden_accel_flag = 0;
80006d7e:	91 00 00 26 	movh.a %a2,24576
80006d82:	82 02       	mov %d2,0
80006d84:	59 22 d4 20 	st.w [%a2]3220 <60000c94 <Sudden_accel_flag>>,%d2

    while(1)
    {
        AppScheduling();
80006d88:	6d ff d3 d1 	call 8000112e <AppScheduling>
    while(1)
80006d8c:	1d ff fe ff 	j 80006d88 <core0_main+0x5a>

80006d90 <core1_main>:
#include "Header_USER.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core1_main(void)
{
80006d90:	40 ae       	mov.aa %a14,%sp
80006d92:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG1 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80006d96:	6d ff a7 e3 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80006d9a:	02 24       	mov %d4,%d2
80006d9c:	6d ff 88 e2 	call 800032ac <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80006da0:	91 00 00 c6 	movh.a %a12,24576
80006da4:	d9 cc f8 00 	lea %a12,[%a12]3128 <60000c38 <g_cpuSyncEvent>>
80006da8:	40 c4       	mov.aa %a4,%a12
80006daa:	6d ff 09 f2 	call 800051bc <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80006dae:	82 14       	mov %d4,1
80006db0:	40 c4       	mov.aa %a4,%a12
80006db2:	6d ff c5 f1 	call 8000513c <IfxCpu_waitEvent>
    
    while(1)
    {
        Encoder();
80006db6:	6d ff 80 fe 	call 80006ab6 <Encoder>
    while(1)
80006dba:	1d ff fe ff 	j 80006db6 <core1_main+0x26>

80006dbe <core2_main>:
#include "IfxScuWdt.h"

extern IfxCpu_syncEvent g_cpuSyncEvent;

void core2_main(void)
{
80006dbe:	40 ae       	mov.aa %a14,%sp
80006dc0:	0d 00 00 03 	enable 
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG2 IS DISABLED HERE!!
     * Enable the watchdog and service it periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
80006dc4:	6d ff 90 e3 	call 800034e4 <IfxScuWdt_getCpuWatchdogPassword>
80006dc8:	02 24       	mov %d4,%d2
80006dca:	6d ff 71 e2 	call 800032ac <IfxScuWdt_disableCpuWatchdog>
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
80006dce:	91 00 00 c6 	movh.a %a12,24576
80006dd2:	d9 cc f8 00 	lea %a12,[%a12]3128 <60000c38 <g_cpuSyncEvent>>
80006dd6:	40 c4       	mov.aa %a4,%a12
80006dd8:	6d ff f2 f1 	call 800051bc <IfxCpu_emitEvent>
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
80006ddc:	82 14       	mov %d4,1
80006dde:	40 c4       	mov.aa %a4,%a12
80006de0:	6d ff ae f1 	call 8000513c <IfxCpu_waitEvent>
    
    while(1)
80006de4:	1d 00 00 00 	j 80006de4 <core2_main+0x26>

80006de8 <memset>:
80006de8:	40 42       	mov.aa %a2,%a4
80006dea:	df 05 07 00 	jeq %d5,0,80006df8 <memset+0x10>
80006dee:	60 53       	mov.a %a3,%d5
80006df0:	b0 f3       	add.a %a3,-1
80006df2:	24 44       	st.b [%a4+],%d4
80006df4:	fd 30 ff 7f 	loop %a3,80006df2 <memset+0xa>
80006df8:	00 90       	ret 

80006dfa <__extendsfdf2>:
80006dfa:	20 20       	sub.a %sp,32
80006dfc:	d9 a5 10 00 	lea %a5,[%sp]16
80006e00:	d9 a4 0c 00 	lea %a4,[%sp]12
80006e04:	59 a4 0c 00 	st.w [%sp]12,%d4
80006e08:	6d 00 d0 02 	call 800073a8 <__unpack_f>
80006e0c:	19 a2 1c 00 	ld.w %d2,[%sp]28
80006e10:	19 a6 18 00 	ld.w %d6,[%sp]24
80006e14:	53 12 40 40 	mul.u %e4,%d2,1
80006e18:	77 45 00 3f 	dextr %d3,%d5,%d4,30
80006e1c:	8f e4 01 20 	sh %d2,%d4,30
80006e20:	19 a5 14 00 	ld.w %d5,[%sp]20
80006e24:	19 a4 10 00 	ld.w %d4,[%sp]16
80006e28:	74 a2       	st.w [%sp],%d2
80006e2a:	59 a3 04 00 	st.w [%sp]4,%d3
80006e2e:	6d 00 8e 02 	call 8000734a <__make_dp>
80006e32:	00 90       	ret 

80006e34 <_fpadd_parts>:
80006e34:	54 42       	ld.w %d2,[%a4]
80006e36:	40 42       	mov.aa %a2,%a4
80006e38:	bf 22 c2 80 	jlt.u %d2,2,80006fbc <_fpadd_parts+0x188>
80006e3c:	54 53       	ld.w %d3,[%a5]
80006e3e:	40 52       	mov.aa %a2,%a5
80006e40:	bf 23 be 80 	jlt.u %d3,2,80006fbc <_fpadd_parts+0x188>
80006e44:	df 42 e3 00 	jeq %d2,4,8000700a <_fpadd_parts+0x1d6>
80006e48:	df 43 ba 00 	jeq %d3,4,80006fbc <_fpadd_parts+0x188>
80006e4c:	df 23 b9 00 	jeq %d3,2,80006fbe <_fpadd_parts+0x18a>
80006e50:	df 22 b6 00 	jeq %d2,2,80006fbc <_fpadd_parts+0x188>
80006e54:	19 40 08 00 	ld.w %d0,[%a4]8
80006e58:	19 57 08 00 	ld.w %d7,[%a5]8
80006e5c:	09 44 4c 09 	ld.d %e4,[%a4]12
80006e60:	0b 70 80 60 	sub %d6,%d0,%d7
80006e64:	09 52 4c 09 	ld.d %e2,[%a5]12
80006e68:	bf 06 c2 00 	jlt %d6,0,80006fec <_fpadd_parts+0x1b8>
80006e6c:	8b 06 84 12 	ge %d1,%d6,64
80006e70:	df 01 c4 80 	jne %d1,0,80006ff8 <_fpadd_parts+0x1c4>
80006e74:	df 06 2a 00 	jeq %d6,0,80006ec8 <_fpadd_parts+0x94>
80006e78:	8b 06 82 72 	ge %d7,%d6,32
80006e7c:	2b 32 50 97 	seln %d9,%d7,%d2,%d3
80006e80:	ab 03 a0 87 	seln %d8,%d7,%d3,0
80006e84:	8f f6 01 71 	and %d7,%d6,31
80006e88:	8b 07 02 11 	rsub %d1,%d7,32
80006e8c:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
80006e90:	2b 91 40 17 	sel %d1,%d7,%d1,%d9
80006e94:	8b 06 82 a2 	ge %d10,%d6,32
80006e98:	32 57       	rsub %d7
80006e9a:	02 19       	mov %d9,%d1
80006e9c:	8f f6 01 61 	and %d6,%d6,31
80006ea0:	82 f1       	mov %d1,-1
80006ea2:	0f 78 00 80 	sh %d8,%d8,%d7
80006ea6:	17 11 80 76 	dextr %d7,%d1,%d1,%d6
80006eaa:	0f 61 00 60 	sh %d6,%d1,%d6
80006eae:	2b 67 50 7a 	seln %d7,%d10,%d7,%d6
80006eb2:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
80006eb6:	0f 62 e0 10 	andn %d1,%d2,%d6
80006eba:	0f 73 e0 60 	andn %d6,%d3,%d7
80006ebe:	a6 16       	or %d6,%d1
80006ec0:	8b 06 00 95 	or.ne %d9,%d6,0
80006ec4:	0b 98 10 28 	mov %e2,%d8,%d9
80006ec8:	19 41 04 00 	ld.w %d1,[%a4]4
80006ecc:	19 56 04 00 	ld.w %d6,[%a5]4
80006ed0:	5f 61 4c 00 	jeq %d1,%d6,80006f68 <_fpadd_parts+0x134>
80006ed4:	0b 24 c0 60 	subx %d6,%d4,%d2
80006ed8:	0b 35 d0 70 	subc %d7,%d5,%d3
80006edc:	df 01 06 00 	jeq %d1,0,80006ee8 <_fpadd_parts+0xb4>
80006ee0:	0b 42 c0 60 	subx %d6,%d2,%d4
80006ee4:	0b 53 d0 70 	subc %d7,%d3,%d5
80006ee8:	8b 07 00 31 	rsub %d3,%d7,0
80006eec:	8b 06 00 91 	rsub %d9,%d6,0
80006ef0:	ab f3 1f 36 	cadd %d3,%d6,%d3,-1
80006ef4:	82 12       	mov %d2,1
80006ef6:	bf 07 05 00 	jlt %d7,0,80006f00 <_fpadd_parts+0xcc>
80006efa:	02 69       	mov %d9,%d6
80006efc:	02 73       	mov %d3,%d7
80006efe:	82 02       	mov %d2,0
80006f00:	8b f9 9f 70 	addx %d7,%d9,-1
80006f04:	82 f5       	mov %d5,-1
80006f06:	8b f3 bf 60 	addc %d6,%d3,-1
80006f0a:	06 c5       	sh %d5,-4
80006f0c:	59 62 04 00 	st.w [%a6]4,%d2
80006f10:	82 e1       	mov %d1,-2
80006f12:	0b 56 00 21 	eq %d2,%d6,%d5
80006f16:	0b 71 30 22 	and.lt.u %d2,%d1,%d7
80006f1a:	59 60 08 00 	st.w [%a6]8,%d0
80006f1e:	59 69 0c 00 	st.w [%a6]12,%d9
80006f22:	59 63 10 00 	st.w [%a6]16,%d3
80006f26:	0b 65 a0 22 	or.lt.u %d2,%d5,%d6
80006f2a:	df 02 2b 80 	jne %d2,0,80006f80 <_fpadd_parts+0x14c>
80006f2e:	1b f0 ff 7f 	addi %d7,%d0,-1
80006f32:	77 93 80 30 	dextr %d3,%d3,%d9,1
80006f36:	06 19       	sh %d9,1
80006f38:	8b f9 9f 00 	addx %d0,%d9,-1
80006f3c:	8b f3 bf 60 	addc %d6,%d3,-1
80006f40:	0b 56 00 21 	eq %d2,%d6,%d5
80006f44:	0b 01 50 22 	and.ge.u %d2,%d1,%d0
80006f48:	0b 56 a0 22 	or.lt.u %d2,%d6,%d5
80006f4c:	02 78       	mov %d8,%d7
80006f4e:	c2 f7       	add %d7,-1
80006f50:	df 02 f1 ff 	jne %d2,0,80006f32 <_fpadd_parts+0xfe>
80006f54:	82 32       	mov %d2,3
80006f56:	59 69 0c 00 	st.w [%a6]12,%d9
80006f5a:	59 63 10 00 	st.w [%a6]16,%d3
80006f5e:	59 68 08 00 	st.w [%a6]8,%d8
80006f62:	74 62       	st.w [%a6],%d2
80006f64:	40 62       	mov.aa %a2,%a6
80006f66:	00 90       	ret 
80006f68:	0b 24 40 90 	addx %d9,%d4,%d2
80006f6c:	0b 35 50 30 	addc %d3,%d5,%d3
80006f70:	59 61 04 00 	st.w [%a6]4,%d1
80006f74:	59 60 08 00 	st.w [%a6]8,%d0
80006f78:	59 69 0c 00 	st.w [%a6]12,%d9
80006f7c:	59 63 10 00 	st.w [%a6]16,%d3
80006f80:	82 32       	mov %d2,3
80006f82:	7b 00 00 52 	movh %d5,8192
80006f86:	40 62       	mov.aa %a2,%a6
80006f88:	74 62       	st.w [%a6],%d2
80006f8a:	0b 53 00 21 	eq %d2,%d3,%d5
80006f8e:	b7 02 01 20 	insert %d2,%d2,0,0,1
80006f92:	0b 53 a0 22 	or.lt.u %d2,%d3,%d5
80006f96:	df 02 13 80 	jne %d2,0,80006fbc <_fpadd_parts+0x188>
80006f9a:	8f f3 1f 20 	sh %d2,%d3,-1
80006f9e:	77 93 80 5f 	dextr %d5,%d3,%d9,31
80006fa2:	8f 19 00 31 	and %d3,%d9,1
80006fa6:	59 62 10 00 	st.w [%a6]16,%d2
80006faa:	19 62 08 00 	ld.w %d2,[%a6]8
80006fae:	a6 53       	or %d3,%d5
80006fb0:	c2 12       	add %d2,1
80006fb2:	d9 63 08 00 	lea %a3,[%a6]8
80006fb6:	59 63 0c 00 	st.w [%a6]12,%d3
80006fba:	74 32       	st.w [%a3],%d2
80006fbc:	00 90       	ret 
80006fbe:	40 42       	mov.aa %a2,%a4
80006fc0:	df 22 fe ff 	jne %d2,2,80006fbc <_fpadd_parts+0x188>
80006fc4:	40 63       	mov.aa %a3,%a6
80006fc6:	09 44 48 01 	ld.d %e4,[%a4+]8
80006fca:	89 34 48 01 	st.d [%a3+]8,%e4
80006fce:	09 44 48 01 	ld.d %e4,[%a4+]8
80006fd2:	89 34 48 01 	st.d [%a3+]8,%e4
80006fd6:	44 44       	ld.w %d4,[%a4+]
80006fd8:	64 34       	st.w [%a3+],%d4
80006fda:	19 23 04 00 	ld.w %d3,[%a2]4
80006fde:	19 52 04 00 	ld.w %d2,[%a5]4
80006fe2:	40 62       	mov.aa %a2,%a6
80006fe4:	26 32       	and %d2,%d3
80006fe6:	59 62 04 00 	st.w [%a6]4,%d2
80006fea:	00 90       	ret 
80006fec:	0b 07 80 60 	sub %d6,%d7,%d0
80006ff0:	8b 06 44 12 	lt %d1,%d6,64
80006ff4:	df 01 1d 80 	jne %d1,0,8000702e <_fpadd_parts+0x1fa>
80006ff8:	3f 07 06 00 	jlt %d7,%d0,80007004 <_fpadd_parts+0x1d0>
80006ffc:	d2 04       	mov %e4,0
80006ffe:	02 70       	mov %d0,%d7
80007000:	1d ff 64 ff 	j 80006ec8 <_fpadd_parts+0x94>
80007004:	d2 02       	mov %e2,0
80007006:	1d ff 61 ff 	j 80006ec8 <_fpadd_parts+0x94>
8000700a:	40 42       	mov.aa %a2,%a4
8000700c:	df 43 d8 ff 	jne %d3,4,80006fbc <_fpadd_parts+0x188>
80007010:	19 43 04 00 	ld.w %d3,[%a4]4
80007014:	19 52 04 00 	ld.w %d2,[%a5]4
80007018:	7b 00 00 48 	movh %d4,32768
8000701c:	0b 23 10 21 	ne %d2,%d3,%d2
80007020:	1b 04 20 40 	addi %d4,%d4,512
80007024:	80 43       	mov.d %d3,%a4
80007026:	2b 43 50 22 	seln %d2,%d2,%d3,%d4
8000702a:	60 22       	mov.a %a2,%d2
8000702c:	00 90       	ret 
8000702e:	8b 06 82 02 	ge %d0,%d6,32
80007032:	2b 54 50 90 	seln %d9,%d0,%d4,%d5
80007036:	ab 05 a0 80 	seln %d8,%d0,%d5,0
8000703a:	8f f6 01 01 	and %d0,%d6,31
8000703e:	8b 00 02 11 	rsub %d1,%d0,32
80007042:	17 98 80 11 	dextr %d1,%d8,%d9,%d1
80007046:	2b 91 40 10 	sel %d1,%d0,%d1,%d9
8000704a:	8b 06 82 a2 	ge %d10,%d6,32
8000704e:	32 50       	rsub %d0
80007050:	02 19       	mov %d9,%d1
80007052:	8f f6 01 61 	and %d6,%d6,31
80007056:	82 f1       	mov %d1,-1
80007058:	0f 08 00 80 	sh %d8,%d8,%d0
8000705c:	17 11 80 06 	dextr %d0,%d1,%d1,%d6
80007060:	0f 61 00 60 	sh %d6,%d1,%d6
80007064:	2b 60 50 0a 	seln %d0,%d10,%d0,%d6
80007068:	ab 06 a0 6a 	seln %d6,%d10,%d6,0
8000706c:	0f 64 e0 10 	andn %d1,%d4,%d6
80007070:	0f 05 e0 60 	andn %d6,%d5,%d0
80007074:	a6 16       	or %d6,%d1
80007076:	8b 06 00 95 	or.ne %d9,%d6,0
8000707a:	0b 98 10 48 	mov %e4,%d8,%d9
8000707e:	02 70       	mov %d0,%d7
80007080:	1d ff 24 ff 	j 80006ec8 <_fpadd_parts+0x94>

80007084 <__adddf3>:
80007084:	20 50       	sub.a %sp,80
80007086:	d9 a5 14 00 	lea %a5,[%sp]20
8000708a:	d9 a4 04 00 	lea %a4,[%sp]4
8000708e:	89 a4 44 09 	st.d [%sp]4,%e4
80007092:	89 a6 4c 09 	st.d [%sp]12,%e6
80007096:	6d 00 a8 02 	call 800075e6 <__unpack_d>
8000709a:	d9 a5 28 00 	lea %a5,[%sp]40
8000709e:	d9 a4 0c 00 	lea %a4,[%sp]12
800070a2:	6d 00 a2 02 	call 800075e6 <__unpack_d>
800070a6:	d9 a4 14 00 	lea %a4,[%sp]20
800070aa:	d9 a6 3c 00 	lea %a6,[%sp]60
800070ae:	d9 a5 28 00 	lea %a5,[%sp]40
800070b2:	6d ff c1 fe 	call 80006e34 <_fpadd_parts>
800070b6:	40 24       	mov.aa %a4,%a2
800070b8:	6d 00 c8 01 	call 80007448 <__pack_d>
800070bc:	00 90       	ret 

800070be <__subdf3>:
800070be:	20 50       	sub.a %sp,80
800070c0:	d9 a5 14 00 	lea %a5,[%sp]20
800070c4:	d9 a4 04 00 	lea %a4,[%sp]4
800070c8:	89 a4 44 09 	st.d [%sp]4,%e4
800070cc:	89 a6 4c 09 	st.d [%sp]12,%e6
800070d0:	6d 00 8b 02 	call 800075e6 <__unpack_d>
800070d4:	d9 a5 28 00 	lea %a5,[%sp]40
800070d8:	d9 a4 0c 00 	lea %a4,[%sp]12
800070dc:	6d 00 85 02 	call 800075e6 <__unpack_d>
800070e0:	19 a2 2c 00 	ld.w %d2,[%sp]44
800070e4:	d9 a4 14 00 	lea %a4,[%sp]20
800070e8:	8f 12 80 21 	xor %d2,%d2,1
800070ec:	d9 a6 3c 00 	lea %a6,[%sp]60
800070f0:	d9 a5 28 00 	lea %a5,[%sp]40
800070f4:	59 a2 2c 00 	st.w [%sp]44,%d2
800070f8:	6d ff 9e fe 	call 80006e34 <_fpadd_parts>
800070fc:	40 24       	mov.aa %a4,%a2
800070fe:	6d 00 a5 01 	call 80007448 <__pack_d>
80007102:	00 90       	ret 

80007104 <__divdf3>:
80007104:	20 38       	sub.a %sp,56
80007106:	d9 a5 10 00 	lea %a5,[%sp]16
8000710a:	40 a4       	mov.aa %a4,%sp
8000710c:	89 a4 40 09 	st.d [%sp],%e4
80007110:	89 a6 48 09 	st.d [%sp]8,%e6
80007114:	6d 00 69 02 	call 800075e6 <__unpack_d>
80007118:	d9 a5 24 00 	lea %a5,[%sp]36
8000711c:	d9 a4 08 00 	lea %a4,[%sp]8
80007120:	6d 00 63 02 	call 800075e6 <__unpack_d>
80007124:	19 a2 10 00 	ld.w %d2,[%sp]16
80007128:	ff 22 07 80 	jge.u %d2,2,80007136 <__divdf3+0x32>
8000712c:	d9 a4 10 00 	lea %a4,[%sp]16
80007130:	6d 00 8c 01 	call 80007448 <__pack_d>
80007134:	00 90       	ret 
80007136:	19 a3 24 00 	ld.w %d3,[%sp]36
8000713a:	d9 a4 24 00 	lea %a4,[%sp]36
8000713e:	bf 23 f9 ff 	jlt.u %d3,2,80007130 <__divdf3+0x2c>
80007142:	19 a5 14 00 	ld.w %d5,[%sp]20
80007146:	19 a4 28 00 	ld.w %d4,[%sp]40
8000714a:	c6 54       	xor %d4,%d5
8000714c:	59 a4 14 00 	st.w [%sp]20,%d4
80007150:	1b e2 ff 4f 	addi %d4,%d2,-2
80007154:	8f 24 c0 41 	andn %d4,%d4,2
80007158:	df 04 0a 80 	jne %d4,0,8000716c <__divdf3+0x68>
8000715c:	91 00 00 48 	movh.a %a4,32768
80007160:	d9 44 00 80 	lea %a4,[%a4]512 <80000200 <__thenan_df>>
80007164:	5f 32 e4 ff 	jne %d2,%d3,8000712c <__divdf3+0x28>
80007168:	1d ff e4 ff 	j 80007130 <__divdf3+0x2c>
8000716c:	df 43 51 00 	jeq %d3,4,8000720e <__divdf3+0x10a>
80007170:	df 23 5a 00 	jeq %d3,2,80007224 <__divdf3+0x120>
80007174:	19 a3 18 00 	ld.w %d3,[%sp]24
80007178:	19 a2 2c 00 	ld.w %d2,[%sp]44
8000717c:	09 a4 70 09 	ld.d %e4,[%sp]48
80007180:	0b 23 80 00 	sub %d0,%d3,%d2
80007184:	09 a2 5c 09 	ld.d %e2,[%sp]28
80007188:	0b 53 00 61 	eq %d6,%d3,%d5
8000718c:	02 67       	mov %d7,%d6
8000718e:	0b 42 50 72 	and.ge.u %d7,%d2,%d4
80007192:	59 a0 18 00 	st.w [%sp]24,%d0
80007196:	0b 35 a0 72 	or.lt.u %d7,%d5,%d3
8000719a:	df 07 0b 80 	jne %d7,0,800071b0 <__divdf3+0xac>
8000719e:	1b f0 ff 6f 	addi %d6,%d0,-1
800071a2:	77 23 80 30 	dextr %d3,%d3,%d2,1
800071a6:	06 12       	sh %d2,1
800071a8:	59 a6 18 00 	st.w [%sp]24,%d6
800071ac:	0b 53 00 61 	eq %d6,%d3,%d5
800071b0:	3b d0 03 10 	mov %d1,61
800071b4:	d2 08       	mov %e8,0
800071b6:	82 00       	mov %d0,0
800071b8:	7b 00 00 71 	movh %d7,4096
800071bc:	1d 00 04 00 	j 800071c4 <__divdf3+0xc0>
800071c0:	0b 53 00 61 	eq %d6,%d3,%d5
800071c4:	0b 42 30 62 	and.lt.u %d6,%d2,%d4
800071c8:	0b 53 a0 62 	or.lt.u %d6,%d3,%d5
800071cc:	df 06 0c 80 	jne %d6,0,800071e4 <__divdf3+0xe0>
800071d0:	0f 08 a0 a0 	or %d10,%d8,%d0
800071d4:	0f 79 a0 60 	or %d6,%d9,%d7
800071d8:	0b 42 c0 20 	subx %d2,%d2,%d4
800071dc:	0b a6 10 88 	mov %e8,%d6,%d10
800071e0:	0b 53 d0 30 	subc %d3,%d3,%d5
800071e4:	c2 f1       	add %d1,-1
800071e6:	77 07 80 0f 	dextr %d0,%d7,%d0,31
800071ea:	77 23 80 30 	dextr %d3,%d3,%d2,1
800071ee:	06 f7       	sh %d7,-1
800071f0:	06 12       	sh %d2,1
800071f2:	df 01 e7 ff 	jne %d1,0,800071c0 <__divdf3+0xbc>
800071f6:	8f f8 0f 41 	and %d4,%d8,255
800071fa:	8b 04 28 42 	ne %d4,%d4,128
800071fe:	df 04 1a 00 	jeq %d4,0,80007232 <__divdf3+0x12e>
80007202:	59 a8 1c 00 	st.w [%sp]28,%d8
80007206:	59 a9 20 00 	st.w [%sp]32,%d9
8000720a:	1d ff 91 ff 	j 8000712c <__divdf3+0x28>
8000720e:	82 02       	mov %d2,0
80007210:	a0 02       	mov.a %a2,0
80007212:	a0 03       	mov.a %a3,0
80007214:	89 a2 dc 09 	st.da [%sp]28,%a2
80007218:	59 a2 18 00 	st.w [%sp]24,%d2
8000721c:	d9 a4 10 00 	lea %a4,[%sp]16
80007220:	1d ff 88 ff 	j 80007130 <__divdf3+0x2c>
80007224:	82 42       	mov %d2,4
80007226:	d9 a4 10 00 	lea %a4,[%sp]16
8000722a:	59 a2 10 00 	st.w [%sp]16,%d2
8000722e:	1d ff 81 ff 	j 80007130 <__divdf3+0x2c>
80007232:	a6 32       	or %d2,%d3
80007234:	77 89 00 4c 	dextr %d4,%d9,%d8,24
80007238:	8b 02 20 32 	ne %d3,%d2,0
8000723c:	0f 43 e0 20 	andn %d2,%d3,%d4
80007240:	df 02 e1 7f 	jeq %d2,0,80007202 <__divdf3+0xfe>
80007244:	8b 08 88 80 	addx %d8,%d8,128
80007248:	8b 09 a0 90 	addc %d9,%d9,0
8000724c:	8f f8 cf 81 	andn %d8,%d8,255
80007250:	1d ff d9 ff 	j 80007202 <__divdf3+0xfe>

80007254 <__gtdf2>:
80007254:	20 38       	sub.a %sp,56
80007256:	d9 a5 10 00 	lea %a5,[%sp]16
8000725a:	40 a4       	mov.aa %a4,%sp
8000725c:	89 a4 40 09 	st.d [%sp],%e4
80007260:	89 a6 48 09 	st.d [%sp]8,%e6
80007264:	6d 00 c1 01 	call 800075e6 <__unpack_d>
80007268:	d9 a5 24 00 	lea %a5,[%sp]36
8000726c:	d9 a4 08 00 	lea %a4,[%sp]8
80007270:	6d 00 bb 01 	call 800075e6 <__unpack_d>
80007274:	19 a3 10 00 	ld.w %d3,[%sp]16
80007278:	82 f2       	mov %d2,-1
8000727a:	bf 23 0c 80 	jlt.u %d3,2,80007292 <__gtdf2+0x3e>
8000727e:	19 a3 24 00 	ld.w %d3,[%sp]36
80007282:	bf 23 08 80 	jlt.u %d3,2,80007292 <__gtdf2+0x3e>
80007286:	d9 a5 24 00 	lea %a5,[%sp]36
8000728a:	d9 a4 10 00 	lea %a4,[%sp]16
8000728e:	6d 00 0b 02 	call 800076a4 <__fpcmp_parts_d>
80007292:	00 90       	ret 

80007294 <__ledf2>:
80007294:	20 38       	sub.a %sp,56
80007296:	d9 a5 10 00 	lea %a5,[%sp]16
8000729a:	40 a4       	mov.aa %a4,%sp
8000729c:	89 a4 40 09 	st.d [%sp],%e4
800072a0:	89 a6 48 09 	st.d [%sp]8,%e6
800072a4:	6d 00 a1 01 	call 800075e6 <__unpack_d>
800072a8:	d9 a5 24 00 	lea %a5,[%sp]36
800072ac:	d9 a4 08 00 	lea %a4,[%sp]8
800072b0:	6d 00 9b 01 	call 800075e6 <__unpack_d>
800072b4:	19 a3 10 00 	ld.w %d3,[%sp]16
800072b8:	82 12       	mov %d2,1
800072ba:	bf 23 0c 80 	jlt.u %d3,2,800072d2 <__ledf2+0x3e>
800072be:	19 a3 24 00 	ld.w %d3,[%sp]36
800072c2:	bf 23 08 80 	jlt.u %d3,2,800072d2 <__ledf2+0x3e>
800072c6:	d9 a5 24 00 	lea %a5,[%sp]36
800072ca:	d9 a4 10 00 	lea %a4,[%sp]16
800072ce:	6d 00 eb 01 	call 800076a4 <__fpcmp_parts_d>
800072d2:	00 90       	ret 

800072d4 <__floatsidf>:
800072d4:	82 32       	mov %d2,3
800072d6:	20 18       	sub.a %sp,24
800072d8:	59 a2 04 00 	st.w [%sp]4,%d2
800072dc:	8f 14 1e 20 	sh %d2,%d4,-31
800072e0:	59 a2 08 00 	st.w [%sp]8,%d2
800072e4:	df 04 0e 80 	jne %d4,0,80007300 <__floatsidf+0x2c>
800072e8:	82 22       	mov %d2,2
800072ea:	59 a2 04 00 	st.w [%sp]4,%d2
800072ee:	d9 a4 04 00 	lea %a4,[%sp]4
800072f2:	6d 00 ab 00 	call 80007448 <__pack_d>
800072f6:	60 25       	mov.a %a5,%d2
800072f8:	60 34       	mov.a %a4,%d3
800072fa:	80 52       	mov.d %d2,%a5
800072fc:	80 43       	mov.d %d3,%a4
800072fe:	00 90       	ret 
80007300:	ff 04 0a 00 	jge %d4,0,80007314 <__floatsidf+0x40>
80007304:	7b 00 00 28 	movh %d2,32768
80007308:	a0 05       	mov.a %a5,0
8000730a:	91 00 1e 4c 	movh.a %a4,49632
8000730e:	5f 24 f6 7f 	jeq %d4,%d2,800072fa <__floatsidf+0x26>
80007312:	32 54       	rsub %d4
80007314:	0f 04 b0 61 	clz %d6,%d4
80007318:	1b d6 01 60 	addi %d6,%d6,29
8000731c:	8f f6 01 21 	and %d2,%d6,31
80007320:	82 05       	mov %d5,0
80007322:	8b 06 82 72 	ge %d7,%d6,32
80007326:	17 45 80 32 	dextr %d3,%d5,%d4,%d2
8000732a:	0f 24 00 20 	sh %d2,%d4,%d2
8000732e:	2b 23 50 37 	seln %d3,%d7,%d3,%d2
80007332:	8b c6 03 61 	rsub %d6,%d6,60
80007336:	ab 02 a0 27 	seln %d2,%d7,%d2,0
8000733a:	59 a3 14 00 	st.w [%sp]20,%d3
8000733e:	59 a6 0c 00 	st.w [%sp]12,%d6
80007342:	59 a2 10 00 	st.w [%sp]16,%d2
80007346:	1d ff d4 ff 	j 800072ee <__floatsidf+0x1a>

8000734a <__make_dp>:
8000734a:	20 18       	sub.a %sp,24
8000734c:	09 a2 d8 09 	ld.da %a2,[%sp]24
80007350:	d9 a4 04 00 	lea %a4,[%sp]4
80007354:	59 a4 04 00 	st.w [%sp]4,%d4
80007358:	59 a5 08 00 	st.w [%sp]8,%d5
8000735c:	59 a6 0c 00 	st.w [%sp]12,%d6
80007360:	89 a2 d0 09 	st.da [%sp]16,%a2
80007364:	6d 00 72 00 	call 80007448 <__pack_d>
80007368:	00 90       	ret 

8000736a <__truncdfsf2>:
8000736a:	20 20       	sub.a %sp,32
8000736c:	d9 a5 0c 00 	lea %a5,[%sp]12
80007370:	d9 a4 04 00 	lea %a4,[%sp]4
80007374:	89 a4 44 09 	st.d [%sp]4,%e4
80007378:	6d 00 37 01 	call 800075e6 <__unpack_d>
8000737c:	19 a3 18 00 	ld.w %d3,[%sp]24
80007380:	19 a2 1c 00 	ld.w %d2,[%sp]28
80007384:	77 32 00 21 	dextr %d2,%d2,%d3,2
80007388:	b7 03 02 3f 	insert %d3,%d3,0,30,2
8000738c:	02 27       	mov %d7,%d2
8000738e:	df 03 04 00 	jeq %d3,0,80007396 <__truncdfsf2+0x2c>
80007392:	8f 12 40 71 	or %d7,%d2,1
80007396:	19 a6 14 00 	ld.w %d6,[%sp]20
8000739a:	19 a5 10 00 	ld.w %d5,[%sp]16
8000739e:	19 a4 0c 00 	ld.w %d4,[%sp]12
800073a2:	6d 00 47 00 	call 80007430 <__make_fp>
800073a6:	00 90       	ret 

800073a8 <__unpack_f>:
800073a8:	54 42       	ld.w %d2,[%a4]
800073aa:	8f 12 1e 50 	sh %d5,%d2,-31
800073ae:	37 02 e8 3b 	extr.u %d3,%d2,23,8
800073b2:	b7 02 89 4b 	insert %d4,%d2,0,23,9
800073b6:	59 55 04 00 	st.w [%a5]4,%d5
800073ba:	df 03 16 80 	jne %d3,0,800073e6 <__unpack_f+0x3e>
800073be:	df 04 25 00 	jeq %d4,0,80007408 <__unpack_f+0x60>
800073c2:	82 33       	mov %d3,3
800073c4:	8f 74 00 20 	sh %d2,%d4,7
800073c8:	7b 00 00 54 	movh %d5,16384
800073cc:	74 53       	st.w [%a5],%d3
800073ce:	3b 10 f8 3f 	mov %d3,-127
800073d2:	06 12       	sh %d2,1
800073d4:	02 34       	mov %d4,%d3
800073d6:	c2 f3       	add %d3,-1
800073d8:	3f 52 fd ff 	jlt.u %d2,%d5,800073d2 <__unpack_f+0x2a>
800073dc:	59 54 08 00 	st.w [%a5]8,%d4
800073e0:	59 52 0c 00 	st.w [%a5]12,%d2
800073e4:	00 90       	ret 
800073e6:	8b f3 2f 52 	ne %d5,%d3,255
800073ea:	df 05 12 00 	jeq %d5,0,8000740e <__unpack_f+0x66>
800073ee:	82 32       	mov %d2,3
800073f0:	1b 13 f8 3f 	addi %d3,%d3,-127
800073f4:	74 52       	st.w [%a5],%d2
800073f6:	8f 74 00 20 	sh %d2,%d4,7
800073fa:	b7 f2 01 2f 	insert %d2,%d2,15,30,1
800073fe:	59 53 08 00 	st.w [%a5]8,%d3
80007402:	59 52 0c 00 	st.w [%a5]12,%d2
80007406:	00 90       	ret 
80007408:	82 22       	mov %d2,2
8000740a:	74 52       	st.w [%a5],%d2
8000740c:	00 90       	ret 
8000740e:	df 04 05 80 	jne %d4,0,80007418 <__unpack_f+0x70>
80007412:	82 42       	mov %d2,4
80007414:	74 52       	st.w [%a5],%d2
80007416:	00 90       	ret 
80007418:	37 02 61 3b 	extr.u %d3,%d2,22,1
8000741c:	06 72       	sh %d2,7
8000741e:	74 53       	st.w [%a5],%d3
80007420:	7b 00 00 32 	movh %d3,8192
80007424:	1b 03 f8 3f 	addi %d3,%d3,-128
80007428:	26 32       	and %d2,%d3
8000742a:	59 52 0c 00 	st.w [%a5]12,%d2
8000742e:	00 90       	ret 

80007430 <__make_fp>:
80007430:	20 10       	sub.a %sp,16
80007432:	40 a4       	mov.aa %a4,%sp
80007434:	74 a4       	st.w [%sp],%d4
80007436:	59 a5 04 00 	st.w [%sp]4,%d5
8000743a:	59 a6 08 00 	st.w [%sp]8,%d6
8000743e:	59 a7 0c 00 	st.w [%sp]12,%d7
80007442:	6d 00 93 01 	call 80007768 <__pack_f>
80007446:	00 90       	ret 

80007448 <__pack_d>:
80007448:	54 44       	ld.w %d4,[%a4]
8000744a:	19 43 0c 00 	ld.w %d3,[%a4]12
8000744e:	19 42 10 00 	ld.w %d2,[%a4]16
80007452:	19 41 04 00 	ld.w %d1,[%a4]4
80007456:	bf 24 56 80 	jlt.u %d4,2,80007502 <__pack_d+0xba>
8000745a:	7b 00 ff 57 	movh %d5,32752
8000745e:	d2 06       	mov %e6,0
80007460:	df 44 0b 00 	jeq %d4,4,80007476 <__pack_d+0x2e>
80007464:	0f 23 a0 50 	or %d5,%d3,%d2
80007468:	8b 05 00 02 	eq %d0,%d5,0
8000746c:	8b 24 e0 04 	or.eq %d0,%d4,2
80007470:	82 05       	mov %d5,0
80007472:	df 00 0c 00 	jeq %d0,0,8000748a <__pack_d+0x42>
80007476:	0b 10 00 28 	mov %e2,%d1
8000747a:	a6 75       	or %d5,%d7
8000747c:	8f f2 01 20 	sh %d2,%d2,31
80007480:	0f 25 a0 40 	or %d4,%d5,%d2
80007484:	02 43       	mov %d3,%d4
80007486:	02 62       	mov %d2,%d6
80007488:	00 90       	ret 
8000748a:	19 44 08 00 	ld.w %d4,[%a4]8
8000748e:	3b 20 c0 0f 	mov %d0,-1022
80007492:	3f 04 41 00 	jlt %d4,%d0,80007514 <__pack_d+0xcc>
80007496:	3b 00 40 00 	mov %d0,1024
8000749a:	7b 00 ff 57 	movh %d5,32752
8000749e:	7f 04 ec 7f 	jge %d4,%d0,80007476 <__pack_d+0x2e>
800074a2:	8f f3 0f 51 	and %d5,%d3,255
800074a6:	8b 05 28 52 	ne %d5,%d5,128
800074aa:	df 05 1b 00 	jeq %d5,0,800074e0 <__pack_d+0x98>
800074ae:	8b f3 87 30 	addx %d3,%d3,127
800074b2:	8b 02 a0 20 	addc %d2,%d2,0
800074b6:	7b 00 00 52 	movh %d5,8192
800074ba:	0b 25 30 61 	lt.u %d6,%d5,%d2
800074be:	0b 25 70 62 	or.eq %d6,%d5,%d2
800074c2:	df 06 19 80 	jne %d6,0,800074f4 <__pack_d+0xac>
800074c6:	1b f4 3f 40 	addi %d4,%d4,1023
800074ca:	0b 40 00 48 	mov %e4,%d4
800074ce:	77 32 00 6c 	dextr %d6,%d2,%d3,24
800074d2:	06 82       	sh %d2,-8
800074d4:	b7 02 0c 7a 	insert %d7,%d2,0,20,12
800074d8:	8f 44 01 50 	sh %d5,%d4,20
800074dc:	1d ff cd ff 	j 80007476 <__pack_d+0x2e>
800074e0:	8f 03 10 51 	and %d5,%d3,256
800074e4:	df 05 e9 7f 	jeq %d5,0,800074b6 <__pack_d+0x6e>
800074e8:	8b 03 88 30 	addx %d3,%d3,128
800074ec:	8b 02 a0 20 	addc %d2,%d2,0
800074f0:	1d ff e3 ff 	j 800074b6 <__pack_d+0x6e>
800074f4:	77 32 80 3f 	dextr %d3,%d2,%d3,31
800074f8:	1b 04 40 40 	addi %d4,%d4,1024
800074fc:	06 f2       	sh %d2,-1
800074fe:	1d ff e6 ff 	j 800074ca <__pack_d+0x82>
80007502:	77 32 00 6c 	dextr %d6,%d2,%d3,24
80007506:	06 82       	sh %d2,-8
80007508:	b7 12 8d 79 	insert %d7,%d2,1,19,13
8000750c:	7b 00 ff 57 	movh %d5,32752
80007510:	1d ff b3 ff 	j 80007476 <__pack_d+0x2e>
80007514:	0b 40 80 40 	sub %d4,%d0,%d4
80007518:	8b 94 83 02 	ge %d0,%d4,57
8000751c:	df 00 ad ff 	jne %d0,0,80007476 <__pack_d+0x2e>
80007520:	8b 04 82 52 	ge %d5,%d4,32
80007524:	2b 23 50 05 	seln %d0,%d5,%d3,%d2
80007528:	ab 02 a0 75 	seln %d7,%d5,%d2,0
8000752c:	8f f4 01 51 	and %d5,%d4,31
80007530:	8b 05 02 61 	rsub %d6,%d5,32
80007534:	17 07 80 66 	dextr %d6,%d7,%d0,%d6
80007538:	2b 06 40 65 	sel %d6,%d5,%d6,%d0
8000753c:	8b 04 82 82 	ge %d8,%d4,32
80007540:	32 55       	rsub %d5
80007542:	02 60       	mov %d0,%d6
80007544:	8f f4 01 41 	and %d4,%d4,31
80007548:	82 f6       	mov %d6,-1
8000754a:	0f 57 00 70 	sh %d7,%d7,%d5
8000754e:	17 66 80 54 	dextr %d5,%d6,%d6,%d4
80007552:	0f 46 00 40 	sh %d4,%d6,%d4
80007556:	2b 45 50 58 	seln %d5,%d8,%d5,%d4
8000755a:	ab 04 a0 48 	seln %d4,%d8,%d4,0
8000755e:	0f 43 e0 30 	andn %d3,%d3,%d4
80007562:	0f 52 e0 20 	andn %d2,%d2,%d5
80007566:	a6 32       	or %d2,%d3
80007568:	02 03       	mov %d3,%d0
8000756a:	8b 02 00 35 	or.ne %d3,%d2,0
8000756e:	8f f3 0f 51 	and %d5,%d3,255
80007572:	82 12       	mov %d2,1
80007574:	8b 05 08 24 	and.eq %d2,%d5,128
80007578:	02 74       	mov %d4,%d7
8000757a:	df 02 14 80 	jne %d2,0,800075a2 <__pack_d+0x15a>
8000757e:	8b f3 87 30 	addx %d3,%d3,127
80007582:	8b 07 a0 20 	addc %d2,%d7,0
80007586:	77 32 00 6c 	dextr %d6,%d2,%d3,24
8000758a:	7b 00 00 31 	movh %d3,4096
8000758e:	8f 82 1f 70 	sh %d7,%d2,-8
80007592:	0b 32 50 21 	ge.u %d2,%d2,%d3
80007596:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
8000759a:	8f 42 01 50 	sh %d5,%d2,20
8000759e:	1d ff 6c ff 	j 80007476 <__pack_d+0x2e>
800075a2:	8b 03 88 60 	addx %d6,%d3,128
800075a6:	8b 07 a0 20 	addc %d2,%d7,0
800075aa:	7b 00 00 a1 	movh %d10,4096
800075ae:	8f 82 1f 70 	sh %d7,%d2,-8
800075b2:	77 62 00 6c 	dextr %d6,%d2,%d6,24
800075b6:	0b a2 50 21 	ge.u %d2,%d2,%d10
800075ba:	53 12 40 80 	mul.u %e8,%d2,1
800075be:	8f 03 10 01 	and %d0,%d3,256
800075c2:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
800075c6:	8f 48 01 50 	sh %d5,%d8,20
800075ca:	df 00 56 ff 	jne %d0,0,80007476 <__pack_d+0x2e>
800075ce:	8f 84 1f 70 	sh %d7,%d4,-8
800075d2:	0b a4 50 21 	ge.u %d2,%d4,%d10
800075d6:	77 34 00 6c 	dextr %d6,%d4,%d3,24
800075da:	b7 07 0c 7a 	insert %d7,%d7,0,20,12
800075de:	8f 42 01 50 	sh %d5,%d2,20
800075e2:	1d ff 4a ff 	j 80007476 <__pack_d+0x2e>

800075e6 <__unpack_d>:
800075e6:	09 48 40 09 	ld.d %e8,[%a4]
800075ea:	3b f0 7f 00 	mov %d0,2047
800075ee:	8f 19 1e 70 	sh %d7,%d9,-31
800075f2:	37 09 6b 5a 	extr.u %d5,%d9,20,11
800075f6:	b7 09 0c 6a 	insert %d6,%d9,0,20,12
800075fa:	59 57 04 00 	st.w [%a5]4,%d7
800075fe:	df 05 26 80 	jne %d5,0,8000764a <__unpack_d+0x64>
80007602:	8b 08 20 22 	ne %d2,%d8,0
80007606:	8b 06 00 25 	or.ne %d2,%d6,0
8000760a:	df 02 33 00 	jeq %d2,0,80007670 <__unpack_d+0x8a>
8000760e:	82 32       	mov %d2,3
80007610:	77 86 00 34 	dextr %d3,%d6,%d8,8
80007614:	8f 88 00 40 	sh %d4,%d8,8
80007618:	74 52       	st.w [%a5],%d2
8000761a:	3b 10 c0 5f 	mov %d5,-1023
8000761e:	7b 00 00 61 	movh %d6,4096
80007622:	77 43 80 30 	dextr %d3,%d3,%d4,1
80007626:	02 57       	mov %d7,%d5
80007628:	0b 63 00 21 	eq %d2,%d3,%d6
8000762c:	b7 02 01 20 	insert %d2,%d2,0,0,1
80007630:	06 14       	sh %d4,1
80007632:	0b 63 a0 22 	or.lt.u %d2,%d3,%d6
80007636:	c2 f5       	add %d5,-1
80007638:	df 02 f5 ff 	jne %d2,0,80007622 <__unpack_d+0x3c>
8000763c:	59 57 08 00 	st.w [%a5]8,%d7
80007640:	59 54 0c 00 	st.w [%a5]12,%d4
80007644:	59 53 10 00 	st.w [%a5]16,%d3
80007648:	00 90       	ret 
8000764a:	5f 05 16 00 	jeq %d5,%d0,80007676 <__unpack_d+0x90>
8000764e:	82 32       	mov %d2,3
80007650:	1b 15 c0 5f 	addi %d5,%d5,-1023
80007654:	8f 88 00 40 	sh %d4,%d8,8
80007658:	74 52       	st.w [%a5],%d2
8000765a:	77 86 00 24 	dextr %d2,%d6,%d8,8
8000765e:	59 55 08 00 	st.w [%a5]8,%d5
80007662:	b7 f2 01 2e 	insert %d2,%d2,15,28,1
80007666:	59 54 0c 00 	st.w [%a5]12,%d4
8000766a:	59 52 10 00 	st.w [%a5]16,%d2
8000766e:	00 90       	ret 
80007670:	82 22       	mov %d2,2
80007672:	74 52       	st.w [%a5],%d2
80007674:	00 90       	ret 
80007676:	8b 08 20 52 	ne %d5,%d8,0
8000767a:	8b 06 00 55 	or.ne %d5,%d6,0
8000767e:	df 05 05 80 	jne %d5,0,80007688 <__unpack_d+0xa2>
80007682:	82 42       	mov %d2,4
80007684:	74 52       	st.w [%a5],%d2
80007686:	00 90       	ret 
80007688:	77 89 00 34 	dextr %d3,%d9,%d8,8
8000768c:	37 09 e1 49 	extr.u %d4,%d9,19,1
80007690:	b7 03 85 3d 	insert %d3,%d3,0,27,5
80007694:	8f 88 00 20 	sh %d2,%d8,8
80007698:	74 54       	st.w [%a5],%d4
8000769a:	59 52 0c 00 	st.w [%a5]12,%d2
8000769e:	59 53 10 00 	st.w [%a5]16,%d3
800076a2:	00 90       	ret 

800076a4 <__fpcmp_parts_d>:
800076a4:	54 43       	ld.w %d3,[%a4]
800076a6:	82 12       	mov %d2,1
800076a8:	bf 23 45 80 	jlt.u %d3,2,80007732 <__fpcmp_parts_d+0x8e>
800076ac:	54 54       	ld.w %d4,[%a5]
800076ae:	bf 24 42 80 	jlt.u %d4,2,80007732 <__fpcmp_parts_d+0x8e>
800076b2:	8b 44 00 52 	eq %d5,%d4,4
800076b6:	8b 43 00 54 	and.eq %d5,%d3,4
800076ba:	df 05 50 80 	jne %d5,0,8000775a <__fpcmp_parts_d+0xb6>
800076be:	df 43 45 00 	jeq %d3,4,80007748 <__fpcmp_parts_d+0xa4>
800076c2:	df 44 3d 00 	jeq %d4,4,8000773c <__fpcmp_parts_d+0x98>
800076c6:	8b 24 00 52 	eq %d5,%d4,2
800076ca:	8b 23 00 54 	and.eq %d5,%d3,2
800076ce:	82 02       	mov %d2,0
800076d0:	df 05 31 80 	jne %d5,0,80007732 <__fpcmp_parts_d+0x8e>
800076d4:	df 23 34 00 	jeq %d3,2,8000773c <__fpcmp_parts_d+0x98>
800076d8:	19 42 04 00 	ld.w %d2,[%a4]4
800076dc:	df 24 2c 00 	jeq %d4,2,80007734 <__fpcmp_parts_d+0x90>
800076e0:	19 53 04 00 	ld.w %d3,[%a5]4
800076e4:	5f 23 28 80 	jne %d3,%d2,80007734 <__fpcmp_parts_d+0x90>
800076e8:	19 44 08 00 	ld.w %d4,[%a4]8
800076ec:	19 53 08 00 	ld.w %d3,[%a5]8
800076f0:	3f 43 22 00 	jlt %d3,%d4,80007734 <__fpcmp_parts_d+0x90>
800076f4:	3f 34 2f 00 	jlt %d4,%d3,80007752 <__fpcmp_parts_d+0xae>
800076f8:	19 45 10 00 	ld.w %d5,[%a4]16
800076fc:	19 56 10 00 	ld.w %d6,[%a5]16
80007700:	19 40 0c 00 	ld.w %d0,[%a4]12
80007704:	0b 65 00 41 	eq %d4,%d5,%d6
80007708:	19 57 0c 00 	ld.w %d7,[%a5]12
8000770c:	02 43       	mov %d3,%d4
8000770e:	0b 07 50 32 	and.ge.u %d3,%d7,%d0
80007712:	0b 70 50 42 	and.ge.u %d4,%d0,%d7
80007716:	0b 65 a0 32 	or.lt.u %d3,%d5,%d6
8000771a:	0b 56 a0 42 	or.lt.u %d4,%d6,%d5
8000771e:	82 f5       	mov %d5,-1
80007720:	ab 15 a0 52 	seln %d5,%d2,%d5,1
80007724:	82 16       	mov %d6,1
80007726:	ab f6 bf 22 	seln %d2,%d2,%d6,-1
8000772a:	ab 05 a0 44 	seln %d4,%d4,%d5,0
8000772e:	2b 24 40 23 	sel %d2,%d3,%d4,%d2
80007732:	00 90       	ret 
80007734:	82 13       	mov %d3,1
80007736:	ab f3 bf 22 	seln %d2,%d2,%d3,-1
8000773a:	00 90       	ret 
8000773c:	19 53 04 00 	ld.w %d3,[%a5]4
80007740:	82 f2       	mov %d2,-1
80007742:	ab 12 a0 23 	seln %d2,%d3,%d2,1
80007746:	00 90       	ret 
80007748:	19 43 04 00 	ld.w %d3,[%a4]4
8000774c:	ab f2 bf 23 	seln %d2,%d3,%d2,-1
80007750:	00 90       	ret 
80007752:	82 f3       	mov %d3,-1
80007754:	ab 13 a0 22 	seln %d2,%d2,%d3,1
80007758:	00 90       	ret 
8000775a:	19 53 04 00 	ld.w %d3,[%a5]4
8000775e:	19 42 04 00 	ld.w %d2,[%a4]4
80007762:	0b 23 80 20 	sub %d2,%d3,%d2
80007766:	00 90       	ret 

80007768 <__pack_f>:
80007768:	54 44       	ld.w %d4,[%a4]
8000776a:	19 43 0c 00 	ld.w %d3,[%a4]12
8000776e:	19 47 04 00 	ld.w %d7,[%a4]4
80007772:	bf 24 3f 80 	jlt.u %d4,2,800077f0 <__pack_f+0x88>
80007776:	7b 00 f8 57 	movh %d5,32640
8000777a:	82 06       	mov %d6,0
8000777c:	df 44 09 00 	jeq %d4,4,8000778e <__pack_f+0x26>
80007780:	8b 03 00 22 	eq %d2,%d3,0
80007784:	8b 24 e0 24 	or.eq %d2,%d4,2
80007788:	82 05       	mov %d5,0
8000778a:	df 02 08 00 	jeq %d2,0,8000779a <__pack_f+0x32>
8000778e:	8f f7 01 70 	sh %d7,%d7,31
80007792:	0f 56 a0 20 	or %d2,%d6,%d5
80007796:	a6 72       	or %d2,%d7
80007798:	00 90       	ret 
8000779a:	19 42 08 00 	ld.w %d2,[%a4]8
8000779e:	8b 22 98 42 	ge %d4,%d2,-126
800077a2:	df 04 33 00 	jeq %d4,0,80007808 <__pack_f+0xa0>
800077a6:	8b 02 88 42 	ge %d4,%d2,128
800077aa:	7b 00 f8 57 	movh %d5,32640
800077ae:	df 04 f0 ff 	jne %d4,0,8000778e <__pack_f+0x26>
800077b2:	8f f3 07 51 	and %d5,%d3,127
800077b6:	8f 03 08 41 	and %d4,%d3,128
800077ba:	8b 05 24 52 	ne %d5,%d5,64
800077be:	ab 03 04 44 	cadd %d4,%d4,%d3,64
800077c2:	1b f3 03 30 	addi %d3,%d3,63
800077c6:	2b 43 40 35 	sel %d3,%d5,%d3,%d4
800077ca:	1b f2 07 50 	addi %d5,%d2,127
800077ce:	bf 03 0c 00 	jlt %d3,0,800077e6 <__pack_f+0x7e>
800077d2:	37 03 f7 63 	extr.u %d6,%d3,7,23
800077d6:	8f 75 01 50 	sh %d5,%d5,23
800077da:	8f f7 01 70 	sh %d7,%d7,31
800077de:	0f 56 a0 20 	or %d2,%d6,%d5
800077e2:	a6 72       	or %d2,%d7
800077e4:	00 90       	ret 
800077e6:	06 f3       	sh %d3,-1
800077e8:	1b 02 08 50 	addi %d5,%d2,128
800077ec:	1d ff f3 ff 	j 800077d2 <__pack_f+0x6a>
800077f0:	37 03 f6 33 	extr.u %d3,%d3,7,22
800077f4:	7b 00 f8 57 	movh %d5,32640
800077f8:	b7 f3 01 6b 	insert %d6,%d3,15,22,1
800077fc:	8f f7 01 70 	sh %d7,%d7,31
80007800:	0f 56 a0 20 	or %d2,%d6,%d5
80007804:	a6 72       	or %d2,%d7
80007806:	00 90       	ret 
80007808:	8b 22 18 21 	rsub %d2,%d2,-126
8000780c:	8b a2 81 42 	ge %d4,%d2,26
80007810:	df 04 bf ff 	jne %d4,0,8000778e <__pack_f+0x26>
80007814:	82 f5       	mov %d5,-1
80007816:	8b 02 00 41 	rsub %d4,%d2,0
8000781a:	0f 25 00 20 	sh %d2,%d5,%d2
8000781e:	0f 43 00 40 	sh %d4,%d3,%d4
80007822:	0f 23 e0 30 	andn %d3,%d3,%d2
80007826:	8b 03 00 45 	or.ne %d4,%d3,0
8000782a:	8f f4 07 31 	and %d3,%d4,127
8000782e:	8b 03 04 32 	eq %d3,%d3,64
80007832:	df 03 0e 80 	jne %d3,0,8000784e <__pack_f+0xe6>
80007836:	1b f4 03 20 	addi %d2,%d4,63
8000783a:	7b 00 00 34 	movh %d3,16384
8000783e:	37 02 f7 63 	extr.u %d6,%d2,7,23
80007842:	0b 32 50 21 	ge.u %d2,%d2,%d3
80007846:	8f 72 01 50 	sh %d5,%d2,23
8000784a:	1d ff a2 ff 	j 8000778e <__pack_f+0x26>
8000784e:	1b 04 04 30 	addi %d3,%d4,64
80007852:	7b 00 00 24 	movh %d2,16384
80007856:	37 03 f7 63 	extr.u %d6,%d3,7,23
8000785a:	0b 23 50 31 	ge.u %d3,%d3,%d2
8000785e:	8f 73 01 50 	sh %d5,%d3,23
80007862:	6f 74 96 ff 	jnz.t %d4,7,8000778e <__pack_f+0x26>
80007866:	0b 24 50 21 	ge.u %d2,%d4,%d2
8000786a:	37 04 f7 63 	extr.u %d6,%d4,7,23
8000786e:	8f 72 01 50 	sh %d5,%d2,23
80007872:	1d ff 8e ff 	j 8000778e <__pack_f+0x26>

80007876 <malloc>:
80007876:	91 00 00 46 	movh.a %a4,24576
8000787a:	99 44 20 10 	ld.a %a4,[%a4]96 <60000060 <_impure_ptr>>
8000787e:	6d 00 03 00 	call 80007884 <_malloc_r>
80007882:	00 90       	ret 

80007884 <_malloc_r>:
80007884:	1b b4 00 20 	addi %d2,%d4,11
80007888:	8b 72 a1 32 	ge.u %d3,%d2,23
8000788c:	40 4e       	mov.aa %a14,%a4
8000788e:	df 03 32 80 	jne %d3,0,800078f2 <_malloc_r+0x6e>
80007892:	8b 14 a1 42 	ge.u %d4,%d4,17
80007896:	df 04 db 80 	jne %d4,0,80007a4c <_malloc_r+0x1c8>
8000789a:	6d 00 e0 04 	call 8000825a <__malloc_lock>
8000789e:	3b 80 01 30 	mov %d3,24
800078a2:	82 26       	mov %d6,2
800078a4:	3b 00 01 80 	mov %d8,16
800078a8:	91 00 00 d6 	movh.a %a13,24576
800078ac:	d9 dd 08 60 	lea %a13,[%a13]392 <60000188 <__malloc_av_>>
800078b0:	01 d3 00 26 	addsc.a %a2,%a13,%d3,0
800078b4:	99 2c 04 00 	ld.a %a12,[%a2]4
800078b8:	d9 23 f8 ff 	lea %a3,[%a2]-8
800078bc:	7d 3c ce 00 	jeq.a %a12,%a3,80007a58 <_malloc_r+0x1d4>
800078c0:	99 c2 0c 00 	ld.a %a2,[%a12]12
800078c4:	99 c3 08 00 	ld.a %a3,[%a12]8
800078c8:	19 c2 04 00 	ld.w %d2,[%a12]4
800078cc:	b5 32 0c 00 	st.a [%a3]12,%a2
800078d0:	8f 32 c0 21 	andn %d2,%d2,3
800078d4:	b5 23 08 00 	st.a [%a2]8,%a3
800078d8:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
800078dc:	b7 10 21 20 	imask %e2,1,0,1
800078e0:	40 e4       	mov.aa %a4,%a14
800078e2:	d9 cc 08 00 	lea %a12,[%a12]8
800078e6:	49 22 44 08 	ldmst [%a2]4,%e2
800078ea:	6d 00 b9 04 	call 8000825c <__malloc_unlock>
800078ee:	40 c2       	mov.aa %a2,%a12
800078f0:	00 90       	ret 
800078f2:	8f 72 c0 81 	andn %d8,%d2,7
800078f6:	0b 48 30 31 	lt.u %d3,%d8,%d4
800078fa:	8b 02 20 35 	or.lt %d3,%d2,0
800078fe:	df 03 a7 80 	jne %d3,0,80007a4c <_malloc_r+0x1c8>
80007902:	6d 00 ac 04 	call 8000825a <__malloc_lock>
80007906:	8b 88 bf 22 	ge.u %d2,%d8,504
8000790a:	df 02 07 02 	jeq %d2,0,80007d18 <_malloc_r+0x494>
8000790e:	8f 78 1f 20 	sh %d2,%d8,-9
80007912:	3b 00 20 30 	mov %d3,512
80007916:	3b 00 04 60 	mov %d6,64
8000791a:	3b f0 03 50 	mov %d5,63
8000791e:	df 02 61 81 	jne %d2,0,80007be0 <_malloc_r+0x35c>
80007922:	91 00 00 d6 	movh.a %a13,24576
80007926:	d9 dd 08 60 	lea %a13,[%a13]392 <60000188 <__malloc_av_>>
8000792a:	01 d3 00 36 	addsc.a %a3,%a13,%d3,0
8000792e:	99 3c 04 00 	ld.a %a12,[%a3]4
80007932:	d9 32 f8 ff 	lea %a2,[%a3]-8
80007936:	7d c2 0a 80 	jne.a %a2,%a12,8000794a <_malloc_r+0xc6>
8000793a:	1d 00 13 00 	j 80007960 <_malloc_r+0xdc>
8000793e:	ff 02 80 01 	jge %d2,0,80007c3e <_malloc_r+0x3ba>
80007942:	99 cc 0c 00 	ld.a %a12,[%a12]12
80007946:	7d c2 0d 00 	jeq.a %a2,%a12,80007960 <_malloc_r+0xdc>
8000794a:	19 c2 04 00 	ld.w %d2,[%a12]4
8000794e:	8f 32 c0 41 	andn %d4,%d2,3
80007952:	0b 84 80 20 	sub %d2,%d4,%d8
80007956:	8b 02 81 32 	ge %d3,%d2,16
8000795a:	df 03 f2 7f 	jeq %d3,0,8000793e <_malloc_r+0xba>
8000795e:	02 56       	mov %d6,%d5
80007960:	99 dc 10 00 	ld.a %a12,[%a13]16 <60000010 <LCF_DSPR1_START+0x10>>
80007964:	d9 d4 08 00 	lea %a4,[%a13]8 <60000008 <LCF_DSPR1_START+0x8>>
80007968:	7d 4c 83 00 	jeq.a %a12,%a4,80007a6e <_malloc_r+0x1ea>
8000796c:	19 c2 04 00 	ld.w %d2,[%a12]4
80007970:	8f 32 c0 21 	andn %d2,%d2,3
80007974:	0b 82 80 30 	sub %d3,%d2,%d8
80007978:	8b 03 41 42 	lt %d4,%d3,16
8000797c:	df 04 d4 01 	jeq %d4,0,80007d24 <_malloc_r+0x4a0>
80007980:	b5 d4 14 00 	st.a [%a13]20 <60000014 <LCF_DSPR1_START+0x14>>,%a4
80007984:	b5 d4 10 00 	st.a [%a13]16 <60000010 <LCF_DSPR1_START+0x10>>,%a4
80007988:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
8000798c:	ff 03 a8 7f 	jge %d3,0,800078dc <_malloc_r+0x58>
80007990:	3b 00 20 30 	mov %d3,512
80007994:	7f 32 6a 81 	jge.u %d2,%d3,80007c68 <_malloc_r+0x3e4>
80007998:	19 d4 04 00 	ld.w %d4,[%a13]4 <60000004 <LCF_DSPR1_START+0x4>>
8000799c:	8f b2 1f 30 	sh %d3,%d2,-5
800079a0:	8f 72 c0 21 	andn %d2,%d2,7
800079a4:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
800079a8:	1b 82 00 20 	addi %d2,%d2,8
800079ac:	01 d2 00 36 	addsc.a %a3,%a13,%d2,0
800079b0:	d9 d2 04 00 	lea %a2,[%a13]4 <60000004 <LCF_DSPR1_START+0x4>>
800079b4:	d4 35       	ld.a %a5,[%a3]
800079b6:	74 23       	st.w [%a2],%d3
800079b8:	40 32       	mov.aa %a2,%a3
800079ba:	b0 82       	add.a %a2,-8
800079bc:	b5 c2 0c 00 	st.a [%a12]12,%a2
800079c0:	b5 c5 08 00 	st.a [%a12]8,%a5
800079c4:	f4 3c       	st.a [%a3],%a12
800079c6:	b5 5c 0c 00 	st.a [%a5]12,%a12
800079ca:	8f e6 3f 40 	sha %d4,%d6,-2
800079ce:	82 12       	mov %d2,1
800079d0:	0f 42 00 20 	sh %d2,%d2,%d4
800079d4:	3f 23 56 80 	jlt.u %d3,%d2,80007a80 <_malloc_r+0x1fc>
800079d8:	0f 32 80 40 	and %d4,%d2,%d3
800079dc:	df 04 0a 80 	jne %d4,0,800079f0 <_malloc_r+0x16c>
800079e0:	8f 36 c0 61 	andn %d6,%d6,3
800079e4:	06 12       	sh %d2,1
800079e6:	0f 32 80 40 	and %d4,%d2,%d3
800079ea:	c2 46       	add %d6,4
800079ec:	df 04 fc 7f 	jeq %d4,0,800079e4 <_malloc_r+0x160>
800079f0:	8f 36 00 30 	sh %d3,%d6,3
800079f4:	01 d3 00 56 	addsc.a %a5,%a13,%d3,0
800079f8:	02 67       	mov %d7,%d6
800079fa:	40 52       	mov.aa %a2,%a5
800079fc:	99 23 0c 00 	ld.a %a3,[%a2]12
80007a00:	7d 32 62 01 	jeq.a %a2,%a3,80007cc4 <_malloc_r+0x440>
80007a04:	19 33 04 00 	ld.w %d3,[%a3]4
80007a08:	d9 36 04 00 	lea %a6,[%a3]4
80007a0c:	8f 33 c0 51 	andn %d5,%d3,3
80007a10:	0b 85 80 30 	sub %d3,%d5,%d8
80007a14:	40 3c       	mov.aa %a12,%a3
80007a16:	8b 03 41 42 	lt %d4,%d3,16
80007a1a:	d9 33 0c 00 	lea %a3,[%a3]12
80007a1e:	d4 33       	ld.a %a3,[%a3]
80007a20:	df 04 5b 01 	jeq %d4,0,80007cd6 <_malloc_r+0x452>
80007a24:	bf 03 ee 7f 	jlt %d3,0,80007a00 <_malloc_r+0x17c>
80007a28:	b7 10 21 20 	imask %e2,1,0,1
80007a2c:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
80007a30:	d9 cc 08 00 	lea %a12,[%a12]8
80007a34:	40 e4       	mov.aa %a4,%a14
80007a36:	49 22 44 08 	ldmst [%a2]4,%e2
80007a3a:	d4 c2       	ld.a %a2,[%a12]
80007a3c:	b5 23 0c 00 	st.a [%a2]12,%a3
80007a40:	b5 32 08 00 	st.a [%a3]8,%a2
80007a44:	6d 00 0c 04 	call 8000825c <__malloc_unlock>
80007a48:	1d 00 06 00 	j 80007a54 <_malloc_r+0x1d0>
80007a4c:	3b c0 00 20 	mov %d2,12
80007a50:	a0 0c       	mov.a %a12,0
80007a52:	74 e2       	st.w [%a14],%d2
80007a54:	40 c2       	mov.aa %a2,%a12
80007a56:	00 90       	ret 
80007a58:	99 2c 0c 00 	ld.a %a12,[%a2]12
80007a5c:	c2 26       	add %d6,2
80007a5e:	7d c2 31 ff 	jne.a %a2,%a12,800078c0 <_malloc_r+0x3c>
80007a62:	99 dc 10 00 	ld.a %a12,[%a13]16
80007a66:	d9 d4 08 00 	lea %a4,[%a13]8
80007a6a:	7d 4c 81 ff 	jne.a %a12,%a4,8000796c <_malloc_r+0xe8>
80007a6e:	8f e6 3f 40 	sha %d4,%d6,-2
80007a72:	82 12       	mov %d2,1
80007a74:	19 d3 04 00 	ld.w %d3,[%a13]4
80007a78:	0f 42 00 20 	sh %d2,%d2,%d4
80007a7c:	7f 23 ae ff 	jge.u %d3,%d2,800079d8 <_malloc_r+0x154>
80007a80:	99 dc 08 00 	ld.a %a12,[%a13]8
80007a84:	19 c2 04 00 	ld.w %d2,[%a12]4
80007a88:	8f 32 c0 b1 	andn %d11,%d2,3
80007a8c:	0b 8b 80 20 	sub %d2,%d11,%d8
80007a90:	8b 02 41 32 	lt %d3,%d2,16
80007a94:	0b 8b a0 32 	or.lt.u %d3,%d11,%d8
80007a98:	df 03 c0 00 	jeq %d3,0,80007c18 <_malloc_r+0x394>
80007a9c:	80 c2       	mov.d %d2,%a12
80007a9e:	91 00 00 26 	movh.a %a2,24576
80007aa2:	0b b2 00 c0 	add %d12,%d2,%d11
80007aa6:	19 22 60 c0 	ld.w %d2,[%a2]1824 <60000720 <__malloc_top_pad>>
80007aaa:	91 00 00 f6 	movh.a %a15,24576
80007aae:	19 f4 00 60 	ld.w %d4,[%a15]384 <60000180 <__malloc_sbrk_base>>
80007ab2:	42 82       	add %d2,%d8
80007ab4:	1b 02 01 a0 	addi %d10,%d2,16
80007ab8:	1b f2 08 20 	addi %d2,%d2,143
80007abc:	8f f2 c7 21 	andn %d2,%d2,127
80007ac0:	8b f4 3f 42 	ne %d4,%d4,-1
80007ac4:	2b a2 40 a4 	sel %d10,%d4,%d2,%d10
80007ac8:	02 a4       	mov %d4,%d10
80007aca:	40 e4       	mov.aa %a4,%a14
80007acc:	6d 00 ce 03 	call 80008268 <_sbrk_r>
80007ad0:	80 29       	mov.d %d9,%a2
80007ad2:	df f9 8a 01 	jeq %d9,-1,80007de6 <_malloc_r+0x562>
80007ad6:	80 c3       	mov.d %d3,%a12
80007ad8:	80 d4       	mov.d %d4,%a13
80007ada:	0b c9 30 21 	lt.u %d2,%d9,%d12
80007ade:	0b 43 10 22 	and.ne %d2,%d3,%d4
80007ae2:	df 02 82 81 	jne %d2,0,80007de6 <_malloc_r+0x562>
80007ae6:	7b 00 00 d6 	movh %d13,24576
80007aea:	60 d2       	mov.a %a2,%d13
80007aec:	d9 22 70 b0 	lea %a2,[%a2]1776
80007af0:	54 22       	ld.w %d2,[%a2]
80007af2:	60 d2       	mov.a %a2,%d13
80007af4:	42 a2       	add %d2,%d10
80007af6:	59 22 70 b0 	st.w [%a2]1776,%d2
80007afa:	5f 9c 64 01 	jeq %d12,%d9,80007dc2 <_malloc_r+0x53e>
80007afe:	19 f3 00 60 	ld.w %d3,[%a15]384 <60000180 <__malloc_sbrk_base>>
80007b02:	df f3 6e 01 	jeq %d3,-1,80007dde <_malloc_r+0x55a>
80007b06:	0b c9 80 c0 	sub %d12,%d9,%d12
80007b0a:	42 c2       	add %d2,%d12
80007b0c:	60 d2       	mov.a %a2,%d13
80007b0e:	59 22 70 b0 	st.w [%a2]1776,%d2
80007b12:	8f 79 00 e1 	and %d14,%d9,7
80007b16:	df 0e 78 01 	jeq %d14,0,80007e06 <_malloc_r+0x582>
80007b1a:	8b 8e 00 21 	rsub %d2,%d14,8
80007b1e:	42 29       	add %d9,%d2
80007b20:	42 9a       	add %d10,%d9
80007b22:	8b 8e 08 21 	rsub %d2,%d14,136
80007b26:	a2 a2       	sub %d2,%d10
80007b28:	8f f2 07 c1 	and %d12,%d2,127
80007b2c:	02 c4       	mov %d4,%d12
80007b2e:	40 e4       	mov.aa %a4,%a14
80007b30:	6d 00 9c 03 	call 80008268 <_sbrk_r>
80007b34:	80 22       	mov.d %d2,%a2
80007b36:	df f2 bd 01 	jeq %d2,-1,80007eb0 <_malloc_r+0x62c>
80007b3a:	a2 92       	sub %d2,%d9
80007b3c:	0b c2 00 a0 	add %d10,%d2,%d12
80007b40:	60 d2       	mov.a %a2,%d13
80007b42:	8f 1a 40 31 	or %d3,%d10,1
80007b46:	d9 22 70 b0 	lea %a2,[%a2]1776
80007b4a:	54 22       	ld.w %d2,[%a2]
80007b4c:	60 d2       	mov.a %a2,%d13
80007b4e:	42 c2       	add %d2,%d12
80007b50:	59 d9 08 00 	st.w [%a13]8,%d9
80007b54:	59 22 70 b0 	st.w [%a2]1776,%d2
80007b58:	60 92       	mov.a %a2,%d9
80007b5a:	59 23 04 00 	st.w [%a2]4,%d3
80007b5e:	7d dc 7f 01 	jeq.a %a12,%a13,80007e5c <_malloc_r+0x5d8>
80007b62:	8b 0b a1 32 	ge.u %d3,%d11,16
80007b66:	df 03 7e 01 	jeq %d3,0,80007e62 <_malloc_r+0x5de>
80007b6a:	19 c4 04 00 	ld.w %d4,[%a12]4
80007b6e:	1b 4b ff 3f 	addi %d3,%d11,-12
80007b72:	8f 73 c0 31 	andn %d3,%d3,7
80007b76:	8f 14 00 41 	and %d4,%d4,1
80007b7a:	a6 34       	or %d4,%d3
80007b7c:	d9 c2 04 00 	lea %a2,[%a12]4
80007b80:	74 24       	st.w [%a2],%d4
80007b82:	82 54       	mov %d4,5
80007b84:	01 c3 00 26 	addsc.a %a2,%a12,%d3,0
80007b88:	8b 03 a1 32 	ge.u %d3,%d3,16
80007b8c:	59 24 04 00 	st.w [%a2]4,%d4
80007b90:	59 24 08 00 	st.w [%a2]8,%d4
80007b94:	df 03 94 81 	jne %d3,0,80007ebc <_malloc_r+0x638>
80007b98:	60 92       	mov.a %a2,%d9
80007b9a:	60 9c       	mov.a %a12,%d9
80007b9c:	19 23 04 00 	ld.w %d3,[%a2]4
80007ba0:	91 00 00 26 	movh.a %a2,24576
80007ba4:	19 24 5c c0 	ld.w %d4,[%a2]1820 <6000071c <__malloc_max_sbrked_mem>>
80007ba8:	7f 24 04 80 	jge.u %d4,%d2,80007bb0 <_malloc_r+0x32c>
80007bac:	59 22 5c c0 	st.w [%a2]1820 <6000071c <__malloc_max_sbrked_mem>>,%d2
80007bb0:	91 00 00 26 	movh.a %a2,24576
80007bb4:	19 24 58 c0 	ld.w %d4,[%a2]1816 <60000718 <__malloc_max_total_mem>>
80007bb8:	7f 24 04 80 	jge.u %d4,%d2,80007bc0 <_malloc_r+0x33c>
80007bbc:	59 22 58 c0 	st.w [%a2]1816 <60000718 <__malloc_max_total_mem>>,%d2
80007bc0:	8f 33 c0 31 	andn %d3,%d3,3
80007bc4:	0b 83 80 20 	sub %d2,%d3,%d8
80007bc8:	0b 83 30 41 	lt.u %d4,%d3,%d8
80007bcc:	8b 02 21 45 	or.lt %d4,%d2,16
80007bd0:	df 04 24 00 	jeq %d4,0,80007c18 <_malloc_r+0x394>
80007bd4:	40 e4       	mov.aa %a4,%a14
80007bd6:	6d 00 43 03 	call 8000825c <__malloc_unlock>
80007bda:	a0 0c       	mov.a %a12,0
80007bdc:	1d ff 3c ff 	j 80007a54 <_malloc_r+0x1d0>
80007be0:	8f a8 1f 60 	sh %d6,%d8,-6
80007be4:	1b 86 03 50 	addi %d5,%d6,56
80007be8:	1b 96 03 60 	addi %d6,%d6,57
80007bec:	8f 36 00 30 	sh %d3,%d6,3
80007bf0:	bf 52 99 fe 	jlt.u %d2,5,80007922 <_malloc_r+0x9e>
80007bf4:	8b 52 a1 32 	ge.u %d3,%d2,21
80007bf8:	df 03 bc 00 	jeq %d3,0,80007d70 <_malloc_r+0x4ec>
80007bfc:	8b 52 a5 32 	ge.u %d3,%d2,85
80007c00:	df 03 20 81 	jne %d3,0,80007e40 <_malloc_r+0x5bc>
80007c04:	8f 48 1f 60 	sh %d6,%d8,-12
80007c08:	1b e6 06 50 	addi %d5,%d6,110
80007c0c:	1b f6 06 60 	addi %d6,%d6,111
80007c10:	8f 36 00 30 	sh %d3,%d6,3
80007c14:	1d ff 87 fe 	j 80007922 <_malloc_r+0x9e>
80007c18:	8f 18 40 31 	or %d3,%d8,1
80007c1c:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
80007c20:	8f 12 40 21 	or %d2,%d2,1
80007c24:	59 c3 04 00 	st.w [%a12]4,%d3
80007c28:	b5 d2 08 00 	st.a [%a13]8,%a2
80007c2c:	59 22 04 00 	st.w [%a2]4,%d2
80007c30:	40 e4       	mov.aa %a4,%a14
80007c32:	6d 00 15 03 	call 8000825c <__malloc_unlock>
80007c36:	d9 cc 08 00 	lea %a12,[%a12]8
80007c3a:	40 c2       	mov.aa %a2,%a12
80007c3c:	00 90       	ret 
80007c3e:	99 c2 0c 00 	ld.a %a2,[%a12]12
80007c42:	99 c3 08 00 	ld.a %a3,[%a12]8
80007c46:	b7 10 21 20 	imask %e2,1,0,1
80007c4a:	40 e4       	mov.aa %a4,%a14
80007c4c:	b5 32 0c 00 	st.a [%a3]12,%a2
80007c50:	b5 23 08 00 	st.a [%a2]8,%a3
80007c54:	01 c4 00 26 	addsc.a %a2,%a12,%d4,0
80007c58:	d9 cc 08 00 	lea %a12,[%a12]8
80007c5c:	49 22 44 08 	ldmst [%a2]4,%e2
80007c60:	6d 00 fe 02 	call 8000825c <__malloc_unlock>
80007c64:	1d ff 45 fe 	j 800078ee <_malloc_r+0x6a>
80007c68:	8f 72 1f 30 	sh %d3,%d2,-9
80007c6c:	bf 53 78 80 	jlt.u %d3,5,80007d5c <_malloc_r+0x4d8>
80007c70:	8b 53 a1 42 	ge.u %d4,%d3,21
80007c74:	df 04 d8 80 	jne %d4,0,80007e24 <_malloc_r+0x5a0>
80007c78:	1b b3 05 50 	addi %d5,%d3,91
80007c7c:	1b c3 05 30 	addi %d3,%d3,92
80007c80:	8f 33 00 40 	sh %d4,%d3,3
80007c84:	01 d4 00 26 	addsc.a %a2,%a13,%d4,0
80007c88:	40 23       	mov.aa %a3,%a2
80007c8a:	d4 33       	ld.a %a3,[%a3]
80007c8c:	b0 82       	add.a %a2,-8
80007c8e:	7d 32 b2 00 	jeq.a %a2,%a3,80007df2 <_malloc_r+0x56e>
80007c92:	19 33 04 00 	ld.w %d3,[%a3]4
80007c96:	8f 33 c0 31 	andn %d3,%d3,3
80007c9a:	7f 32 07 80 	jge.u %d2,%d3,80007ca8 <_malloc_r+0x424>
80007c9e:	d9 33 08 00 	lea %a3,[%a3]8
80007ca2:	d4 33       	ld.a %a3,[%a3]
80007ca4:	7d 32 f7 ff 	jne.a %a2,%a3,80007c92 <_malloc_r+0x40e>
80007ca8:	99 32 0c 00 	ld.a %a2,[%a3]12
80007cac:	19 d3 04 00 	ld.w %d3,[%a13]4
80007cb0:	b5 c2 0c 00 	st.a [%a12]12,%a2
80007cb4:	b5 c3 08 00 	st.a [%a12]8,%a3
80007cb8:	b5 2c 08 00 	st.a [%a2]8,%a12
80007cbc:	b5 3c 0c 00 	st.a [%a3]12,%a12
80007cc0:	1d ff 85 fe 	j 800079ca <_malloc_r+0x146>
80007cc4:	c2 17       	add %d7,1
80007cc6:	8f 37 00 31 	and %d3,%d7,3
80007cca:	d9 22 08 00 	lea %a2,[%a2]8
80007cce:	df 03 97 fe 	jne %d3,0,800079fc <_malloc_r+0x178>
80007cd2:	1d 00 5d 00 	j 80007d8c <_malloc_r+0x508>
80007cd6:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
80007cda:	8f 18 40 81 	or %d8,%d8,1
80007cde:	99 c5 08 00 	ld.a %a5,[%a12]8
80007ce2:	8f 13 40 21 	or %d2,%d3,1
80007ce6:	74 68       	st.w [%a6],%d8
80007ce8:	b5 53 0c 00 	st.a [%a5]12,%a3
80007cec:	b5 35 08 00 	st.a [%a3]8,%a5
80007cf0:	b5 d2 14 00 	st.a [%a13]20,%a2
80007cf4:	b5 d2 10 00 	st.a [%a13]16,%a2
80007cf8:	b5 24 0c 00 	st.a [%a2]12,%a4
80007cfc:	b5 24 08 00 	st.a [%a2]8,%a4
80007d00:	59 22 04 00 	st.w [%a2]4,%d2
80007d04:	01 c5 00 26 	addsc.a %a2,%a12,%d5,0
80007d08:	40 e4       	mov.aa %a4,%a14
80007d0a:	74 23       	st.w [%a2],%d3
80007d0c:	6d 00 a8 02 	call 8000825c <__malloc_unlock>
80007d10:	d9 cc 08 00 	lea %a12,[%a12]8
80007d14:	1d ff a0 fe 	j 80007a54 <_malloc_r+0x1d0>
80007d18:	8f d8 1f 60 	sh %d6,%d8,-3
80007d1c:	1b 88 00 30 	addi %d3,%d8,8
80007d20:	1d ff c4 fd 	j 800078a8 <_malloc_r+0x24>
80007d24:	01 c8 00 26 	addsc.a %a2,%a12,%d8,0
80007d28:	8f 18 40 81 	or %d8,%d8,1
80007d2c:	8f 13 40 41 	or %d4,%d3,1
80007d30:	59 c8 04 00 	st.w [%a12]4,%d8
80007d34:	b5 d2 14 00 	st.a [%a13]20,%a2
80007d38:	b5 d2 10 00 	st.a [%a13]16,%a2
80007d3c:	b5 24 0c 00 	st.a [%a2]12,%a4
80007d40:	b5 24 08 00 	st.a [%a2]8,%a4
80007d44:	59 24 04 00 	st.w [%a2]4,%d4
80007d48:	01 c2 00 26 	addsc.a %a2,%a12,%d2,0
80007d4c:	40 e4       	mov.aa %a4,%a14
80007d4e:	74 23       	st.w [%a2],%d3
80007d50:	6d 00 86 02 	call 8000825c <__malloc_unlock>
80007d54:	d9 cc 08 00 	lea %a12,[%a12]8
80007d58:	1d ff 7e fe 	j 80007a54 <_malloc_r+0x1d0>
80007d5c:	8f a2 1f 30 	sh %d3,%d2,-6
80007d60:	1b 83 03 50 	addi %d5,%d3,56
80007d64:	1b 93 03 30 	addi %d3,%d3,57
80007d68:	8f 33 00 40 	sh %d4,%d3,3
80007d6c:	1d ff 8c ff 	j 80007c84 <_malloc_r+0x400>
80007d70:	1b c2 05 60 	addi %d6,%d2,92
80007d74:	1b b2 05 50 	addi %d5,%d2,91
80007d78:	8f 36 00 30 	sh %d3,%d6,3
80007d7c:	1d ff d3 fd 	j 80007922 <_malloc_r+0x9e>
80007d80:	40 52       	mov.aa %a2,%a5
80007d82:	d4 22       	ld.a %a2,[%a2]
80007d84:	b0 85       	add.a %a5,-8
80007d86:	c2 f6       	add %d6,-1
80007d88:	7d 52 ba 80 	jne.a %a2,%a5,80007efc <_malloc_r+0x678>
80007d8c:	8f 36 00 31 	and %d3,%d6,3
80007d90:	df 03 f8 ff 	jne %d3,0,80007d80 <_malloc_r+0x4fc>
80007d94:	19 d3 04 00 	ld.w %d3,[%a13]4
80007d98:	d9 d2 04 00 	lea %a2,[%a13]4
80007d9c:	0f 23 e0 30 	andn %d3,%d3,%d2
80007da0:	74 23       	st.w [%a2],%d3
80007da2:	06 12       	sh %d2,1
80007da4:	1b f2 ff 4f 	addi %d4,%d2,-1
80007da8:	3f 34 06 80 	jlt.u %d4,%d3,80007db4 <_malloc_r+0x530>
80007dac:	1d ff 6a fe 	j 80007a80 <_malloc_r+0x1fc>
80007db0:	c2 47       	add %d7,4
80007db2:	06 12       	sh %d2,1
80007db4:	0f 32 80 40 	and %d4,%d2,%d3
80007db8:	df 04 fc 7f 	jeq %d4,0,80007db0 <_malloc_r+0x52c>
80007dbc:	02 76       	mov %d6,%d7
80007dbe:	1d ff 19 fe 	j 800079f0 <_malloc_r+0x16c>
80007dc2:	8f fc 07 31 	and %d3,%d12,127
80007dc6:	df 03 9c fe 	jne %d3,0,80007afe <_malloc_r+0x27a>
80007dca:	0b ab 00 30 	add %d3,%d11,%d10
80007dce:	99 dc 08 00 	ld.a %a12,[%a13]8
80007dd2:	8f 13 40 31 	or %d3,%d3,1
80007dd6:	59 c3 04 00 	st.w [%a12]4,%d3
80007dda:	1d ff e3 fe 	j 80007ba0 <_malloc_r+0x31c>
80007dde:	59 f9 00 60 	st.w [%a15]384,%d9
80007de2:	1d ff 98 fe 	j 80007b12 <_malloc_r+0x28e>
80007de6:	99 dc 08 00 	ld.a %a12,[%a13]8
80007dea:	19 c3 04 00 	ld.w %d3,[%a12]4
80007dee:	1d ff e9 fe 	j 80007bc0 <_malloc_r+0x33c>
80007df2:	19 d3 04 00 	ld.w %d3,[%a13]4
80007df6:	86 e5       	sha %d5,-2
80007df8:	d7 13 01 35 	insert %d3,%d3,1,%d5,1
80007dfc:	d9 d5 04 00 	lea %a5,[%a13]4
80007e00:	74 53       	st.w [%a5],%d3
80007e02:	1d ff 57 ff 	j 80007cb0 <_malloc_r+0x42c>
80007e06:	0b a9 00 20 	add %d2,%d9,%d10
80007e0a:	32 52       	rsub %d2
80007e0c:	8f f2 07 c1 	and %d12,%d2,127
80007e10:	02 c4       	mov %d4,%d12
80007e12:	40 e4       	mov.aa %a4,%a14
80007e14:	6d 00 2a 02 	call 80008268 <_sbrk_r>
80007e18:	80 22       	mov.d %d2,%a2
80007e1a:	df f2 90 fe 	jne %d2,-1,80007b3a <_malloc_r+0x2b6>
80007e1e:	82 0c       	mov %d12,0
80007e20:	1d ff 90 fe 	j 80007b40 <_malloc_r+0x2bc>
80007e24:	8b 53 a5 42 	ge.u %d4,%d3,85
80007e28:	df 04 22 80 	jne %d4,0,80007e6c <_malloc_r+0x5e8>
80007e2c:	8f 42 1f 30 	sh %d3,%d2,-12
80007e30:	1b e3 06 50 	addi %d5,%d3,110
80007e34:	1b f3 06 30 	addi %d3,%d3,111
80007e38:	8f 33 00 40 	sh %d4,%d3,3
80007e3c:	1d ff 24 ff 	j 80007c84 <_malloc_r+0x400>
80007e40:	8b 52 b5 32 	ge.u %d3,%d2,341
80007e44:	df 03 22 80 	jne %d3,0,80007e88 <_malloc_r+0x604>
80007e48:	8f 18 1f 60 	sh %d6,%d8,-15
80007e4c:	1b 76 07 50 	addi %d5,%d6,119
80007e50:	1b 86 07 60 	addi %d6,%d6,120
80007e54:	8f 36 00 30 	sh %d3,%d6,3
80007e58:	1d ff 65 fd 	j 80007922 <_malloc_r+0x9e>
80007e5c:	60 9c       	mov.a %a12,%d9
80007e5e:	1d ff a1 fe 	j 80007ba0 <_malloc_r+0x31c>
80007e62:	82 12       	mov %d2,1
80007e64:	59 22 04 00 	st.w [%a2]4,%d2
80007e68:	1d ff b6 fe 	j 80007bd4 <_malloc_r+0x350>
80007e6c:	8b 53 b5 42 	ge.u %d4,%d3,341
80007e70:	df 04 34 80 	jne %d4,0,80007ed8 <_malloc_r+0x654>
80007e74:	8f 12 1f 30 	sh %d3,%d2,-15
80007e78:	1b 73 07 50 	addi %d5,%d3,119
80007e7c:	1b 83 07 30 	addi %d3,%d3,120
80007e80:	8f 33 00 40 	sh %d4,%d3,3
80007e84:	1d ff 00 ff 	j 80007c84 <_malloc_r+0x400>
80007e88:	3b 50 55 40 	mov %d4,1365
80007e8c:	3b 80 3f 30 	mov %d3,1016
80007e90:	3b f0 07 60 	mov %d6,127
80007e94:	3b e0 07 50 	mov %d5,126
80007e98:	7f 42 45 fd 	jge.u %d2,%d4,80007922 <_malloc_r+0x9e>
80007e9c:	8f e8 1e 60 	sh %d6,%d8,-18
80007ea0:	1b c6 07 50 	addi %d5,%d6,124
80007ea4:	1b d6 07 60 	addi %d6,%d6,125
80007ea8:	8f 36 00 30 	sh %d3,%d6,3
80007eac:	1d ff 3b fd 	j 80007922 <_malloc_r+0x9e>
80007eb0:	c2 8e       	add %d14,-8
80007eb2:	42 ea       	add %d10,%d14
80007eb4:	a2 9a       	sub %d10,%d9
80007eb6:	82 0c       	mov %d12,0
80007eb8:	1d ff 44 fe 	j 80007b40 <_malloc_r+0x2bc>
80007ebc:	d9 c5 08 00 	lea %a5,[%a12]8
80007ec0:	40 e4       	mov.aa %a4,%a14
80007ec2:	6d 00 85 00 	call 80007fcc <_free_r>
80007ec6:	99 dc 08 00 	ld.a %a12,[%a13]8
80007eca:	60 d2       	mov.a %a2,%d13
80007ecc:	19 c3 04 00 	ld.w %d3,[%a12]4
80007ed0:	19 22 70 b0 	ld.w %d2,[%a2]1776
80007ed4:	1d ff 66 fe 	j 80007ba0 <_malloc_r+0x31c>
80007ed8:	3b 50 55 70 	mov %d7,1365
80007edc:	3b 80 3f 40 	mov %d4,1016
80007ee0:	3b e0 07 50 	mov %d5,126
80007ee4:	7f 73 d0 fe 	jge.u %d3,%d7,80007c84 <_malloc_r+0x400>
80007ee8:	8f e2 1e 30 	sh %d3,%d2,-18
80007eec:	1b c3 07 50 	addi %d5,%d3,124
80007ef0:	1b d3 07 30 	addi %d3,%d3,125
80007ef4:	8f 33 00 40 	sh %d4,%d3,3
80007ef8:	1d ff c6 fe 	j 80007c84 <_malloc_r+0x400>
80007efc:	19 d3 04 00 	ld.w %d3,[%a13]4
80007f00:	1d ff 51 ff 	j 80007da2 <_malloc_r+0x51e>

80007f04 <_malloc_trim_r>:
80007f04:	91 00 00 c6 	movh.a %a12,24576
80007f08:	02 49       	mov %d9,%d4
80007f0a:	80 48       	mov.d %d8,%a4
80007f0c:	d9 cc 08 60 	lea %a12,[%a12]392 <60000188 <__malloc_av_>>
80007f10:	6d 00 a5 01 	call 8000825a <__malloc_lock>
80007f14:	99 c2 08 00 	ld.a %a2,[%a12]8 <60000008 <LCF_DSPR1_START+0x8>>
80007f18:	8b f9 06 21 	rsub %d2,%d9,111
80007f1c:	19 2a 04 00 	ld.w %d10,[%a2]4
80007f20:	8f 3a c0 a1 	andn %d10,%d10,3
80007f24:	42 a2       	add %d2,%d10
80007f26:	8f f2 c7 21 	andn %d2,%d2,127
80007f2a:	1b 02 f8 9f 	addi %d9,%d2,-128
80007f2e:	8b 09 88 22 	ge %d2,%d9,128
80007f32:	df 02 0c 00 	jeq %d2,0,80007f4a <_malloc_trim_r+0x46>
80007f36:	60 84       	mov.a %a4,%d8
80007f38:	82 04       	mov %d4,0
80007f3a:	6d 00 97 01 	call 80008268 <_sbrk_r>
80007f3e:	19 c2 08 00 	ld.w %d2,[%a12]8 <60000008 <LCF_DSPR1_START+0x8>>
80007f42:	80 23       	mov.d %d3,%a2
80007f44:	42 a2       	add %d2,%d10
80007f46:	5f 23 07 00 	jeq %d3,%d2,80007f54 <_malloc_trim_r+0x50>
80007f4a:	60 84       	mov.a %a4,%d8
80007f4c:	6d 00 88 01 	call 8000825c <__malloc_unlock>
80007f50:	82 02       	mov %d2,0
80007f52:	00 90       	ret 
80007f54:	60 84       	mov.a %a4,%d8
80007f56:	8b 09 00 41 	rsub %d4,%d9,0
80007f5a:	6d 00 87 01 	call 80008268 <_sbrk_r>
80007f5e:	80 22       	mov.d %d2,%a2
80007f60:	df f2 18 00 	jeq %d2,-1,80007f90 <_malloc_trim_r+0x8c>
80007f64:	0b 9a 80 20 	sub %d2,%d10,%d9
80007f68:	99 c2 08 00 	ld.a %a2,[%a12]8
80007f6c:	8f 12 40 21 	or %d2,%d2,1
80007f70:	60 84       	mov.a %a4,%d8
80007f72:	59 22 04 00 	st.w [%a2]4,%d2
80007f76:	91 00 00 26 	movh.a %a2,24576
80007f7a:	d9 23 70 b0 	lea %a3,[%a2]1776 <600006f0 <__malloc_current_mallinfo>>
80007f7e:	54 32       	ld.w %d2,[%a3]
80007f80:	0b 92 80 90 	sub %d9,%d2,%d9
80007f84:	59 29 70 b0 	st.w [%a2]1776 <600006f0 <__malloc_current_mallinfo>>,%d9
80007f88:	6d 00 6a 01 	call 8000825c <__malloc_unlock>
80007f8c:	82 12       	mov %d2,1
80007f8e:	00 90       	ret 
80007f90:	60 84       	mov.a %a4,%d8
80007f92:	82 04       	mov %d4,0
80007f94:	6d 00 6a 01 	call 80008268 <_sbrk_r>
80007f98:	80 24       	mov.d %d4,%a2
80007f9a:	99 c2 08 00 	ld.a %a2,[%a12]8
80007f9e:	80 22       	mov.d %d2,%a2
80007fa0:	0b 24 80 30 	sub %d3,%d4,%d2
80007fa4:	8b 03 41 22 	lt %d2,%d3,16
80007fa8:	df 02 d1 ff 	jne %d2,0,80007f4a <_malloc_trim_r+0x46>
80007fac:	91 00 00 36 	movh.a %a3,24576
80007fb0:	19 32 00 60 	ld.w %d2,[%a3]384 <60000180 <__malloc_sbrk_base>>
80007fb4:	8f 13 40 31 	or %d3,%d3,1
80007fb8:	0b 24 80 20 	sub %d2,%d4,%d2
80007fbc:	91 00 00 36 	movh.a %a3,24576
80007fc0:	59 23 04 00 	st.w [%a2]4,%d3
80007fc4:	59 32 70 b0 	st.w [%a3]1776 <600006f0 <__malloc_current_mallinfo>>,%d2
80007fc8:	1d ff c1 ff 	j 80007f4a <_malloc_trim_r+0x46>

80007fcc <_free_r>:
80007fcc:	80 48       	mov.d %d8,%a4
80007fce:	40 5c       	mov.aa %a12,%a5
80007fd0:	bd 05 5c 00 	jz.a %a5,80008088 <_SMALL_DATA2_+0x88>
80007fd4:	6d 00 43 01 	call 8000825a <__malloc_lock>
80007fd8:	19 c3 fc ff 	ld.w %d3,[%a12]-4
80007fdc:	d9 c3 f8 ff 	lea %a3,[%a12]-8
80007fe0:	8f 13 c0 21 	andn %d2,%d3,1
80007fe4:	91 00 00 66 	movh.a %a6,24576
80007fe8:	01 32 00 26 	addsc.a %a2,%a3,%d2,0
80007fec:	d9 66 08 60 	lea %a6,[%a6]392 <60000188 <__malloc_av_>>
80007ff0:	99 64 08 00 	ld.a %a4,[%a6]8 <60000008 <LCF_DSPR1_START+0x8>>
80007ff4:	19 24 04 00 	ld.w %d4,[%a2]4 <60000008 <LCF_DSPR1_START+0x8>>
80007ff8:	8f 34 c0 41 	andn %d4,%d4,3
80007ffc:	7d 24 ae 00 	jeq.a %a4,%a2,80008158 <_SMALL_DATA2_+0x158>
80008000:	59 24 04 00 	st.w [%a2]4,%d4
80008004:	01 24 00 56 	addsc.a %a5,%a2,%d4,0
80008008:	6f 03 41 80 	jnz.t %d3,0,8000808a <_SMALL_DATA2_+0x8a>
8000800c:	19 c3 f8 ff 	ld.w %d3,[%a12]-8
80008010:	60 34       	mov.a %a4,%d3
80008012:	42 32       	add %d2,%d3
80008014:	01 43 20 30 	sub.a %a3,%a3,%a4
80008018:	99 34 08 00 	ld.a %a4,[%a3]8
8000801c:	19 53 04 00 	ld.w %d3,[%a5]4
80008020:	d9 65 08 00 	lea %a5,[%a6]8 <60000008 <LCF_DSPR1_START+0x8>>
80008024:	8f 13 00 31 	and %d3,%d3,1
80008028:	7d 54 81 00 	jeq.a %a4,%a5,8000812a <_SMALL_DATA2_+0x12a>
8000802c:	99 37 0c 00 	ld.a %a7,[%a3]12
80008030:	b5 47 0c 00 	st.a [%a4]12,%a7
80008034:	b5 74 08 00 	st.a [%a7]8,%a4
80008038:	df 03 c7 00 	jeq %d3,0,800081c6 <_SMALL_DATA2_+0x1c6>
8000803c:	8f 12 40 31 	or %d3,%d2,1
80008040:	59 33 04 00 	st.w [%a3]4,%d3
80008044:	74 22       	st.w [%a2],%d2
80008046:	3b 00 20 30 	mov %d3,512
8000804a:	7f 32 44 80 	jge.u %d2,%d3,800080d2 <_SMALL_DATA2_+0xd2>
8000804e:	19 64 04 00 	ld.w %d4,[%a6]4 <60000004 <LCF_DSPR1_START+0x4>>
80008052:	8f b2 1f 30 	sh %d3,%d2,-5
80008056:	8f 72 c0 21 	andn %d2,%d2,7
8000805a:	d7 14 01 33 	insert %d3,%d4,1,%d3,1
8000805e:	1b 82 00 20 	addi %d2,%d2,8
80008062:	d9 62 04 00 	lea %a2,[%a6]4 <60000004 <LCF_DSPR1_START+0x4>>
80008066:	01 62 00 66 	addsc.a %a6,%a6,%d2,0
8000806a:	74 23       	st.w [%a2],%d3
8000806c:	d4 65       	ld.a %a5,[%a6]
8000806e:	40 62       	mov.aa %a2,%a6
80008070:	b0 82       	add.a %a2,-8
80008072:	b5 32 0c 00 	st.a [%a3]12,%a2
80008076:	b5 35 08 00 	st.a [%a3]8,%a5
8000807a:	f4 63       	st.a [%a6],%a3
8000807c:	b5 53 0c 00 	st.a [%a5]12,%a3
80008080:	60 84       	mov.a %a4,%d8
80008082:	6d 00 ed 00 	call 8000825c <__malloc_unlock>
80008086:	00 90       	ret 
80008088:	00 90       	ret 
8000808a:	19 53 04 00 	ld.w %d3,[%a5]4
8000808e:	6f 03 19 80 	jnz.t %d3,0,800080c0 <_SMALL_DATA2_+0xc0>
80008092:	42 42       	add %d2,%d4
80008094:	d9 65 08 00 	lea %a5,[%a6]8
80008098:	99 24 08 00 	ld.a %a4,[%a2]8
8000809c:	01 32 00 76 	addsc.a %a7,%a3,%d2,0
800080a0:	8f 12 40 31 	or %d3,%d2,1
800080a4:	7d 54 9c 00 	jeq.a %a4,%a5,800081dc <_SMALL_DATA2_+0x1dc>
800080a8:	d9 22 0c 00 	lea %a2,[%a2]12
800080ac:	d4 22       	ld.a %a2,[%a2]
800080ae:	b5 42 0c 00 	st.a [%a4]12,%a2
800080b2:	b5 24 08 00 	st.a [%a2]8,%a4
800080b6:	59 33 04 00 	st.w [%a3]4,%d3
800080ba:	74 72       	st.w [%a7],%d2
800080bc:	1d ff c5 ff 	j 80008046 <_SMALL_DATA2_+0x46>
800080c0:	8f 12 40 31 	or %d3,%d2,1
800080c4:	59 c3 fc ff 	st.w [%a12]-4,%d3
800080c8:	74 22       	st.w [%a2],%d2
800080ca:	3b 00 20 30 	mov %d3,512
800080ce:	3f 32 c0 ff 	jlt.u %d2,%d3,8000804e <_SMALL_DATA2_+0x4e>
800080d2:	8f 72 1f 30 	sh %d3,%d2,-9
800080d6:	ff 53 66 80 	jge.u %d3,5,800081a2 <_SMALL_DATA2_+0x1a2>
800080da:	8f a2 1f 30 	sh %d3,%d2,-6
800080de:	1b 83 03 50 	addi %d5,%d3,56
800080e2:	1b 93 03 30 	addi %d3,%d3,57
800080e6:	8f 33 00 40 	sh %d4,%d3,3
800080ea:	01 64 00 56 	addsc.a %a5,%a6,%d4,0
800080ee:	40 52       	mov.aa %a2,%a5
800080f0:	d4 22       	ld.a %a2,[%a2]
800080f2:	b0 85       	add.a %a5,-8
800080f4:	7d 25 81 00 	jeq.a %a5,%a2,800081f6 <_SMALL_DATA2_+0x1f6>
800080f8:	19 23 04 00 	ld.w %d3,[%a2]4
800080fc:	8f 33 c0 31 	andn %d3,%d3,3
80008100:	7f 32 07 80 	jge.u %d2,%d3,8000810e <_SMALL_DATA2_+0x10e>
80008104:	d9 22 08 00 	lea %a2,[%a2]8
80008108:	d4 22       	ld.a %a2,[%a2]
8000810a:	7d 25 f7 ff 	jne.a %a5,%a2,800080f8 <_SMALL_DATA2_+0xf8>
8000810e:	99 25 0c 00 	ld.a %a5,[%a2]12
80008112:	b5 35 0c 00 	st.a [%a3]12,%a5
80008116:	b5 32 08 00 	st.a [%a3]8,%a2
8000811a:	b5 53 08 00 	st.a [%a5]8,%a3
8000811e:	60 84       	mov.a %a4,%d8
80008120:	b5 23 0c 00 	st.a [%a2]12,%a3
80008124:	6d 00 9c 00 	call 8000825c <__malloc_unlock>
80008128:	00 90       	ret 
8000812a:	df 03 91 80 	jne %d3,0,8000824c <_SMALL_DATA2_+0x24c>
8000812e:	99 24 0c 00 	ld.a %a4,[%a2]12
80008132:	d9 22 08 00 	lea %a2,[%a2]8
80008136:	d4 22       	ld.a %a2,[%a2]
80008138:	42 42       	add %d2,%d4
8000813a:	8f 12 40 31 	or %d3,%d2,1
8000813e:	b5 24 0c 00 	st.a [%a2]12,%a4
80008142:	b5 42 08 00 	st.a [%a4]8,%a2
80008146:	59 33 04 00 	st.w [%a3]4,%d3
8000814a:	01 32 00 36 	addsc.a %a3,%a3,%d2,0
8000814e:	60 84       	mov.a %a4,%d8
80008150:	74 32       	st.w [%a3],%d2
80008152:	6d 00 85 00 	call 8000825c <__malloc_unlock>
80008156:	00 90       	ret 
80008158:	42 42       	add %d2,%d4
8000815a:	6f 03 0f 80 	jnz.t %d3,0,80008178 <_SMALL_DATA2_+0x178>
8000815e:	54 33       	ld.w %d3,[%a3]
80008160:	60 32       	mov.a %a2,%d3
80008162:	42 32       	add %d2,%d3
80008164:	01 23 20 30 	sub.a %a3,%a3,%a2
80008168:	99 32 0c 00 	ld.a %a2,[%a3]12
8000816c:	99 34 08 00 	ld.a %a4,[%a3]8
80008170:	b5 42 0c 00 	st.a [%a4]12,%a2
80008174:	b5 24 08 00 	st.a [%a2]8,%a4
80008178:	8f 12 40 31 	or %d3,%d2,1
8000817c:	91 00 00 26 	movh.a %a2,24576
80008180:	59 33 04 00 	st.w [%a3]4,%d3
80008184:	19 23 04 60 	ld.w %d3,[%a2]388 <60000184 <__malloc_trim_threshold>>
80008188:	b5 63 08 00 	st.a [%a6]8 <60000184 <__malloc_trim_threshold>>,%a3
8000818c:	3f 32 7a ff 	jlt.u %d2,%d3,80008080 <_SMALL_DATA2_+0x80>
80008190:	91 00 00 26 	movh.a %a2,24576
80008194:	19 24 60 c0 	ld.w %d4,[%a2]1824 <60000720 <__malloc_top_pad>>
80008198:	60 84       	mov.a %a4,%d8
8000819a:	6d ff b5 fe 	call 80007f04 <_malloc_trim_r>
8000819e:	1d ff 71 ff 	j 80008080 <_SMALL_DATA2_+0x80>
800081a2:	8b 53 a1 42 	ge.u %d4,%d3,21
800081a6:	df 04 13 00 	jeq %d4,0,800081cc <_SMALL_DATA2_+0x1cc>
800081aa:	8b 53 a5 42 	ge.u %d4,%d3,85
800081ae:	df 04 2f 80 	jne %d4,0,8000820c <_SMALL_DATA2_+0x20c>
800081b2:	8f 42 1f 30 	sh %d3,%d2,-12
800081b6:	1b e3 06 50 	addi %d5,%d3,110
800081ba:	1b f3 06 30 	addi %d3,%d3,111
800081be:	8f 33 00 40 	sh %d4,%d3,3
800081c2:	1d ff 94 ff 	j 800080ea <_SMALL_DATA2_+0xea>
800081c6:	42 42       	add %d2,%d4
800081c8:	1d ff 68 ff 	j 80008098 <_SMALL_DATA2_+0x98>
800081cc:	1b b3 05 50 	addi %d5,%d3,91
800081d0:	1b c3 05 30 	addi %d3,%d3,92
800081d4:	8f 33 00 40 	sh %d4,%d3,3
800081d8:	1d ff 89 ff 	j 800080ea <_SMALL_DATA2_+0xea>
800081dc:	b5 63 14 00 	st.a [%a6]20,%a3
800081e0:	b5 63 10 00 	st.a [%a6]16,%a3
800081e4:	b5 35 0c 00 	st.a [%a3]12,%a5
800081e8:	b5 35 08 00 	st.a [%a3]8,%a5
800081ec:	59 33 04 00 	st.w [%a3]4,%d3
800081f0:	74 72       	st.w [%a7],%d2
800081f2:	1d ff 47 ff 	j 80008080 <_SMALL_DATA2_+0x80>
800081f6:	19 63 04 00 	ld.w %d3,[%a6]4
800081fa:	8f e5 3f 20 	sha %d2,%d5,-2
800081fe:	d7 13 01 22 	insert %d2,%d3,1,%d2,1
80008202:	d9 64 04 00 	lea %a4,[%a6]4
80008206:	74 42       	st.w [%a4],%d2
80008208:	1d ff 85 ff 	j 80008112 <_SMALL_DATA2_+0x112>
8000820c:	8b 53 b5 42 	ge.u %d4,%d3,341
80008210:	df 04 0c 80 	jne %d4,0,80008228 <_SMALL_DATA2_+0x228>
80008214:	8f 12 1f 30 	sh %d3,%d2,-15
80008218:	1b 73 07 50 	addi %d5,%d3,119
8000821c:	1b 83 07 30 	addi %d3,%d3,120
80008220:	8f 33 00 40 	sh %d4,%d3,3
80008224:	1d ff 63 ff 	j 800080ea <_SMALL_DATA2_+0xea>
80008228:	3b 50 55 60 	mov %d6,1365
8000822c:	3b 80 3f 40 	mov %d4,1016
80008230:	3b e0 07 50 	mov %d5,126
80008234:	7f 63 5b ff 	jge.u %d3,%d6,800080ea <_SMALL_DATA2_+0xea>
80008238:	8f e2 1e 30 	sh %d3,%d2,-18
8000823c:	1b c3 07 50 	addi %d5,%d3,124
80008240:	1b d3 07 30 	addi %d3,%d3,125
80008244:	8f 33 00 40 	sh %d4,%d3,3
80008248:	1d ff 51 ff 	j 800080ea <_SMALL_DATA2_+0xea>
8000824c:	8f 12 40 31 	or %d3,%d2,1
80008250:	59 33 04 00 	st.w [%a3]4,%d3
80008254:	74 22       	st.w [%a2],%d2
80008256:	1d ff 15 ff 	j 80008080 <_SMALL_DATA2_+0x80>

8000825a <__malloc_lock>:
8000825a:	00 90       	ret 

8000825c <__malloc_unlock>:
8000825c:	00 90       	ret 

8000825e <__errno>:
8000825e:	91 00 00 26 	movh.a %a2,24576
80008262:	99 22 20 10 	ld.a %a2,[%a2]96 <60000060 <_impure_ptr>>
80008266:	00 90       	ret 

80008268 <_sbrk_r>:
80008268:	82 02       	mov %d2,0
8000826a:	91 00 00 c6 	movh.a %a12,24576
8000826e:	40 4d       	mov.aa %a13,%a4
80008270:	59 c2 68 c0 	st.w [%a12]1832 <60000728 <errno>>,%d2
80008274:	6d 00 24 00 	call 800082bc <sbrk>
80008278:	80 22       	mov.d %d2,%a2
8000827a:	df f2 04 00 	jeq %d2,-1,80008282 <_sbrk_r+0x1a>
8000827e:	60 22       	mov.a %a2,%d2
80008280:	00 90       	ret 
80008282:	19 c3 68 c0 	ld.w %d3,[%a12]1832
80008286:	df 03 fc 7f 	jeq %d3,0,8000827e <_sbrk_r+0x16>
8000828a:	60 22       	mov.a %a2,%d2
8000828c:	74 d3       	st.w [%a13],%d3
8000828e:	00 90       	ret 

80008290 <abort>:
80008290:	00 a0       	debug 
80008292:	7b e0 ea 2d 	movh %d2,57006
80008296:	1b f2 ee 2b 	addi %d2,%d2,-16657
8000829a:	60 2e       	mov.a %a14,%d2
8000829c:	1d 00 04 00 	j 800082a4 <_exit>
800082a0:	1d 00 00 00 	j 800082a0 <abort+0x10>

800082a4 <_exit>:
800082a4:	df 04 06 00 	jeq %d4,0,800082b0 <_exit+0xc>
800082a8:	60 4e       	mov.a %a14,%d4
800082aa:	00 a0       	debug 
800082ac:	1d 00 00 00 	j 800082ac <_exit+0x8>
800082b0:	bb d0 00 29 	mov.u %d2,36877
800082b4:	60 2e       	mov.a %a14,%d2
800082b6:	00 a0       	debug 
800082b8:	1d ff fa ff 	j 800082ac <_exit+0x8>

800082bc <sbrk>:
800082bc:	91 00 00 36 	movh.a %a3,24576
800082c0:	99 32 50 60 	ld.a %a2,[%a3]1424 <60000590 <heap_top.0>>
800082c4:	91 00 00 46 	movh.a %a4,24576
800082c8:	80 22       	mov.d %d2,%a2
800082ca:	42 24       	add %d4,%d2
800082cc:	80 42       	mov.d %d2,%a4
800082ce:	1b 42 df 21 	addi %d2,%d2,7668
800082d2:	3f 42 0c 80 	jlt.u %d2,%d4,800082ea <sbrk+0x2e>
800082d6:	91 00 00 46 	movh.a %a4,24576
800082da:	80 42       	mov.d %d2,%a4
800082dc:	1b 42 df 20 	addi %d2,%d2,3572
800082e0:	3f 24 0d 80 	jlt.u %d4,%d2,800082fa <sbrk+0x3e>
800082e4:	59 34 50 60 	st.w [%a3]1424 <60000590 <heap_top.0>>,%d4
800082e8:	00 90       	ret 
800082ea:	6d ff ba ff 	call 8000825e <__errno>
800082ee:	3b c0 00 20 	mov %d2,12
800082f2:	74 22       	st.w [%a2],%d2
800082f4:	a0 02       	mov.a %a2,0
800082f6:	b0 f2       	add.a %a2,-1
800082f8:	00 90       	ret 
800082fa:	6d ff cb ff 	call 80008290 <abort>

800082fe <__do_global_ctors_aux>:
800082fe:	91 10 00 28 	movh.a %a2,32769
80008302:	d9 22 00 d8 	lea %a2,[%a2]-31936 <80008340 <__CTOR_END__>>
80008306:	19 22 fc ff 	ld.w %d2,[%a2]-4 <8000fffc <__DTOR_END__+0x7ca4>>
8000830a:	d9 23 fc ff 	lea %a3,[%a2]-4 <8000fffc <__DTOR_END__+0x7ca4>>
8000830e:	df f2 0a 00 	jeq %d2,-1,80008322 <__do_global_ctors_aux+0x24>
80008312:	40 3c       	mov.aa %a12,%a3
80008314:	60 22       	mov.a %a2,%d2
80008316:	b0 cc       	add.a %a12,-4
80008318:	2d 02 00 00 	calli %a2
8000831c:	54 c2       	ld.w %d2,[%a12]
8000831e:	df f2 fb ff 	jne %d2,-1,80008314 <__do_global_ctors_aux+0x16>
80008322:	00 90       	ret 

Disassembly of section .init:

80008324 <_init>:
80008324:	6d ff de c1 	call 800006e0 <frame_dummy>
80008328:	6d ff eb ff 	call 800082fe <__do_global_ctors_aux>
8000832c:	00 90       	ret 
	...

Disassembly of section .fini:

80008330 <_fini>:
80008330:	6d ff a6 c1 	call 8000067c <__do_global_dtors_aux>
80008334:	00 90       	ret 
	...

Disassembly of section .traptab_tc2:

801f6100 <IfxCpu_Trap_vectorTable2>:
#pragma ghs section text=".traptab_cpu2"
#endif

void IfxCpu_Trap_vectorTable2(void)
{
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6100:	0d 00 00 02 	svlcx 
801f6104:	02 f4       	mov %d4,%d15
801f6106:	91 00 00 28 	movh.a %a2,32768
801f610a:	d9 22 e0 64 	lea %a2,[%a2]19872 <80004da0 <IfxCpu_Trap_memoryManagementError>>
801f610e:	dc 02       	ji %a2
801f6110:	00 80       	rfe 
	...
801f611e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6120:	0d 00 00 02 	svlcx 
801f6124:	02 f4       	mov %d4,%d15
801f6126:	91 00 00 28 	movh.a %a2,32768
801f612a:	d9 22 ce 74 	lea %a2,[%a2]19918 <80004dce <IfxCpu_Trap_internalProtectionError>>
801f612e:	dc 02       	ji %a2
801f6130:	00 80       	rfe 
	...
801f613e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6140:	0d 00 00 02 	svlcx 
801f6144:	02 f4       	mov %d4,%d15
801f6146:	91 00 00 28 	movh.a %a2,32768
801f614a:	d9 22 fc 74 	lea %a2,[%a2]19964 <80004dfc <IfxCpu_Trap_instructionError>>
801f614e:	dc 02       	ji %a2
801f6150:	00 80       	rfe 
	...
801f615e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6160:	02 f4       	mov %d4,%d15
801f6162:	91 00 00 28 	movh.a %a2,32768
801f6166:	d9 22 ea 84 	lea %a2,[%a2]20010 <80004e2a <IfxCpu_Trap_contextManagementError>>
801f616a:	dc 02       	ji %a2
801f616c:	00 80       	rfe 
	...
801f617e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6180:	0d 00 00 02 	svlcx 
801f6184:	02 f4       	mov %d4,%d15
801f6186:	91 00 00 28 	movh.a %a2,32768
801f618a:	d9 22 d8 94 	lea %a2,[%a2]20056 <80004e58 <IfxCpu_Trap_busError>>
801f618e:	dc 02       	ji %a2
801f6190:	00 80       	rfe 
	...
801f619e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f61a0:	0d 00 00 02 	svlcx 
801f61a4:	02 f4       	mov %d4,%d15
801f61a6:	91 00 00 28 	movh.a %a2,32768
801f61aa:	d9 22 c6 a4 	lea %a2,[%a2]20102 <80004e86 <IfxCpu_Trap_assertion>>
801f61ae:	dc 02       	ji %a2
801f61b0:	00 80       	rfe 
	...
801f61be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu2);
801f61c0:	0d 00 00 02 	svlcx 
801f61c4:	02 f4       	mov %d4,%d15
801f61c6:	91 00 00 28 	movh.a %a2,32768
801f61ca:	d9 22 d2 c4 	lea %a2,[%a2]20242 <80004f12 <IfxCpu_Trap_systemCall_Cpu2>>
801f61ce:	dc 02       	ji %a2
801f61d0:	00 80       	rfe 
	...
801f61de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f61e0:	0d 00 00 02 	svlcx 
801f61e4:	02 f4       	mov %d4,%d15
801f61e6:	91 00 00 28 	movh.a %a2,32768
801f61ea:	d9 22 fe c4 	lea %a2,[%a2]20286 <80004f3e <IfxCpu_Trap_nonMaskableInterrupt>>
801f61ee:	dc 02       	ji %a2
801f61f0:	00 80       	rfe 
}
801f61f2:	00 90       	ret 

801f61f4 <IfxCpu_Trap_vectorTable2_end>:
	...

Disassembly of section .traptab_tc1:

801f6200 <IfxCpu_Trap_vectorTable1>:
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_memoryManagementError);
801f6200:	0d 00 00 02 	svlcx 
801f6204:	02 f4       	mov %d4,%d15
801f6206:	91 00 00 28 	movh.a %a2,32768
801f620a:	d9 22 e0 64 	lea %a2,[%a2]19872 <80004da0 <IfxCpu_Trap_memoryManagementError>>
801f620e:	dc 02       	ji %a2
801f6210:	00 80       	rfe 
	...
801f621e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_internalProtectionError);
801f6220:	0d 00 00 02 	svlcx 
801f6224:	02 f4       	mov %d4,%d15
801f6226:	91 00 00 28 	movh.a %a2,32768
801f622a:	d9 22 ce 74 	lea %a2,[%a2]19918 <80004dce <IfxCpu_Trap_internalProtectionError>>
801f622e:	dc 02       	ji %a2
801f6230:	00 80       	rfe 
	...
801f623e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_instructionError);
801f6240:	0d 00 00 02 	svlcx 
801f6244:	02 f4       	mov %d4,%d15
801f6246:	91 00 00 28 	movh.a %a2,32768
801f624a:	d9 22 fc 74 	lea %a2,[%a2]19964 <80004dfc <IfxCpu_Trap_instructionError>>
801f624e:	dc 02       	ji %a2
801f6250:	00 80       	rfe 
	...
801f625e:	00 00       	nop 
    IfxCpu_Tsr_CallCSATSR(IfxCpu_Trap_contextManagementError);
801f6260:	02 f4       	mov %d4,%d15
801f6262:	91 00 00 28 	movh.a %a2,32768
801f6266:	d9 22 ea 84 	lea %a2,[%a2]20010 <80004e2a <IfxCpu_Trap_contextManagementError>>
801f626a:	dc 02       	ji %a2
801f626c:	00 80       	rfe 
	...
801f627e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_busError);
801f6280:	0d 00 00 02 	svlcx 
801f6284:	02 f4       	mov %d4,%d15
801f6286:	91 00 00 28 	movh.a %a2,32768
801f628a:	d9 22 d8 94 	lea %a2,[%a2]20056 <80004e58 <IfxCpu_Trap_busError>>
801f628e:	dc 02       	ji %a2
801f6290:	00 80       	rfe 
	...
801f629e:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_assertion);
801f62a0:	0d 00 00 02 	svlcx 
801f62a4:	02 f4       	mov %d4,%d15
801f62a6:	91 00 00 28 	movh.a %a2,32768
801f62aa:	d9 22 c6 a4 	lea %a2,[%a2]20102 <80004e86 <IfxCpu_Trap_assertion>>
801f62ae:	dc 02       	ji %a2
801f62b0:	00 80       	rfe 
	...
801f62be:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_systemCall_Cpu1);
801f62c0:	0d 00 00 02 	svlcx 
801f62c4:	02 f4       	mov %d4,%d15
801f62c6:	91 00 00 28 	movh.a %a2,32768
801f62ca:	d9 22 e6 b4 	lea %a2,[%a2]20198 <80004ee6 <IfxCpu_Trap_systemCall_Cpu1>>
801f62ce:	dc 02       	ji %a2
801f62d0:	00 80       	rfe 
	...
801f62de:	00 00       	nop 
    IfxCpu_Tsr_CallTSR(IfxCpu_Trap_nonMaskableInterrupt);
801f62e0:	0d 00 00 02 	svlcx 
801f62e4:	02 f4       	mov %d4,%d15
801f62e6:	91 00 00 28 	movh.a %a2,32768
801f62ea:	d9 22 fe c4 	lea %a2,[%a2]20286 <80004f3e <IfxCpu_Trap_nonMaskableInterrupt>>
801f62ee:	dc 02       	ji %a2
801f62f0:	00 80       	rfe 
}
801f62f2:	00 90       	ret 

801f62f4 <IfxCpu_Trap_vectorTable1_end>:
	...

Disassembly of section .inttab_tc0_004:

801f4080 <__intvec_tc0_4>:
801f4080:	0d 00 00 02 	svlcx 
801f4084:	91 00 00 e8 	movh.a %a14,32768
801f4088:	d9 ee d0 b0 	lea %a14,[%a14]3792 <80000ed0 <asc0RxISR>>
801f408c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_005:

801f40a0 <__intvec_tc0_5>:
801f40a0:	0d 00 00 02 	svlcx 
801f40a4:	91 00 00 e8 	movh.a %a14,32768
801f40a8:	d9 ee f2 e0 	lea %a14,[%a14]4018 <80000fb2 <asc2RxISR>>
801f40ac:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_008:

801f4100 <__intvec_tc0_8>:
801f4100:	0d 00 00 02 	svlcx 
801f4104:	91 00 00 e8 	movh.a %a14,32768
801f4108:	d9 ee fc a0 	lea %a14,[%a14]3772 <80000ebc <asc0TxISR>>
801f410c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_009:

801f4120 <__intvec_tc0_9>:
801f4120:	0d 00 00 02 	svlcx 
801f4124:	91 00 00 e8 	movh.a %a14,32768
801f4128:	d9 ee de e0 	lea %a14,[%a14]3998 <80000f9e <asc2TxISR>>
801f412c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_00C:

801f4180 <__intvec_tc0_12>:
801f4180:	0d 00 00 02 	svlcx 
801f4184:	91 00 00 e8 	movh.a %a14,32768
801f4188:	d9 ee d8 e0 	lea %a14,[%a14]3992 <80000f98 <asc0ErrISR>>
801f418c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_00D:

801f41a0 <__intvec_tc0_13>:
801f41a0:	0d 00 00 02 	svlcx 
801f41a4:	91 00 00 e8 	movh.a %a14,32768
801f41a8:	d9 ee 04 31 	lea %a14,[%a14]4292 <800010c4 <asc2ErrISR>>
801f41ac:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_064:

801f4c80 <__intvec_tc0_100>:
801f4c80:	0d 00 00 02 	svlcx 
801f4c84:	91 00 00 e8 	movh.a %a14,32768
801f4c88:	d9 ee 32 81 	lea %a14,[%a14]4658 <80001232 <ISR_STM>>
801f4c8c:	dc 0e       	ji %a14

Disassembly of section .inttab_tc0_0C8:

801f5900 <__intvec_tc0_200>:
801f5900:	0d 00 00 02 	svlcx 
801f5904:	91 00 00 e8 	movh.a %a14,32768
801f5908:	d9 ee 2e b1 	lea %a14,[%a14]4846 <800012ee <ISR_PWM_GTM>>
801f590c:	dc 0e       	ji %a14
